language: rs
name: HumanEval_17_parse_music
results:
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            current_note\
    \ += c.to_string();\n        } else {\n            if current_note.len() == 1\
    \ {\n                beats.push(current_beat);\n                current_beat =\
    \ 0;\n                current_note = String::new();\n            }\n         \
    \   current_note += c.to_string();\n        }\n    }\n    beats.push(current_beat);\n\
    \    current_beat = 0;\n    current_note.len()\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptjecruyd.rs:16:29\n   |\n\
    16 |             current_note += c.to_string();\n   |                        \
    \     ^^^^^^^^^^^^^\n   |                             |\n   |                \
    \             expected `&str`, found struct `String`\n   |                   \
    \          help: consider borrowing here: `&c.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptjecruyd.rs:23:29\n   |\n23 |             current_note\
    \ += c.to_string();\n   |                             ^^^^^^^^^^^^^\n   |    \
    \                         |\n   |                             expected `&str`,\
    \ found struct `String`\n   |                             help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptjecruyd.rs:28:5\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                  ---------- expected `Vec<isize>` because of\
    \ return type\n...\n28 |     current_note.len()\n   |     ^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_index = 0;\n    let mut current_note_length = 0;\n   \
    \ let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_index = 0;\n    let mut current_note_length_value_value\
    \ = 0;\n    let mut current_note_length_value_value_index = 0;\n    let mut current_note_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpqbwv8sxp.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    let mut current_note_len:\
    \ isize = 0;\n    let mut current_note_octave: isize = 0;\n    let mut current_note_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave: isize = 0;\n    let mut\
    \ current_note_octave_octave_len: isize = 0;\n    let mut current_note_octave_octave_octave:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_len: isize = 0;\n\
    \    let mut current_note_octave_octave_octave_octave: isize = 0;\n    let mut\
    \ current_note_octave_octave_octave_octave_len: isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm4oa0ida.rs:35:26\n   |\n\
    35 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpm4oa0ida.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_type = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = \n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp72a27wew.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats_vec: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    for c in music_string {\n        if c == 'o' {\n            if current_beat\
    \ > 0 {\n                beats_vec.push(current_beat);\n                current_beat\
    \ = 0;\n            }\n            current_note = String::new();\n        } else\
    \ if c == '|' {\n            if current_note.is_empty() {\n                println!(\"\
    Invalid music string\");\n                break;\n            }\n            beats_vec.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      } else if c == '.' {\n            if current_note.is_empty() {\n      \
    \          println!(\"Invalid music string\");\n                break;\n     \
    \       }\n            beats_vec.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n        } else {\n        \
    \    current_note.push(c);\n            current_beat += 1;\n        }\n    }\n\
    \    if current_beat > 0 {\n        beats_vec.push(current_beat);\n    }\n   \
    \ beats_vec\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp3em3lwo3.rs:14:14\n\
    \   |\n14 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o' {\n                current_beat\
    \ += 1;\n            } else if c.to_ascii_lowercase() == '.' {\n             \
    \   current_beat += 1;\n            } else {\n                current_note +=\
    \ c.to_ascii_lowercase();\n            }\n        } else {\n            current_note\
    \ += c.to_ascii_lowercase();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4kax25qq.rs:25:33\n   |\n\
    25 |                 current_note += c.to_ascii_lowercase();\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4kax25qq.rs:28:29\n   |\n28 |  \
    \           current_note += c.to_ascii_lowercase();\n   |                    \
    \         ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length = 0;\n    let\
    \ mut current_note_length_to_beat_with_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_n1b7pib.rs:32:96\n   |\n\
    32 |     let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_\n\
    \   |                                                                        \
    \                        ^ help: add `;` here\n33 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_n1b7pib.rs:10:41\n   |\n10 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------  \
    \                        ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut last_note = String::from(\"\");\n    let mut last_beat = 0;\n   \
    \ let mut last_beat_index = 0;\n    let mut last_beat_index2 = 0;\n    let mut\
    \ last_beat_index3 = 0;\n    let mut last_beat_index4 = 0;\n    let mut last_beat_index5\
    \ = 0;\n    let mut last_beat_index6 = 0;\n    let mut last_beat_index7 = 0;\n\
    \    let mut last_beat_index8 = 0;\n    let mut last_beat_index9 = 0;\n    let\
    \ mut last_beat_index10 = 0;\n    let mut last_beat_index11 = 0;\n    let mut\
    \ last_beat_index12 = 0;\n    let mut last_beat_index13 = 0;\n    let mut last_beat_index14\
    \ = 0;\n    let mut last_beat_index15 = 0;\n    let mut last_beat_index16 = 0;\n\
    \    let mut last_beat_index17 = 0;\n    let mut last_beat_index18 = 0;\n    let\
    \ mut last_beat_index19 = 0;\n    let mut last_beat_index20 = 0;\n    let mut\
    \ last_beat_index21 = 0;\n    let mut last_beat_index22 = 0;\n    let mut last_beat_index23\
    \ = 0;\n    let mut last_beat_index24 = 0;\n    let mut last_beat_index25 = 0;\n\
    \    let mut last_beat_index26 = 0;\n    let mut last_beat_index27 = 0;\n    let\
    \ mut last_beat_index28 = 0;\n    let mut last_beat_index29 = 0;\n    let mut\
    \ last_beat_index30 = 0;\n    let mut last_beat_index31 = 0;\n    let mut last_beat_index32\
    \ = 0;\n    let mut last_beat_index33 = 0;\n    let mut last_beat_index34 = 0;\n\
    \    let mut last_beat_index35 = 0;\n    let mut last_beat_index36 = 0;\n    let\
    \ mut last_beat_index37 = 0;\n    let mut last_beat_index38 = 0;\n    let mut\
    \ last_beat_index39 = 0;\n    let mut last_beat_index40 = 0;\n    let mut last_beat_index41\
    \ = 0;\n    let mut last_beat_index42 = 0;\n    let mut last_beat_index43 = 0;\n\
    \    let mut last_beat_index44 = 0;\n    let mut last_beat_index45 = 0;\n    let\
    \ mut last_beat_index46 = 0;\n    let mut last_beat_index47 = 0;\n    let mut\
    \ last_beat_index48 = 0;\n    let mut last_beat_index49 = 0;\n    let mut last_beat_index50\
    \ = 0;\n    let mut last_beat_index51 = 0;\n    let mut last_beat\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwe7lv08w.rs:66:22\n   |\n\
    66 |     let mut last_beat\n   |                      ^ help: add `;` here\n67\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwe7lv08w.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index48\
    \ = 1;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpettriq6r.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7sfaoq0w.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.clone();\n    let mut current_beat = 0;\n  \
    \  while current_note.is_not_empty() {\n        let note = current_note.clone();\n\
    \        let beat = current_beat;\n        if note == \"o\" {\n            beats.push(beat);\n\
    \            current_beat += 4;\n        } else if note == \"o|\" {\n        \
    \    beats.push(beat);\n            current_beat += 2;\n        } else if note\
    \ == \".|\" {\n            beats.push(beat);\n            current_beat += 1;\n\
    \        } else {\n            beats.push(beat);\n            current_beat +=\
    \ 1;\n        }\n        current_note.pop();\n    }\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_not_empty` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpdnp9z8zc.rs:15:24\n   |\n15 |     while\
    \ current_note.is_not_empty() {\n   |                        ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_empty`\n\nerror[E0277]:\
    \ can't compare `Vec<&str>` with `&str`\n  --> /tmp/tmpdnp9z8zc.rs:18:17\n   |\n\
    18 |         if note == \"o\" {\n   |                 ^^ no implementation for\
    \ `Vec<&str> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `Vec<&str>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: can't compare\
    \ `Vec<&str>` with `&str`\n  --> /tmp/tmpdnp9z8zc.rs:21:24\n   |\n21 |       \
    \  } else if note == \"o|\" {\n   |                        ^^ no implementation\
    \ for `Vec<&str> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not\
    \ implemented for `Vec<&str>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: can't compare\
    \ `Vec<&str>` with `&str`\n  --> /tmp/tmpdnp9z8zc.rs:24:24\n   |\n24 |       \
    \  } else if note == \".|\" {\n   |                        ^^ no implementation\
    \ for `Vec<&str> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not\
    \ implemented for `Vec<&str>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_beats:\
    \ isize = 0;\n    while notes.len() > 0 {\n        let note = notes.remove(0);\n\
    \        note = note.chars().next().unwrap();\n        if note == 'o' {\n    \
    \        beats.push(current_beats);\n            current_beats += 4;\n       \
    \     current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beat\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpj6my49f0.rs:90:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n16 |\
    \     while notes.len() > 0 {\n   |                           - unclosed delimiter\n\
    ...\n19 |         if note == 'o' {\n   |                        - this delimiter\
    \ might not be properly closed...\n...\n81 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n90 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj6my49f0.rs:18:16\n   |\n17 |         let note = notes.remove(0);\n\
    \   |                    --------------- expected due to this value\n18 |    \
    \     note = note.chars().next().unwrap();\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0277]: can't compare `&str` with `char`\n\
    \  --> /tmp/tmpj6my49f0.rs:19:17\n   |\n19 |         if note == 'o' {\n   |  \
    \               ^^ no implementation for `&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj6my49f0.rs:80:13\n\
    \   |\n19 | /         if note == 'o' {\n20 | |             beats.push(current_beats);\n\
    21 | |             current_beats += 4;\n22 | |             current_beats += current_beats;\n\
    ...  |\n80 | |             current_beat\n   | |             ^^^^^^^^^^^^ expected\
    \ `()`, found integer\n81 | | }\n   | |_- expected this to be `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj6my49f0.rs:16:5\n   |\n10 |   fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |                   "
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi0rwqg7u.rs:62:26\n   |\n\
    62 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi0rwqg7u.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n    \
    \            beats.push(current_beat);\n                current_beat = 0;\n  \
    \              current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n              \
    \  current_note_length += 1;\n            } else if c.to_ascii_lowercase() ==\
    \ '|' {\n                current_beat += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                current_beat += 1;\n            }\n        } else\
    \ {\n            current_note.push(c);\n            current_note_length += 1;\n\
    \        }\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n    current_note\
    \ = String::new();\n    current_note_length = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n              \
    \  current_note_length += 1;\n            } else if c.to_ascii_lowercase() ==\
    \ '|' {\n                current_beat += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                current_beat += 1;\n            }\n        } else\
    \ {\n            current_note.push(c);\n            current_note_length += 1;\n\
    \        }\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n    current_note\
    \ = String::new();\n    current_note_length = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n              \
    \  current_note_length += 1;\n            } else if c.to_ascii_lowercase() ==\
    \ '|' {\n                current_beat += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                current_beat += 1;\n            }\n        } else\
    \ {\n            current_note.push(c);\n            current_note_length += 1;\n\
    \        }\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n    current_note\
    \ = String::new();\n    current_note_length = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpw9a6dwhe.rs:99:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n84 |\
    \     for c in music_string.chars() {\n   |                                  \
    \ - unclosed delimiter\n85 |         if c.is_ascii() {\n   |                 \
    \        - unclosed delimiter\n86 |             if c.to_ascii_lowercase() == 'o'\
    \ {\n   |                                              - this delimiter might\
    \ not be properly closed...\n...\n90 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n99 | }\n   |   ^\n\nerror[E0423]: expected value,\
    \ found struct `String`\n   --> /tmp/tmpw9a6dwhe.rs:89:32\n    |\n89  |      \
    \             current_note = String\n    |                                  ^^^^^^\
    \ help: use struct literal syntax instead: `String { vec: val }`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw9a6dwhe.rs:84:5\n   |\n10 |   fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |                                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n84 | /     for c in music_string.chars()\
    \ {\n85 | |         if c.is_ascii() {\n86 | |             if c.to_ascii_lowercase()\
    \ == 'o' {\n87 | |                 beats.push(current_beat);\n...  |\n98 | | \
    \    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\")), vec![2, 1,\
    \ 2, 1, 4, 2, 4, 2]);\n99 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmptaryoovv.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::from(\"\");\n    let mut current_beat = 0;\n    let mut current_octave\
    \ = 0;\n    let mut current_length = 0;\n    let mut current_length_index = 0;\n\
    \    let mut current_length_index2 = 0;\n    let mut current_length_index3 = 0;\n\
    \    let mut current_length_index4 = 0;\n    let mut current_length_index5 = 0;\n\
    \    let mut current_length_index6 = 0;\n    let mut current_length_index7 = 0;\n\
    \    let mut current_length_index8 = 0;\n    let mut current_length_index9 = 0;\n\
    \    let mut current_length_index10 = 0;\n    let mut current_length_index11 =\
    \ 0;\n    let mut current_length_index12 = 0;\n    let mut current_length_index13\
    \ = 0;\n    let mut current_length_index14 = 0;\n    let mut current_length_index15\
    \ = 0;\n    let mut current_length_index16 = 0;\n    let mut current_length_index17\
    \ = 0;\n    let mut current_length_index18 = 0;\n    let mut current_length_index19\
    \ = 0;\n    let mut current_length_index20 = 0;\n    let mut current_length_index21\
    \ = 0;\n    let mut current_length_index22 = 0;\n    let mut current_length_index23\
    \ = 0;\n    let mut current_length_index24 = 0;\n    let mut current_length_index25\
    \ = 0;\n    let mut current_length_index26 = 0;\n    let mut current_length_index27\
    \ = 0;\n    let mut current_length_index28 = 0;\n    let mut current_length_index29\
    \ = 0;\n    let mut current_length_index30 = 0;\n    let mut current_length_index31\
    \ = 0;\n    let mut current_length_index32 = 0;\n    let mut current_length_index33\
    \ = 0;\n    let mut current_length_index34 = 0;\n    let mut current_length_index35\
    \ = 0;\n    let mut current_length_index36 = 0;\n    let mut current_length_index37\
    \ = 0;\n    let mut current_length_index38 = 0;\n    let mut current_length_index39\
    \ = 0;\n    let mut current_length_index40 = 0;\n    let mut current_length_index41\
    \ = 0;\n    let mut current_length_index42 = 0;\n    let mut current_length_index43\
    \ = 0;\n    let mut current_length_index44 = 0;\n    let mut current_length_index45\
    \ = 0;\n    let mut current_length_index46 = 0;\n    let mut current_length_index47\
    \ = 0;\n    let mut current_length_index48 = 0;\n    let mut current_length_index49\
    \ = 0;\n    let mut current_length_index50 = 0;\n    let mut current_\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpql4rf1zi.rs:67:21\n   |\n\
    67 |     let mut current_\n   |                     ^ help: add `;` here\n68 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpql4rf1zi.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::new();\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    for c in music_string.chars() {\n        if c == 'o' {\n         \
    \   if current_note_length == 0 {\n                notes.push(current_note);\n\
    \                current_note = String::new();\n                current_beat =\
    \ 0;\n                current_note_length = 0;\n            }\n            current_note_length\
    \ += 1;\n        } else if c == '|' {\n            if current_note_length == 0\
    \ {\n                notes.push(current_note);\n                current_note =\
    \ String::new();\n                current_beat = 0;\n                current_note_length\
    \ = 0;\n            }\n            current_note_length += 1;\n        } else if\
    \ c == ' ' {\n            if current_note_length == 0 {\n                notes.push(current_note);\n\
    \                current_note = String::new();\n                current_beat =\
    \ 0;\n                current_note_length = 0;\n            }\n            current_note_length\
    \ += 1;\n        } else {\n            if current_note_length == 0 {\n       \
    \         notes.push(current_note);\n                current_note = String::new();\n\
    \                current_beat = 0;\n                current_note_length = 0;\n\
    \            }\n            current_note_length += 1;\n            current_note.push_str(&c);\n\
    \        }\n    }\n    for note in notes {\n        beats.push(current_beat +\
    \ 4);\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnrv0omhw.rs:19:28\n   |\n\
    19 |                 notes.push(current_note);\n   |                         \
    \   ^^^^^^^^^^^^\n   |                            |\n   |                    \
    \        expected `&str`, found struct `String`\n   |                        \
    \    help: consider borrowing here: `&current_note`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnrv0omhw.rs:27:28\n   |\n27 |                 notes.push(current_note);\n\
    \   |                            ^^^^^^^^^^^^\n   |                          \
    \  |\n   |                            expected `&str`, found struct `String`\n\
    \   |                            help: consider borrowing here: `&current_note`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnrv0omhw.rs:35:28\n   |\n35 |\
    \                 notes.push(current_note);\n   |                            ^^^^^^^^^^^^\n\
    \   |                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&current_note`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnrv0omhw.rs:43:28\n\
    \   |\n43 |                 notes.push(current_note);\n   |                  \
    \          ^^^^^^^^^^^^\n   |                            |\n   |             \
    \               expected `&str`, found struct `String`\n   |                 \
    \           help: consider borrowing here: `&current_note`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnrv0omhw.rs:49:35\n   |\n49 |             current_note.push_str(&c);\n\
    \   |                                   ^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&'static str> = vec![];\n    let mut last_note\
    \ = String::new();\n    let mut last_beat = 0;\n    let mut last_beat_size = 0;\n\
    \    let mut last_beat_length = 0;\n    let mut last_beat_length_size = 0;\n \
    \   let mut last_beat_length_length = 0;\n    let mut last_beat_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length = 0;\n    let mut last_beat_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length = 0;\n    let mut last_beat_length_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_length = 0;\n\
    \    let mut last_beat_length_length_length_length_length_size = 0;\n    let mut\
    \ last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_size = 0;\n \
    \   let mut last_beat_length_length_length_length_length_length_size = 0;\n  \
    \  let mut last_beat_length_length_length_length_length_length = 0;\n    let mut\
    \ last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_size = 0;\n \
    \   let mut last_beat_length_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_size = 0;\n \
    \   let mut last_beat_length_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_size = 0;\n \
    \   let mut last_beat_length_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_size = 0;\n \
    \   let mut last_beat_length_length_length_length_length_length = 0;\n    let\
    \ mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps9am9alz.rs:50:11\n   |\n\
    50 |     let mu\n   |           ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9am9alz.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note += c.to_ascii_lowercase();\n\
    \            }\n        } else {\n            if current_note.is_empty() {\n \
    \               println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoq54im34.rs:21:33\n   |\n\
    21 |                 current_note += c.to_ascii_lowercase();\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_to_beat =\
    \ String::new();\n    let mut current_note_length_to_beat_length = 0;\n    let\
    \ mut current_note_length_to_beat_length_to_beat = String::new();\n    let mut\
    \ current_note_length_to_beat_length_to_beat_length = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat\
    \ = String::new();\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = String::new();\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = String::new();\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = String::new();\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = String::new();\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = String::new();\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = String::new();\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = String::new();\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_be\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbzr7bqs1.rs:29:263\n   |\n\
    29 |     let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_be\n\
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                                       ^ help: add `;` here\n30 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbzr7bqs1.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_note = String::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_beats_length = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_whitespace() {\n            continue;\n        }\n      \
    \  if c.is_ascii_digit() {\n            current_note = c.to_string();\n      \
    \      current_beat = 0;\n            current_beats_length = 0;\n        } else\
    \ {\n            if current_note.is_empty() {\n                continue;\n   \
    \         }\n            if c.is_ascii_letter() {\n                if current_beat\
    \ == 0 {\n                    current_beats_length += 1;\n                } else\
    \ {\n                    current_beats_length += 2;\n                }\n     \
    \       }\n            current_beat += 1;\n            beats.push(current_beats_length);\n\
    \            current_beats_length = 0;\n            current_note = String::new();\n\
    \        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmph3xqj782.rs:27:18\n   |\n27 |             if\
    \ c.is_ascii_letter() {\n   |                  ^^^^^^^^^^^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi0rwqg7u.rs:62:26\n   |\n\
    62 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi0rwqg7u.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::from(\"\");\n    let mut current_beat = 0;\n    let mut current_octave\
    \ = 0;\n    let mut current_length = 0;\n    let mut current_length_index = 0;\n\
    \    let mut current_length_index2 = 0;\n    let mut current_length_index3 = 0;\n\
    \    let mut current_length_index4 = 0;\n    let mut current_length_index5 = 0;\n\
    \    let mut current_length_index6 = 0;\n    let mut current_length_index7 = 0;\n\
    \    let mut current_length_index8 = 0;\n    let mut current_length_index9 = 0;\n\
    \    let mut current_length_index10 = 0;\n    let mut current_length_index11 =\
    \ 0;\n    let mut current_length_index12 = 0;\n    let mut current_length_index13\
    \ = 0;\n    let mut current_length_index14 = 0;\n    let mut current_length_index15\
    \ = 0;\n    let mut current_length_index16 = 0;\n    let mut current_length_index17\
    \ = 0;\n    let mut current_length_index18 = 0;\n    let mut current_length_index19\
    \ = 0;\n    let mut current_length_index20 = 0;\n    let mut current_length_index21\
    \ = 0;\n    let mut current_length_index22 = 0;\n    let mut current_length_index23\
    \ = 0;\n    let mut current_length_index24 = 0;\n    let mut current_length_index25\
    \ = 0;\n    let mut current_length_index26 = 0;\n    let mut current_length_index27\
    \ = 0;\n    let mut current_length_index28 = 0;\n    let mut current_length_index29\
    \ = 0;\n    let mut current_length_index30 = 0;\n    let mut current_length_index31\
    \ = 0;\n    let mut current_length_index32 = 0;\n    let mut current_length_index33\
    \ = 0;\n    let mut current_length_index34 = 0;\n    let mut current_length_index35\
    \ = 0;\n    let mut current_length_index36 = 0;\n    let mut current_length_index37\
    \ = 0;\n    let mut current_length_index38 = 0;\n    let mut current_length_index39\
    \ = 0;\n    let mut current_length_index40 = 0;\n    let mut current_length_index41\
    \ = 1;\n    let mut current_length_index42 = 1;\n    let mut current_length_index43\
    \ = 1;\n    let mut current_length_index44 = 1;\n    let mut current_length_index45\
    \ = 1;\n    let mut current_length_index46 = 1;\n    let mut current_length_index47\
    \ = 1;\n    let mut current_length_index48 = 1;\n    let mut current_length_index49\
    \ = 1;\n    let mut current_length_index50 = 1;\n    let mu\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgu0w9ngd.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgu0w9ngd.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_note_length_index\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg9jy7hkb.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg9jy7hkb.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_length = 0;\n    let mut current_note_index = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv28bjx9z.rs:61:40\n   |\n\
    61 |     let mut current_note_length_index44\n   |                           \
    \             ^ help: add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv28bjx9z.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let\
    \ mut current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut\
    \ current_note_oct4 = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6\
    \ = 0;\n    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n\
    \    let mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n   \
    \ let mut current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let\
    \ mut current_note_oct13 = 0;\n    let mut current_note_oct14 = 0;\n    let mut\
    \ current_note_oct15 = 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17\
    \ = 0;\n    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 =\
    \ 0;\n    let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n\
    \    let mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n  \
    \  let mut current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let\
    \ mut current_note_oct26 = 0;\n    let mut current_note_oct27 = 0;\n    let mut\
    \ current_note_oct28 = 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30\
    \ = 0;\n    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 =\
    \ 0;\n    let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n\
    \    let mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n  \
    \  let mut current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let\
    \ mut current_note_oct39 = 0;\n    let mut current_note_oct40 = 0;\n    let mut\
    \ current_note_oct41 = 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43\
    \ = 0;\n    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 =\
    \ 0;\n    let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n\
    \    let mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n  \
    \  let mut current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let\
    \ mut current_note_oct52 = 0;\n    let mut current_note_oct53\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwdt0xy5k.rs:67:31\n   |\n\
    67 |     let mut current_note_oct53\n   |                               ^ help:\
    \ add `;` here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwdt0xy5k.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    for c in music_string.chars() {\n \
    \       if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n  \
    \              beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n              \
    \  current_note += c.to_ascii_lowercase();\n                current_note_length\
    \ += 1;\n            } else if c.to_ascii_lowercase() == '|' {\n             \
    \   beats.push(current_beat);\n                current_beat = 0;\n           \
    \     current_note = String::new();\n                current_note_length = 0;\n\
    \            } else if c.to_ascii_lowercase() == '.' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 0;\n            } else {\n            \
    \    panic!(\"Unknown note in music string\");\n            }\n        } else\
    \ {\n            current_note += c.to_ascii_lowercase();\n            current_note_length\
    \ += 1;\n        }\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n\
    \    current_note.into_owned();\n    current_note_length\n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjvp1jogn.rs:23:33\n   |\n\
    23 |                 current_note += c.to_ascii_lowercase();\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjvp1jogn.rs:39:29\n   |\n39 |  \
    \           current_note += c.to_ascii_lowercase();\n   |                    \
    \         ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0599]:\
    \ no method named `into_owned` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpjvp1jogn.rs:45:18\n   |\n45 |     current_note.into_owned();\n\
    \   |                  ^^^^^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjvp1jogn.rs:46:5\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |                                         ----------\
    \ expected `Vec<isize>` because of return type\n...\n46 |     current_note_length\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found integer\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n                found type `{integer}`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_beats_length = 0;\n    while current_note != \"\"\
    \ {\n        if current_note == \"o\" {\n            beats.push(current_beat);\n\
    \            current_beats_length += 4;\n            current_beat = 0;\n     \
    \       current_note = notes.next();\n        } else if current_note == \"o|\"\
    \ {\n            beats.push(current_beat);\n            current_beats_length +=\
    \ 2;\n            current_beat = 0;\n            current_note = notes.next();\n\
    \        } else if current_note == \".|\" {\n            beats.push(current_beat);\n\
    \            current_beats_length += 1;\n            current_beat = 0;\n     \
    \       current_note = notes.next();\n        } else {\n            current_beat\
    \ += 1;\n            current_note = notes.next();\n        }\n    }\n    beats.push(current_beat);\n\
    \    current_beats_length += 1;\n    current_beat = 0;\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmpfwjbxgue.rs:16:24\n\
    \   |\n16 |     while current_note != \"\" {\n   |                        ^^ no\
    \ implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare\
    \ `&str` with `str`\n  --> /tmp/tmpfwjbxgue.rs:17:25\n   |\n17 |         if current_note\
    \ == \"o\" {\n   |                         ^^ no implementation for `&str == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&str`\n \
    \  = note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&&str`\n\nerror[E0599]: no method named `next` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpfwjbxgue.rs:21:34\n   |\n21 |          \
    \   current_note = notes.next();\n   |                                  ^^^^ method\
    \ not found in `Vec<&str>`\n\nerror[E0277]: can't compare `&str` with `str`\n\
    \  --> /tmp/tmpfwjbxgue.rs:22:32\n   |\n22 |         } else if current_note ==\
    \ \"o|\" {\n   |                                ^^ no implementation for `&str\
    \ == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented for\
    \ `&str`\n   = note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&&str`\n\nerror[E0599]: no method named `next` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpfwjbxgue.rs:26:34\n   |\n26 |          \
    \   current_note = notes.next();\n   |                                  ^^^^ method\
    \ not found in `Vec<&str>`\n\nerror[E0277]: can't compare `&str` with `str`\n\
    \  --> /tmp/tmpfwjbxgue.rs:27:32\n   |\n27 |         } else if current_note ==\
    \ \".|\" {\n   |                                ^^ no implementation for `&str\
    \ == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented for\
    \ `&str`\n   = note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&&str`\n\nerror[E0599]: no method named `next` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpfwjb"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    for c in music_string {\n\
    \        if c == 'o' {\n            if current_note.len() == 0 {\n           \
    \     println!(\"Invalid music string\");\n                break;\n          \
    \  }\n            beats.push(current_beat + 4);\n            current_beat = 0;\n\
    \            current_note = String::new();\n            current_note_length =\
    \ String::new();\n        } else if c == 'o|' {\n            if current_note.len()\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  break;\n            }\n            beats.push(current_beat + 2);\n        \
    \    current_beat = 0;\n            current_note = String::new();\n          \
    \  current_note_length = String::new();\n        } else if c == '.|' {\n     \
    \       if current_note.len() == 0 {\n                println!(\"Invalid music\
    \ string\");\n                break;\n            }\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_length = String::new();\n        } else {\n          \
    \  current_note.push(c);\n            current_note_length.push(c);\n        }\n\
    \    }\n    beats.push(current_beat + 4);\n    beats\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp_9has6dw.rs:25:27\n\
    \   |\n25 |         } else if c == 'o|' {\n   |                           ^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    for c in music_string {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                if current_note_len\
    \ == 0 {\n                    current_note_len = 4;\n                    current_note\
    \ = String::from(\"o\");\n                } else {\n                    current_note_len\
    \ += 1;\n                }\n            } else if c.to_ascii_lowercase() == 'o|'\
    \ {\n                if current_note_len == 0 {\n                    current_note_len\
    \ = 2;\n                    current_note = String::from(\"o|\");\n           \
    \     } else {\n                    current_note_len += 1;\n                }\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                if current_note_len\
    \ == 0 {\n                    current_note_len = 1;\n                    current_note\
    \ = String::from(\".|\");\n                } else {\n                    current_note_len\
    \ += 1;\n                }\n            } else {\n                println!(\"\
    unknown note {}\", c);\n            }\n        } else {\n            println!(\"\
    unknown character {}\", c);\n        }\n        if current_note_len == 0 {\n \
    \           beats.push(current_beat);\n            current_beat = 0;\n       \
    \     current_note_len = 0;\n            current_note = String::new();\n     \
    \   } else {\n            current_beat += 1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmppmg1s8lp.rs:24:52\n\
    \   |\n24 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_index = 0;\n    let mut current_note_length = 0;\n   \
    \ let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_index = 0;\n    let mut current_note_length_value_value\
    \ = 0;\n    let mut current_note_length_value_value_index = 0;\n    let mut current_note_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpqbwv8sxp.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_beat_length = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat = 0;\n    let mut\
    \ current_note_length_to_beat_length_to_beat_length = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpufssvn14.rs:34:77\n   |\n\
    34 |     let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\n\
    \   |                                                                        \
    \     ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpufssvn14.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.split_whitespace();\n    let mut current_note\
    \ = notes.next().unwrap();\n    let mut current_beat = 0;\n    while let Some(note)\
    \ = notes.next() {\n        if note != current_note {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = note;\n        }\n\
    \        current_beat += 1;\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp9mwteu6v.rs:13:41

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_note = String::from(\"\");\n    let mut current_beat\
    \ = 0;\n    let mut current_octave = 0;\n    let mut current_length = 0;\n\n \
    \   for c in music_string.chars() {\n        match c {\n            'o' => {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_length += 1;\n                current_note += \".\";\n\
    \            }\n            '|' => {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_length += 1;\n   \
    \             current_note += \"|\";\n            }\n            '.' => {\n  \
    \              beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_length += 1;\n                current_note += \"o\";\n\
    \            }\n            _ => {\n                current_beat += 1;\n     \
    \           current_length += 1;\n                current_note += c.to_string();\n\
    \            }\n        }\n    }\n    beats.push(current_beat);\n    current_length\
    \ += 1;\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpljm4usgc.rs:40:33\n   |\n\
    40 |                 current_note += c.to_string();\n   |                    \
    \             ^^^^^^^^^^^^^\n   |                                 |\n   |    \
    \                             expected `&str`, found struct `String`\n   |   \
    \                              help: consider borrowing here: `&c.to_string()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_note_length_index\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg9jy7hkb.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg9jy7hkb.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_len = 0;\n    let mut current_note_oct\
    \ = 0;\n    let mut current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n\
    \    let mut current_note_oct4 = 0;\n    let mut current_note_oct5 = 0;\n    let\
    \ mut current_note_oct6 = 0;\n    let mut current_note_oct7 = 0;\n    let mut\
    \ current_note_oct8 = 0;\n    let mut current_note_oct9 = 0;\n    let mut current_note_oct10\
    \ = 0;\n    let mut current_note_oct11 = 0;\n    let mut current_note_oct12 =\
    \ 0;\n    let mut current_note_oct13 = 0;\n    let mut current_note_oct14 = 0;\n\
    \    let mut current_note_oct15 = 0;\n    let mut current_note_oct16 = 0;\n  \
    \  let mut current_note_oct17 = 0;\n    let mut current_note_oct18 = 0;\n    let\
    \ mut current_note_oct19 = 0;\n    let mut current_note_oct20 = 0;\n    let mut\
    \ current_note_oct21 = 0;\n    let mut current_note_oct22 = 0;\n    let mut current_note_oct23\
    \ = 0;\n    let mut current_note_oct24 = 0;\n    let mut current_note_oct25 =\
    \ 0;\n    let mut current_note_oct26 = 0;\n    let mut current_note_oct27 = 0;\n\
    \    let mut current_note_oct28 = 0;\n    let mut current_note_oct29 = 0;\n  \
    \  let mut current_note_oct30 = 0;\n    let mut current_note_oct31 = 0;\n    let\
    \ mut current_note_oct32 = 0;\n    let mut current_note_oct33 = 0;\n    let mut\
    \ current_note_oct34 = 0;\n    let mut current_note_oct35 = 0;\n    let mut current_note_oct36\
    \ = 0;\n    let mut current_note_oct37 = 0;\n    let mut current_note_oct38 =\
    \ 0;\n    let mut current_note_oct39 = 0;\n    let mut current_note_oct40 = 0;\n\
    \    let mut current_note_oct41 = 0;\n    let mut current_note_oct42 = 0;\n  \
    \  let mut current_note_oct43 = 0;\n    let mut current_note_oct44 = 0;\n    let\
    \ mut current_note_oct45 = 0;\n    let mut current_note_oct46 = 0;\n    let mut\
    \ current_note_oct47 = 0;\n    let mut current_note_oct48 = 0;\n    let mut current_note_oct49\
    \ = 0;\n    let mut current_note_oct50 = 0;\n    let mut current_note_oct51 =\
    \ 0;\n    let mut current_note_oct52 = 0;\n    let mut current_note_\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjo28dgg9.rs:67:26\n   |\n\
    67 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjo28dgg9.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c == 'o' {\n            if current_note_len == 0 {\n                println!(\"\
    Invalid music string\");\n                return beats;\n            }\n     \
    \       beats.push(current_beat);\n            current_beat += 1;\n          \
    \  current_note = String::new();\n            current_note_len = 0;\n        }\
    \ else if c == '|' {\n            if current_note_len == 0 {\n               \
    \ println!(\"Invalid music string\");\n                return beats;\n       \
    \     }\n            beats.push(current_beat);\n            current_beat += 1;\n\
    \            current_note_len += 1;\n        } else if c == '.' {\n          \
    \  if current_note_len != 0 {\n                println!(\"Invalid music string\"\
    );\n                return beats;\n            }\n            current_beat +=\
    \ 1;\n            current_note = String::new();\n            current_note_len\
    \ = 0;\n        } else {\n            current_note.push(c);\n            current_note_len\
    \ = c.len_utf8();\n        }\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmprkio3a48.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    for c in music_string.chars() {\n \
    \       if c == 'o' {\n            if current_note != 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = 0;\n      \
    \          current_note_length = 0;\n            }\n            current_note =\
    \ 1;\n            current_note_length = 4;\n        } else if c == '|' {\n   \
    \         if current_note != 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = 0;\n      \
    \          current_note_length = 0;\n            }\n            current_note =\
    \ 2;\n            current_note_length = 2;\n        } else if c == '.' {\n   \
    \         if current_note != 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = 0;\n      \
    \          current_note_length = 0;\n            }\n            current_note =\
    \ 3;\n            current_note_length = 1;\n        } else {\n            current_note\
    \ += 1;\n            current_note_length += 1;\n            current_beat += 1;\n\
    \        }\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n    current_note\
    \ = 0;\n    current_note_length = 0;\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpk0qj9j_r.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_note_count = 0;\n    let mut current_note_length =\
    \ 0;\n    while current_note != \"\" {\n        if current_note == \"o\" {\n \
    \           current_note_count += 4;\n            current_note_length = 4;\n \
    \       } else if current_note == \"o|\" {\n            current_note_count +=\
    \ 2;\n            current_note_length = 2;\n        } else if current_note ==\
    \ \".|\" {\n            current_note_count += 1;\n            current_note_length\
    \ = 1;\n        } else {\n            assert!(current_note != \".|\");\n     \
    \       current_note_count += 1;\n            current_note_length = 1;\n     \
    \   }\n        beats.push(current_beat);\n        current_beat = 0;\n        current_note\
    \ = notes.next();\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp72hl8mr4.rs:17:24\n\
    \   |\n17 |     while current_note != \"\" {\n   |                        ^^ no\
    \ implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare\
    \ `&str` with `str`\n  --> /tmp/tmp72hl8mr4.rs:18:25\n   |\n18 |         if current_note\
    \ == \"o\" {\n   |                         ^^ no implementation for `&str == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&str`\n \
    \  = note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&&str`\n\nerror[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp72hl8mr4.rs:21:32\n\
    \   |\n21 |         } else if current_note == \"o|\" {\n   |                 \
    \               ^^ no implementation for `&str == str`\n   |\n   = help: the trait\
    \ `PartialEq<str>` is not implemented for `&str`\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmp72hl8mr4.rs:24:32\n   |\n24 |\
    \         } else if current_note == \".|\" {\n   |                           \
    \     ^^ no implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare\
    \ `&str` with `str`\n  --> /tmp/tmp72hl8mr4.rs:28:34\n   |\n28 |             assert!(current_note\
    \ != \".|\");\n   |                                  ^^ no implementation for\
    \ `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&&str`\n\nerror[E0599]: no method named `next` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmp72hl8mr4.rs:34:30\n   |\n34 |         current_note\
    \ = notes.next();\n   |                              ^^^^ method not found "
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_char = String::new();\n    let mut current_note_char_len\
    \ = music_string.len();\n    let mut current_note_char_pos = 0;\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut current_note_char_pos\
    \ = music_string.len();\n    let mut current_note_char_pos = music_string.len();\n\
    \    let mut current_note_char_pos = music_string.len();\n    let mut \n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpp5k278vc.rs:53:1\n\
    \   |\n53 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      } else if c == '|' {\n            current_beat = current_beat + 1;\n  \
    \          current_note.push(c);\n        } else if c == '.' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      } else {\n            current_note.push(c);\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpz11g0g8o.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_note_count = 0;\n    for note in notes {\n       \
    \ if note == current_note {\n            current_note_count = current_note_count\
    \ + 1;\n        } else {\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note_count = 1;\n            current_note = note;\n\
    \        }\n        current_beat = current_beat + 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpluids15j.rs:17:17\n\
    \   |\n17 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = note: required because of the requirements on the impl of `PartialEq<&&str>`\
    \ for `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpluids15j.rs:23:28\n\
    \   |\n23 |             current_note = note;\n   |                           \
    \ ^^^^ expected `&str`, found `str`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&str`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    for c in music_string.chars() {\n        if\
    \ c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n           \
    \     beats.push(current_beat);\n                current_beat = 0;\n         \
    \       current_note = String::new();\n                current_octave = 0;\n \
    \           } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_octave = 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.|' {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_octave\
    \ = 2;\n            } else {\n                current_note.push(c);\n        \
    \    }\n        } else {\n            current_note.push(c);\n        }\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpp5jro0g6.rs:22:52\n\
    \   |\n22 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = String::new();\n                current_note_length\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == 'o|' {\n \
    \               beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = String::new();\n                current_note_length = String::new();\n   \
    \         } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = String::new();\n                current_note_length\
    \ = String::new();\n            } else {\n                current_note.push(c);\n\
    \                current_note_length.push(c);\n            }\n        } else {\n\
    \            if current_note.is_empty() {\n                println!(\"Invalid\
    \ music string\");\n                return beats;\n            }\n           \
    \ let note = current_note.to_ascii_lowercase();\n            let note_length =\
    \ current_note_length.to_ascii_lowercase();\n            if note == \"o\" {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = String::new();\n                current_note_length = String::new();\n   \
    \         } else if note == \"o|\" {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = String::new();\n                current_note_length\
    \ = String::new();\n            } else if note == \".|\" {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = String::new();\n                current_note_length\
    \ = String::new();\n            } else {\n                current_note.push(c);\n\
    \                current_note_length.push(c);\n            }\n        }\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpzgsjjhuh.rs:24:52\n\
    \   |\n24 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note.push(c);\n            }\n\
    \        } else {\n            if current_note.is_empty() {\n                panic!(\"\
    Music string contains non-ASCII character\");\n            }\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpfiytj518.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats_vec: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    for c in music_string {\n        if c == 'o' {\n       \
    \     if current_beat == 0 {\n                current_beat = 4;\n            }\n\
    \            current_note = String::new();\n            current_note.push_str(&c.to_string());\n\
    \        } else {\n            if current_beat == 0 {\n                current_beat\
    \ = 1;\n            }\n            if current_beat == 1 {\n                current_note.push_str(&c.to_string());\n\
    \            } else {\n                beats_vec.push(current_beat);\n       \
    \         current_beat = 1;\n                current_note.push_str(&c.to_string());\n\
    \            }\n        }\n    }\n    beats_vec.push(current_beat);\n    beats_vec\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpxf248q4f.rs:14:14\n\
    \    |\n14  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaplppc90.rs:63:32\n   |\n\
    63 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpaplppc90.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpimyn5mcd.rs:62:32\n   |\n\
    62 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpimyn5mcd.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string {\n        if c\
    \ == 'o' {\n            if current_note != String::new() {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            }\n            current_note_length = 0;\n        } else if c == '|'\
    \ {\n            if current_note != String::new() {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            }\n            current_note_length = 1;\n        } else if c == '.'\
    \ {\n            if current_note != String::new() {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            }\n            current_note_length = 2;\n        } else {\n     \
    \       current_note.push(c);\n            current_note_length += 1;\n       \
    \ }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpq6rhgfmn.rs:15:14\n\
    \    |\n15  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9uz9mh3q.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().map(|c| match c {\n        'o' => 4,\n\
    \        'o|' => 2,\n        '.|' => 1,\n        _ => 0,\n    });\n    let mut\
    \ last_note = notes.last().unwrap();\n    let mut last_beat = 0;\n    while notes.len()\
    \ > 0 {\n        let mut beat = 0;\n        let mut note = notes.last().unwrap();\n\
    \        while note != last_note {\n            beat += 1;\n            last_beat\
    \ = beat;\n            last_note = note;\n            note = notes.last().unwrap();\n\
    \        }\n        beats.push(beat);\n        notes = notes.iter().skip(1).collect();\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpuaszdpzm.rs:14:12\n\
    \   |\n14 |         'o|' => 2,\n   |            ^^^^^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != 'o');\n    for note in notes {\n        let mut beat = 0;\n        let mut\
    \ last_note = note.1;\n        while note != last_note {\n            beat +=\
    \ 1;\n            last_note = note.1;\n            note = note.2;\n        }\n\
    \        beats.push(beat);\n    }\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0fwqh5vp.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0fwqh5vp.rs:16:23\n   |\n16 |         while\
    \ note != last_note {\n   |                       ^^^^^^^^^ expected tuple, found\
    \ `char`\n   |\n   = note: expected tuple `(usize, char)`\n               found\
    \ type `char`\n\nerror[E0609]: no field `2` on type `(usize, char)`\n  --> /tmp/tmp0fwqh5vp.rs:19:25\n\
    \   |\n19 |             note = note.2;\n   |                         ^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    let mut current_note_length:\
    \ isize = 0;\n    let mut current_note_length_index: usize = 0;\n    let mut current_note_length_index2:\
    \ usize = 0;\n    let mut current_note_length_index3: usize = 0;\n    let mut\
    \ current_note_length_index4: usize = 0;\n    let mut current_note_length_index5:\
    \ usize = 0;\n    let mut current_note_length_index6: usize = 0;\n    let mut\
    \ current_note_length_index7: usize = 0;\n    let mut current_note_length_index8:\
    \ usize = 0;\n    let mut current_note_length_index9: usize = 0;\n    let mut\
    \ current_note_length_index10: usize = 0;\n    let mut current_note_length_index11:\
    \ usize = 0;\n    let mut current_note_length_index12: usize = 0;\n    let mut\
    \ current_note_length_index13: usize = 0;\n    let mut current_note_length_index14:\
    \ usize = 0;\n    let mut current_note_length_index15: usize = 0;\n    let mut\
    \ current_note_length_index16: usize = 0;\n    let mut current_note_length_index17:\
    \ usize = 0;\n    let mut current_note_length_index18: usize = 0;\n    let mut\
    \ current_note_length_index19: usize = 0;\n    let mut current_note_length_index20:\
    \ usize = 0;\n    let mut current_note_length_index21: usize = 0;\n    let mut\
    \ current_note_length_index22: usize = 0;\n    let mut current_note_length_index23:\
    \ usize = 0;\n    let mut current_note_length_index24: usize = 0;\n    let mut\
    \ current_note_length_index25: usize = 0;\n    let mut current_note_length_index26:\
    \ usize = 0;\n    let mut current_note_length_index27: usize = 0;\n    let mut\
    \ current_note_length_index28: usize = 0;\n    let mut current_note_length_index29:\
    \ usize = 0;\n    let mut current_note_length_index30: usize = 0;\n    let mut\
    \ current_note_length_index31: usize = 0;\n    let mut current_note_length_index32:\
    \ usize = 0;\n    let mut current_note_length_index33: usize = 0;\n    let mut\
    \ current_note_length_index34: usize = 0;\n    let mut current_note_length_index35:\
    \ usize = 0;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp42a7p6bg.rs:51:21\n   |\n\
    51 |     let mut current_\n   |                     ^ help: add `;` here\n52 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp42a7p6bg.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9uz9mh3q.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octoctlen = 0;\n    let\
    \ mut current_note_octoctlen2 = 0;\n    let mut current_note_octlen3 = 0;\n  \
    \  let mut current_note_octlen4 = 0;\n    let mut current_note_octlen5 = 0;\n\
    \    let mut current_note_octlen6 = 0;\n    let mut current_note_octlen7 = 0;\n\
    \    let mut current_note_octlen8 = 0;\n    let mut current_note_octlen9 = 0;\n\
    \    let mut current_note_octlen10 = 0;\n    let mut current_note_octlen11 = 0;\n\
    \    let mut current_note_octlen12 = 0;\n    let mut current_note_octlen13 = 0;\n\
    \    let mut current_note_octlen14 = 0;\n    let mut current_note_octlen15 = 0;\n\
    \    let mut current_note_octlen16 = 0;\n    let mut current_note_octlen17 = 0;\n\
    \    let mut current_note_octlen18 = 0;\n    let mut current_note_octlen19 = 0;\n\
    \    let mut current_note_octlen20 = 0;\n    let mut current_note_octlen21 = 0;\n\
    \    let mut current_note_octlen22 = 0;\n    let mut current_note_octlen23 = 0;\n\
    \    let mut current_note_octlen24 = 0;\n    let mut current_note_octlen25 = 0;\n\
    \    let mut current_note_octlen26 = 0;\n    let mut current_note_octlen27 = 0;\n\
    \    let mut current_note_octlen28 = 0;\n    let mut current_note_octlen29 = 0;\n\
    \    let mut current_note_octlen30 = 0;\n    let mut current_note_octlen31 = 0;\n\
    \    let mut current_note_octlen32 = 0;\n    let mut current_note_octlen33 = 0;\n\
    \    let mut current_note_octlen34 = 0;\n    let mut current_note_octlen35 = 0;\n\
    \    let mut current_note_octlen36 = 0;\n    let mut current_note_octlen37 = 0;\n\
    \    let mut current_note_octlen38 = 0;\n    let mut current_note_octlen39 = 0;\n\
    \    let mut current_note_octlen40 = 0;\n    let mut current_note_octlen41 = 0;\n\
    \    let mut current_note_octlen42 = 0;\n    let mut current_note_octlen43 = 0;\n\
    \    let mut current_note_octlen44 = 0;\n    let mut current_note_octlen45 = 0;\n\
    \    let mut current_note_oct\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6ocgwrbh.rs:62:29\n   |\n\
    62 |     let mut current_note_oct\n   |                             ^ help: add\
    \ `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6ocgwrbh.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_note = String::from(\"\");\n    let mut current_beat\
    \ = 0;\n    let mut current_note_index = 0;\n    let mut current_note_length =\
    \ 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note_index\
    \ == 0 {\n                beats.push(current_beat);\n            }\n         \
    \   current_note_index += 1;\n            current_beat = 0;\n            current_note\
    \ = String::from(\"\");\n            current_note_length = 0;\n        } else\
    \ if c == '|' {\n            if current_note_index == 0 {\n                beats.push(current_beat);\n\
    \            }\n            current_note_index += 1;\n            current_beat\
    \ = 0;\n            current_note = String::from(\"\");\n            current_note_length\
    \ = 0;\n        } else if c == '.' {\n            if current_note_index == 0 {\n\
    \                beats.push(current_beat);\n            }\n            current_note_index\
    \ += 1;\n            current_beat = 0;\n            current_note = String::from(\"\
    \");\n            current_note_length = 0;\n        } else {\n            current_note\
    \ += c;\n            current_note_length += 1;\n            current_beat += 1;\n\
    \        }\n    }\n    if current_note_index == 0 {\n        beats.push(current_beat);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmps2irozon.rs:16:14\n\
    \    |\n16  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmps2irozon.rs:17:14\n\
    \   |\n17 |         if c == 'o' {\n   |              ^^ no implementation for\
    \ `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmps2irozon.rs:25:21\n\
    \   |\n25 |         } else if c == '|' {\n   |                     ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmps2irozon.rs:33:21\n\
    \   |\n33 |         } else if c == '.' {\n   |                     ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplvdvbj06.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplvdvbj06.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaplppc90.rs:63:32\n   |\n\
    63 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpaplppc90.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    for c in music_string.chars() {\n        if\
    \ c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n           \
    \     if current_beat > 0 {\n                    beats.push(current_beat);\n \
    \               }\n                current_beat = 0;\n                current_note\
    \ = String::new();\n                current_octave = 0;\n            } else if\
    \ c.to_ascii_lowercase() == '|' {\n                if current_beat > 0 {\n   \
    \                 beats.push(current_beat);\n                }\n             \
    \   current_beat = 0;\n                current_note = String::new();\n       \
    \         current_octave = 0;\n            } else if c.to_ascii_lowercase() ==\
    \ '.' {\n                if current_beat > 0 {\n                    beats.push(current_beat);\n\
    \                }\n                current_beat = 0;\n                current_note\
    \ = String::new();\n                current_octave = 0;\n            } else {\n\
    \                current_note.push(c);\n            }\n        } else {\n    \
    \        if current_beat > 0 {\n                beats.push(current_beat);\n  \
    \          }\n            current_beat = 0;\n            current_note = String::new();\n\
    \            current_octave = 0;\n        }\n    }\n    if current_beat > 0 {\n\
    \        beats.push(current_beat);\n    }\n    beats\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[4, 4, 4, 4]`', /tmp/tmps_7ewz0a.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats_vec: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_len = 0;\n    let mut current_note_char = 0;\n    let\
    \ mut current_note_char_len = 0;\n    let mut current_note_char_char = 0;\n  \
    \  let mut current_note_char_char_len = 0;\n    let mut current_note_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_len = 0;\n    let mut current_note_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_len = 0;\n    let mut current_note_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_len = 0;\n    let mut\
    \ current_note_char_char_char_char_char_char = 0;\n    let mut current_note_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char = 0;\n   \
    \ let mut current_note_char_char_char_char_char_char_char_len = 0;\n    let mut\
    \ current_note_char_char_char_char_char_char_char_char = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpq1h8y_hx.rs:45:1\n  \
    \ |\n45 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    for c in music_string.chars() {\n        if\
    \ c == 'o' {\n            if current_note.is_empty() {\n                println!(\"\
    Invalid music string\");\n                return beats;\n            }\n     \
    \       beats.push(current_beat);\n            current_beat = 0;\n           \
    \ current_note = String::new();\n            current_octave = 0;\n        } else\
    \ if c == '|' {\n            if current_note.is_empty() {\n                println!(\"\
    Invalid music string\");\n                return beats;\n            }\n     \
    \       current_beat += 1;\n            current_note.push(c);\n            current_octave\
    \ += 1;\n        } else if c == '.' {\n            if current_note.is_empty()\
    \ {\n                println!(\"Invalid music string\");\n                return\
    \ beats;\n            }\n            current_beat += 1;\n            current_note.push(c);\n\
    \            current_octave += 1;\n        } else {\n            current_note.push(c);\n\
    \            current_octave += 1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpb2as1ghz.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: usize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: usize = 0;\n    let mut current_note_is_octave\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rest\
    \ = false;\n    let mut current_note\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkm6ccjnz.rs:66:25\n   |\n\
    66 |     let mut current_note\n   |                         ^ help: add `;` here\n\
    67 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkm6ccjnz.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&'static str> = vec![];\n    let mut last_note\
    \ = String::from(\"\");\n    let mut last_beat = 0;\n    let mut last_beat_index\
    \ = 0;\n    for note in music_string.chars() {\n        if note == 'o' {\n   \
    \         if last_note != \"\" {\n                notes.push(last_note);\n   \
    \             beats.push(last_beat);\n            }\n            last_note = String::from(\"\
    \");\n            last_beat = 0;\n            last_beat_index = 0;\n        }\
    \ else if note == '|' {\n            if last_note != \"\" {\n                notes.push(last_note);\n\
    \                beats.push(last_beat);\n            }\n            last_note\
    \ = String::from(\"\");\n            last_beat = 0;\n            last_beat_index\
    \ = 0;\n        } else if note == '.' {\n            if last_note != \"\" {\n\
    \                notes.push(last_note);\n                beats.push(last_beat);\n\
    \            }\n            last_note = String::from(\"\");\n            last_beat\
    \ = 0;\n            last_beat_index = 0;\n        } else {\n            let mut\
    \ beat = last_beat_index;\n            let mut note = note.to_string();\n    \
    \        if note != last_note {\n                notes.push(note);\n         \
    \       beats.push(beat);\n            }\n            last_beat_index += 1;\n\
    \            last_beat = beat;\n            last_note = note;\n        }\n   \
    \ }\n    notes.push(last_note);\n    beats.push(last_beat);\n    beats\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdm4uveid.rs:19:28\n   |\n\
    19 |                 notes.push(last_note);\n   |                            ^^^^^^^^^\n\
    \   |                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&last_note`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdm4uveid.rs:27:28\n\
    \   |\n27 |                 notes.push(last_note);\n   |                     \
    \       ^^^^^^^^^\n   |                            |\n   |                   \
    \         expected `&str`, found struct `String`\n   |                       \
    \     help: consider borrowing here: `&last_note`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdm4uveid.rs:35:28\n   |\n35 |                 notes.push(last_note);\n\
    \   |                            ^^^^^^^^^\n   |                            |\n\
    \   |                            expected `&str`, found struct `String`\n   |\
    \                            help: consider borrowing here: `&last_note`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdm4uveid.rs:45:28\n   |\n45 |              \
    \   notes.push(note);\n   |                            ^^^^\n   |            \
    \                |\n   |                            expected `&str`, found struct\
    \ `String`\n   |                            help: consider borrowing here: `&note`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdm4uveid.rs:53:16\n   |\n53 |\
    \     notes.push(last_note);\n   |                ^^^^^^^^^\n   |            \
    \    |\n   |                expected `&str`, found struct `String`\n   |     \
    \           help: consider borrowing here: `&last_note`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpe94v67xa.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi0rwqg7u.rs:62:26\n   |\n\
    62 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi0rwqg7u.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_octave = 0;\n    let\
    \ mut current_note_duration = 0;\n    let mut current_note_duration_octave = 0;\n\
    \    let mut current_note_duration_duration = 0;\n    let mut current_note_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration = 0;\n    let mut\
    \ current_note_duration_duration_duration_octave = 0;\n    let mut current_note_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_octave =\
    \ 0;\n    let mut current_note_duration_duration_duration_duration_duration =\
    \ 0;\n    let mut current_note_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_octave\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_duration\
    \ = 0;\n    let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpojs2pei1.rs:47:107\n   |\n\
    47 |     let mut current_note_duration_duration_duration_duration_duration_duration_duration_duration_duration_\n\
    \   |                                                                        \
    \                                   ^ help: add `;` here\n48 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpojs2pei1.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n\
    \    let mut current_note = 0;\n    for note in notes {\n        if note.1 ==\
    \ notes.len() {\n            notes.remove(note);\n        }\n        let note\
    \ = note.0;\n        if note == 'o' {\n            beats.push(4);\n          \
    \  current_note = 0;\n        } else if note == 'o|' {\n            beats.push(2);\n\
    \            current_note = 1;\n        } else if note == '.|' {\n           \
    \ beats.push(1);\n            current_note = 2;\n        } else {\n          \
    \  beats.push(0);\n        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp634yp0t5.rs:22:30\n\
    \   |\n22 |         } else if note == 'o|' {\n   |                           \
    \   ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1q04hoe.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats_vec: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octoct = 0;\n    let\
    \ mut current_note_octoctlen = 0;\n    let mut current_note_octoctlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n \
    \   let mut current_note_octlen = 0;\n\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnxrtiist.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplvdvbj06.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplvdvbj06.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    let mut current_is_last\
    \ = false;\n    let mut current_is_octave = false;\n    let mut current_is_note\
    \ = false;\n    for c in music_string.chars() {\n        if c.is_ascii() {\n \
    \           if current_is_note {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_is_note = false;\n\
    \            }\n            current_note = c.to_string();\n            current_is_note\
    \ = true;\n        } else if c.is_digit() {\n            if current_is_note {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_is_note = false;\n            }\n            current_is_last\
    \ = true;\n            current_is_octave = false;\n            current_octave\
    \ = c.to_digit(10).unwrap();\n            current_is_note = true;\n        } else\
    \ if c.is_whitespace() {\n            if current_is_note {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_is_note = false;\n\
    \            }\n            current_is_last = false;\n            current_is_octave\
    \ = false;\n            current_is_note = true;\n        } else {\n          \
    \  if current_is_note {\n                beats.push(current_beat);\n         \
    \       current_beat = 0;\n                current_is_note = false;\n        \
    \    }\n            current_is_last = false;\n            current_is_octave =\
    \ false;\n            current_is_note = true;\n        }\n    }\n    if current_is_note\
    \ {\n        beats.push(current_beat);\n    }\n    beats\n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpw3w_qox3.rs:27:21\n    |\n27  |         } else if c.is_digit()\
    \ {\n    |                     ^^^^^^^^- supplied 0 arguments\n    |         \
    \            |\n    |                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw3w_qox3.rs:35:30\n\
    \   |\n35 |             current_octave = c.to_digit(10).unwrap();\n   |      \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `u32`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::from(\"\");\n    let mut current_beat = 0;\n    let mut current_octave\
    \ = 0;\n    let mut current_note_count = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.is_ascii(10) {\n            \
    \    notes.push(current_note);\n                current_note = String::from(\"\
    \");\n                current_beat = 0;\n                current_octave = 0;\n\
    \                current_note_count = 0;\n            } else {\n             \
    \   current_note += c.to_string();\n            }\n        } else {\n        \
    \    if c.is_ascii(122) {\n                current_note = notes[current_note_count].to_string();\n\
    \                current_note_count = current_note_count + 1;\n            } else\
    \ {\n                let note = notes[current_note_count].to_string();\n     \
    \           let octave = notes[current_note_count + 1].to_string();\n        \
    \        let beat = notes[current_note_count + 2].to_string();\n             \
    \   beats.push(current_beat + beat.parse().unwrap());\n                current_beat\
    \ = 0;\n                current_octave = octave.parse().unwrap();\n          \
    \      current_note_count = 0;\n                current_note = note.to_string();\n\
    \            }\n        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp979dc4r7.rs:19:18\n     |\n19   |             if c.is_ascii(10)\
    \ {\n     |                  ^^^^^^^^ -- supplied 1 argument\n     |         \
    \         |\n     |                  expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp979dc4r7.rs:20:28\n\
    \   |\n20 |                 notes.push(current_note);\n   |                  \
    \          ^^^^^^^^^^^^\n   |                            |\n   |             \
    \               expected `&str`, found struct `String`\n   |                 \
    \           help: consider borrowing here: `&current_note`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp979dc4r7.rs:26:33\n   |\n26 |                 current_note\
    \ += c.to_string();\n   |                                 ^^^^^^^^^^^^^\n   |\
    \                                 |\n   |                                 expected\
    \ `&str`, found struct `String`\n   |                                 help: consider\
    \ borrowing here: `&c.to_string()`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmp979dc4r7.rs:29:18\n     |\n29 \
    \  |             if c.is_ascii(122) {\n     |                  ^^^^^^^^ --- supplied\
    \ 1 argument\n     |                  |\n     |                  expected 0 arguments\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_beat = 0;\n    let\
    \ mut current_note_beat_len = 0;\n    let mut current_note_octave = 0;\n    let\
    \ mut current_note_octave_len = 0;\n    let mut current_note_octave_sign = 0;\n\
    \    let mut current_note_octave_sign_len = 0;\n    let mut current_note_octave_sign_index\
    \ = 0;\n    let mut current_note_octave_index = 0;\n    let mut current_note_octave_len_index\
    \ = 0;\n    let mut current_note_octave_len_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_octave_index_len = 0;\n    let mut current_note_octave_index_len\
    \ = 0;\n    let mut current_note_oct\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2nadn339.rs:58:29\n   |\n\
    58 |     let mut current_note_oct\n   |                             ^ help: add\
    \ `;` here\n59 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2nadn339.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_is_octave = false;\n\
    \    let mut current_note_is_rest = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_resting = false;\n    let mut current_note_is_resting_octave\
    \ = 0;\n    let mut current_note_is_resting_note = String::new();\n    let mut\
    \ current_note_is_resting_octave_is_octave = false;\n    let mut current_note_is_resting_note_is_rest\
    \ = false;\n    let mut current_note_is_resting_note_is_rested = false;\n    let\
    \ mut current_note_is_resting_note_is_resting = false;\n    let mut current_note_is_resting_note_is_resting_octave\
    \ = 0;\n    let mut current_note_is_resting_note_is_resting_note = String::new();\n\
    \    let mut current_note_is_resting_note_is_resting_octave_is_octave = false;\n\
    \    let mut current_note_is_resting_note_is_resting_note_is_rest = false;\n \
    \   let mut current_note_is_resting_note_is_resting_note_is_rested = false;\n\
    \    let mut current_note_is_resting_note_is_resting_note_is_resting = false;\n\
    \    let mut current_note_is_resting_note_is_resting_note_is_resting_octave =\
    \ 0;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note\
    \ = String::new();\n    let mut current_note_is_resting_note_is_resting_note_is_resting_octave_is_octave\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_rest\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_rested\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting_octave\
    \ = 0;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting_note\
    \ = String::new();\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting_octave_is_octave\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting_note_is_rest\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9xxhib32.rs:41:61\n   |\n\
    41 |     let mut current_note_is_resting_note_is_resting_note_is_\n   |      \
    \                                                       ^ help: add `;` here\n\
    42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9xxhib32.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_beats: isize = 0;\n    let mut current_notes: isize\
    \ = 0;\n    while current_note != \".\" {\n        if current_note == \"o\" {\n\
    \            beats.push(current_beats);\n            current_beats += 1;\n   \
    \         current_notes += 1;\n            current_beat = 0;\n            current_note\
    \ = 0;\n        } else if current_note == \"o|\" {\n            beats.push(current_beats);\n\
    \            current_beats += 1;\n            current_notes += 1;\n          \
    \  current_beat = 0;\n            current_note = 0;\n        } else if current_note\
    \ == \".\" {\n            beats.push(current_beats);\n            current_beats\
    \ += 1;\n            current_notes += 1;\n            current_beat = 0;\n    \
    \        current_note = 0;\n        } else {\n            current_notes += 1;\n\
    \            current_beat = 0;\n        }\n        current_note = notes.next();\n\
    \    }\n    beats.push(current_beats);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp1nhoyv79.rs:17:24\n\
    \   |\n17 |     while current_note != \".\" {\n   |                        ^^\
    \ no implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare\
    \ `&str` with `str`\n  --> /tmp/tmp1nhoyv79.rs:18:25\n   |\n18 |         if current_note\
    \ == \"o\" {\n   |                         ^^ no implementation for `&str == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&str`\n \
    \  = note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1nhoyv79.rs:23:28\n\
    \   |\n23 |             current_note = 0;\n   |                            ^ expected\
    \ `&&str`, found integer\n\nerror[E0277]: can't compare `&str` with `str`\n  -->\
    \ /tmp/tmp1nhoyv79.rs:24:32\n   |\n24 |         } else if current_note == \"o|\"\
    \ {\n   |                                ^^ no implementation for `&str == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&str`\n \
    \  = note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1nhoyv79.rs:29:28\n\
    \   |\n29 |             current_note = 0;\n   |                            ^ expected\
    \ `&&str`, found integer\n\nerror[E0277]: can't compare `&str` with `str`\n  -->\
    \ /tmp/tmp1nhoyv79.rs:30:32\n   |\n30 |         } else if current_note == \".\"\
    \ {\n   |                                ^^ no implementation for `&str == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&str`\n \
    \  = note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1nhoyv79.rs:35:28\n\
    \   |\n35 |             current_note = 0;\n   |                            ^ expected\
    \ `&&str`, found integer\n\nerror[E0599]: no method named `next` found for struct\
    \ `Vec<&str>` in the current scope\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut last_note = String::from(\"\");\n    let mut last_beat = 0;\n   \
    \ for note in notes {\n        if note == last_note {\n            beats.push(last_beat);\n\
    \            last_beat = 0;\n        } else {\n            last_beat = beats.last().unwrap_or(0)\
    \ + 1;\n        }\n        last_note = note;\n    }\n    beats.push(last_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy52ka4c9.rs:20:48\n   |\n\
    20 |             last_beat = beats.last().unwrap_or(0) + 1;\n   |            \
    \                                    ^\n   |                                 \
    \               |\n   |                                                expected\
    \ `&isize`, found integer\n   |                                              \
    \  help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpy52ka4c9.rs:22:21\n   |\n22 |         last_note = note;\n   |      \
    \               ^^^^- help: try using a conversion method: `.to_string()`\n  \
    \ |                     |\n   |                     expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c == 'o' {\n            if current_note_len == 0 {\n                println!(\"\
    Invalid music string\");\n                return beats;\n            }\n     \
    \       beats.push(current_beat);\n            current_beat = 0;\n           \
    \ current_note = String::new();\n            current_note_len = current_note.len();\n\
    \        } else if c == '|' {\n            if current_note_len == 0 {\n      \
    \          println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n            current_note_len\
    \ = current_note.len();\n        } else if c == '.' {\n            if current_note_len\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  return beats;\n            }\n            beats.push(current_beat);\n     \
    \       current_beat = 0;\n            current_note = String::new();\n       \
    \     current_note_len = current_note.len();\n        } else {\n            current_note.push(c);\n\
    \            current_note_len = current_note.len();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpl60_4sfe.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplvdvbj06.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplvdvbj06.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let\
    \ mut current_note_octlen = 0;\n\n    for c in music_string {\n        if c.is_ascii()\
    \ {\n            if c == 'o' {\n                if current_note_len == 0 {\n \
    \                   current_note_len = 4;\n                    current_note_octlen\
    \ = 1;\n                    current_note_oct = 0;\n                } else {\n\
    \                    current_note_len += 1;\n                    current_note_octlen\
    \ += 1;\n                }\n            } else if c == '|' {\n               \
    \ if current_note_len == 0 {\n                    current_note_len = 2;\n    \
    \                current_note_octlen = 1;\n                    current_note_oct\
    \ = 0;\n                } else {\n                    current_note_len += 1;\n\
    \                    current_note_octlen += 1;\n                }\n          \
    \  } else if c == '.' {\n                if current_note_len == 0 {\n        \
    \            current_note_len = 1;\n                    current_note_octlen =\
    \ 1;\n                    current_note_oct = 0;\n                } else {\n  \
    \                  current_note_len += 1;\n                    current_note_octlen\
    \ += 1;\n                }\n            } else {\n                let oct = match\
    \ c {\n                    '0' => 0,\n                    '1' => 1,\n        \
    \            '2' => 2,\n                    '3' => 3,\n                    '4'\
    \ => 4,\n                    '5' => 5,\n                    '6' => 6,\n      \
    \              '7' => 7,\n                    '8' => 8,\n                    '9'\
    \ => 9,\n                    'a' => 10,\n                    'b' => 11,\n    \
    \                'c' => 12,\n                    'd' => 13,\n                \
    \    'e' => 14,\n                    'f' => 15,\n                    'g' => 16,\n\
    \                    'h' => 17,\n                    'i' => 18,\n            \
    \        'j' => 19,\n                    'k' => 20,\n                    'l' =>\
    \ 21,\n                    'm' => 22,\n                    'n' => 23,\n      \
    \              'o' => 24,\n                    'p' => 25,\n                  \
    \  'q' => 26,\n                    'r' => 27,\n                    's' => 28,\n\
    \                    't' => 29,\n                    'u' => 30,\n            \
    \        'v' => 31,\n                    'w' => 32,\n                    'x' =>\
    \ 33,\n                    'y' => 34,\n                    'z' => 35,\n      \
    \              'A' => 36,\n                    'B' => 37,\n                  \
    \  'C' => 38,\n                    'D' => 39,\n                    'E' => 40,\n\
    \                    'F' => 41,\n                    'G' => 42,\n            \
    \        'H' => 43,\n                    'I' => 44,\n                    'J' =>\
    \ 45,\n                    'K' => 46,\n                    'L' => 47,\n      \
    \              'M' => 48,\n                    'N' => 49,\n                  \
    \  'O' => 50,\n                    'P' => 51,\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpbqjqdkzi.rs:110:3\n\
    \    |\n10  | fn parse_music(music_string: String) -> Vec<isize> {\n    |    \
    \                                                - unclosed delimiter\n...\n18\
    \  |     for c in music_string {\n    |                           - unclosed delimiter\n\
    19  |         if c.is_ascii() {\n    |                         - unclosed delimiter\n\
    ...\n47  |             } else {\n    |                    - unclosed delimiter\n\
    48  |                 let oct = match c {\n    |                             \
    \      - this delimiter might not be properly closed...\n...\n101 | }\n    | -\
    \ ...as it matches this but it has different indentation\n...\n110 | }\n    |\
    \   ^\n\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found keyword\
    \ `fn`\n   --> /tmp/tmpbqjqdkzi.rs:103:1\n    |\n101 | }\n    |  - expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n102 | \n103 | fn main() {\n    | ^^\
    \ unexpected token\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpbqjqdkzi.rs:18:14\n\
    \    |\n18  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpbqjqdkzi.rs:18:5\n\
    \    |\n10  |   fn parse_music(music_string: String) -> Vec<isize> {\n    |  \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n18  | /     for c in music_string {\n19  | |         if\
    \ c.is_ascii() {\n20  | |             if c == 'o' {\n21  | |                 if\
    \ current_note_len == 0 {\n...   |\n109 | |     assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n110 | | }\n    | |__^\
    \ expected struct `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n\
    \            found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_note = String::from(\"\");\n    let mut current_beat\
    \ = 0;\n    for c in music_string.chars() {\n        if c.is_whitespace() {\n\
    \            continue;\n        }\n        if c.is_ascii_digit() {\n         \
    \   current_note = c.to_string();\n            current_beat = 0;\n           \
    \ beats.push(current_beat);\n            continue;\n        }\n        if c.is_ascii_letter()\
    \ {\n            if current_note.is_empty() {\n                continue;\n   \
    \         }\n            if c.to_ascii_lowercase() == current_note {\n       \
    \         current_beat += 1;\n            } else {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = c.to_string();\n\
    \            }\n            continue;\n        }\n        assert!(false);\n  \
    \  }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpu4w779k1.rs:24:14\n   |\n24 |         if c.is_ascii_letter()\
    \ {\n   |              ^^^^^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu4w779k1.rs:28:42\n   |\n28 |             if\
    \ c.to_ascii_lowercase() == current_note {\n   |                             \
    \             ^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note.push(c);\n            }\n\
    \        } else {\n            if current_note.is_empty() {\n                println!(\"\
    Invalid music string\");\n                panic!(\"Invalid music string\");\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpq1_9hp_6.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter = 0;\n    let\
    \ mut current_note_length_to_beat_counter_counter_counter = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwfbqxsn2.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note_length_index\
    \ == 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_length\
    \ = 0;\n                current_note_length_index = 0;\n            } else {\n\
    \                current_beat += 1;\n            }\n        } else if c == '|'\
    \ {\n            if current_note_length_index == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 0;\n                current_note_length_index\
    \ = 0;\n            } else {\n                current_beat += 1;\n           \
    \ }\n        } else if c == '.' {\n            if current_note_length_index ==\
    \ 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_length\
    \ = 0;\n                current_note_length_index = 0;\n            } else {\n\
    \                current_beat += 1;\n            }\n        } else {\n       \
    \     if current_note_length_index == 0 {\n                current_note += c;\n\
    \            } else {\n                current_note_length += 1;\n           \
    \ }\n        }\n        current_note_length_index += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp9l2_4gn7.rs:16:14\n\
    \    |\n16  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp9l2_4gn7.rs:17:14\n\
    \   |\n17 |         if c == 'o' {\n   |              ^^ no implementation for\
    \ `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp9l2_4gn7.rs:27:21\n\
    \   |\n27 |         } else if c == '|' {\n   |                     ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp9l2_4gn7.rs:37:21\n\
    \   |\n37 |         } else if c == '.' {\n   |                     ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_is_octave = false;\n\
    \    let mut current_note_is_rest = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_resting_octave = false;\n    for c in\
    \ music_string.chars() {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase()\
    \ == 'o' {\n                if current_note_is_octave {\n                    current_note_is_octave\
    \ = false;\n                    current_note_is_rest = false;\n              \
    \      current_note_is_rested = false;\n                    current_note_is_resting_octave\
    \ = false;\n                    current_octave += 1;\n                } else {\n\
    \                    current_note_is_octave = true;\n                    current_octave\
    \ = 0;\n                }\n            } else if c.to_ascii_lowercase() == '.'\
    \ {\n                if current_note_is_resting {\n                    current_note_is_resting_octave\
    \ = false;\n                } else {\n                    current_note_is_resting_octave\
    \ = true;\n                }\n            } else if c.to_ascii_lowercase() ==\
    \ '|' {\n                if current_note_is_rested {\n                    current_note_is_rest\
    \ = false;\n                } else {\n                    current_note_is_rest\
    \ = true;\n                }\n            } else if c.to_ascii_lowercase() ==\
    \ 'o|' {\n                if current_note_is_resting_octave {\n              \
    \      current_note_is_resting_octave = false;\n                } else {\n   \
    \                 current_note_is_resting_octave = true;\n                }\n\
    \            } else {\n                current_note_is_rest = false;\n       \
    \         current_note_is_rested = false;\n                current_note_is_resting_octave\
    \ = false;\n                current_note_is_octave = false;\n                current_note\
    \ = c.to_ascii_lowercase();\n            }\n        } else {\n            if current_note_is_rest\
    \ {\n                beats.push(current_beat);\n                current_beat =\
    \ 0;\n                current_note_is_rest = false;\n                current_note_is_rested\
    \ = false;\n                current_note_is_resting_octave = false;\n        \
    \        current_note_is_octave = false;\n                current_note = String::new();\n\
    \            } else {\n                current_beat += 1;\n            }\n   \
    \     }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp0rp75oay.rs:44:52\n\
    \   |\n44 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = String::new();\n            } else if c.to_ascii_lowercase()\
    \ == 'o' {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_length\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == '|' {\n  \
    \              beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == '.' {\n  \
    \              beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = String::new();\n            } else {\n                current_note.push(c);\n\
    \                current_note_length.push(c);\n            }\n        } else {\n\
    \            if current_note.is_empty() {\n                println!(\"Music string\
    \ contains non-ascii character\");\n                break;\n            }\n  \
    \          if c.is_ascii() {\n                if c.to_ascii_lowercase() == 'o'\
    \ {\n                    beats.push(current_beat);\n                    current_beat\
    \ = 0;\n                    current_note = String::new();\n                  \
    \  current_note_length = String::new();\n                } else if c.to_ascii_lowercase()\
    \ == 'o' {\n                    beats.push(current_beat);\n                  \
    \  current_beat = 0;\n                    current_note = String::new();\n    \
    \                current_note_length = String::new();\n                } else\
    \ if c.to_ascii_lowercase() == '|' {\n                    beats.push(current_beat);\n\
    \                    current_beat = 0;\n                    current_note = String::new();\n\
    \                    current_note_length = String::new();\n                } else\
    \ if c.to_ascii_lowercase() == '.' {\n                    beats.push(current_beat);\n\
    \                    current_beat = 0;\n                    current_note = String::new();\n\
    \                    current_note_length = String::new();\n                } else\
    \ {\n                    current_note.push(c);\n                    current_note_length.push(c);\n\
    \                }\n            } else {\n                if current_note.is_empty()\
    \ {\n                    println!(\"Music string contains non-ascii character\"\
    );\n                    break;\n                }\n                if c.is_ascii()\
    \ {\n                    if c.to_ascii_lowercase() == 'o' {\n                \
    \        beats.push(current_beat);\n                        current_beat = 0;\n\
    \                        current_note = String\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_n1finew.rs:91:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n16 |\
    \     for c in music_string.chars() {\n   |                                  \
    \ - unclosed delimiter\n...\n42 |         } else {\n   |                - unclosed\
    \ delimiter\n...\n72 |             } else {\n   |                    - unclosed\
    \ delimiter\n...\n77 |                 if c.is_ascii() {\n   |               \
    \                  - unclosed delimiter\n78 |                     if c.to_ascii_lowercase()\
    \ == 'o' {\n   |                                                      - this delimiter\
    \ might not be properly closed...\n...\n82 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n91 | }\n   |   ^\n\nerror[E0423]: expected\
    \ value, found struct `String`\n   --> /tmp/tmp_n1finew.rs:81:40\n    |\n81  |\
    \                           current_note = String\n    |                     \
    \                     ^^^^^^ help: use struct literal syntax instead: `String\
    \ { vec: val }`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_n1finew.rs:16:5\n\
    \   |\n10 |   fn parse_music(music_string: String) -> Vec<isize> {\n   |     \
    \                                      ---------- expected `Vec<isize>` because\
    \ of return type\n...\n16 | /     for c in music_string.chars() {\n17 | |    \
    \     if c.is_ascii() {\n18 | |             if c.to_ascii_lowercase() == 'o' {\n\
    19 | |                 beats.push(current_beat);\n...  |\n90 | |     assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n91 | | }\n   | |__^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.chars().collect::<Vec<_>>();\n    let mut current_note\
    \ = notes.len() - 1;\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let \n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmppq36wvl6.rs:74:1\n  \
    \ |\n74 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != '|');\n    let mut current_note = 0;\n    let mut current_beat = 0;\n   \
    \ for note in notes {\n        if note.1 == '.' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note += 1;\n        } else\
    \ {\n            current_beat += 1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6xq2nd7e.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != 'o');\n    for note in notes {\n        match note {\n            'o' =>\
    \ beats.push(4),\n            'o|' => beats.push(2),\n            '.|' => beats.push(1),\n\
    \            _ => (),\n        }\n    }\n    beats\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpdu15fqed.rs:16:16\n\
    \   |\n16 |             'o|' => beats.push(2),\n   |                ^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().collect::<Vec<_>>();\n    let mut current_note\
    \ = notes.len() - 1;\n    let mut current_beat = 0;\n    let mut current_beats_length\
    \ = 0;\n    let mut current_notes_length = 0;\n    while current_note > -1 {\n\
    \        let note = notes[current_note];\n        let note_type = note[0];\n \
    \       let note_length = note[1];\n        let note_octave = note[2];\n     \
    \   let note_octave_length = note[3];\n        let note_octave_sign = note[4];\n\
    \        let note_octave_sign_index = note[5];\n        let note_octave_sign_index\
    \ = note[6];\n        let note_octave_sign_index = note[7];\n        let note_octave_sign_index\
    \ = note[8];\n        let note_octave_sign_index = note[9];\n        let note_octave_sign_index\
    \ = note[10];\n        let note_octave_sign_index = note[11];\n        let note_octave_sign_index\
    \ = note[12];\n        let note_octave_sign_index = note[13];\n        let note_octave_sign_index\
    \ = note[14];\n        let note_octave_sign_index = note[15];\n        let note_octave_sign_index\
    \ = note[16];\n        let note_octave_sign_index = note[17];\n        let note_octave_sign_index\
    \ = note[18];\n        let note_octave_sign_index = note[19];\n        let note_octave_sign_index\
    \ = note[20];\n        let note_octave_sign_index = note[21];\n        let note_octave_sign_index\
    \ = note[22];\n        let note_octave_sign_index = note[23];\n        let note_octave_sign_index\
    \ = note[24];\n        let note_octave_sign_index = note[25];\n        let note_octave_sign_index\
    \ = note[26];\n        let note_octave_sign_index = note[27];\n        let note_octave_sign_index\
    \ = note[28];\n        let note_octave_sign_index = note[29];\n        let note_octave_sign_index\
    \ = note[30];\n        let note_octave_sign_index = note[31];\n        let note_octave_sign_index\
    \ = note[32];\n        let note_octave_sign_index = note[33];\n        let note_octave_sign_index\
    \ = note[34];\n        let note_octave_sign_index = note[35];\n        let note_octave_sign_index\
    \ = note[36];\n        let note_octave_sign_index = note[37];\n        let note_octave_sign\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmu0blbm6.rs:67:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n17 |\
    \     while current_note > -1 {\n   |                             - this delimiter\
    \ might not be properly closed...\n...\n58 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n67 | }\n   |   ^\n\nerror: expected `;`,\
    \ found `}`\n  --> /tmp/tmpmu0blbm6.rs:57:29\n   |\n57 |         let note_octave_sign\n\
    \   |                             ^ help: add `;` here\n58 | }\n   | - unexpected\
    \ token\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  -->\
    \ /tmp/tmpmu0blbm6.rs:17:26\n   |\n17 |     while current_note > -1 {\n   |  \
    \                        ^^\n   |                          |\n   |           \
    \               cannot apply unary operator `-`\n   |                        \
    \  help: you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n\
    \   = note: unsigned values cannot be negated\n\nerror[E0608]: cannot index into\
    \ a value of type `char`\n  --> /tmp/tmpmu0blbm6.rs:19:25\n   |\n19 |        \
    \ let note_type = note[0];\n   |                         ^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpmu0blbm6.rs:20:27\n\
    \   |\n20 |         let note_length = note[1];\n   |                         \
    \  ^^^^^^^\n\nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpmu0blbm6.rs:21:27\n\
    \   |\n21 |         let note_octave = note[2];\n   |                         \
    \  ^^^^^^^\n\nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpmu0blbm6.rs:22:34\n\
    \   |\n22 |         let note_octave_length = note[3];\n   |                  \
    \                ^^^^^^^\n\nerror[E0608]: cannot index into a value of type `char`\n\
    \  --> /tmp/tmpmu0blbm6.rs:23:32\n   |\n23 |         let note_octave_sign = note[4];\n\
    \   |                                ^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `char`\n  --> /tmp/tmpmu0blbm6.rs:24:38\n   |\n24 |        \
    \ let note_octave_sign_index = no"
  stdout: ''
  timestamp: 1659749083
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c == 'o' {\n                if current_note_length_index == 0 {\n          \
    \          current_note_length_index = 1;\n                    current_note_length\
    \ = 4; // whole note\n                } else {\n                    current_note_length_index\
    \ += 1;\n                    current_note_length += 1;\n                }\n  \
    \          } else if c == '|' {\n                if current_note_length_index\
    \ == 0 {\n                    current_note_length_index = 1;\n               \
    \     current_note_length = 2; // half note\n                } else {\n      \
    \              current_note_length_index += 1;\n                    current_note_length\
    \ += 1;\n                }\n            } else if c == '.' {\n               \
    \ if current_note_length_index == 0 {\n                    current_note_length_index\
    \ = 1;\n                    current_note_length = 1; // quater note\n        \
    \        } else {\n                    current_note_length_index += 1;\n     \
    \               current_note_length += 1;\n                }\n            } else\
    \ {\n                println!(\"Unknown note {}\", c);\n            }\n      \
    \  } else {\n            println!(\"Unknown character {}\", c);\n        }\n \
    \   }\n    if current_note_length_index != 0 {\n        println!(\"Unknown note\
    \ length\");\n    }\n    beats.push(current_beat);\n    current_beat += current_note_length;\n\
    \    for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c == 'o' {\n                current_beat += 4;\n            } else if c == '|'\
    \ {\n                current_beat += 2;\n            } else if c == '.' {\n  \
    \              current_beat += 1;\n            } else {\n                println!(\"\
    Unknown note {}\", c);\n            }\n        } else {\n            println!(\"\
    Unknown character {}\", c);\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0]`,\n right: `[]`', /tmp/tmpny1ixnhg.rs:75:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n    \
    \            if current_note_length == 0 {\n                    current_note =\
    \ c.to_ascii_lowercase();\n                    current_note_length = 1;\n    \
    \            } else {\n                    current_note_length += 1;\n       \
    \         }\n            } else if c.to_ascii_lowercase() == 'o|' {\n        \
    \        if current_note_length == 0 {\n                    current_note = c.to_ascii_lowercase();\n\
    \                    current_note_length = 1;\n                } else {\n    \
    \                current_note_length += 1;\n                }\n            } else\
    \ if c.to_ascii_lowercase() == '.|' {\n                if current_note_length\
    \ == 0 {\n                    current_note = c.to_ascii_lowercase();\n       \
    \             current_note_length = 1;\n                } else {\n           \
    \         current_note_length += 1;\n                }\n            } else {\n\
    \                println!(\"Unknown note {}\", c);\n            }\n        } else\
    \ {\n            println!(\"Unknown character {}\", c);\n        }\n        if\
    \ current_note != String::new() && current_note_length != 0 {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_length = 0;\n        }\n        current_beat += 1;\n \
    \   }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpls4ppjqr.rs:24:52\n\
    \   |\n24 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat: isize = 0;\n    let mut current_note\
    \ = String::new();\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxjg_2hnz.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxjg_2hnz.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats_vec: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_nkb3n2h.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_nkb3n2h.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    let mut current_note_is_octave\
    \ = false;\n    let mut current_note_is_rest = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_resting = false;\n    let mut current_note_is_resting_octave\
    \ = false;\n    let mut current_note_is_resting_octave_is_octave = false;\n  \
    \  let mut current_note_is_resting_octave_is_rest = false;\n    let mut current_note_is_resting_octave_is_rested\
    \ = false;\n    let mut current_note_is_resting_octave_is_resting = false;\n \
    \   let mut current_note_is_resting_octave_is_resting_octave = false;\n    let\
    \ mut current_note_is_resting_octave_is_resting_octave = false;\n    let mut current_note_is_resting_octave_is_resting_octave\
    \ = false;\n    let mut current_note_is_resting_octave_is_resting_octave = false;\n\
    \    let mut current_note_is_resting_octave_is_resting_octave = false;\n    let\
    \ mut current_note_is_resting_octave_is_resting_octave = false;\n    let mut current_note_is_resting_octave_is_resting_octave\
    \ = false;\n    let mut current_note_is_resting_octave_is_resting_octave = false;\n\
    \    let mut current_note_is_resting_octave_is_resting_octave = false;\n    let\
    \ mut current_note_is_resting_octave_is_resting_octave = false;\n    let mut current_note_is_resting_octave_is_resting_octave\
    \ = false;\n    let mut current_note_is_resting_octave_is_resting_octave = false;\n\
    \    let mut current_note_is_resting_octave_is_resting_octave = false;\n    let\
    \ mut current_note_is_resting_octave_is_resting_octave = false;\n    let mut current_note_is_resting_octave_is_resting_octave\
    \ = false;\n    let mut current_note_is_resting_octave_is_resting_octave = false;\n\
    \    let mut current_note_is_resting_octave_is_resting_octave = false;\n    let\
    \ mut current_note_is_resting_octave_is_resting_octave = false;\n    let mut current_note_is_resting_octave_is_resting_octave\
    \ = false;\n    let mut current_note_is_resting_octave_is_resting_octave = false;\n\
    \    let mut current_note_is_resting_octave_is_resting_octave\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3irqxou0.rs:44:61\n   |\n\
    44 |     let mut current_note_is_resting_octave_is_resting_octave\n   |      \
    \                                                       ^ help: add `;` here\n\
    45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3irqxou0.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen2 = 0;\n    let\
    \ mut current_note_octlen3 = 0;\n    let mut current_note_octlen4 = 0;\n    let\
    \ mut current_note_octlen5 = 0;\n    let mut current_note_octlen6 = 0;\n    let\
    \ mut current_note_octlen7 = 0;\n    let mut current_note_octlen8 = 0;\n    let\
    \ mut current_note_octlen9 = 0;\n    let mut current_note_octlen10 = 0;\n    let\
    \ mut current_note_octlen11 = 0;\n    let mut current_note_octlen12 = 0;\n   \
    \ let mut current_note_octlen13 = 0;\n    let mut current_note_octlen14 = 0;\n\
    \    let mut current_note_octlen15 = 0;\n    let mut current_note_octlen16 = 0;\n\
    \    let mut current_note_octlen17 = 0;\n    let mut current_note_octlen18 = 0;\n\
    \    let mut current_note_octlen19 = 0;\n    let mut current_note_octlen20 = 0;\n\
    \    let mut current_note_octlen21 = 0;\n    let mut current_note_octlen22 = 0;\n\
    \    let mut current_note_octlen23 = 0;\n    let mut current_note_octlen24 = 0;\n\
    \    let mut current_note_octlen25 = 0;\n    let mut current_note_octlen26 = 0;\n\
    \    let mut current_note_octlen27 = 0;\n    let mut current_note_octlen28 = 0;\n\
    \    let mut current_note_octlen29 = 0;\n    let mut current_note_octlen30 = 0;\n\
    \    let mut current_note_octlen31 = 0;\n    let mut current_note_octlen32 = 0;\n\
    \    let mut current_note_octlen33 = 0;\n    let mut current_note_octlen34 = 0;\n\
    \    let mut current_note_octlen35 = 0;\n    let mut current_note_octlen36 = 0;\n\
    \    let mut current_note_octlen37 = 0;\n    let mut current_note_octlen38 = 0;\n\
    \    let mut current_note_octlen39 = 0;\n    let mut current_note_octlen40 = 0;\n\
    \    let mut current_note_octlen41 = 0;\n    let mut current_note_octlen42 = 0;\n\
    \    let mut current_note_octlen43 = 0;\n    let mut current_note_octlen44 = 0;\n\
    \    let mut current_note_octlen45 = 0;\n    let mut current_note_octlen46 = 0;\n\
    \    let mut current_note_octlen\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2oex8lt5.rs:62:32\n   |\n\
    62 |     let mut current_note_octlen\n   |                                ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2oex8lt5.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.split_whitespace();\n    let mut current_note\
    \ = notes.next().unwrap();\n    let mut current_beat = 0;\n    while let Some(note)\
    \ = notes.next() {\n        match note {\n            \"o\" => {\n           \
    \     beats.push(current_beat);\n                current_beat += 4;\n        \
    \    }\n            \"o|\" => {\n                beats.push(current_beat);\n \
    \               current_beat += 2;\n            }\n            \".|\" => {\n \
    \               beats.push(current_beat);\n                current_beat += 1;\n\
    \            }\n            _ => {\n                current_note = note;\n   \
    \             current_beat = 0;\n            }\n        }\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp9x19o5v1.rs:13:41

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749083
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      } else if c == '|' {\n            beats.push(current_beat);\n         \
    \   current_beat = 0;\n            current_note = String::new();\n        } else\
    \ if c == '.' {\n            current_beat = current_beat + 1;\n        } else\
    \ {\n            current_note.push(c);\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmp080l1inb.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index48\
    \ = 1;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoe75nrnm.rs:63:21\n   |\n\
    63 |     let mut current_\n   |                     ^ help: add `;` here\n64 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoe75nrnm.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::new();\n    let mut current_beat = 0;\n    let mut current_note_index\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpeyesz772.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    let mut current_note_is_octave\
    \ = false;\n    let mut current_note_is_rest = false;\n    for c in music_string.chars()\
    \ {\n        if c == 'o' {\n            if current_note_is_octave {\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave);\n          \
    \      println!(\"current_note is rest {}\", current_note_is_rest);\n        \
    \        println!(\"current_note is octave {}\", current_octave\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcipxp3rn.rs:54:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n17 |\
    \     for c in music_string.chars() {\n   |                                  \
    \ - unclosed delimiter\n18 |         if c == 'o' {\n   |                     -\
    \ unclosed delimiter\n19 |             if current_note_is_octave {\n   |     \
    \                                  - this delimiter might not be properly closed...\n\
    ...\n45 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    54 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpcipxp3rn.rs:44:25\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - closing delimiter possibly meant\
    \ for this\n...\n44 |                 println!(\"current_note is octave {}\",\
    \ current_octave\n   |                         ^ unclosed delimiter\n45 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcipxp3rn.rs:17:5\n   |\n10 |   fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |                                           ---------- expected\
    \ `Vec<isize>` because of return type\n...\n17 | /     for c in music_string.chars()\
    \ {\n18 | |         if c == 'o' {\n19 | |             if current_note_is_octave\
    \ {\n20 | |                 println!(\"current_note is octave {}\", current_octave);\n\
    ...  |\n53 | |     assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\"\
    )), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n54 | | }\n   | |__^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_length = 0;\n    let\
    \ mut current_note_length_index = 0;\n    let mut current_note_length_is_octave\
    \ = false;\n\n    for c in music_string.chars() {\n        if c.is_ascii() {\n\
    \            if c.to_ascii_lowercase() == 'o' {\n                if current_note_length_is_octave\
    \ {\n                    current_octave += 1;\n                    current_note_length_is_octave\
    \ = false;\n                }\n                current_note += c.to_ascii_lowercase();\n\
    \                current_note_length += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '|' {\n                if current_note_length_is_octave {\n             \
    \       current_octave += 1;\n                    current_note_length_is_octave\
    \ = false;\n                }\n                current_note += c.to_ascii_lowercase();\n\
    \                current_note_length += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                if current_note_length_is_octave {\n             \
    \       current_octave += 1;\n                    current_note_length_is_octave\
    \ = false;\n                }\n                current_note += c.to_ascii_lowercase();\n\
    \                current_note_length += 1;\n            } else {\n           \
    \     if current_note_length_is_octave {\n                    current_octave +=\
    \ 1;\n                    current_note_length_is_octave = false;\n           \
    \     }\n                current_note += c.to_ascii_lowercase();\n           \
    \     current_note_length += 1;\n            }\n        } else {\n           \
    \ if c.to_ascii_lowercase() == 'o' {\n                current_note_length_is_octave\
    \ = true;\n                current_octave += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '|' {\n                current_note_length_is_octave = true;\n          \
    \      current_octave += 1;\n            } else if c.to_ascii_lowercase() == '.'\
    \ {\n                current_note_length_is_octave = true;\n                current_octave\
    \ += 1;\n            } else {\n                current_note_length_is_octave =\
    \ true;\n                current_octave += 1;\n            }\n        }\n    }\n\
    \n    if current_note_length == 0 {\n        return beats;\n    }\n\n    if current_octave\
    \ == 0 {\n        current_octave = 1;\n    }\n\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                if current_note_length_is_octave {\n                    current_octave\
    \ += 1;\n                    current_note_length_is_octave = false;\n        \
    \        }\n                current_note += c.to_ascii_lowercase();\n        \
    \        current_note_length += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '|' {\n                if current_note_length_is_octave {\n             \
    \       current_octave += 1;\n                    current_note_length_is_octave\
    \ = false;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpl8z0d45h.rs:97:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n75 |\
    \     for c in music_string.chars() {\n   |                                  \
    \ - unclosed delimiter\n76 |         if c.is_ascii() {\n   |                 \
    \        - unclosed delimiter\n...\n84 |             } else if c.to_ascii_lowercase()\
    \ == '|' {\n   |                                                     - unclosed\
    \ delimiter\n85 |                 if current_note_length_is_octave {\n   |   \
    \                                               - this delimiter might not be\
    \ properly closed...\n...\n88 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n97 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpl8z0d45h.rs:26:33\n   |\n26 |                 current_note += c.to_ascii_lowercase();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl8z0d45h.rs:33:33\n\
    \   |\n33 |                 current_note += c.to_ascii_lowercase();\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl8z0d45h.rs:40:33\n   |\n40 |\
    \                 current_note += c.to_ascii_lowercase();\n   |              \
    \                   ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl8z0d45h.rs:47:33\n   |\n47 |              \
    \   current_note += c.to_ascii_lowercase();\n   |                            \
    \     ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl8z0d45h.rs:82:33\n   |\n82 |                 current_note\
    \ += c.to_ascii_lowercase();\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl8z0d45h.rs:75:5\n\
    \   |\n10 |   fn parse_music(music_string: String) -> Vec<isize> {\n   |     \
    \             "
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n       \
    \         beats.push(current_beat);\n                current_beat = 0;\n     \
    \           current_note = String::new();\n                current_note_len =\
    \ String::new();\n            } else if c.to_ascii_lowercase() == 'o|' {\n   \
    \             beats.push(current_beat);\n                current_beat = 0;\n \
    \               current_note = String::new();\n                current_note_len\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == '.|' {\n \
    \               beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_len\
    \ = String::new();\n            } else {\n                current_note.push(c);\n\
    \                current_note_len = current_note.len() + 1;\n            }\n \
    \       } else {\n            if current_note.len() > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = String::new();\n            }\n        }\n\
    \    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp_xzo93pe.rs:22:52\n\
    \   |\n22 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string {\n        if c == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      } else if c == '|' {\n            beats.push(current_beat);\n         \
    \   current_beat = 0;\n            current_note = String::new();\n        } else\
    \ if c == '.' {\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n        } else {\n        \
    \    current_note.push(c);\n            current_beat++;\n        }\n    }\n  \
    \  beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpcloz2s_y.rs:29:26\n\
    \   |\n29 |             current_beat++;\n   |                          ^ expected\
    \ expression\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpcloz2s_y.rs:14:14\n\
    \    |\n14  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c == 'o' {\n            if current_note_len == 0 {\n                println!(\"\
    Invalid music string\");\n                return beats;\n            }\n     \
    \       beats.push(current_beat);\n            current_beat += 1;\n          \
    \  current_note_len = 0;\n            current_note = String::new();\n        }\
    \ else if c == '|' {\n            if current_note_len == 0 {\n               \
    \ println!(\"Invalid music string\");\n                return beats;\n       \
    \     }\n            beats.push(current_beat);\n            current_beat += 1;\n\
    \            current_note_len = 1;\n            current_note = String::new();\n\
    \        } else if c == '.' {\n            if current_note_len == 0 {\n      \
    \          println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ += 1;\n            current_note_len = 0;\n            current_note = String::new();\n\
    \        } else {\n            current_note.push(c);\n            current_note_len\
    \ = c.len_utf8();\n        }\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpwyw3h2zu.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      } else if c == '|' {\n            beats.push(current_beat);\n         \
    \   current_beat = 0;\n            current_note = String::new();\n        } else\
    \ if c.is_whitespace() {\n            continue;\n        } else {\n          \
    \  current_note.push(c);\n            current_beat += 1;\n        }\n    }\n \
    \   beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmp6ydt_9jt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n       \
    \         beats.push(current_beat);\n                current_beat = 0;\n     \
    \           current_note = String::new();\n                current_note_len =\
    \ 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n                current_note.push_str(&c.to_ascii_lowercase());\n\
    \                current_note_len = current_note.len();\n            } else if\
    \ c.to_ascii_lowercase() == '|' {\n                current_beat += 1;\n      \
    \      } else if c.to_ascii_lowercase() == '.' {\n                current_beat\
    \ += 4;\n            }\n        } else {\n            current_note.push_str(&c.to_ascii_lowercase());\n\
    \            current_note_len = current_note.len();\n        }\n    }\n    beats.push(current_beat);\n\
    \    current_beat = 0;\n    current_note = String::new();\n    current_note_len\
    \ = 0;\n    for c in music_string.chars() {\n        if c.is_ascii() {\n     \
    \       if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = 0;\n            } else if c.to_ascii_lowercase()\
    \ == 'o' {\n                current_note.push_str(&c.to_ascii_lowercase());\n\
    \                current_note_len = current_note.len();\n            } else if\
    \ c.to_ascii_lowercase() == '|' {\n                current_beat += 1;\n      \
    \      } else if c.to_ascii_lowercase() == '.' {\n                current_beat\
    \ += 4;\n            }\n        } else {\n            current_note.push_str(&c.to_ascii_lowercase());\n\
    \            current_note_len = current_note.len();\n        }\n    }\n    beats.push(current_beat);\n\
    \    current_beat = 0;\n    current_note = String::new();\n    current_note_len\
    \ = 0;\n    for c in music_string.chars() {\n        if c.is_ascii() {\n     \
    \       if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = 0;\n            } else if c.to_ascii_lowercase()\
    \ == 'o' {\n                current_note.push_str(&c.to_ascii_lowercase());\n\
    \                current_note_len = current_note.len();\n            } else if\
    \ c.to_ascii_lowercase() == '|' {\n                current_beat += 1;\n      \
    \      } else if c.to_ascii_lowercase() == '.' {\n                current_beat\
    \ += 4;\n            }\n        } else {\n            current_note.push_str(&c.to_ascii_lowercase());\n\
    \            current_note_len = current_\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwjx8ps5m.rs:90:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n63 |\
    \     for c in music_string.chars() {\n   |                                  \
    \ - unclosed delimiter\n...\n78 |         } else {\n   |                - this\
    \ delimiter might not be properly closed...\n...\n81 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n90 | }\n   |   ^\n\nerror[E0425]:\
    \ cannot find value `current_` in this scope\n  --> /tmp/tmpwjx8ps5m.rs:80:32\n\
    \   |\n80 |             current_note_len = current_\n   |                    \
    \            ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwjx8ps5m.rs:23:39\n   |\n23 |                 current_note.push_str(&c.to_ascii_lowercase());\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwjx8ps5m.rs:31:35\n\
    \   |\n31 |             current_note.push_str(&c.to_ascii_lowercase());\n   |\
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwjx8ps5m.rs:47:39\n\
    \   |\n47 |                 current_note.push_str(&c.to_ascii_lowercase());\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwjx8ps5m.rs:55:35\n\
    \   |\n55 |             current_note.push_str(&c.to_ascii_lowercase());\n   |\
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwjx8ps5m.rs:71:39\n\
    \   |\n71 |              "
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_is_octave = false;\n\
    \    let mut current_note_is_rest = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptap6twhb.rs:62:35\n   |\n\
    62 |     let mut current_note_is_rested\n   |                                \
    \   ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptap6twhb.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_note_length_index\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg9jy7hkb.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg9jy7hkb.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    for c in music_string {\n\
    \        if c == 'o' {\n            if current_note.len() > 0 {\n            \
    \    beats.push(current_beat + 1);\n                current_beat = 0;\n      \
    \          current_note = String::new();\n            }\n            current_note.push_str(&c);\n\
    \            current_note_length.push_str(&current_note);\n        } else if c\
    \ == '|' {\n            if current_note.len() > 0 {\n                beats.push(current_beat\
    \ + 1);\n                current_beat = 0;\n                current_note = String::new();\n\
    \            }\n            current_note.push_str(&c);\n            current_note_length.push_str(&current_note);\n\
    \        } else if c == '.' {\n            if current_note.len() > 0 {\n     \
    \           beats.push(current_beat + 1);\n                current_beat = 0;\n\
    \                current_note = String::new();\n            }\n            current_note.push_str(&c);\n\
    \            current_note_length.push_str(&current_note);\n        } else {\n\
    \            current_note.push_str(&c);\n            current_note_length.push_str(&current_note);\n\
    \        }\n    }\n    if current_note.len() > 0 {\n        beats.push(current_beat\
    \ + 1);\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp892s93al.rs:15:14\n\
    \    |\n15  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n  --> /tmp/tmp892s93al.rs:15:9\n   |\n15 |     for\
    \ c in music_string {\n   |         ^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: can't compare `str` with `char`\n\
    \  --> /tmp/tmp892s93al.rs:16:14\n   |\n16 |         if c == 'o' {\n   |     \
    \         ^^ no implementation for `str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `str`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmp892s93al.rs:15:14\n   |\n\
    15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n   --> /tmp/tmp892s93al.rs:15:5\n\
    \    |\n15  | /     for c in music_string {\n16  | |         if c == 'o' {\n17\
    \  | |             if current_note.len() > 0 {\n18  | |                 beats.push(current_beat\
    \ + 1);\n...   |\n43  | |         }\n44  | |     }\n    | |_____^ doesn't have\
    \ a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by `None`\n\nerror[E0277]: can't compare `str` with\
    \ `char`\n  --> /tmp/tmp892s93al.rs:24:21\n   |\n24 |         } else if c =="
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats_vec: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = 0;\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpklo3wgnp.rs:62:40\n   |\n\
    62 |     let mut current_note_length_index48\n   |                           \
    \             ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpklo3wgnp.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpimyn5mcd.rs:62:32\n   |\n\
    62 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpimyn5mcd.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_octave\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o|' {\n             \
    \   beats.push(current_beat);\n                current_beat = 0;\n           \
    \     current_note = String::new();\n                current_octave = 1;\n   \
    \         } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_octave = 2;\n            } else {\n                current_note.push(c);\n\
    \            }\n        } else {\n            if current_note.is_empty() {\n \
    \               panic!(\"Music string contains non-ascii character\");\n     \
    \       }\n            if current_note.len() == 3 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_octave = 0;\n            }\n            current_note.push(c);\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp_eu_g9qu.rs:23:52\n\
    \   |\n23 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n\
    \    let mut last_note = notes.next();\n    let mut last_beat = 0;\n    let mut\
    \ last_beats = 1;\n    for note in notes {\n        if note.1.is_ascii() {\n \
    \           let note = note.1.to_ascii_lowercase();\n            if note == \"\
    o\" {\n                beats.push(last_beat);\n                last_beat = 1;\n\
    \            } else if note == \"o|\" {\n                beats.push(last_beat);\n\
    \                last_beat = 2;\n            } else if note == \".|\" {\n    \
    \            beats.push(last_beat);\n                last_beat = 1;\n        \
    \    } else {\n                panic!(\"Unknown note '{}'\", note);\n        \
    \    }\n        } else {\n            last_beats += 1;\n            last_beat\
    \ = last_beats;\n        }\n        last_note = note;\n    }\n    beats.push(last_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0c1prapi.rs:12:72\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0c1prapi.rs:19:24\n   |\n19 |             if note == \"\
    o\" {\n   |                        ^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0c1prapi.rs:22:31\n   |\n22 |             }\
    \ else if note == \"o|\" {\n   |                               ^^^^ expected `char`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0c1prapi.rs:25:31\n\
    \   |\n25 |             } else if note == \".|\" {\n   |                     \
    \          ^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0c1prapi.rs:35:21\n   |\n35 |         last_note = note;\n   | \
    \                    ^^^^\n   |                     |\n   |                  \
    \   expected enum `Option`, found tuple\n   |                     help: try using\
    \ a variant of the expected enum: `Some(note)`\n   |\n   = note: expected enum\
    \ `Option<(usize, char)>`\n             found tuple `(usize, char)`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_octave = 0;\n    for c in music_string {\n        if c ==\
    \ 'o' {\n            if current_note != String::new() {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n            }\n            current_note =\
    \ String::new();\n            current_octave = 0;\n        } else if c == '|'\
    \ {\n            if current_note != String::new() {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n            }\n            current_note =\
    \ String::new();\n            current_octave = 1;\n        } else if c == '.'\
    \ {\n            if current_note != String::new() {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n            }\n            current_note =\
    \ String::new();\n            current_octave = 2;\n        } else {\n        \
    \    current_note.push(c);\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpqoc09ysq.rs:15:14\n\
    \    |\n15  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != '|');\n    for note in notes {\n        let mut beat = 0;\n        let mut\
    \ last_note = note.1;\n        for _ in 0..note.0 {\n            beat += 1;\n\
    \            last_note = notes[notes.len() - 1].1;\n        }\n        beats.push(beat);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpyegnephk.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Filter` in the current scope\n  -->\
    \ /tmp/tmpyegnephk.rs:18:37\n   |\n18 |             last_note = notes[notes.len()\
    \ - 1].1;\n   |                                     ^^^ method not found in `Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpyegnephk.rs:12:61: 12:84]>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_to_beat =\
    \ 0;\n    let mut current_note_length_to_beat_counter = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c == 'o' {\n                if\
    \ current_note_length == 0 {\n                    current_note = String::from(\"\
    o\");\n                    current_note_length = 1;\n                    current_note_length_to_beat\
    \ = 4;\n                    current_note_length_to_beat_counter = 0;\n       \
    \         } else {\n                    current_note.push_str(&format!(\"{}\"\
    , current_note_length));\n                    current_note_length_to_beat += current_note_length;\n\
    \                    current_note_length_to_beat_counter += 1;\n             \
    \       current_note_length = 0;\n                }\n            } else if c ==\
    \ '|' {\n                if current_note_length == 0 {\n                    current_note\
    \ = String::from(\"|\");\n                    current_note_length = 1;\n     \
    \               current_note_length_to_beat = 2;\n                    current_note_length_to_beat_counter\
    \ = 0;\n                } else {\n                    current_note.push_str(&format!(\"\
    {}\", current_note_length));\n                    current_note_length_to_beat\
    \ += current_note_length;\n                    current_note_length_to_beat_counter\
    \ += 1;\n                    current_note_length = 0;\n                }\n   \
    \         } else if c == '.' {\n                if current_note_length == 0 {\n\
    \                    current_note = String::from(\".\");\n                   \
    \ current_note_length = 1;\n                    current_note_length_to_beat =\
    \ 1;\n                    current_note_length_to_beat_counter = 0;\n         \
    \       } else {\n                    current_note.push_str(&format!(\"{}\", current_note_length));\n\
    \                    current_note_length_to_beat += current_note_length;\n   \
    \                 current_note_length_to_beat_counter += 1;\n                \
    \    current_note_length = 0;\n                }\n            } else {\n     \
    \           panic!(\"Unknown note symbol: {}\", c);\n            }\n        }\
    \ else {\n            current_note.push_str(&format!(\"{}\", current_note_length));\n\
    \            current_note_length_to_beat += current_note_length;\n           \
    \ current_note_length_to_beat_counter += 1;\n            current_note_length =\
    \ 0;\n        }\n        if current_note_length_to_beat_counter == current_note_length_to_beat\
    \ {\n            beats.push(current_beat);\n            current_beat += 1;\n \
    \           current_note_length_to_beat_counter = 0;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpa77b4bw_.rs:76:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_len = 0;\n    let mut current_note_oct\
    \ = 0;\n    let mut current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n\
    \    let mut current_note_oct4 = 0;\n    let mut current_note_oct5 = 0;\n    let\
    \ mut current_note_oct6 = 0;\n    let mut current_note_oct7 = 0;\n    let mut\
    \ current_note_oct8 = 0;\n    let mut current_note_oct9 = 0;\n    let mut current_note_oct10\
    \ = 0;\n    let mut current_note_oct11 = 0;\n    let mut current_note_oct12 =\
    \ 0;\n    let mut current_note_oct13 = 0;\n    let mut current_note_oct14 = 0;\n\
    \    let mut current_note_oct15 = 0;\n    let mut current_note_oct16 = 0;\n  \
    \  let mut current_note_oct17 = 0;\n    let mut current_note_oct18 = 0;\n    let\
    \ mut current_note_oct19 = 0;\n    let mut current_note_oct20 = 0;\n    let mut\
    \ current_note_oct21 = 0;\n    let mut current_note_oct22 = 0;\n    let mut current_note_oct23\
    \ = 0;\n    let mut current_note_oct24 = 0;\n    let mut current_note_oct25 =\
    \ 0;\n    let mut current_note_oct26 = 0;\n    let mut current_note_oct27 = 0;\n\
    \    let mut current_note_oct28 = 0;\n    let mut current_note_oct29 = 0;\n  \
    \  let mut current_note_oct30 = 0;\n    let mut current_note_oct31 = 0;\n    let\
    \ mut current_note_oct32 = 0;\n    let mut current_note_oct33 = 0;\n    let mut\
    \ current_note_oct34 = 0;\n    let mut current_note_oct35 = 0;\n    let mut current_note_oct36\
    \ = 0;\n    let mut current_note_oct37 = 0;\n    let mut current_note_oct38 =\
    \ 0;\n    let mut current_note_oct39 = 0;\n    let mut current_note_oct40 = 0;\n\
    \    let mut current_note_oct41 = 0;\n    let mut current_note_oct42 = 0;\n  \
    \  let mut current_note_oct43 = 0;\n    let mut current_note_oct44 = 0;\n    let\
    \ mut current_note_oct45 = 0;\n    let mut current_note_oct46 = 0;\n    let mut\
    \ current_note_oct47 = 0;\n    let mut current_note_oct48 = 0;\n    let mut current_note_oct49\
    \ = 0;\n    let mut current_note_oct50 = 0;\n    let mut current_note_oct51 =\
    \ 0;\n    let mut current_note_oct52 = 0;\n    let mut current_note_\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjo28dgg9.rs:67:26\n   |\n\
    67 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjo28dgg9.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length = 0;\n    let\
    \ mut current_note_length_to_beat_with_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp6btjro9.rs:32:36\n   |\n\
    32 |     let mut current_note_length_to_\n   |                               \
    \     ^ help: add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp6btjro9.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::from(\"\");\n    let mut current_beat = 0;\n    let mut current_note_count\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp0c_t6jlj.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_octlen = 0;\n    let mut current_note_octlen2 = 0;\n    let mut\
    \ current_note_octlen3 = 0;\n    let mut current_note_octlen4 = 0;\n    let mut\
    \ current_note_octlen5 = 0;\n    let mut current_note_octlen6 = 0;\n    let mut\
    \ current_note_octlen7 = 0;\n    let mut current_note_octlen8 = 0;\n    let mut\
    \ current_note_octlen9 = 0;\n    let mut current_note_octlen10 = 0;\n    let mut\
    \ current_note_octlen11 = 0;\n    let mut current_note_octlen12 = 0;\n    let\
    \ mut current_note_octlen13 = 0;\n    let mut current_note_octlen14 = 0;\n   \
    \ let mut current_note_octlen15 = 0;\n    let mut current_note_octlen16 = 0;\n\
    \    let mut current_note_octlen17 = 0;\n    let mut current_note_octlen18 = 0;\n\
    \    let mut current_note_octlen19 = 0;\n    let mut current_note_octlen20 = 0;\n\
    \    let mut current_note_octlen21 = 0;\n    let mut current_note_octlen22 = 0;\n\
    \    let mut current_note_octlen23 = 0;\n    let mut current_note_octlen24 = 0;\n\
    \    let mut current_note_octlen25 = 0;\n    let mut current_note_octlen26 = 0;\n\
    \    let mut current_note_octlen27 = 0;\n    let mut current_note_octlen28 = 0;\n\
    \    let mut current_note_octlen29 = 0;\n    let mut current_note_octlen30 = 0;\n\
    \    let mut current_note_octlen31 = 0;\n    let mut current_note_octlen32 = 0;\n\
    \    let mut current_note_octlen33 = 0;\n    let mut current_note_octlen34 = 0;\n\
    \    let mut current_note_octlen35 = 0;\n    let mut current_note_octlen36 = 0;\n\
    \    let mut current_note_octlen37 = 0;\n    let mut current_note_octlen38 = 0;\n\
    \    let mut current_note_octlen39 = 0;\n    let mut current_note_octlen40 = 0;\n\
    \    let mut current_note_octlen41 = 0;\n    let mut current_note_octlen42 = 0;\n\
    \    let mut current_note_octlen43 = 0;\n    let mut current_note_octlen44 = 0;\n\
    \    let mut current_note_octlen45 = 0;\n    let mut current_note_octlen46 = 0;\n\
    \    let mut current_note_octlen47 = 0;\n    let mut current_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpijcoy12u.rs:63:21\n   |\n\
    63 |     let mut current_\n   |                     ^ help: add `;` here\n64 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpijcoy12u.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_octave = 0;\n\n    for c in music_string.chars() {\n    \
    \    if c.is_whitespace() {\n            continue;\n        }\n\n        if c.is_ascii(0)\
    \ {\n            if current_note.is_empty() {\n                continue;\n   \
    \         }\n\n            if current_octave == 0 {\n                beats.push(current_beat);\n\
    \            }\n\n            current_note = String::new();\n            current_octave\
    \ = 0;\n            current_beat = 0;\n            continue;\n        }\n\n  \
    \      let note = c.to_ascii_lowercase();\n        let octave = note.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() as isize;\n\n        if note.len() == 1 {\n  \
    \          current_note += note;\n            current_octave += octave;\n    \
    \    } else {\n            current_note += note;\n            current_octave +=\
    \ octave;\n            current_beat = 1;\n        }\n    }\n\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpqmzxc03s.rs:21:14\n     |\n21   |         if c.is_ascii(0) {\n\
    \     |              ^^^^^^^^ - supplied 1 argument\n     |              |\n \
    \    |              expected 0 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpqmzxc03s.rs:37:27\n   |\n37 |         let octave = note.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() as isize;\n   |                           ^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `len` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpqmzxc03s.rs:39:17\n   |\n39\
    \ |         if note.len() == 1 {\n   |                 ^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqmzxc03s.rs:40:29\n\
    \   |\n40 |             current_note += note;\n   |                          \
    \   ^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqmzxc03s.rs:43:29\n   |\n43 |             current_note += note;\n  \
    \ |                             ^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == 'o|' {\n \
    \               beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == '.|' {\n \
    \               beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = String::new();\n            } else {\n                current_note.push(c);\n\
    \                current_note_length.push(1);\n            }\n        } else {\n\
    \            if current_note.is_empty() {\n                panic!(\"Music string\
    \ contains non-ASCII character\");\n            }\n            if c.to_ascii_lowercase()\
    \ == 'o' {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_length\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == 'o|' {\n \
    \               beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == '.|' {\n \
    \               beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = String::new();\n            } else {\n                current_note.push(c);\n\
    \                current_note_length.push(1);\n            }\n        }\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpfiv_ubs0.rs:22:52\n\
    \   |\n22 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string {\n        if c.is_whitespace()\
    \ {\n            continue;\n        }\n        if c.is_ascii(0) {\n          \
    \  current_note = c.to_string();\n            current_note_length = 1;\n     \
    \   } else {\n            if current_note.is_empty() {\n                panic!(\"\
    Music string contains invalid character: {}\", c);\n            }\n          \
    \  if c.is_ascii(127) {\n                current_note_length += 1;\n         \
    \   } else {\n                let mut current_note_length = c.len_utf8();\n  \
    \              let mut current_note = c.to_string();\n                let mut\
    \ current_beat = current_note_length / 4;\n                beats.push(current_beat);\n\
    \                current_note_length -= 4;\n            }\n        }\n    }\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpns0tiv9l.rs:15:14\n\
    \    |\n15  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = String::from(\"\");\n    let mut current_beat = 0;\n\
    \    let mut current_note_index = 0;\n    let mut current_note_length = 0;\n \
    \   for note in notes {\n        if note == \"o\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_index = 0;\n        \
    \    current_note_length = 0;\n            current_note = String::from(\"\");\n\
    \        } else if note == \"o|\" {\n            beats.push(current_beat);\n \
    \           current_beat = 0;\n            current_note_index = 0;\n         \
    \   current_note_length = 2;\n            current_note = String::from(\"\");\n\
    \        } else if note == \".|\" {\n            beats.push(current_beat);\n \
    \           current_beat = 0;\n            current_note_index = 0;\n         \
    \   current_note_length = 1;\n            current_note = String::from(\"\");\n\
    \        } else {\n            current_note.push_str(note);\n            current_note_length\
    \ += 1;\n        }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpv0007baz.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note += c.to_ascii_lowercase();\n\
    \            }\n        } else {\n            if current_note.is_empty() {\n \
    \               println!(\"Invalid music string\");\n                break;\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpm5id3c8n.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note.push(c);\n            }\n\
    \        } else {\n            current_note.push(c);\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmphr97oqxd.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_is_octave = false;\n\
    \    let mut current_note_is_rest = false;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                if current_note_is_octave {\n                    current_note_is_octave\
    \ = false;\n                    current_note_is_rest = true;\n               \
    \ } else {\n                    current_note_is_octave = true;\n             \
    \       current_note_is_rest = false;\n                }\n            } else if\
    \ c.to_ascii_lowercase() == '|' {\n                if current_note_is_octave {\n\
    \                    current_note_is_octave = false;\n                    current_note_is_rest\
    \ = false;\n                } else {\n                    current_note_is_octave\
    \ = true;\n                    current_note_is_rest = true;\n                }\n\
    \            } else if c.to_ascii_lowercase() == '.' {\n                if current_note_is_octave\
    \ {\n                    current_note_is_octave = false;\n                   \
    \ current_note_is_rest = false;\n                } else {\n                  \
    \  current_note_is_octave = false;\n                    current_note_is_rest =\
    \ true;\n                }\n            } else {\n                let note = c.to_ascii_lowercase();\n\
    \                if note == \"b\" {\n                    current_note_is_rest\
    \ = false;\n                } else if note == \"#\" {\n                    current_note_is_octave\
    \ = false;\n                } else {\n                    current_note_is_octave\
    \ = false;\n                    current_note_is_rest = false;\n              \
    \  }\n            }\n        } else {\n            current_note_is_octave = false;\n\
    \            current_note_is_rest = false;\n        }\n        if current_note_is_rest\
    \ {\n            beats.push(current_beat);\n            current_beat = 0;\n  \
    \          current_note = String::new();\n            current_note_is_rest = false;\n\
    \            current_note_is_octave = false;\n            current_note_is_octave\
    \ = false;\n        }\n        if current_note_is_octave {\n            current_beat\
    \ += 1;\n        }\n        current_note.push_str(&c);\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppdn4sfo_.rs:45:28\n   |\n\
    45 |                 if note == \"b\" {\n   |                            ^^^ expected\
    \ `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppdn4sfo_.rs:47:35\n\
    \   |\n47 |                 } else if note == \"#\" {\n   |                  \
    \                 ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppdn4sfo_.rs:69:31\n   |\n69 |         current_note.push_str(&c);\n\
    \   |                               ^^ expected `str`, found `char`\n   |\n  \
    \ = note: expected reference `&str`\n              found reference `&char`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_index = 0;\n    let mut current_note_length = 0;\n   \
    \ let mut current_note_octave = 0;\n    let mut current_note_octave_change = 0;\n\
    \    let mut current_note_octave_change_sign = 1;\n    let mut current_note_octave_change_octave\
    \ = 0;\n    let mut current_note_octave_change_octave_sign = 1;\n    let mut current_note_octave_change_octave_octave\
    \ = 0;\n    let mut current_note_octave_change_octave_octave_sign = 1;\n    let\
    \ mut current_note_octave_change_octave_octave_octave = 0;\n    let mut current_note_octave_change_octave_octave_octave_sign\
    \ = 1;\n    let mut current_note_octave_change_octave_octave_octave_octave = 0;\n\
    \    let mut current_note_octave_change_octave_octave_octave_octave_sign = 1;\n\
    \    let mut current_note_octave_change_octave_octave_octave_octave_octave = 0;\n\
    \    let mut current_note_octave_change_octave_octave_octave_octave_octave_sign\
    \ = 1;\n    let mut current_note_octave_change_octave_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_change_octave_octave_octave_octave_octave_octave_sign\
    \ = 1;\n    let mut current_note_octave_change_octave_octave_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_change_octave_octave_octave_octave_octave_octave_octave_sign\
    \ = 1;\n    let mut current_note_octave_change_octave_octave_octave_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_change_octave_octave_octave_octave_octave_octave_octave_octave_octave_sign\
    \ = 1;\n    let mut current_note_octave_change_octave_octave_octave_octave_octave_octave_octave_octave_octave_octave\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw9v0ehqk.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9v0ehqk.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n    \
    \            beats.push(current_beat);\n                current_beat += 4;\n \
    \               current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o|' {\n             \
    \   beats.push(current_beat);\n                current_beat += 2;\n          \
    \      current_note = String::new();\n                current_note_length = 0;\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat += 1;\n                current_note = String::new();\n\
    \                current_note_length = 0;\n            } else {\n            \
    \    current_note.push(c);\n                current_note_length += 1;\n      \
    \      }\n        } else {\n            if current_note_length == 0 {\n      \
    \          println!(\"Invalid music string\");\n                panic!(\"Invalid\
    \ music string\");\n            }\n            if c.is_whitespace() {\n      \
    \          if current_note_length == 0 {\n                    println!(\"Invalid\
    \ music string\");\n                    panic!(\"Invalid music string\");\n  \
    \              }\n            } else {\n                println!(\"Invalid music\
    \ string\");\n                panic!(\"Invalid music string\");\n            }\n\
    \        }\n    }\n    beats.push(current_beat);\n    current_beat += current_note_length;\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmphxn2iejt.rs:22:52\n\
    \   |\n22 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                if current_note.is_empty()\
    \ {\n                    current_note = c.to_ascii_lowercase();\n            \
    \        current_note_length = c.to_ascii_lowercase();\n                } else\
    \ {\n                    current_note += c.to_ascii_lowercase();\n           \
    \         current_note_length += c.to_ascii_lowercase();\n                }\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                if current_note.is_empty()\
    \ {\n                    current_note = c.to_ascii_lowercase();\n            \
    \        current_note_length = c.to_ascii_lowercase();\n                } else\
    \ {\n                    current_note += c.to_ascii_lowercase();\n           \
    \         current_note_length += c.to_ascii_lowercase();\n                }\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                if current_note.is_empty()\
    \ {\n                    current_note = c.to_ascii_lowercase();\n            \
    \        current_note_length = c.to_ascii_lowercase();\n                } else\
    \ {\n                    current_note += c.to_ascii_lowercase();\n           \
    \         current_note_length += c.to_ascii_lowercase();\n                }\n\
    \            }\n        } else {\n            if current_note.is_empty() {\n \
    \               println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n            current_note_length\
    \ = String::new();\n        }\n    }\n    if current_note.is_empty() {\n     \
    \   println!(\"Invalid music string\");\n        return beats;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpd_i9i_ha.rs:26:52\n\
    \   |\n26 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1q04hoe.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_beat_length = 0;\n    let mut current_note_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat = 0;\n    let mut current_note_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length = 0;\n    let mut current_note_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat = 0;\n    let mut\
    \ current_note_length_to_beat_length_to_beat_length = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpctamfo8z.rs:39:21\n   |\n\
    39 |     let mut current_\n   |                     ^ help: add `;` here\n40 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpctamfo8z.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::from(\"\");\n    let mut current_beat = 0;\n    let mut current_note_index\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_octave\
    \ = 0;\n    let mut current_note_octave_offset = 0;\n    let mut current_note_octave_length\
    \ = 0;\n    let mut current_note_octave_octave = 0;\n    let mut current_note_octave_octave_offset\
    \ = 0;\n    let mut current_note_octave_octave_length = 0;\n    let mut current_note_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_offset = 0;\n    let mut\
    \ current_note_octave_octave_octave_length = 0;\n    let mut current_note_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_offset = 0;\n   \
    \ let mut current_note_octave_octave_octave_octave_length = 0;\n    let mut current_note_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_offset = 0;\n   \
    \ let mut current_note_octave_octave_octave_octave_length = 0;\n    let mut current_note_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_offset = 0;\n   \
    \ let mut current_note_octave_octave_octave_octave_length = 0;\n    let mut current_note_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_offset = 0;\n   \
    \ let mut current_note_octave_octave_octave_octave_length = 0;\n    let mut current_note_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_offset = 0;\n   \
    \ let mut current_note_octave_octave_octave_octave_length = 0;\n    let mut current_note_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf2kx9ysz.rs:42:26\n   |\n\
    42 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpf2kx9ysz.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9uz9mh3q.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = \n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpdgc6cvb4.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            current_note.push_str(&c.to_string());\n\
    \            current_note_length += 1;\n        } else {\n            if current_note\
    \ != String::new() && current_note_length > 0 {\n                beats.push(current_beat\
    \ + current_note_length);\n                current_note.clear();\n           \
    \     current_note_length = 0;\n            }\n            current_note.push_str(&c.to_string());\n\
    \        }\n    }\n    if current_note != String::new() && current_note_length\
    \ > 0 {\n        beats.push(current_beat + current_note_length);\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7]`,\n right: `[4, 4, 4, 4]`', /tmp/tmp1rkx1iif.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpe94v67xa.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n       \
    \         beats.push(current_beat);\n                current_beat += 4;\n    \
    \            current_note = String::new();\n                current_note_len =\
    \ c.len_utf8();\n            } else if c.to_ascii_lowercase() == 'o|' {\n    \
    \            beats.push(current_beat);\n                current_beat += 2;\n \
    \               current_note = String::new();\n                current_note_len\
    \ = c.len_utf8();\n            } else if c.to_ascii_lowercase() == '.|' {\n  \
    \              beats.push(current_beat);\n                current_beat += 1;\n\
    \                current_note = String::new();\n                current_note_len\
    \ = c.len_utf8();\n            } else {\n                current_note.push(c);\n\
    \                current_note_len = c.len_utf8();\n            }\n        } else\
    \ {\n            if current_note.len() == 0 {\n                println!(\"Invalid\
    \ music string\");\n                return beats;\n            }\n           \
    \ if current_note_len == 0 {\n                println!(\"Invalid music string\"\
    );\n                return beats;\n            }\n            let beat = current_beat\
    \ / current_note_len;\n            beats.push(beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n            current_note_len\
    \ = c.len_utf8();\n        }\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpa_ira47j.rs:22:52\n\
    \   |\n22 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut last_note = String::new();\n   \
    \ let mut last_note_len = 0;\n    let mut last_note_len_len = 0;\n    let mut\
    \ last_note_len_len_len = 0;\n    let mut last_note_len_len_len = 0;\n    let\
    \ mut last_note_len_len_len = 0;\n    let mut last_note_len_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len = 0;\n    let\
    \ mut last_note_len = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxkacc97m.rs:73:11\n   |\n\
    73 |     let mu\n   |           ^ help: add `;` here\n74 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxkacc97m.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != 'o');\n    let mut current_note = 0;\n    for note in notes {\n        if\
    \ note == current_note {\n            beats.push(1);\n        } else {\n     \
    \       beats.push(beats[beats.len() - 1] + 1);\n        }\n        current_note\
    \ = note;\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpi98tybtf.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi98tybtf.rs:15:20\n   |\n15 |         if note\
    \ == current_note {\n   |                    ^^^^^^^^^^^^ expected tuple, found\
    \ integer\n   |\n   = note: expected tuple `(usize, char)`\n               found\
    \ type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi98tybtf.rs:20:24\n\
    \   |\n20 |         current_note = note;\n   |                        ^^^^ expected\
    \ integer, found tuple\n   |\n   = note: expected type `{integer}`\n         \
    \    found tuple `(usize, char)`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n    \
    \            beats.push(current_beat);\n                current_beat = 0;\n  \
    \              current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n              \
    \  beats.push(current_beat);\n                current_beat = 0;\n            \
    \    current_note = String::new();\n                current_note_length = 0;\n\
    \            } else if c.to_ascii_lowercase() == '|' {\n                current_beat\
    \ += 1;\n            } else if c.to_ascii_lowercase() == '.' {\n             \
    \   current_beat += 1;\n                current_note_length += 1;\n          \
    \  } else {\n                current_note += c.to_ascii_lowercase();\n       \
    \         current_note_length += 1;\n            }\n        } else {\n       \
    \     if current_note.is_empty() {\n                continue;\n            }\n\
    \            let note = current_note.chars().collect::<String>().parse().unwrap();\n\
    \            let length = current_note_length;\n            current_note = String::new();\n\
    \            current_note_length = 0;\n            beats.push(note as isize);\n\
    \        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu8ku2_8z.rs:33:33\n   |\n\
    33 |                 current_note += c.to_ascii_lowercase();\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '|' {\n                current_beat\
    \ += 1;\n                current_note.push_str(&c.to_ascii_lowercase());\n   \
    \         } else {\n                current_note.push_str(&c.to_ascii_lowercase());\n\
    \            }\n        } else {\n            current_note.push_str(&c.to_ascii_lowercase());\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdfu5m5xs.rs:30:39\n   |\n\
    30 |                 current_note.push_str(&c.to_ascii_lowercase());\n   |   \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdfu5m5xs.rs:32:39\n\
    \   |\n32 |                 current_note.push_str(&c.to_ascii_lowercase());\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdfu5m5xs.rs:35:35\n\
    \   |\n35 |             current_note.push_str(&c.to_ascii_lowercase());\n   |\
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: usize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: usize = 0;\n    let mut current_length:\
    \ usize = 0;\n    let mut current_length_index: usize = 0;\n    let mut current_length_index2:\
    \ usize = 0;\n    let mut current_length_index3: usize = 0;\n    let mut current_length_index4:\
    \ usize = 0;\n    let mut current_length_index5: usize = 0;\n    let mut current_length_index6:\
    \ usize = 0;\n    let mut current_length_index7: usize = 0;\n    let mut current_length_index8:\
    \ usize = 0;\n    let mut current_length_index9: usize = 0;\n    let mut current_length_index10:\
    \ usize = 0;\n    let mut current_length_index11: usize = 0;\n    let mut current_length_index12:\
    \ usize = 0;\n    let mut current_length_index13: usize = 0;\n    let mut current_length_index14:\
    \ usize = 0;\n    let mut current_length_index15: usize = 0;\n    let mut current_length_index16:\
    \ usize = 0;\n    let mut current_length_index17: usize = 0;\n    let mut current_length_index18:\
    \ usize = 0;\n    let mut current_length_index19: usize = 0;\n    let mut current_length_index20:\
    \ usize = 0;\n    let mut current_length_index21: usize = 0;\n    let mut current_length_index22:\
    \ usize = 0;\n    let mut current_length_index23: usize = 0;\n    let mut current_length_index24:\
    \ usize = 0;\n    let mut current_length_index25: usize = 0;\n    let mut current_length_index26:\
    \ usize = 0;\n    let mut current_length_index27: usize = 0;\n    let mut current_length_index28:\
    \ usize = 0;\n    let mut current_length_index29: usize = 0;\n    let mut current_length_index30:\
    \ usize = 0;\n    let mut current_length_index31: usize = 0;\n    let mut current_length_index32:\
    \ usize = 0;\n    let mut current_length_index33: usize = 0;\n    let mut current_length_index34:\
    \ usize = 0;\n    let mut current_length_index35: usize = 0;\n    let mut current_length_index36:\
    \ usize = 0;\n    let mut current_length_index37: usize = 0;\n    let mut current_length_index38:\
    \ usize = 0;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg_qsyhqb.rs:54:21\n   |\n\
    54 |     let mut current_\n   |                     ^ help: add `;` here\n55 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg_qsyhqb.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp8jcspwor.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    for c in music_string.chars() {\n        if c.is_ascii() {\n     \
    \       let note = match c {\n                'o' => 0,\n                'o|'\
    \ => 1,\n                '.|' => 2,\n                _ => panic!(\"Invalid music\
    \ note: {:?}\", c),\n            };\n            beats.push(current_beat);\n \
    \           current_beat += note;\n            current_note_length += note;\n\
    \            current_note += note;\n        } else {\n            current_beat\
    \ += 1;\n            current_note_length += 1;\n            current_note += 1;\n\
    \        }\n    }\n    beats.push(current_beat);\n    current_beat += current_note_length;\n\
    \    beats.push(current_beat);\n    current_beat += current_note;\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp9tf4scqq.rs:19:20\n\
    \   |\n19 |                 'o|' => 1,\n   |                    ^^^^^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_is_octave = false;\n\n\
    \    for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                if current_note_is_octave {\n\
    \                    current_octave += 1;\n                } else {\n        \
    \            current_octave = 0;\n                    current_note_is_octave =\
    \ true;\n                }\n            } else {\n                if current_note_is_octave\
    \ {\n                    current_octave -= 1;\n                }\n           \
    \     current_note_is_octave = false;\n            }\n            current_note\
    \ += c.to_ascii_lowercase();\n        } else {\n            if current_note_is_octave\
    \ {\n                current_octave -= 1;\n            }\n            current_note_is_octave\
    \ = false;\n            current_note += c.to_ascii_lowercase();\n        }\n \
    \   }\n\n    if current_note.is_empty() {\n        return beats;\n    }\n\n  \
    \  let mut note = String::new();\n    let mut octave = String::new();\n    let\
    \ mut note_is_octave = false;\n    for c in current_note.chars() {\n        if\
    \ c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n           \
    \     if note_is_octave {\n                    octave += c.to_ascii_lowercase();\n\
    \                } else {\n                    octave = c.to_ascii_lowercase();\n\
    \                    note_is_octave = true;\n                }\n            }\
    \ else {\n                if note_is_octave {\n                    octave -= c.to_ascii_lowercase();\n\
    \                }\n                note_is_octave = false;\n            }\n \
    \       } else {\n            if note_is_octave {\n                octave -= c.to_ascii_lowercase();\n\
    \            }\n            note_is_octave = false;\n            note += c.to_ascii_lowercase();\n\
    \        }\n    }\n\n    if note.is_empty() {\n        return beats;\n    }\n\n\
    \    let mut beat = 0;\n    let mut octave = 0;\n    let mut note_is_octave =\
    \ false;\n    for c in note.chars() {\n        if c.is_ascii() {\n           \
    \ if c.to_ascii_lowercase() == 'o' {\n                if note_is_octave {\n  \
    \                  octave += c.to_ascii_lowercase();\n                } else {\n\
    \                    octave = c.to_ascii_lowercase();\n                    note_is_octave\
    \ = true;\n                }\n            } else {\n                if note_is_octave\
    \ {\n                    octave -= c.to_ascii_lowercase();\n                }\n\
    \                note_is_octave = false;\n            }\n        } else {\n  \
    \          if note_is_octave {\n                octave -= c.to_ascii_lowercase();\n\
    \            }\n            note_is_octave = false;\n            beat += c.to_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4m2f1ll2.rs:110:3\n\
    \    |\n10  | fn parse_music(music_string: String) -> Vec<isize> {\n    |    \
    \                                                - unclosed delimiter\n...\n80\
    \  |     for c in note.chars() {\n    |                           - unclosed delimiter\n\
    ...\n95  |         } else {\n    |                - this delimiter might not be\
    \ properly closed...\n...\n101 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n110 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4m2f1ll2.rs:32:29\n   |\n32 |             current_note += c.to_ascii_lowercase();\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4m2f1ll2.rs:38:29\n\
    \   |\n38 |             current_note += c.to_ascii_lowercase();\n   |        \
    \                     ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4m2f1ll2.rs:53:31\n   |\n53 |  \
    \                   octave += c.to_ascii_lowercase();\n   |                  \
    \             ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4m2f1ll2.rs:55:30\n   |\n55 |              \
    \       octave = c.to_ascii_lowercase();\n   |                              ^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \            |\n   |                              expected struct `String`, found\
    \ `char`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied to\
    \ type `String`\n  --> /tmp/tmp4m2f1ll2.rs:60:21\n   |\n60 |                 \
    \    octave -= c.to_ascii_lowercase();\n   |                     ------^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                     |\n   |                     cannot use `-=` on type\
    \ `String`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `String`\n  --> /tmp/tmp4m2f1ll2.rs:66:17\n   |\n66 |              \
    \   octave -= c.to_ascii_lowercase();\n   |                 ------^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  "
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5_3r3k9x.rs:63:11\n   |\n\
    63 |     let mu\n   |           ^ help: add `;` here\n64 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5_3r3k9x.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n    \
    \            if current_beat == 0 {\n                    current_note = c.to_ascii_lowercase();\n\
    \                    current_note_length = 1;\n                } else {\n    \
    \                current_note += c.to_ascii_lowercase();\n                   \
    \ current_note_length += 1;\n                }\n            } else {\n       \
    \         if current_beat == 0 {\n                    current_note = c.to_ascii_lowercase();\n\
    \                    current_note_length = 1;\n                } else {\n    \
    \                current_note += c.to_ascii_lowercase();\n                   \
    \ current_note_length += 1;\n                }\n            }\n        } else\
    \ {\n            if current_beat == 0 {\n                current_note = c.to_ascii_lowercase();\n\
    \                current_note_length = 1;\n            } else {\n            \
    \    current_note += c.to_ascii_lowercase();\n                current_note_length\
    \ += 1;\n            }\n        }\n        current_beat += 1;\n        if current_beat\
    \ == 4 {\n            beats.push(current_note_length);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n            current_note_length\
    \ = 0;\n        }\n    }\n    beats.push(current_note_length);\n    beats\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_j8hgtcn.rs:19:36\n   |\n\
    19 |                     current_note = c.to_ascii_lowercase();\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                    |\n   |    \
    \                                expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_j8hgtcn.rs:22:37\n   |\n22 |              \
    \       current_note += c.to_ascii_lowercase();\n   |                        \
    \             ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_j8hgtcn.rs:27:36\n   |\n27 |              \
    \       current_note = c.to_ascii_lowercase();\n   |                         \
    \           ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                    |\n   |                             \
    \       expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_j8hgtcn.rs:30:37\n   |\n30 |                     current_note\
    \ += c.to_ascii_lowercase();\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_j8hgtcn.rs:36:32\n\
    \   |\n36 |                 current_note = c.to_ascii_lowercase();\n   |     \
    \                           ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                |\n   |        \
    \                        expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_j8hgtcn.rs:39:33\n   |\n39 |              \
    \   current_note += c.to_ascii_lowercase();\n   |                            \
    \     ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().collect::<Vec<char>>();\n    let mut\
    \ last_note = notes.len() - 1;\n    let mut last_beat = 0;\n    let mut last_beats\
    \ = 1;\n    let mut last_notes = 1;\n    let mut last_notes_beats = 1;\n    let\
    \ mut last_notes_beats_beats = 1;\n    let mut last_notes_beats_beats_beats =\
    \ 1;\n    let mut last_notes_beats_beats_beats_beats = 1;\n    let mut last_notes_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats = 1;\n    let\
    \ mut last_notes_beats_beats_beats_beats_beats_beats_beats = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = 1;\n    let mut last_notes_beats_beats_beats_beats_beats_beats_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5z_chxji.rs:35:60\n   |\n\
    35 |     let mut last_notes_beats_beats_beats_beats_beats_beats_\n   |       \
    \                                                     ^ help: add `;` here\n36\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5z_chxji.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n    \
    \            if current_note_length == 0 {\n                    current_note =\
    \ c.to_string();\n                    current_note_length = 1;\n             \
    \   } else {\n                    current_note_length += 1;\n                }\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                if current_note_length\
    \ == 0 {\n                    current_note = c.to_string();\n                \
    \    current_note_length = 1;\n                } else {\n                    current_note_length\
    \ += 1;\n                }\n            } else if c.to_ascii_lowercase() == '.|'\
    \ {\n                if current_note_length == 0 {\n                    current_note\
    \ = c.to_string();\n                    current_note_length = 1;\n           \
    \     } else {\n                    current_note_length += 1;\n              \
    \  }\n            } else {\n                println!(\"Invalid music note: {}\"\
    , c);\n            }\n        } else {\n            println!(\"Invalid music note:\
    \ {}\", c);\n        }\n    }\n    if current_note_length == 0 {\n        beats.push(current_beat);\n\
    \    } else {\n        beats.push(current_beat + current_note_length);\n    }\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpdp8sn9xj.rs:24:52\n\
    \   |\n24 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa5a2jf2q.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpa5a2jf2q.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.next();\n    let mut current_beat = 0;\n   \
    \ while let Some(note) = current_note {\n        if note == \"o\" {\n        \
    \    beats.push(current_beat);\n            current_beat = 0;\n            current_note\
    \ = notes.next();\n        } else if note == \"o|\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = notes.next();\n   \
    \     } else if note == \".|\" {\n            beats.push(current_beat);\n    \
    \        current_beat = 0;\n            current_note = notes.next();\n       \
    \ } else {\n            current_beat += 1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<&str>` in the\
    \ current scope\n  --> /tmp/tmp7r3b_cou.rs:13:34\n   |\n13 |     let mut current_note\
    \ = notes.next();\n   |                                  ^^^^ method not found\
    \ in `Vec<&str>`\n\nerror[E0599]: no method named `next` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmp7r3b_cou.rs:19:34\n   |\n19 |          \
    \   current_note = notes.next();\n   |                                  ^^^^ method\
    \ not found in `Vec<&str>`\n\nerror[E0599]: no method named `next` found for struct\
    \ `Vec<&str>` in the current scope\n  --> /tmp/tmp7r3b_cou.rs:23:34\n   |\n23\
    \ |             current_note = notes.next();\n   |                           \
    \       ^^^^ method not found in `Vec<&str>`\n\nerror[E0599]: no method named\
    \ `next` found for struct `Vec<&str>` in the current scope\n  --> /tmp/tmp7r3b_cou.rs:27:34\n\
    \   |\n27 |             current_note = notes.next();\n   |                   \
    \               ^^^^ method not found in `Vec<&str>`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_octave = 0;\n    let mut current_note_length = 0;\n    let\
    \ mut current_note_length_index = 0;\n    let mut current_note_length_index2 =\
    \ 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9u2dnjo8.rs:62:40\n   |\n\
    62 |     let mut current_note_length_index47\n   |                           \
    \             ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9u2dnjo8.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            let note = c.to_ascii_lowercase();\n\
    \            if note == \"o\" {\n                beats.push(current_beat);\n \
    \               current_beat = 0;\n                current_note = String::new();\n\
    \                current_octave = 0;\n            } else if note == \"o|\" {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_octave\
    \ = 1;\n            } else if note == \".|\" {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_octave = 2;\n            } else {\n                current_note.push_str(note);\n\
    \            }\n        } else {\n            current_note.push_str(&c.to_string());\n\
    \        }\n    }\n\n    beats.push(current_beat);\n    current_beat = 0;\n  \
    \  current_note = String::new();\n    current_octave = 0;\n\n    beats\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcilqp6mu.rs:19:24\n   |\n\
    19 |             if note == \"o\" {\n   |                        ^^^ expected\
    \ `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcilqp6mu.rs:24:31\n\
    \   |\n24 |             } else if note == \"o|\" {\n   |                     \
    \          ^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcilqp6mu.rs:29:31\n   |\n29 |             } else if note == \"\
    .|\" {\n   |                               ^^^^ expected `char`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcilqp6mu.rs:35:39\n   |\n35 |\
    \                 current_note.push_str(note);\n   |                         \
    \              ^^^^ expected `&str`, found `char`\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_octave = 0;\n    let mut current_note_is_rest = false;\n\n\
    \    for c in music_string.chars() {\n        match c {\n            'o' => current_note_is_rest\
    \ = false,\n            'o|' => current_note_is_rest = true,\n            '.|'\
    \ => current_note_is_rest = false,\n            _ => {\n                let note\
    \ = match c {\n                    'o' => \"whole_note\",\n                  \
    \  'o|' => \"half_note\",\n                    '.|' => \"quater_note\",\n    \
    \                _ => panic!(\"Unexpected character in music string: {}\", c),\n\
    \                };\n\n                let octave = match c {\n              \
    \      'o' => 0,\n                    'o|' => 1,\n                    '.|' =>\
    \ 2,\n                    _ => panic!(\"Unexpected character in music string:\
    \ {}\", c),\n                };\n\n                let beat = current_beat + octave\
    \ * 12 + note_to_beat(note);\n                beats.push(beat);\n            \
    \    current_beat = beat;\n                current_note = note;\n            \
    \    current_octave = octave;\n                current_note_is_rest = false;\n\
    \            }\n        }\n    }\n\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpx2meu6ql.rs:20:16\n\
    \   |\n20 |             'o|' => current_note_is_rest = true,\n   |           \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    for c in music_string {\n        if c == 'o' {\n            if current_note_length_index\
    \ == 0 {\n                current_note = String::new();\n                current_note_length\
    \ = 0;\n                current_note_length_index = 0;\n            }\n      \
    \      current_note.push(c);\n            current_note_length += 1;\n        \
    \    current_note_length_index += 1;\n        } else if c == '|' {\n         \
    \   if current_note_length_index == 0 {\n                current_note = String::new();\n\
    \                current_note_length = 0;\n                current_note_length_index\
    \ = 0;\n            }\n            current_note.push(c);\n            current_note_length\
    \ += 1;\n            current_note_length_index += 1;\n        } else if c == '\
    \ ' {\n            if current_note_length_index == 0 {\n                current_note\
    \ = String::new();\n                current_note_length = 0;\n               \
    \ current_note_length_index = 0;\n            }\n            current_note.push(c);\n\
    \            current_note_length += 1;\n            current_note_length_index\
    \ += 1;\n        } else {\n            if current_note_length_index == 0 {\n \
    \               current_note = String::new();\n                current_note_length\
    \ = 0;\n                current_note_length_index = 0;\n            }\n      \
    \      current_note.push(c);\n            current_note_length += 1;\n        \
    \    current_note_length_index += 1;\n        }\n        if current_note_length_index\
    \ == 4 {\n            beats.push(current_beat + current_note_length);\n      \
    \      current_beat = 0;\n            current_note_length = 0;\n            current_note_length_index\
    \ = 0;\n        }\n    }\n    beats.push(current_beat + current_note_length);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpdl3_kuea.rs:16:14\n\
    \    |\n16  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_octave = 0;\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcndayv67.rs:57:46\n   |\n\
    57 |     let mut current_note_length = String::new\n   |                     \
    \                         ^ help: add `;` here\n58 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcndayv67.rs:10:41\n   |\n10 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------  \
    \                        ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != 'o');\n    let mut current_note = 0;\n    for note in notes {\n        let\
    \ mut current_beat = 0;\n        note.for_each(|c| {\n            match c {\n\
    \                'o' => beats.push(current_beat),\n                '|' => beats.push(current_beat\
    \ + 1),\n                '.' => current_beat += 1,\n                _ => current_beat\
    \ += 1,\n            }\n        });\n        current_note += 1;\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpb8brwjnl.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0599]:\
    \ the method `for_each` exists for tuple `(usize, char)`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpb8brwjnl.rs:16:14\n   |\n16 |         note.for_each(|c|\
    \ {\n   |              ^^^^^^^^ method cannot be called on `(usize, char)` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `(usize, char): Iterator`\n           which is required\
    \ by `&mut (usize, char): Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = \n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpdgc6cvb4.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_len = 0;\n    let mut current_note_oct\
    \ = 0;\n    let mut current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n\
    \    let mut current_note_oct4 = 0;\n    let mut current_note_oct5 = 0;\n    let\
    \ mut current_note_oct6 = 0;\n    let mut current_note_oct7 = 0;\n    let mut\
    \ current_note_oct8 = 0;\n    let mut current_note_oct9 = 0;\n    let mut current_note_oct10\
    \ = 0;\n    let mut current_note_oct11 = 0;\n    let mut current_note_oct12 =\
    \ 0;\n    let mut current_note_oct13 = 0;\n    let mut current_note_oct14 = 0;\n\
    \    let mut current_note_oct15 = 0;\n    let mut current_note_oct16 = 0;\n  \
    \  let mut current_note_oct17 = 0;\n    let mut current_note_oct18 = 0;\n    let\
    \ mut current_note_oct19 = 0;\n    let mut current_note_oct20 = 0;\n    let mut\
    \ current_note_oct21 = 0;\n    let mut current_note_oct22 = 0;\n    let mut current_note_oct23\
    \ = 0;\n    let mut current_note_oct24 = 0;\n    let mut current_note_oct25 =\
    \ 0;\n    let mut current_note_oct26 = 0;\n    let mut current_note_oct27 = 0;\n\
    \    let mut current_note_oct28 = 0;\n    let mut current_note_oct29 = 0;\n  \
    \  let mut current_note_oct30 = 0;\n    let mut current_note_oct31 = 0;\n    let\
    \ mut current_note_oct32 = 0;\n    let mut current_note_oct33 = 0;\n    let mut\
    \ current_note_oct34 = 0;\n    let mut current_note_oct35 = 0;\n    let mut current_note_oct36\
    \ = 0;\n    let mut current_note_oct37 = 0;\n    let mut current_note_oct38 =\
    \ 0;\n    let mut current_note_oct39 = 0;\n    let mut current_note_oct40 = 0;\n\
    \    let mut current_note_oct41 = 0;\n    let mut current_note_oct42 = 0;\n  \
    \  let mut current_note_oct43 = 0;\n    let mut current_note_oct44 = 0;\n    let\
    \ mut current_note_oct45 = 0;\n    let mut current_note_oct46 = 0;\n    let mut\
    \ current_note_oct47 = 0;\n    let mut current_note_oct48 = 0;\n    let mut current_note_oct49\
    \ = 0;\n    let mut current_note_oct50 = 0;\n    let mut current_note_oct51 =\
    \ 0;\n    let mut current_note_oct52 = 0;\n    let mut current_note_\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjo28dgg9.rs:67:26\n   |\n\
    67 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjo28dgg9.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != '|');\n    for note in notes {\n        let mut beat = 0;\n        let mut\
    \ last_note = note.1;\n        for _ in 0..note.0 {\n            beat += 1;\n\
    \            last_note = notes[notes.len() - 1].1;\n        }\n        beats.push(beat);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpyegnephk.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Filter` in the current scope\n  -->\
    \ /tmp/tmpyegnephk.rs:18:37\n   |\n18 |             last_note = notes[notes.len()\
    \ - 1].1;\n   |                                     ^^^ method not found in `Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpyegnephk.rs:12:61: 12:84]>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index48\
    \ = 1;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoe75nrnm.rs:63:21\n   |\n\
    63 |     let mut current_\n   |                     ^ help: add `;` here\n64 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoe75nrnm.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749083
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string {\n        if c\
    \ == 'o' {\n            current_note = String::new();\n            current_note_length\
    \ = 0;\n            current_beat += 1;\n            beats.push(current_beat);\n\
    \        } else if c == '|' {\n            current_beat += 1;\n            beats.push(current_beat);\n\
    \        } else if c == '.' {\n            current_beat += 1;\n            current_note_length\
    \ += 1;\n            beats.push(current_beat);\n        } else {\n           \
    \ current_note.push(c);\n            current_note_length += 1;\n        }\n  \
    \  }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpixyv8t94.rs:15:14\n\
    \    |\n15  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_len = 0;\n    let mut current_note_char = 0;\n    let\
    \ mut current_note_char_len = 0;\n    let mut current_note_char_char = 0;\n  \
    \  let mut current_note_char_char_len = 0;\n    let mut current_note_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_len = 0;\n    let mut current_note_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_len = 0;\n    let mut current_note_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_len = 0;\n    let mut\
    \ current_note_char_char_char_char_char_char = 0;\n    let mut current_note_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char = 0;\n   \
    \ let mut current_note_char_char_char_char_char_char_char_len = 0;\n    let mut\
    \ current_note_char_char_char_char_char_char_char_char = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = 0;\n    let mut current_note_char_char_char_char_\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr3vv8xo6.rs:45:46\n   |\n\
    45 |     let mut current_note_char_char_char_char_\n   |                     \
    \                         ^ help: add `;` here\n46 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr3vv8xo6.rs:10:41\n   |\n10 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------  \
    \                        ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_value = 0;\n    let mut current_note_length_value_length\
    \ = 0;\n    let mut current_note_length_value_length_index = 0;\n    let mut current_note_length_value_length_value\
    \ = 0;\n    let mut current_note_length_value_length_value_index = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_length_value_value_value = 0;\n\
    \    let mut current_note_length_value_length_value_value_index = 0;\n    let\
    \ mut current_note_length_value_length_value_value_value = 0;\n    let mut current_note_length_value_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_length_value_value_value = 0;\n\
    \    let mut current_note_length_value_length_value_value_index = 0;\n    let\
    \ mut current_note_length_value_length_value_value_value = 0;\n    let mut current_note_length_value_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_length_value_value_value = 0;\n\
    \    let mut current_note_length_value_length_value_value_index = 0;\n    let\
    \ mut current_note_length_value_length_value_value_value = 0;\n    let mut current_note_length_value_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_length_value_value_value = 0;\n\
    \    let mut current_note_length_value_length_value_value_index = 0;\n    let\
    \ mut current_note_length_value_length_value_value_value = 0;\n    let mut current_note_length_value_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_length_value_value_value = 0;\n\
    \    let mut current_note_length_value_length_value_value_index = 0;\n    let\
    \ mut current_note_length_value_length_value_value_value = 0;\n    let mut current_note_length_value_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_length_value_value_value = 0;\n\
    \    let mut current_note_length_value_length_value_value_index = 0;\n    let\
    \ mut current_note_length_value_length_value_value_value = 0;\n    let mut current_note_length_value_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_length_value_value_value = 0;\n\
    \    let mut current_note_length_value_length_value_value_index = 0;\n    let\
    \ mut current_note_length_value_length_value_value_value = 0;\n    let mut current_note_length_value_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_length_value_value_value = 0;\n\
    \    let mut current_note_length_value_length_value_value_index = 0;\n\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbt1ekf4d.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 0;\n            } else if c.to_ascii_lowercase()\
    \ == 'o' {\n                current_note_length += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '|' {\n                current_beat += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                current_beat += 1;\n            } else {\n       \
    \         current_note += c.to_ascii_lowercase();\n            }\n        } else\
    \ {\n            current_note += c.to_ascii_lowercase();\n        }\n    }\n \
    \   beats.push(current_beat);\n    current_beat = 0;\n    current_note.trim().to_string().chars().for_each(|c|\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n              \
    \  current_note_length += 1;\n            } else if c.to_ascii_lowercase() ==\
    \ '|' {\n                current_beat += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                current_beat += 1;\n            } else {\n       \
    \         current_note += c.to_ascii_lowercase();\n            }\n        } else\
    \ {\n            current_note += c.to_ascii_lowercase();\n        }\n    });\n\
    \    beats.push(current_beat);\n    current_beat = 0;\n    current_note.trim().to_string().chars().for_each(|c|\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n              \
    \  current_note_length += 1;\n            } else if c.to_ascii_lowercase() ==\
    \ '|' {\n                current_beat += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                current_beat += 1;\n            } else {\n       \
    \         current_note += c.to_ascii_lowercase();\n            }\n        } else\
    \ {\n            current_note += c.to_ascii_lowercase();\n        }\n    });\n\
    \    beats.push(current_beat);\n    current_beat = 0;\n    current_note.trim().to_string().chars().for_each(|c|\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpsvz73pea.rs:95:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n81 |\
    \     current_note.trim().to_string().chars().for_each(|c| {\n   |           \
    \                                          -    - unclosed delimiter\n   |   \
    \                                                  |\n   |                   \
    \                                  unclosed delimiter\n82 |         if c.is_ascii()\
    \ {\n   |                         - unclosed delimiter\n83 |             if c.to_ascii_lowercase()\
    \ == 'o' {\n   |                                              - this delimiter\
    \ might not be properly closed...\n...\n86 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n95 | }\n   |   ^\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmpsvz73pea.rs:15:14\n    |\n15  |     for c\
    \ in music_string {\n    |              ^^^^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator`\
    \ is not implemented for `String`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\nnote: required by `into_iter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpsvz73pea.rs:51:33\n   |\n51 |  \
    \               current_note += c.to_ascii_lowercase();\n   |                \
    \                 ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsvz73pea.rs:54:29\n   |\n54 |             current_note\
    \ += c.to_ascii_lowercase();\n   |                             ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsvz73pea.rs:73:33\n\
    \   |\n73 |                 current_note += c.to_ascii_lowercase();\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsvz73pea.rs:76:29\n   |\n76 |\
    \             current_note += c.to_ascii_lowercase();\n   |                  \
    \           "
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != 'o');\n    for note in notes {\n        note = note.unwrap();\n        if\
    \ note == 'o' {\n            beats.push(4);\n        } else {\n            beats.push(note\
    \ as isize);\n        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_5uihg4x.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0599]:\
    \ no method named `unwrap` found for tuple `(usize, char)` in the current scope\n\
    \  --> /tmp/tmp_5uihg4x.rs:14:21\n   |\n14 |         note = note.unwrap();\n \
    \  |                     ^^^^^^ method not found in `(usize, char)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_5uihg4x.rs:15:20\n   |\n15 |         if note\
    \ == 'o' {\n   |                    ^^^ expected tuple, found `char`\n   |\n \
    \  = note: expected tuple `(usize, char)`\n               found type `char`\n\n\
    error[E0605]: non-primitive cast: `(usize, char)` as `isize`\n  --> /tmp/tmp_5uihg4x.rs:18:24\n\
    \   |\n18 |             beats.push(note as isize);\n   |                     \
    \   ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive\
    \ types or to coerce to a specific trait object\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599, E0605.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpimyn5mcd.rs:62:32\n   |\n\
    62 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpimyn5mcd.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.split_whitespace();\n    for note in notes {\n\
    \        if note.len() == 1 {\n            beats.push(4);\n        } else {\n\
    \            let mut beat = 1;\n            let mut last_note = note[0];\n   \
    \         for c in note.chars().skip(1) {\n                let note = match c\
    \ {\n                    'o' => 4,\n                    'o|' => 2,\n         \
    \           '.|' => 1,\n                    _ => panic!(\"Unknown note {}\", c),\n\
    \                };\n                if note != last_note {\n                \
    \    beat += 1;\n                }\n                last_note = note;\n      \
    \      }\n            beats.push(beat);\n        }\n    }\n    beats\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmprhwltct_.rs:22:24\n\
    \   |\n22 |                     'o|' => 2,\n   |                        ^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0gjjrxmu.rs:58:21\n   |\n\
    58 |     let mut current_\n   |                     ^ help: add `;` here\n59 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0gjjrxmu.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::from(\"\");\n    let mut current_beat = 0;\n    let mut current_beats:\
    \ isize = 0;\n    let mut current_notes: isize = 0;\n    for c in music_string.chars()\
    \ {\n        if c == ' ' {\n            if current_notes.is_empty() {\n      \
    \          notes.push(current_note);\n                current_note = String::from(\"\
    \");\n                current_beat = 0;\n                current_beats = 0;\n\
    \                current_notes = 0;\n            } else {\n                current_notes.push(current_note);\n\
    \                current_note = String::from(\"\");\n                current_beat\
    \ = 0;\n                current_beats = 0;\n                current_notes = 0;\n\
    \            }\n        } else {\n            if current_note.is_empty() {\n \
    \               current_note = String::from(c);\n            } else {\n      \
    \          current_note.push(c);\n            }\n        }\n        if current_note.is_empty()\
    \ {\n            current_beats += 1;\n        } else {\n            current_beats\
    \ += 1;\n            if current_notes.is_empty() {\n                current_notes.push(current_note);\n\
    \                current_note = String::from(\"\");\n                current_beat\
    \ = 0;\n                current_beats = 0;\n                current_notes = 0;\n\
    \            } else {\n                current_notes.push(current_note);\n   \
    \             current_note = String::from(\"\");\n                current_beat\
    \ = 0;\n                current_beats = 0;\n                current_notes = 0;\n\
    \            }\n        }\n    }\n    if current_notes.is_empty() {\n        current_notes.push(current_note);\n\
    \    }\n    for note in current_notes {\n        beats.push(current_beats);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_empty` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpcxglftme.rs:19:30\n   |\n19 |             if current_notes.is_empty()\
    \ {\n   |                              ^^^^^^^^ method not found in `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcxglftme.rs:20:28\n   |\n20 |  \
    \               notes.push(current_note);\n   |                            ^^^^^^^^^^^^\n\
    \   |                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&current_note`\n\nerror[E0599]: no method named `push` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpcxglftme.rs:26:31\n   |\n26 |  \
    \               current_notes.push(current_note);\n   |                      \
    \         ^^^^ method not found in `isize`\n\nerror[E0599]: no method named `is_empty`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpcxglftme.rs:43:30\n\
    \   |\n43 |             if current_notes.is_empty() {\n   |                  \
    \            ^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named\
    \ `push` found for type `isize` in the current scope\n  --> /tmp/tmpcxglftme.rs:44:31\n\
    \   |\n44 |                 current_notes.push(current_note);\n   |          \
    \                     ^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `push` found for type `isize` in the current scope\n  --> /tmp/tmpcxglftme.rs:50:31\n\
    \   |\n50 |                 current_notes.push(current_note);\n   |          \
    \                     ^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `is_empty` found for type `isize` in the current scope\n  --> /tmp/tmpcxglftme.rs:58:22\n\
    \   |\n58 |     if current_notes.is_empty() {\n   |                      ^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `push` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmpcxglftme.rs:59:23\n   |\n59\
    \ |         current_notes.push(current_note);\n   |                       ^^^^\
    \ method not found in `isize`\n\nerror[E0277]: `isize` is not an iterator\n   "
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    for c in music_string.chars() {\n    \
    \    if c.is_whitespace() {\n            continue;\n        }\n        if c.is_ascii_digit()\
    \ {\n            current_note = c.to_string();\n            current_note_len =\
    \ c.len() as isize;\n        } else {\n            if current_note.len() == 0\
    \ {\n                continue;\n            }\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_len = c.len() as isize;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpoz8jytn3.rs:21:34\n   |\n21 |             current_note_len\
    \ = c.len() as isize;\n   |                                  ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpoz8jytn3.rs:29:34\n   |\n29 |             current_note_len\
    \ = c.len() as isize;\n   |                                  ^^^ method not found\
    \ in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let\
    \ mut current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut\
    \ current_note_oct4 = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6\
    \ = 0;\n    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n\
    \    let mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n   \
    \ let mut current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let\
    \ mut current_note_oct13 = 0;\n    let mut current_note_oct14 = 0;\n    let mut\
    \ current_note_oct15 = 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17\
    \ = 0;\n    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 =\
    \ 0;\n    let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n\
    \    let mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n  \
    \  let mut current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let\
    \ mut current_note_oct26 = 0;\n    let mut current_note_oct27 = 0;\n    let mut\
    \ current_note_oct28 = 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30\
    \ = 0;\n    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 =\
    \ 0;\n    let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n\
    \    let mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n  \
    \  let mut current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let\
    \ mut current_note_oct39 = 0;\n    let mut current_note_oct40 = 0;\n    let mut\
    \ current_note_oct41 = 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43\
    \ = 0;\n    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 =\
    \ 0;\n    let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n\
    \    let mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n  \
    \  let mut current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let\
    \ mut current_note_oct52 = 0;\n    let mut current_note_oct53\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwdt0xy5k.rs:67:31\n   |\n\
    67 |     let mut current_note_oct53\n   |                               ^ help:\
    \ add `;` here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwdt0xy5k.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749082
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_length = 0;\n    let mut current_length_index\
    \ = 0;\n    let mut current_length_index2 = 0;\n    let mut current_length_index3\
    \ = 0;\n    let mut current_length_index4 = 0;\n    let mut current_length_index5\
    \ = 0;\n    let mut current_length_index6 = 0;\n    let mut current_length_index7\
    \ = 0;\n    let mut current_length_index8 = 0;\n    let mut current_length_index9\
    \ = 0;\n    let mut current_length_index10 = 0;\n    let mut current_length_index11\
    \ = 0;\n    let mut current_length_index12 = 0;\n    let mut current_length_index13\
    \ = 0;\n    let mut current_length_index14 = 0;\n    let mut current_length_index15\
    \ = 0;\n    let mut current_length_index16 = 0;\n    let mut current_length_index17\
    \ = 0;\n    let mut current_length_index18 = 0;\n    let mut current_length_index19\
    \ = 0;\n    let mut current_length_index20 = 0;\n    let mut current_length_index21\
    \ = 0;\n    let mut current_length_index22 = 0;\n    let mut current_length_index23\
    \ = 0;\n    let mut current_length_index24 = 0;\n    let mut current_length_index25\
    \ = 0;\n    let mut current_length_index26 = 0;\n    let mut current_length_index27\
    \ = 0;\n    let mut current_length_index28 = 0;\n    let mut current_length_index29\
    \ = 0;\n    let mut current_length_index30 = 0;\n    let mut current_length_index31\
    \ = 0;\n    let mut current_length_index32 = 0;\n    let mut current_length_index33\
    \ = 0;\n    let mut current_length_index34 = 0;\n    let mut current_length_index35\
    \ = 0;\n    let mut current_length_index36 = 0;\n    let mut current_length_index37\
    \ = 0;\n    let mut current_length_index38 = 0;\n    let mut current_length_index39\
    \ = 0;\n    let mut current_length_index40 = 0;\n    let mut current_length_index41\
    \ = 0;\n    let mut current_length_index42 = 0;\n    let mut current_length_index43\
    \ = 0;\n    let mut current_length_index44 = 0;\n    let mut current_length_index45\
    \ = 0;\n    let mut current_length_index46 = 0;\n    let mut current_length_index47\
    \ = 0;\n    let mut current_length_index48 = 0;\n    let mut current_length_index49\
    \ = 0;\n    let mut current_length_index50 = 0;\n    let mut current_length_index51\
    \ = 0;\n    let mut current_length_index52 = 0;\n    let mut current_length_index53\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnrjmx10s.rs:68:35\n   |\n\
    68 |     let mut current_length_index53\n   |                                \
    \   ^ help: add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnrjmx10s.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '|' {\n                current_beat\
    \ = 1;\n            } else if c.to_ascii_lowercase() == '.' {\n              \
    \  current_beat = 2;\n            } else {\n                current_note += c.to_ascii_lowercase();\n\
    \            }\n        } else {\n            current_note += c.to_ascii_lowercase();\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuaoapje.rs:29:33\n   |\n\
    29 |                 current_note += c.to_ascii_lowercase();\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnuaoapje.rs:32:29\n   |\n32 |  \
    \           current_note += c.to_ascii_lowercase();\n   |                    \
    \         ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    for c in music_string.chars() {\n        match c {\n   \
    \         'o' => current_note = String::from(\"o\"),\n            'o|' => current_note\
    \ = String::from(\"o|\"),\n            '.|' => current_note = String::from(\"\
    .|\"),\n            _ => continue,\n        }\n        beats.push(current_beat);\n\
    \        current_beat += 1;\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpy14d9a0k.rs:17:16\n\
    \   |\n17 |             'o|' => current_note = String::from(\"o|\"),\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note = 0;\n    let mut current_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat = 0;\n\
    \    let mut current_note_length_to_beat_with_note_length_to_beat_with_note =\
    \ 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfnb39ku_.rs:32:66\n   |\n\
    32 |     let mut current_note_length_to_beat_with_note_length_to_beat_\n   | \
    \                                                                 ^ help: add\
    \ `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfnb39ku_.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note.push(c);\n            }\n\
    \        } else {\n            if current_note.is_empty() {\n                println!(\"\
    Invalid music string\");\n                return beats;\n            }\n     \
    \       let note = current_note.trim_end().to_string();\n            beats.push(note.parse().unwrap());\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpowbq6lbk.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c == 'o' {\n                if\
    \ current_note.is_empty() {\n                    current_note = String::from(\"\
    o\");\n                    current_octave = 0;\n                } else {\n   \
    \                 current_note = String::from(current_note + \"o\");\n       \
    \         }\n            } else if c == '|' {\n                if current_note.is_empty()\
    \ {\n                    current_note = String::from(\"|\");\n               \
    \     current_octave = 0;\n                } else {\n                    current_note\
    \ = String::from(current_note + \"|\");\n                }\n            } else\
    \ if c == '.' {\n                if current_note.is_empty() {\n              \
    \      current_note = String::from(\".\");\n                    current_octave\
    \ = 0;\n                } else {\n                    current_note = String::from(current_note\
    \ + \".\");\n                }\n            } else {\n                let note\
    \ = c.to_ascii_lowercase();\n                if note == \"o\" {\n            \
    \        current_note = String::from(\"o\");\n                    current_octave\
    \ = 0;\n                } else if note == \"|\" {\n                    current_note\
    \ = String::from(\"|\");\n                    current_octave = 0;\n          \
    \      } else if note == \".\" {\n                    current_note = String::from(\"\
    .\");\n                    current_octave = 0;\n                } else {\n   \
    \                 current_note = String::from(note);\n                }\n    \
    \        }\n        } else {\n            if current_note.is_empty() {\n     \
    \           beats.push(current_beat);\n                current_beat = 0;\n   \
    \         } else {\n                current_beat = current_beat + 1;\n       \
    \     }\n            current_note = String::new();\n            current_octave\
    \ = 0;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj385o6ia.rs:40:28\n   |\n\
    40 |                 if note == \"o\" {\n   |                            ^^^ expected\
    \ `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj385o6ia.rs:43:35\n\
    \   |\n43 |                 } else if note == \"|\" {\n   |                  \
    \                 ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj385o6ia.rs:46:35\n   |\n46 |                 } else if\
    \ note == \".\" {\n   |                                   ^^^ expected `char`,\
    \ found `&str`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_len = 0;\n    for c in music_string\
    \ {\n        if c.is_ascii() {\n            current_note.push_str(&c.to_string());\n\
    \            current_note_len = c.len();\n        } else {\n            if current_note_len\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  return beats;\n            }\n            beats.push(current_beat);\n     \
    \       current_beat = 0;\n            current_note.clear();\n            current_note_len\
    \ = c.len();\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpll2d8w8t.rs:15:14\n\
    \    |\n15  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n    \
    \            beats.push(current_beat);\n                current_beat = 0;\n  \
    \              current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o|' {\n             \
    \   beats.push(current_beat);\n                current_beat = 0;\n           \
    \     current_note = String::new();\n                current_note_length = 1;\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 2;\n            } else {\n            \
    \    current_note.push(c);\n                current_note_length += 1;\n      \
    \      }\n        } else {\n            if current_note.is_empty() {\n       \
    \         println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            let note = current_note.trim_left_matches('o').trim_left_matches('|').trim_left_matches('.');\n\
    \            beats.push(current_beat + note.chars().filter(|c| c.is_ascii()).count()\
    \ as isize);\n            current_beat = 0;\n            current_note = String::new();\n\
    \            current_note_length = 0;\n        }\n    }\n    beats.push(current_beat\
    \ + current_note.chars().filter(|c| c.is_ascii()).count() as isize);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp0zldbnn_.rs:22:52\n\
    \   |\n22 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    for c in music_string.chars() {\n        match c {\n            'o'\
    \ | 'o|' => current_note += 1,\n            '.|' => current_note += 2,\n     \
    \       _ => {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = 0;\n                current_note_length\
    \ = 1;\n            }\n        }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n\
    \    current_beat = 0;\n    current_note = 0;\n    current_note_length = 1;\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpknxyt28x.rs:17:22\n\
    \   |\n17 |             'o' | 'o|' => current_note += 1,\n   |               \
    \       ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c == 'o' {\n            if current_note != String::new() {\n        \
    \        beats.push(current_beat);\n                current_beat = 0;\n      \
    \          current_note = String::new();\n            }\n            current_note_length\
    \ = 0;\n            current_note.push_str(&c.to_string());\n        } else if\
    \ c == '|' {\n            if current_note != String::new() {\n               \
    \ beats.push(current_beat);\n                current_beat = 0;\n             \
    \   current_note = String::new();\n            }\n            current_note_length\
    \ = 1;\n            current_note.push_str(&c.to_string());\n        } else if\
    \ c == '.' {\n            if current_note != String::new() {\n               \
    \ beats.push(current_beat);\n                current_beat = 0;\n             \
    \   current_note = String::new();\n            }\n            current_note_length\
    \ = 2;\n            current_note.push_str(&c.to_string());\n        } else {\n\
    \            current_note.push_str(&c.to_string());\n            current_note_length\
    \ += 1;\n        }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmp41gyeb1p.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_beats_left = 0;\n \
    \   let mut last_note = -1;\n    let mut last_beat = -1;\n    let mut last_beats_left\
    \ = 0;\n    while let Some(note) = notes.next() {\n        if note.1 == last_note\
    \ {\n            last_beats_left += 1;\n        } else {\n            beats.push(current_beats_left);\n\
    \            current_beats_left = 0;\n            current_beat = 0;\n        \
    \    current_note = note.1;\n            last_beat = current_note;\n         \
    \   last_beats_left = 0;\n        }\n        if note.1 == current_note {\n   \
    \         current_beat += 1;\n        } else {\n            current_beats_left\
    \ += 1;\n        }\n        last_note = note.1;\n    }\n    beats.push(current_beats_left);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpadr92tco.rs:20:22\n   |\n\
    20 |         if note.1 == last_note {\n   |                      ^^^^^^^^^ expected\
    \ `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpadr92tco.rs:26:28\n\
    \   |\n26 |             current_note = note.1;\n   |                         \
    \   ^^^^^^ expected integer, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpadr92tco.rs:30:22\n   |\n30 |         if note.1 == current_note\
    \ {\n   |                      ^^^^^^^^^^^^ expected `char`, found integer\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpadr92tco.rs:35:21\n   |\n35 |  \
    \       last_note = note.1;\n   |                     ^^^^^^ expected integer,\
    \ found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_is_last = false;\n\n\
    \    for c in music_string.chars() {\n        match c {\n            'o' => current_note_is_last\
    \ = true,\n            'o|' => current_note_is_last = false,\n            '.|'\
    \ => current_note_is_last = false,\n            'o' => current_note = c.to_string(),\n\
    \            '|' => current_octave += 1,\n            '.' => current_octave -=\
    \ 1,\n            _ => (),\n        }\n\n        if current_note_is_last {\n \
    \           beats.push(current_beat);\n            current_beat = 0;\n       \
    \     current_note_is_last = false;\n        }\n\n        current_beat += 1;\n\
    \    }\n\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpkpbrw9zv.rs:20:16\n\
    \   |\n20 |             'o|' => current_note_is_last = false,\n   |          \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_note_index = 0;\n    let mut current_note_length =\
    \ 0;\n    while current_note_index < notes.len() {\n        let note = notes[current_note_index].to_string();\n\
    \        let note = note.trim_left_matches('o|');\n        let note = note.trim_left_matches('.|');\n\
    \        let note = note.trim_left_matches('o');\n        let note = note.trim_left_matches('.');\n\
    \        let note = note.trim_left_matches('|');\n        let note = note.trim_left_matches('\
    \ ');\n        let note = note.trim_left_matches('o');\n        let note = note.trim_left_matches('|');\n\
    \        let note = note.trim_left_matches(' ');\n        let note = note.trim_left_matches('.');\n\
    \        let note = note.trim_left_matches('|');\n        let note = note.trim_left_matches('\
    \ ');\n        let note = note.trim_left_matches('o');\n        let note = note.trim_left_matches('|');\n\
    \        let note = note.trim_left_matches(' ');\n        let note = note.trim_left_matches('.');\n\
    \        let note = note.trim_left_matches('|');\n        let note = note.trim_left_matches('\
    \ ');\n        let note = note.trim_left_matches('o');\n        let note = note.trim_left_matches('|');\n\
    \        let note = note.trim_left_matches(' ');\n        let note = note.trim_left_matches('.');\n\
    \        let note = note.trim_left_matches('|');\n        let note = note.trim_left_matches('\
    \ ');\n        let note = note.trim_left_matches('o');\n        let note = note.trim_left_matches('|');\n\
    \        let note = note.trim_left_matches(' ');\n        let note = note.trim_left_matches('.');\n\
    \        let note = note.trim_left_matches('|');\n        let note = note.trim_left_matches('\
    \ ');\n        let note = note.trim_left_matches('o');\n        let note = note.trim_left_matches('|');\n\
    \        let note = note.trim_left_matches(' ');\n        let note = note.trim_left_matches('.');\n\
    \        let note = note.trim_left_matches('\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp48zxb0vj.rs:19:46\n\
    \   |\n19 |         let note = note.trim_left_matches('o|');\n   |           \
    \                                   ^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c == 'o' {\n            if current_beat\
    \ == 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n            } else {\n\
    \                current_beat += 1;\n            }\n        } else if c == '|'\
    \ {\n            if current_beat == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_beat += 1;\n            }\n   \
    \     } else if c == '.' {\n            if current_beat == 0 {\n             \
    \   beats.push(current_beat);\n                current_beat = 0;\n           \
    \     current_note = String::new();\n            } else {\n                current_beat\
    \ += 1;\n            }\n        } else {\n            current_note.push(c);\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmp1zn5g87u.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|&(_, c)| c != '|').collect::<Vec<_>>();\n\
    \    let mut last_note = notes.len() - 1;\n    let mut last_beat = 0;\n    let\
    \ mut last_beats = vec![];\n    for note in notes {\n        let beat = note.1.to_digit(10).unwrap();\n\
    \        if note.1 == last_note {\n            last_beats.push(beat);\n      \
    \  } else {\n            beats.push(beat);\n            last_beats.push(beat);\n\
    \        }\n        last_beat = beat;\n        last_note = note.1;\n    }\n  \
    \  last_beats.push(beats.len());\n    last_beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppilvm33d.rs:18:22\n   |\n\
    18 |         if note.1 == last_note {\n   |                      ^^^^^^^^^ expected\
    \ `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppilvm33d.rs:25:21\n\
    \   |\n25 |         last_note = note.1;\n   |                     ^^^^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppilvm33d.rs:27:21\n\
    \   |\n27 |     last_beats.push(beats.len());\n   |                     ^^^^^^^^^^^\
    \ expected `u32`, found `usize`\n   |\nhelp: you can convert a `usize` to a `u32`\
    \ and panic if the converted value doesn't fit\n   |\n27 |     last_beats.push(beats.len().try_into().unwrap());\n\
    \   |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppilvm33d.rs:28:5\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |                                         ----------\
    \ expected `Vec<isize>` because of return type\n...\n28 |     last_beats\n   |\
    \     ^^^^^^^^^^ expected `isize`, found `u32`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<u32>`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749084
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::from(\"\
    \");\n    let mut current_note_length = 0;\n    for c in music_string {\n    \
    \    if c == 'o' {\n            if current_note.len() == 0 {\n               \
    \ println!(\"Invalid music string\");\n                return beats;\n       \
    \     }\n            beats.push(current_beat);\n            current_beat = 0;\n\
    \            current_note = String::from(\"\");\n            current_note_length\
    \ = 0;\n        } else if c == '|' {\n            if current_note.len() == 0 {\n\
    \                println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::from(\"\");\n            current_note_length\
    \ = 0;\n        } else if c == '.' {\n            if current_note.len() == 0 {\n\
    \                println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            current_beat += 1;\n        } else {\n           \
    \ current_note += c;\n            current_note_length += 1;\n        }\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmprabax1sf.rs:15:14\n\
    \    |\n15  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmprabax1sf.rs:16:14\n\
    \   |\n16 |         if c == 'o' {\n   |              ^^ no implementation for\
    \ `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmprabax1sf.rs:25:21\n\
    \   |\n25 |         } else if c == '|' {\n   |                     ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmprabax1sf.rs:34:21\n\
    \   |\n34 |         } else if c == '.' {\n   |                     ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749084
