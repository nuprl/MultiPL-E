language: rs
name: HumanEval_91_is_bored
results:
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkfhc7ejd.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkfhc7ejd.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkfhc7ejd.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence: String = S.to_string();\n\
    \    let mut idx = 0;\n    while idx < sentence.len() {\n        if sentence[idx]\
    \ == '.' || sentence[idx] == '?' || sentence[idx] == '!' {\n            boredoms\
    \ += 1;\n        }\n        idx += 1;\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp74_9xuol.rs:14:12\n\
    \   |\n14 |         if sentence[idx] == '.' || sentence[idx] == '?' || sentence[idx]\
    \ == '!' {\n   |            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp74_9xuol.rs:14:36\n   |\n14 |         if sentence[idx] == '.' ||\
    \ sentence[idx] == '?' || sentence[idx] == '!' {\n   |                       \
    \             ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp74_9xuol.rs:14:60\n\
    \   |\n14 |         if sentence[idx] == '.' || sentence[idx] == '?' || sentence[idx]\
    \ == '!' {\n   |                                                            ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeI"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n            boredom_count += 1;\n  \
    \      }\n    }\n    boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1udsw6wx.rs:18:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n18 |     boredom_count\n   |     ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     boredom_count.try_into().unwrap()\n\
    \   |                  ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for s in S.chars() {\n        if s.is_ascii()\
    \ {\n            if s.as_bytes()[0] == b'I' {\n                boredoms += 1;\n\
    \            }\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp1sa6pf5k.rs:13:18\n   |\n13 |             if s.as_bytes()[0]\
    \ == b'I' {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5gz06yys.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp5gz06yys.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn5axg6lv.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn5axg6lv.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn5axg6lv.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp9cfc0qtm.rs:10:28\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |                            ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9cfc0qtm.rs:10:47\n\
    \    |\n10  |     S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n\
    \    |                                               ^^^^^ ------------ supplied\
    \ 1 argument\n    |                                               |\n    |   \
    \                                            expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9cfc0qtm.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I').try_into().unwrap()\n   |         \
    \                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S;\n    while let\
    \ Some(word) = sentence.split_first_word() {\n        if word == \"I\" {\n   \
    \         boredoms += 1;\n        }\n        sentence = sentence.split_last_word();\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_first_word` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmptws9vpyl.rs:12:37\n   |\n12 |     while\
    \ let Some(word) = sentence.split_first_word() {\n   |                       \
    \              ^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split_at`\n\nerror[E0599]: no method named `split_last_word` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmptws9vpyl.rs:16:29\n   |\n\
    16 |         sentence = sentence.split_last_word();\n   |                    \
    \         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split_at`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_61kf8m.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    for s in S.split_whitespace() {\n\
    \        if s.starts_with(\"I\") {\n            boredoms.push(s);\n        }\n\
    \    }\n    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1wr8umze.rs:16:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n16 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmph8jz_mp_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.iter().filter(|&b| b == 'I').count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu_k5u86g.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu_k5u86g.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu_k5u86g.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> =\
    \ vec![];\n    let mut sentence: Vec<&str> = vec![];\n    let mut sentence_words:\
    \ Vec<&str> = vec![];\n    let mut sentence_length: usize = 0;\n    let mut sentence_length2:\
    \ usize = 0;\n    let mut sentence_length3: usize = 0;\n    let mut sentence_length4:\
    \ usize = 0;\n    let mut sentence_length5: usize = 0;\n    let mut sentence_length6:\
    \ usize = 0;\n    let mut sentence_length7: usize = 0;\n    let mut sentence_length8:\
    \ usize = 0;\n    let mut sentence_length9: usize = 0;\n    let mut sentence_length10:\
    \ usize = 0;\n    let mut sentence_length11: usize = 0;\n    let mut sentence_length12:\
    \ usize = 0;\n    let mut sentence_length13: usize = 0;\n    let mut sentence_length14:\
    \ usize = 0;\n    let mut sentence_length15: usize = 0;\n    let mut sentence_length16:\
    \ usize = 0;\n    let mut sentence_length17: usize = 0;\n    let mut sentence_length18:\
    \ usize = 0;\n    let mut sentence_length19: usize = 0;\n    let mut sentence_length20:\
    \ usize = 0;\n    let mut sentence_length21: usize = 0;\n    let mut sentence_length22:\
    \ usize = 0;\n    let mut sentence_length23: usize = 0;\n    let mut sentence_length24:\
    \ usize = 0;\n    let mut sentence_length25: usize = 0;\n    let mut sentence_length26:\
    \ usize = 0;\n    let mut sentence_length27: usize = 0;\n    let mut sentence_length28:\
    \ usize = 0;\n    let mut sentence_length29: usize = 0;\n    let mut sentence_length30:\
    \ usize = 0;\n    let mut sentence_length31: usize = 0;\n    let mut sentence_length32:\
    \ usize = 0;\n    let mut sentence_length33: usize = 0;\n    let mut sentence_length34:\
    \ usize = 0;\n    let mut sentence_length35: usize = 0;\n    let mut sentence_length36:\
    \ usize = 0;\n    let mut sentence_length37: usize = 0;\n    let mut sentence_length38:\
    \ usize = 0;\n    let mut sentence_length39: usize = 0;\n    let mut sentence_length40:\
    \ usize = 0;\n    let mut sentence_length41: usize = 0;\n    let mut sentence_length42\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk12bwd2s.rs:55:30\n   |\n\
    55 |     let mut sentence_length42\n   |                              ^ help:\
    \ add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpk12bwd2s.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize {\n \
    \ |    --------               ^^^^^ expected `isize`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.starts_with(\"I\") {\n        boredoms += 1;\n        s = s.trim_start_matches(\"\
    I\");\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprqjy9zhs.rs:14:13\n   |\n\
    11 |     let mut s = S.to_string();\n   |                 ------------- expected\
    \ due to this value\n...\n14 |         s = s.trim_start_matches(\"I\");\n   |\
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |             |\n   |             expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<String>\
    \ = vec![];\n    let mut boredom_sentence: Vec<String> = vec![];\n    let mut\
    \ boredom_sentence_index: usize = 0;\n    let mut boredom_word_index: usize =\
    \ 0;\n    let mut boredom_word_length: usize = 0;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_word_found2 = false;\n    let mut boredom_word_found3\
    \ = false;\n    let mut boredom_word_found4 = false;\n    let mut boredom_word_found5\
    \ = false;\n    let mut boredom_word_found6 = false;\n    let mut boredom_word_found7\
    \ = false;\n    let mut boredom_word_found8 = false;\n    let mut boredom_word_found9\
    \ = false;\n    let mut boredom_word_found10 = false;\n    let mut boredom_word_found11\
    \ = false;\n    let mut boredom_word_found12 = false;\n    let mut boredom_word_found13\
    \ = false;\n    let mut boredom_word_found14 = false;\n    let mut boredom_word_found15\
    \ = false;\n    let mut boredom_word_found16 = false;\n    let mut boredom_word_found17\
    \ = false;\n    let mut boredom_word_found18 = false;\n    let mut boredom_word_found19\
    \ = false;\n    let mut boredom_word_found20 = false;\n    let mut boredom_word_found21\
    \ = false;\n    let mut boredom_word_found22 = false;\n    let mut boredom_word_found23\
    \ = false;\n    let mut boredom_word_found24 = false;\n    let mut boredom_word_found25\
    \ = false;\n    let mut boredom_word_found26 = false;\n    let mut boredom_word_found27\
    \ = false;\n    let mut boredom_word_found28 = false;\n    let mut boredom_word_found29\
    \ = false;\n    let mut boredom_word_found30 = false;\n    let mut boredom_word_found31\
    \ = false;\n    let mut boredom_word_found32 = false;\n    let mut boredom_word_found33\
    \ = false;\n    let mut boredom_word_found34 = false;\n    let mut boredom_word_found35\
    \ = false;\n    let mut boredom_word_found36 = false;\n    let mut boredom_word_found37\
    \ = false;\n    let mut boredom_word_found38 = false;\n    let mut boredom_word_found39\
    \ = false;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphcekoqhu.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i + 1]);\n            i += 2;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp4kzw0s90.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp4kzw0s90.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp4kzw0s90.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4kzw0s90.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.iter().filter(|&x| x == 'I').count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7411yfki.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7411yfki.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7411yfki.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i: usize = 0;\n    while i < sentence.len() {\n        if sentence[i]\
    \ == \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc5pxp5z6.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmph8jz_mp_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        let mut j = i;\n        while j < S.len() {\n            if S[j]\
    \ == ' ' || S[j] == '.' || S[j] == '?' || S[j] == '!' {\n                break;\n\
    \            }\n            j += 1\n        }\n        boredoms.push(S.split_whitespace()[i]);\n\
    \        i = j;\n    }\n    boredoms.iter().filter(|&x| x.starts_with(\"I\")).count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpapzutl_6.rs:15:16\n\
    \   |\n15 |             if S[j] == ' ' || S[j] == '.' || S[j] == '?' || S[j] ==\
    \ '!' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpapzutl_6.rs:15:31\n\
    \   |\n15 |             if S[j] == ' ' || S[j] == '.' || S[j] == '?' || S[j] ==\
    \ '!' {\n   |                               ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpapzutl_6.rs:15:46\n\
    \   |\n15 |             if S[j] == ' ' || S[j] == '.' || S[j] == '?' || S[j] ==\
    \ '!' {\n   |                                              ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpapzutl_6.rs:15:61\n   |\n15 |             if S[j] == ' ' || S[j]\
    \ == '.' || S[j] == '?' || S[j] == '!' {\n   |                               \
    \                              ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpapzutl_6.rs:20:23\n\
    \   |\n20 |         boredoms.push(S.split_whitespace()[i]);\n   |            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            boredoms.push(S[i]);\n        }\n \
    \       i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl9jes5or.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpl9jes5or.rs:14:27\n   |\n14 |             boredoms.push(S[i]);\n\
    \   |                           ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpl9jes5or.rs:18:5\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n18 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     boredoms.len().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp9cfc0qtm.rs:10:28\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |                            ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9cfc0qtm.rs:10:47\n\
    \    |\n10  |     S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n\
    \    |                                               ^^^^^ ------------ supplied\
    \ 1 argument\n    |                                               |\n    |   \
    \                                            expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9cfc0qtm.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I').try_into().unwrap()\n   |         \
    \                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            if sentence[i] == \"i\" {\n                boredoms += 1;\n \
    \           }\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp0s0p5c7u.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp0s0p5c7u.rs:14:12\n   |\n14 |         if sentence[i].is_ascii_lowercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmp0s0p5c7u.rs:15:16\n   |\n15 |    \
    \         if sentence[i] == \"i\" {\n   |                ^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms.push(1);\n       \
    \ } else {\n            boredoms.push(0);\n        }\n    }\n    boredoms.iter().sum()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpo7e8dxvv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_61kf8m.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        let c = S[i];\n        if c == '.' || c == '?' || c == '!' {\n  \
    \          boredoms.push(S[i]);\n        }\n        i += 1;\n    }\n    boredoms.iter().filter(|&b|\
    \ b == 'I').count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe1a6mtbh.rs:13:17\n\
    \   |\n13 |         let c = S[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpe1a6mtbh.rs:15:27\n   |\n15 |             boredoms.push(S[i]);\n\
    \   |                           ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpe1a6mtbh.rs:19:35\n\
    \   |\n19 |     boredoms.iter().filter(|&b| b == 'I').count()\n   |          \
    \                         ^^ no implementation for `&_ == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe1a6mtbh.rs:19:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n19 |     boredoms.iter().filter(|&b| b == 'I').count()\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     boredoms.iter().filter(|&b| b == 'I').count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i..i + 1]);\n            i += 1;\n      \
    \  }\n        i += 1;\n    }\n    boredoms.iter().filter(|&b| b.starts_with(\"\
    I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpdpt4n5tc.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpdpt4n5tc.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpdpt4n5tc.rs:15:27\n   |\n15 |             boredoms.push(words[i..i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for s in S.chars() {\n        if s.is_ascii_lowercase()\
    \ {\n            if s.starts_with(\"i\") {\n                boredoms += 1;\n \
    \           }\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpz317mla_.rs:13:18\n   |\n13 |             if s.starts_with(\"\
    i\") {\n   |                  ^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_counter =\
    \ 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"I\"\
    ) {\n            boredoms.push(word);\n        }\n    }\n    for boredom in boredoms\
    \ {\n        if boredom.ends_with(\".\") || boredom.ends_with(\"?\") || boredom.ends_with(\"\
    !\") {\n            boredom_counter = boredom_counter + 1;\n        }\n    }\n\
    \    boredom_counter\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpmljr9sh2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> =\
    \ vec![];\n    let mut boredom_sentence: Vec<&str> = vec![];\n    let mut boredom_sentence_index:\
    \ usize = 0;\n    let mut boredom_sentence_length: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_length: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd2_yk7cw.rs:48:42\n   |\n\
    48 |     let mut boredom_word_end_index: usize\n   |                         \
    \                 ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpd2_yk7cw.rs:9:27\n  |\n9 | fn is_bored(S: String)\
    \ -> isize {\n  |    --------               ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747036
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> =\
    \ vec![];\n    let mut sentence: Vec<&str> = vec![];\n    let mut sentence_words:\
    \ Vec<&str> = vec![];\n\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n            boredom_words.push(word);\n  \
    \      } else {\n            sentence.push(word);\n            sentence_words.push(word);\n\
    \        }\n    }\n\n    for sentence in sentence.iter() {\n        for word in\
    \ sentence.split_whitespace() {\n            if word.starts_with(\"I\") {\n  \
    \              boredoms += 1;\n                boredom_words.push(word);\n   \
    \         }\n        }\n    }\n\n    for boredom_word in boredom_words.iter()\
    \ {\n        for sentence_word in sentence_words.iter() {\n            if boredom_word\
    \ == sentence_word {\n                boredoms += 1;\n            }\n        }\n\
    \    }\n\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp4q9y5hst.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_61kf8m.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_61kf8m.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:14:27\n\
    \   |\n14 |             boredoms.push(S[i]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41ikz7oc.rs:18:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n18 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n18 |     boredoms.len().try_into().unwrap()\n   |\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            i += 1;\n        } else {\n            boredoms += 1;\n  \
    \      }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpch87ysgu.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpch87ysgu.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.iter().filter(|&b| b == 'I').count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu_k5u86g.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu_k5u86g.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu_k5u86g.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        if s.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n \
    \   let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpv6kxz0pb.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.starts_with(\"I\") {\n        boredoms += 1;\n        s = &s[1..];\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6vt9elqc.rs:14:13\n   |\n\
    14 |         s = &s[1..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n14 |        \
    \ s = (&s[1..]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms.push(1);\n       \
    \ } else {\n            boredoms.push(0);\n        }\n    }\n    boredoms.iter().sum()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpo7e8dxvv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    loop {\n        if let Some(word) = words.next() {\n            if word ==\
    \ \"I\" {\n                boredoms += 1;\n            }\n        }\n        if\
    \ !words.next().is_some() {\n            break;\n        }\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmplqd1uizj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredoms_counter = 0;\n \
    \   let mut boredom_counter = 0;\n    let mut boredom_counter2 = 0;\n    let mut\
    \ boredom_counter3 = 0;\n    let mut boredom_counter4 = 0;\n    let mut boredom_counter5\
    \ = 0;\n    let mut boredom_counter6 = 0;\n    let mut boredom_counter7 = 0;\n\
    \    let mut boredom_counter8 = 0;\n    let mut boredom_counter9 = 0;\n    let\
    \ mut boredom_counter10 = 0;\n    let mut boredom_counter11 = 0;\n    let mut\
    \ boredom_counter12 = 0;\n    let mut boredom_counter13 = 0;\n    let mut boredom_counter14\
    \ = 0;\n    let mut boredom_counter15 = 0;\n    let mut boredom_counter16 = 0;\n\
    \    let mut boredom_counter17 = 0;\n    let mut boredom_counter18 = 0;\n    let\
    \ mut boredom_counter19 = 0;\n    let mut boredom_counter20 = 0;\n    let mut\
    \ boredom_counter21 = 0;\n    let mut boredom_counter22 = 0;\n    let mut boredom_counter23\
    \ = 0;\n    let mut boredom_counter24 = 0;\n    let mut boredom_counter25 = 0;\n\
    \    let mut boredom_counter26 = 0;\n    let mut boredom_counter27 = 0;\n    let\
    \ mut boredom_counter28 = 0;\n    let mut boredom_counter29 = 0;\n    let mut\
    \ boredom_counter30 = 0;\n    let mut boredom_counter31 = 0;\n    let mut boredom_counter32\
    \ = 0;\n    let mut boredom_counter33 = 0;\n    let mut boredom_counter34 = 0;\n\
    \    let mut boredom_counter35 = 0;\n    let mut boredom_counter36 = 0;\n    let\
    \ mut boredom_counter37 = 0;\n    let mut boredom_counter38 = 0;\n    let mut\
    \ boredom_counter39 = 0;\n    let mut boredom_counter40 = 0;\n    let mut boredom_counter41\
    \ = 0;\n    let mut boredom_counter42 = 0;\n    let mut boredom_counter43 = 0;\n\
    \    let mut boredom_counter44 = 0;\n    let mut boredom_counter45 = 0;\n    let\
    \ mut boredom_counter46 = 0;\n    let mut boredom_counter47 = 0;\n    let mut\
    \ boredom_counter48 = 0;\n    let mut boredom_counter49 = 0;\n    let mut bore\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpch_11849.rs:61:17\n   |\n\
    61 |     let mut bore\n   |                 ^ help: add `;` here\n62 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpch_11849.rs:9:27\n\
    \  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747036
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.to_string();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n            i += 1;\n   \
    \     } else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdr35dlbr.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdr35dlbr.rs:14:34\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |                                  ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdr35dlbr.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n        } else if sentence[i].is_ascii_uppercase() {\n\
    \            i += 1;\n        } else if sentence[i].is_ascii_punctuation() {\n\
    \            i += 1;\n        } else if sentence[i].is_ascii_digit() {\n     \
    \       i += 1;\n        } else if sentence[i].is_ascii_symbol() {\n         \
    \   i += 1;\n        } else {\n            boredoms += 1;\n            i += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpher1ljur.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpher1ljur.rs:14:12\n   |\n14 |         if sentence[i].is_ascii_lowercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpher1ljur.rs:16:19\n   |\n16 |    \
    \     } else if sentence[i].is_ascii_uppercase() {\n   |                   ^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpher1ljur.rs:18:19\n   |\n18 |         } else if sentence[i].is_ascii_punctuation()\
    \ {\n   |                   ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmpher1ljur.rs:20:19\n   |\n20 | \
    \        } else if sentence[i].is_ascii_digit() {\n   |                   ^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpher1ljur.rs:22:19\n   |\n22 |         } else if sentence[i].is_ascii_symbol()\
    \ {\n   |                   ^^^^^^^^^^^\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        let mut i = s.find('i');\n        if i == s.len() {\n\
    \            break;\n        }\n        if s.starts_with(\"i\") {\n          \
    \  boredoms += 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg6ochssl.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^\n   |           \
    \      |\n   |                 expected enum `Option`, found `usize`\n   |   \
    \              help: try using a variant of the expected enum: `Some(s.len())`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmpg6ochssl.rs:20:14\n   |\n20 |         s = &s[i..];\n   |      \
    \        ^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n   |\n\
    \   = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented for\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg6ochssl.rs:20:13\n\
    \   |\n20 |         s = &s[i..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found reference\n   |\n   = note: expected struct `String`\n           found\
    \ reference `&_`\nhelp: consider removing the borrow\n   |\n20 -         s = &s[i..];\n\
    20 +         s = s[i..];\n   | \n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_counter: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n        } else {\n            boredom_counter\
    \ += 1;\n        }\n    }\n    boredom_counter\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu_4a3z3k.rs:19:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n19 |     boredom_counter\n   |     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |     boredom_counter.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747036
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_count = 0;\n    let\
    \ mut words = S.split_whitespace();\n    let mut i = 0;\n    while i < words.len()\
    \ {\n        if words[i] == \"I\" {\n            boredoms.push(words[i..i + 1]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for boredom in boredoms {\n        if boredom.starts_with(\"I\") {\n    \
    \        boredom_count += 1;\n        }\n    }\n    boredom_count\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpf92evuz8.rs:14:21\n   |\n14 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpf92evuz8.rs:15:12\n   |\n15 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpf92evuz8.rs:16:27\n   |\n16 |             boredoms.push(words[i..i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5gz06yys.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp5gz06yys.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_counter = 0;\n  \
    \  let mut boredom_counter2 = 0;\n    let mut boredom_counter3 = 0;\n    let mut\
    \ boredom_counter4 = 0;\n    let mut boredom_counter5 = 0;\n    let mut boredom_counter6\
    \ = 0;\n    let mut boredom_counter7 = 0;\n    let mut boredom_counter8 = 0;\n\
    \    let mut boredom_counter9 = 0;\n    let mut boredom_counter10 = 0;\n    let\
    \ mut boredom_counter11 = 0;\n    let mut boredom_counter12 = 0;\n    let mut\
    \ boredom_counter13 = 0;\n    let mut boredom_counter14 = 0;\n    let mut boredom_counter15\
    \ = 0;\n    let mut boredom_counter16 = 0;\n    let mut boredom_counter17 = 0;\n\
    \    let mut boredom_counter18 = 0;\n    let mut boredom_counter19 = 0;\n    let\
    \ mut boredom_counter20 = 0;\n    let mut boredom_counter21 = 0;\n    let mut\
    \ boredom_counter22 = 0;\n    let mut boredom_counter23 = 0;\n    let mut boredom_counter24\
    \ = 0;\n    let mut boredom_counter25 = 0;\n    let mut boredom_counter26 = 0;\n\
    \    let mut boredom_counter27 = 0;\n    let mut boredom_counter28 = 0;\n    let\
    \ mut boredom_counter29 = 0;\n    let mut boredom_counter30 = 0;\n    let mut\
    \ boredom_counter31 = 0;\n    let mut boredom_counter32 = 0;\n    let mut boredom_counter33\
    \ = 0;\n    let mut boredom_counter34 = 0;\n    let mut boredom_counter35 = 0;\n\
    \    let mut boredom_counter36 = 0;\n    let mut boredom_counter37 = 0;\n    let\
    \ mut boredom_counter38 = 0;\n    let mut boredom_counter39 = 0;\n    let mut\
    \ boredom_counter40 = 0;\n    let mut boredom_counter41 = 0;\n    let mut boredom_counter42\
    \ = 0;\n    let mut boredom_counter43 = 0;\n    let mut boredom_counter44 = 0;\n\
    \    let mut boredom_counter45 = 0;\n    let mut boredom_counter46 = 0;\n    let\
    \ mut boredom_counter47 = 0;\n    let mut boredom_counter48 = 0;\n    let mut\
    \ boredom_counter49 = 0;\n    let mut boredom_counter50 = 0;\n    let mut bore\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7tbzf58x.rs:61:17\n   |\n\
    61 |     let mut bore\n   |                 ^ help: add `;` here\n62 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7tbzf58x.rs:9:27\n\
    \  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredoms_idx = 0;\n    let\
    \ mut boredom_idx = 0;\n    let mut boredom_idx2 = 0;\n    let mut boredom_idx3\
    \ = 0;\n    let mut boredom_idx4 = 0;\n    let mut boredom_idx5 = 0;\n    let\
    \ mut boredom_idx6 = 0;\n    let mut boredom_idx7 = 0;\n    let mut boredom_idx8\
    \ = 0;\n    let mut boredom_idx9 = 0;\n    let mut boredom_idx10 = 0;\n    let\
    \ mut boredom_idx11 = 0;\n    let mut boredom_idx12 = 0;\n    let mut boredom_idx13\
    \ = 0;\n    let mut boredom_idx14 = 0;\n    let mut boredom_idx15 = 0;\n    let\
    \ mut boredom_idx16 = 0;\n    let mut boredom_idx17 = 0;\n    let mut boredom_idx18\
    \ = 0;\n    let mut boredom_idx19 = 0;\n    let mut boredom_idx20 = 0;\n    let\
    \ mut boredom_idx21 = 0;\n    let mut boredom_idx22 = 0;\n    let mut boredom_idx23\
    \ = 0;\n    let mut boredom_idx24 = 0;\n    let mut boredom_idx25 = 0;\n    let\
    \ mut boredom_idx26 = 0;\n    let mut boredom_idx27 = 0;\n    let mut boredom_idx28\
    \ = 0;\n    let mut boredom_idx29 = 0;\n    let mut boredom_idx30 = 0;\n    let\
    \ mut boredom_idx31 = 0;\n    let mut boredom_idx32 = 0;\n    let mut boredom_idx33\
    \ = 0;\n    let mut boredom_idx34 = 0;\n    let mut boredom_idx35 = 0;\n    let\
    \ mut boredom_idx36 = 0;\n    let mut boredom_idx37 = 0;\n    let mut boredom_idx38\
    \ = 0;\n    let mut boredom_idx39 = 0;\n    let mut boredom_idx40 = 0;\n    let\
    \ mut boredom_idx41 = 0;\n    let mut boredom_idx42 = 0;\n    let mut boredom_idx43\
    \ = 0;\n    let mut boredom_idx44 = 0;\n    let mut boredom_idx45 = 0;\n    let\
    \ mut boredom_idx46 = 0;\n    let mut boredom_idx47 = 0;\n    let mut boredom_idx48\
    \ = 0;\n    let mut boredom_idx49 = 0;\n    let mut boredom_\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmgcg8esv.rs:61:21\n   |\n\
    61 |     let mut boredom_\n   |                     ^ help: add `;` here\n62 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpmgcg8esv.rs:9:27\n\
    \  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_count = 0;\n    let mut\
    \ boredom_word: String;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredom_word = word;\n            boredom_count += 1;\n  \
    \      } else {\n            boredoms.push(boredom_word);\n            boredom_count\
    \ = 0;\n            boredom_word = word;\n        }\n    }\n    boredoms.push(boredom_word);\n\
    \    boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnmgh8l_9.rs:15:28\n   |\n\
    15 |             boredom_word = word;\n   |                            ^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \    |\n   |                            expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnmgh8l_9.rs:20:28\n   |\n20 |\
    \             boredom_word = word;\n   |                            ^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \    |\n   |                            expected struct `String`, found `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.starts_with(\"I\") {\n        s = &s[1..];\n        boredoms += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe1xwlpnx.rs:13:13\n   |\n\
    13 |         s = &s[1..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n13 |        \
    \ s = (&s[1..]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpenafur9p.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_count = 0;\n    for word\
    \ in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n          \
    \  boredoms.push(word);\n            boredom_count += 1;\n        }\n    }\n \
    \   boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp0dzjiew4.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_61kf8m.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i + 1]);\n            i += 2;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpkovgtijj.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpkovgtijj.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpkovgtijj.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkovgtijj.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599, E0608.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        let mut i = 0;\n        while i < s.len() && s[i] ==\
    \ '.' || s[i] == '?' || s[i] == '!' {\n            i += 1;\n        }\n      \
    \  if i == s.len() {\n            break;\n        }\n        if s[i] == 'I' {\n\
    \            boredoms += 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpj06alfgz.rs:14:30\n\
    \   |\n14 |         while i < s.len() && s[i] == '.' || s[i] == '?' || s[i] ==\
    \ '!' {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpj06alfgz.rs:14:45\n\
    \   |\n14 |         while i < s.len() && s[i] == '.' || s[i] == '?' || s[i] ==\
    \ '!' {\n   |                                             ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpj06alfgz.rs:14:60\n   |\n14 |         while i < s.len() && s[i]\
    \ == '.' || s[i] == '?' || s[i] == '!' {\n   |                               \
    \                             ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpj06alfgz.rs:20:12\n\
    \   |\n20 |         if s[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj06alfgz.rs:23:13\n\
    \   |\n23 |         s = &s[i..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n23 |        \
    \ s = (&s[i..]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n        }\n    }\n    for boredom in\
    \ boredoms {\n        if boredom.ends_with(\".\") || boredom.ends_with(\"?\")\
    \ || boredom.ends_with(\"!\") {\n            boredom_count += 1;\n        }\n\
    \    }\n    boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf9xl75yt.rs:22:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n22 |     boredom_count\n   |     ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |     boredom_count.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        let mut i = 0;\n        while i < s.len() {\n       \
    \     if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n                break;\n\
    \            }\n            i += 1;\n        }\n        if i == s.len() {\n  \
    \          break;\n        }\n        boredoms += 1;\n        s = &s[..i];\n \
    \   }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbwxolaj2.rs:15:16\n\
    \   |\n15 |             if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   | \
    \               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpbwxolaj2.rs:15:31\n   |\n\
    15 |             if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |        \
    \                       ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbwxolaj2.rs:15:46\n\
    \   |\n15 |             if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   | \
    \                                             ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbwxolaj2.rs:24:13\n\
    \   |\n24 |         s = &s[..i];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n24 |        \
    \ s = (&s[..i]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_counter: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n        } else {\n            boredom_counter\
    \ += 1;\n        }\n    }\n    boredom_counter\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu_4a3z3k.rs:19:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n19 |     boredom_counter\n   |     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |     boredom_counter.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747036
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpenafur9p.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let mut boredom_word_count:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpib0fe1_8.rs:51:38\n   |\n\
    51 |     let mut boredom_word_index: usize\n   |                             \
    \         ^ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpib0fe1_8.rs:9:27\n  |\n9 | fn is_bored(S: String)\
    \ -> isize {\n  |    --------               ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.iter().filter(|&b| b == 'I').count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3g8oyiug.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp3g8oyiug.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp3g8oyiug.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3g8oyiug.rs:14:27\n\
    \   |\n14 |             boredoms.push(S[i]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: can't compare `&_` with `char`\n\
    \  --> /tmp/tmp3g8oyiug.rs:18:35\n   |\n18 |     boredoms.iter().filter(|&b| b\
    \ == 'I').count()\n   |                                   ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3g8oyiug.rs:18:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n18 |     boredoms.iter().filter(|&b|\
    \ b == 'I').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     boredoms.iter().filter(|&b|\
    \ b == 'I').count().try_into().unwrap()\n   |\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome e"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpenafur9p.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i + 1]);\n            i += 2;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&b|\
    \ b == \"I\").count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpvkdf3ale.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpvkdf3ale.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpvkdf3ale.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvkdf3ale.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.iter().filter(|&b| b == \"I\").count()\n   |  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     boredoms.iter().filter(|&b| b == \"I\").count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599, E0608.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            if sentence[i] == \"i\" {\n                boredoms += 1;\n \
    \           }\n            i += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmphh_gymat.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmphh_gymat.rs:14:12\n   |\n14 |         if sentence[i].is_ascii_lowercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmphh_gymat.rs:15:16\n   |\n15 |    \
    \         if sentence[i] == \"i\" {\n   |                ^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5gz06yys.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp5gz06yys.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_count = 0;\n    for word\
    \ in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n          \
    \  boredoms.push(word);\n            boredom_count += 1;\n        }\n    }\n \
    \   boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp0dzjiew4.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:14:27\n\
    \   |\n14 |             boredoms.push(S[i]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41ikz7oc.rs:18:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n18 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n18 |     boredoms.len().try_into().unwrap()\n   |\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpc27g3igv.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpc27g3igv.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        let mut i = s.find('I');\n        if i == s.len() {\n\
    \            break;\n        }\n        if s.starts_with(\"I\") {\n          \
    \  boredoms += 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzvwr2w3s.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^\n   |           \
    \      |\n   |                 expected enum `Option`, found `usize`\n   |   \
    \              help: try using a variant of the expected enum: `Some(s.len())`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmpzvwr2w3s.rs:20:14\n   |\n20 |         s = &s[i..];\n   |      \
    \        ^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n   |\n\
    \   = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented for\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvwr2w3s.rs:20:13\n\
    \   |\n20 |         s = &s[i..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found reference\n   |\n   = note: expected struct `String`\n           found\
    \ reference `&_`\nhelp: consider removing the borrow\n   |\n20 -         s = &s[i..];\n\
    20 +         s = s[i..];\n   | \n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.iter().filter(|&b| b == 'I').count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:14:27\n\
    \   |\n14 |             boredoms.push(S[i]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: can't compare `&_` with `char`\n\
    \  --> /tmp/tmpbwjqkktt.rs:18:35\n   |\n18 |     boredoms.iter().filter(|&b| b\
    \ == 'I').count()\n   |                                   ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbwjqkktt.rs:18:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n18 |     boredoms.iter().filter(|&b|\
    \ b == 'I').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     boredoms.iter().filter(|&b|\
    \ b == 'I').count().try_into().unwrap()\n   |\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome e"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> =\
    \ vec![];\n    let mut boredom_word_len: usize = 0;\n    let mut boredom_word_start:\
    \ usize = 0;\n    let mut boredom_word_end: usize = 0;\n    let mut boredom_word_found\
    \ = false;\n\n    for c in S.chars() {\n        if c == ' ' {\n            boredom_word_found\
    \ = false;\n            boredom_word_len = 0;\n            boredom_word_start\
    \ = 0;\n            boredom_word_end = 0;\n            boredom_words.push(&\"\"\
    );\n        }\n        if c == '.' || c == '?' || c == '!' {\n            boredom_word_found\
    \ = true;\n            boredom_word_len += 1;\n            boredom_word_start\
    \ = boredom_word_len;\n            boredom_word_end = boredom_word_len;\n    \
    \        boredom_words.push(&\"\");\n        }\n        if boredom_word_found\
    \ {\n            if c == '.' {\n                boredom_word_end += 1;\n     \
    \       }\n            if c == '?' {\n                boredom_word_end += 1;\n\
    \            }\n            if c == '!' {\n                boredom_word_end +=\
    \ 1;\n            }\n        }\n    }\n\n    for boredom_word in &boredom_words\
    \ {\n        if boredom_word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpgpw0k2qk.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        let mut i = s.find('i');\n        if i == s.len() {\n\
    \            break;\n        }\n        if s.starts_with(\"I\") {\n          \
    \  boredoms += 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvtwbvqc2.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^\n   |           \
    \      |\n   |                 expected enum `Option`, found `usize`\n   |   \
    \              help: try using a variant of the expected enum: `Some(s.len())`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmpvtwbvqc2.rs:20:14\n   |\n20 |         s = &s[i..];\n   |      \
    \        ^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n   |\n\
    \   = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented for\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtwbvqc2.rs:20:13\n\
    \   |\n20 |         s = &s[i..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found reference\n   |\n   = note: expected struct `String`\n           found\
    \ reference `&_`\nhelp: consider removing the borrow\n   |\n20 -         s = &s[i..];\n\
    20 +         s = s[i..];\n   | \n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1j2a35s2.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.to_string();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n            i += 1;\n   \
    \     } else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdr35dlbr.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdr35dlbr.rs:14:34\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |                                  ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdr35dlbr.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n        } else {\n            boredom_count\
    \ += 1;\n        }\n    }\n    boredom_count\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7r8b2caf.rs:19:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n19 |     boredom_count\n   |     ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |     boredom_count.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_counter = 0;\n  \
    \  for s in S.chars() {\n        if s.is_ascii() {\n            if s.to_ascii_lowercase()\
    \ == \"i\" {\n                boredom_counter = boredom_counter + 1;\n       \
    \     }\n        }\n    }\n    boredoms.push(boredom_counter);\n    boredoms.iter().sum()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ofb61mk.rs:14:42\n   |\n\
    14 |             if s.to_ascii_lowercase() == \"i\" {\n   |                  \
    \                        ^^^ expected `char`, found `&str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_words: Vec<&str>\
    \ = vec![];\n    let mut boredom_word_count: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_length: usize = 0;\n    let mut boredom_word_start\
    \ = false;\n    let mut boredom_word_end = false;\n    let mut boredom_word_word_start\
    \ = false;\n    let mut boredom_word_word_end = false;\n    let mut boredom_word_word_word_start\
    \ = false;\n    let mut boredom_word_word_word_end = false;\n    let mut boredom_word_word_word_word_start\
    \ = false;\n    let mut boredom_word_word_word_word_end = false;\n    let mut\
    \ boredom_word_word_word_word_word_start = false;\n    let mut boredom_word_word_word_word_word_end\
    \ = false;\n    let mut boredom_word_word_word_word_word_word_start = false;\n\
    \    let mut boredom_word_word_word_word_word_word_end = false;\n    let mut boredom_word_word_word_word_word_word_word_start\
    \ = false;\n    let mut boredom_word_word_word_word_word_word_word_end = false;\n\
    \    let mut boredom_word_word_word_word_word_word_word_word_start = false;\n\
    \    let mut boredom_word_word_word_word_word_word_word_word_end = false;\n  \
    \  let mut boredom_word_word_word_word_word_word_word_word_word_start = false;\n\
    \    let mut boredom_word_word_word_word_word_word_word_word_word_end = false;\n\
    \    let mut boredom_word_word_word_word_word_word_word_word_word_word_start =\
    \ false;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_end\
    \ = false;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_word_start\
    \ = false;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_word_word_end\
    \ = false;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_word_word_word_start\
    \ = false;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_word_word_word_word_end\
    \ = false;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_word_word_word_word_word_start\
    \ = false;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_word_word_word_word_word_end\
    \ = false;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_csmnius.rs:41:71\n   |\n\
    41 |     let mut boredom_word_word_word_word_word_word_word_word_word_word_\n\
    \   |                                                                       ^\
    \ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp_csmnius.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize\
    \ {\n  |    --------               ^^^^^ expected `isize`, found `()`\n  |   \
    \ |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace().collect();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmppbbkbleb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5gz06yys.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp5gz06yys.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmph8jz_mp_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n            i += 1;\n    \
    \    }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfb80wlo1.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpfb80wlo1.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpfb80wlo1.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredoms_cnt: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n            boredoms_cnt += 1;\n   \
    \     }\n    }\n    boredoms_cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdiqvdcxp.rs:18:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n18 |     boredoms_cnt\n   |     ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     boredoms_cnt.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        let c = S[i];\n        if c == '.' || c == '?' || c == '!' {\n  \
    \          i += 1;\n        } else {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm_1zjgry.rs:13:17\n\
    \   |\n13 |         let c = S[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i + 1]);\n            i += 2;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&b|\
    \ b != \"I\").count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpq58immok.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpq58immok.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpq58immok.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq58immok.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.iter().filter(|&b| b != \"I\").count()\n   |  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     boredoms.iter().filter(|&b| b != \"I\").count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599, E0608.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5gz06yys.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp5gz06yys.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:14:27\n\
    \   |\n14 |             boredoms.push(S[i]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41ikz7oc.rs:18:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n18 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n18 |     boredoms.len().try_into().unwrap()\n   |\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: -1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n        s = s.trim_end().to_string();\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747042
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_counter = 0;\n  \
    \  let mut boredom_string = \"\";\n    let mut boredom_string_counter = 0;\n \
    \   let mut boredom_string_counter2 = 0;\n    let mut boredom_string_counter3\
    \ = 0;\n    let mut boredom_string_counter4 = 0;\n    let mut boredom_string_counter5\
    \ = 0;\n    let mut boredom_string_counter6 = 0;\n    let mut boredom_string_counter7\
    \ = 0;\n    let mut boredom_string_counter8 = 0;\n    let mut boredom_string_counter9\
    \ = 0;\n    let mut boredom_string_counter10 = 0;\n    let mut boredom_string_counter11\
    \ = 0;\n    let mut boredom_string_counter12 = 0;\n    let mut boredom_string_counter13\
    \ = 0;\n    let mut boredom_string_counter14 = 0;\n    let mut boredom_string_counter15\
    \ = 0;\n    let mut boredom_string_counter16 = 0;\n    let mut boredom_string_counter17\
    \ = 0;\n    let mut boredom_string_counter18 = 0;\n    let mut boredom_string_counter19\
    \ = 0;\n    let mut boredom_string_counter20 = 0;\n    let mut boredom_string_counter21\
    \ = 0;\n    let mut boredom_string_counter22 = 0;\n    let mut boredom_string_counter23\
    \ = 0;\n    let mut boredom_string_counter24 = 0;\n    let mut boredom_string_counter25\
    \ = 0;\n    let mut boredom_string_counter26 = 0;\n    let mut boredom_string_counter27\
    \ = 0;\n    let mut boredom_string_counter28 = 0;\n    let mut boredom_string_counter29\
    \ = 0;\n    let mut boredom_string_counter30 = 0;\n    let mut boredom_string_counter31\
    \ = 0;\n    let mut boredom_string_counter32 = 0;\n    let mut boredom_string_counter33\
    \ = 0;\n    let mut boredom_string_counter34 = 0;\n    let mut boredom_string_counter35\
    \ = 0;\n    let mut boredom_string_counter36 = 0;\n    let mut boredom_string_counter37\
    \ = 0;\n    let mut boredom_string_counter38 = 0;\n    let mut boredom_string_counter39\
    \ = 0;\n    let mut boredom_string_counter40 = 0;\n    let mut boredom_string_counter41\
    \ = 0;\n    let mut boredom_string_counter42 = 0;\n    let mut boredom_string_counter43\
    \ = 0;\n    let mut boredom_string_counter44 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpbnaqwkcm.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms.push(1);\n       \
    \ } else {\n            boredoms.push(0);\n        }\n    }\n    boredoms.iter().sum()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpo7e8dxvv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_counter = 0;\n    for\
    \ word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n     \
    \       boredoms.push(word);\n        }\n    }\n    for boredom in boredoms {\n\
    \        if boredom.ends_with(\".\") || boredom.ends_with(\"!\") || boredom.ends_with(\"\
    ?\") {\n            boredom_counter += 1;\n        }\n    }\n    boredom_counter\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpmspf46ps.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i]);\n        }\n        i += 1;\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpgbe68uhx.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpgbe68uhx.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpgbe68uhx.rs:15:27\n   |\n15 |             boredoms.push(words[i]);\n\
    \   |                           ^^^^^^^^\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpgbe68uhx.rs:19:5\n   |\n9  | fn is_bored(S: String) -> isize {\n\
    \   |                           ----- expected `isize` because of return type\n\
    ...\n19 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |     boredoms.len().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599, E0608.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S;\n    while !s.is_empty()\
    \ {\n        let mut i = s.find('i');\n        if i == s.len() {\n           \
    \ break;\n        }\n        let mut j = s.find('i', i + 1);\n        if j ==\
    \ s.len() {\n            break;\n        }\n        let mut k = s.find('i', j\
    \ + 1);\n        if k == s.len() {\n            break;\n        }\n        if\
    \ s.starts_with(\"i\") {\n            boredoms += 1;\n        }\n        s = &s[..i]\
    \ + &s[j..k] + &s[k..];\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptg3iw842.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^\n   |           \
    \      |\n   |                 expected enum `Option`, found `usize`\n   |   \
    \              help: try using a variant of the expected enum: `Some(s.len())`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmptg3iw842.rs:17:23\n     |\n17   |         let mut j = s.find('i',\
    \ i + 1);\n     |                       ^^^^ ---  ----- supplied 2 arguments\n\
    \     |                       |\n     |                       expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmptg3iw842.rs:17:35\n   |\n17 |         let\
    \ mut j = s.find('i', i + 1);\n   |                                 - ^ - {integer}\n\
    \   |                                 |\n   |                                \
    \ Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptg3iw842.rs:18:17\n\
    \   |\n18 |         if j == s.len() {\n   |                 ^^^^^^^\n   |    \
    \             |\n   |                 expected enum `Option`, found `usize`\n\
    \   |                 help: try using a variant of the expected enum: `Some(s.len())`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmptg3iw842.rs:21:23\n     |\n21   |         let mut k = s.find('i',\
    \ j + 1);\n     |                       ^^^^ ---  ----- supplied 2 arguments\n\
    \     |                       |\n     |                       expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmptg3iw842.rs:21:35\n   |\n21 |         let\
    \ mut k = s.find('i', j + 1);\n   |                                 - ^ - {integer}\n\
    \   |                                 |\n   |                                \
    \ Option<usize>\n\nerror[E0308]: mismatch"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for s in S.chars() {\n        if s.is_ascii_lowercase()\
    \ {\n            if s.starts_with(\"i\") {\n                boredoms += 1;\n \
    \           }\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpz317mla_.rs:13:18\n   |\n13 |             if s.starts_with(\"\
    i\") {\n   |                  ^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmph8jz_mp_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.iter().filter(|&b| b == 'I').count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:14:27\n\
    \   |\n14 |             boredoms.push(S[i]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: can't compare `&_` with `char`\n\
    \  --> /tmp/tmpbwjqkktt.rs:18:35\n   |\n18 |     boredoms.iter().filter(|&b| b\
    \ == 'I').count()\n   |                                   ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbwjqkktt.rs:18:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n18 |     boredoms.iter().filter(|&b|\
    \ b == 'I').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     boredoms.iter().filter(|&b|\
    \ b == 'I').count().try_into().unwrap()\n   |\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome e"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i..]);\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&s| s.starts_with(\"\
    I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp6z85mrmx.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp6z85mrmx.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp6z85mrmx.rs:15:27\n   |\n15 |             boredoms.push(words[i..]);\n\
    \   |                           ^^^^^^^^^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5gz06yys.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp5gz06yys.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_count = 0;\n    for word\
    \ in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n          \
    \  boredoms.push(word);\n            boredom_count += 1;\n        }\n    }\n \
    \   boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp0dzjiew4.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        let mut i = 0;\n        while i < s.len() {\n       \
    \     match s[i] {\n                '.' => i += 1,\n                '?' => i +=\
    \ 1,\n                '!' => i += 1,\n                _ => i += 1,\n         \
    \   }\n        }\n        if i == 0 {\n            break;\n        }\n       \
    \ boredoms += 1;\n        s = &s[..i];\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_7evq83l.rs:15:19\n\
    \   |\n15 |             match s[i] {\n   |                   ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_7evq83l.rs:26:13\n\
    \   |\n26 |         s = &s[..i];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n26 |        \
    \ s = (&s[..i]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp386wnla0.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp386wnla0.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp386wnla0.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp386wnla0.rs:14:27\n\
    \   |\n14 |             boredoms.push(S[i]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp386wnla0.rs:20:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n20 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n20 |     boredoms.len().try_into().unwrap()\n   |\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n        }\n    }\n    for boredom in\
    \ boredoms {\n        boredom_count += 1;\n    }\n    boredom_count\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6vm2pp75.rs:20:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n20 |     boredom_count\n   |     ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n20 |     boredom_count.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i + 1]);\n            i += 2;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpkovgtijj.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpkovgtijj.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpkovgtijj.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkovgtijj.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599, E0608.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpenafur9p.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    loop {\n        if let Some(word) = words.next() {\n            if word ==\
    \ \"I\" {\n                boredoms += 1;\n            }\n        }\n        if\
    \ !words.next().is_some() {\n            break;\n        }\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmplqd1uizj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.to_string();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n            boredoms += 1;\n\
    \        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsex_0oo9.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsex_0oo9.rs:14:34\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |                                  ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsex_0oo9.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        let mut i = 0;\n        while i < s.len() && s[i] ==\
    \ ' ' {\n            i += 1;\n        }\n        if i == s.len() {\n         \
    \   break;\n        }\n        let mut j = i;\n        while j < s.len() && s[j]\
    \ != ' ' {\n            j += 1;\n        }\n        if j == s.len() {\n      \
    \      break;\n        }\n        if s[i] == 'I' && s[j] == '.' {\n          \
    \  boredoms += 1;\n        }\n        s = &s[j..];\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptpq9sheb.rs:14:30\n\
    \   |\n14 |         while i < s.len() && s[i] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmptpq9sheb.rs:21:30\n   |\n\
    21 |         while j < s.len() && s[j] != ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmptpq9sheb.rs:27:12\n   |\n27 |  \
    \       if s[i] == 'I' && s[j] == '.' {\n   |            ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptpq9sheb.rs:27:27\n   |\n27 |         if s[i] == 'I' && s[j] ==\
    \ '.' {\n   |                           ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptpq9sheb.rs:30:13\n   |\n30 |  \
    \       s = &s[j..];\n   |             ^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n30 |         s = (&s[j..]).to_string();\n\
    \   |             +       +++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpenafur9p.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms\
    \ += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n \
    \   let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjt74qph5.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpjt74qph5.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpjt74qph5.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredoms_cnt: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n            boredoms_cnt += 1;\n   \
    \     }\n    }\n    boredoms_cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdiqvdcxp.rs:18:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n18 |     boredoms_cnt\n   |     ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     boredoms_cnt.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.to_string();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n            i += 1;\n   \
    \     } else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdr35dlbr.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdr35dlbr.rs:14:34\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |                                  ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdr35dlbr.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpenafur9p.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmph8jz_mp_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i..i + 1]);\n            i += 1;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&b|\
    \ b.starts_with(\"I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmps_1ycqeh.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmps_1ycqeh.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmps_1ycqeh.rs:15:27\n   |\n15 |             boredoms.push(words[i..i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> =\
    \ vec![];\n    let mut boredom_sentence: Vec<&str> = vec![];\n    let mut boredom_sentence_words:\
    \ Vec<&str> = vec![];\n    let mut boredom_sentence_word: &str;\n    let mut boredom_sentence_word_index:\
    \ usize;\n    let mut boredom_sentence_word_length: usize;\n    let mut boredom_sentence_word_length_index:\
    \ usize;\n    let mut boredom_sentence_word_length_index2: usize;\n    let mut\
    \ boredom_sentence_word_length_index3: usize;\n    let mut boredom_sentence_word_length_index4:\
    \ usize;\n    let mut boredom_sentence_word_length_index5: usize;\n    let mut\
    \ boredom_sentence_word_length_index6: usize;\n    let mut boredom_sentence_word_length_index7:\
    \ usize;\n    let mut boredom_sentence_word_length_index8: usize;\n    let mut\
    \ boredom_sentence_word_length_index9: usize;\n    let mut boredom_sentence_word_length_index10:\
    \ usize;\n    let mut boredom_sentence_word_length_index11: usize;\n    let mut\
    \ boredom_sentence_word_length_index12: usize;\n    let mut boredom_sentence_word_length_index13:\
    \ usize;\n    let mut boredom_sentence_word_length_index14: usize;\n    let mut\
    \ boredom_sentence_word_length_index15: usize;\n    let mut boredom_sentence_word_length_index16:\
    \ usize;\n    let mut boredom_sentence_word_length_index17: usize;\n    let mut\
    \ boredom_sentence_word_length_index18: usize;\n    let mut boredom_sentence_word_length_index19:\
    \ usize;\n    let mut boredom_sentence_word_length_index20: usize;\n    let mut\
    \ boredom_sentence_word_length_index21: usize;\n    let mut boredom_sentence_word_length_index22:\
    \ usize;\n    let mut boredom_sentence_word_length_index23: usize;\n    let mut\
    \ boredom_sentence_word_length_index24: usize;\n    let mut boredom_sentence_word_length_index25:\
    \ usize;\n    let mut boredom_sentence_word_length_index26: usize;\n    let mut\
    \ boredom_sentence_word_length_index27: usize;\n    let mut boredom_sentence_word_length\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpplwfn2fz.rs:44:41\n   |\n\
    44 |     let mut boredom_sentence_word_length\n   |                          \
    \               ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpplwfn2fz.rs:9:27\n  |\n9 | fn is_bored(S: String)\
    \ -> isize {\n  |    --------               ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            boredoms.push(S[i]);\n            i\
    \ += 1;\n        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2cmmhq2y.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2cmmhq2y.rs:14:27\n   |\n14 |             boredoms.push(S[i]);\n\
    \   |                           ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2cmmhq2y.rs:19:5\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n19 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |     boredoms.len().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i..].to_owned());\n            i += 1;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    boredoms.iter().filter(|s|\
    \ s.starts_with(\"I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpstewz_i8.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpstewz_i8.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpstewz_i8.rs:15:27\n   |\n15 |             boredoms.push(words[i..].to_owned());\n\
    \   |                           ^^^^^^^^^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> =\
    \ vec![];\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n            boredom_words.push(word);\n  \
    \      }\n    }\n    boredoms.iter().filter(|&b| b != 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpa7kc3k3c.rs:18:14\n   |\n18 |     boredoms.iter().filter(|&b|\
    \ b != 0).count()\n   |              ^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.to_string();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n            i += 1;\n   \
    \     } else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdr35dlbr.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdr35dlbr.rs:14:34\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |                                  ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdr35dlbr.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_61kf8m.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmph8jz_mp_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> =\
    \ vec![];\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n            boredom_words.push(word);\n  \
    \      }\n    }\n    boredoms.iter().cloned().count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp4wwypfg6.rs:18:14\n   |\n18 |     boredoms.iter().cloned().count()\n\
    \   |              ^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == String::from(\"I\") {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw3uw96dw.rs:13:12\n\
    \   |\n13 |         if S[i] == String::from(\"I\") {\n   |            ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpw3uw96dw.rs:14:27\n   |\n14 |             boredoms.push(S[i]);\n\
    \   |                           ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpw3uw96dw.rs:20:5\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n20 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n20 |     boredoms.len().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_count = 0;\n    let mut\
    \ boredom_words = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredom_words += 1;\n            boredom_count += 1;\n   \
    \     } else {\n            boredoms.push(word);\n        }\n    }\n    if boredom_words\
    \ == 0 {\n        return 0;\n    }\n    if boredom_count == 0 {\n        return\
    \ boredoms.len();\n    }\n    if boredoms.len() == 0 {\n        return boredom_count;\n\
    \    }\n    if boredoms.len() == 1 {\n        return boredoms.len();\n    }\n\
    \    if boredoms.len() == 2 {\n        return boredoms.len();\n    }\n    if boredoms.len()\
    \ == 3 {\n        return boredoms.len();\n    }\n    if boredoms.len() == 4 {\n\
    \        return boredoms.len();\n    }\n    if boredoms.len() == 5 {\n       \
    \ return boredoms.len();\n    }\n    if boredoms.len() == 6 {\n        return\
    \ boredoms.len();\n    }\n    if boredoms.len() == 7 {\n        return boredoms.len();\n\
    \    }\n    if boredoms.len() == 8 {\n        return boredoms.len();\n    }\n\
    \    if boredoms.len() == 9 {\n        return boredoms.len();\n    }\n    if boredoms.len()\
    \ == 10 {\n        return boredoms.len();\n    }\n    if boredoms.len() == 11\
    \ {\n        return boredoms.len();\n    }\n    if boredoms.len() == 12 {\n  \
    \      return boredoms.len();\n    }\n    if boredoms.len() == 13 {\n        return\
    \ boredoms.len();\n    }\n    if boredoms.len() == 14 {\n        return boredoms.len();\n\
    \    }\n    if boredoms.len() == 15 {\n        return boredoms.len();\n    }\n\
    \    if boredoms.len() == 16 {\n        return boredoms.len();\n    }\n    if\
    \ boredoms.len() == 17 {\n        return boredoms.len();\n    }\n    if boredoms.len()\
    \ == 18 {\n        return boredoms.len();\n    }\n    if boredoms.len() == 19\
    \ {\n        return boredoms.len();\n    }\n    if boredoms.len() == 20 {\n  \
    \      return boredoms.\n}\n\nfn main() {\n    let candidate = is_bored;\n   \
    \ assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjllq3j1p.rs:99:3\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \       - unclosed delimiter\n...\n87 |     if boredoms.len() == 20 {\n   |  \
    \                           - this delimiter might not be properly closed...\n\
    88 |         return boredoms.\n89 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n99 | }\n   |   ^\n\nerror: unexpected token: `}`\n\
    \  --> /tmp/tmpjllq3j1p.rs:89:1\n   |\n89 | }\n   | ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjllq3j1p.rs:25:16\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n25 |         return boredoms.len();\n   |                ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n25 |         return\
    \ boredoms.len().try_into().unwrap();\n   |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpjllq3j1p.rs:9:27\n  |\n9 | fn is_bored(S:\
    \ String) -> isize {\n  |    --------               ^^^^^ expected `isize`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S;\n    while s.len() >\
    \ 0 {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n       \
    \ }\n        s = s.trim_end().trim_start();\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa6_ywn2m.rs:16:13\n   |\n\
    16 |         s = s.trim_end().trim_start();\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |             |\n  \
    \ |             expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp9cfc0qtm.rs:10:28\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |                            ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9cfc0qtm.rs:10:47\n\
    \    |\n10  |     S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n\
    \    |                                               ^^^^^ ------------ supplied\
    \ 1 argument\n    |                                               |\n    |   \
    \                                            expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9cfc0qtm.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I').try_into().unwrap()\n   |         \
    \                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.to_string();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n            i += 1;\n   \
    \     } else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdr35dlbr.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdr35dlbr.rs:14:34\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |                                  ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdr35dlbr.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n            i += 1;\n    \
    \    }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfb80wlo1.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpfb80wlo1.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpfb80wlo1.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i: usize = 0;\n    while i < sentence.len() {\n        if sentence[i]\
    \ == \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc5pxp5z6.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    let mut boredom_word: &str = String::from(\"\");\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_count: usize = 0;\n    let mut boredom_word_len:\
    \ usize = 0;\n    let mut boredom_word_start = 0;\n    let mut boredom_word_end\
    \ = 0;\n    let mut boredom_word_word_len: usize = 0;\n    let mut boredom_word_word_start\
    \ = 0;\n    let mut boredom_word_word_end = 0;\n    let mut boredom_word_word_word_len:\
    \ usize = 0;\n    let mut boredom_word_word_word_start = 0;\n    let mut boredom_word_word_word_end\
    \ = 0;\n    let mut boredom_word_word_word_word_len: usize = 0;\n    let mut boredom_word_word_word_word_start\
    \ = 0;\n    let mut boredom_word_word_word_word_end = 0;\n    let mut boredom_word_word_word_word_word_len:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_start = 0;\n    let\
    \ mut boredom_word_word_word_word_word_end = 0;\n    let mut boredom_word_word_word_word_word_word_len:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_start = 0;\n \
    \   let mut boredom_word_word_word_word_word_word_end = 0;\n    let mut boredom_word_word_word_word_word_word_word_len:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_start = 0;\n\
    \    let mut boredom_word_word_word_word_word_word_word_end = 0;\n    let mut\
    \ boredom_word_word_word_word_word_word_word_word_len: usize = 0;\n    let mut\
    \ boredom_word_word_word_word_word_word_word_word_start = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_end\
    \ = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_len:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_start\
    \ = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_end =\
    \ 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_len:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_start\
    \ = 0;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpasczvkxc.rs:12:34\n   |\n\
    12 |     let mut boredom_word: &str = String::from(\"\");\n   |              \
    \             ----   ^^^^^^^^^^^^^^^^\n   |                           |      |\n\
    \   |                           |      expected `&str`, found struct `String`\n\
    \   |                           |      help: consider borrowing here: `&String::from(\"\
    \")`\n   |                           expected due to this\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpasczvkxc.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize\
    \ {\n  |    --------               ^^^^^ expected `isize`, found `()`\n  |   \
    \ |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_count = 0;\n    for\
    \ word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n     \
    \       boredom_count += 1;\n        }\n        if word.starts_with(\".\") ||\
    \ word.starts_with(\"?\") || word.starts_with(\"!\") {\n            boredoms.push(word);\n\
    \        }\n    }\n    boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpauhrio5p.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747038
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms.push(word);\n\
    \        }\n    }\n    boredoms.iter().filter(|&b| b.starts_with(\"I\")).count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplov4_uyw.rs:16:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n16 |     boredoms.iter().filter(|&b| b.starts_with(\"\
    I\")).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |     boredoms.iter().filter(|&b|\
    \ b.starts_with(\"I\")).count().try_into().unwrap()\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp9cfc0qtm.rs:10:28\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |                            ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9cfc0qtm.rs:10:47\n\
    \    |\n10  |     S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n\
    \    |                                               ^^^^^ ------------ supplied\
    \ 1 argument\n    |                                               |\n    |   \
    \                                            expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9cfc0qtm.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I').try_into().unwrap()\n   |         \
    \                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5gz06yys.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp5gz06yys.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpji4bmg9z.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.iter().filter(|&b| b == 'I').count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbwjqkktt.rs:14:27\n\
    \   |\n14 |             boredoms.push(S[i]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: can't compare `&_` with `char`\n\
    \  --> /tmp/tmpbwjqkktt.rs:18:35\n   |\n18 |     boredoms.iter().filter(|&b| b\
    \ == 'I').count()\n   |                                   ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbwjqkktt.rs:18:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n18 |     boredoms.iter().filter(|&b|\
    \ b == 'I').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     boredoms.iter().filter(|&b|\
    \ b == 'I').count().try_into().unwrap()\n   |\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome e"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: -1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n        s = s.trim_end().to_string();\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747042
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_61kf8m.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:27\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:13:42\n   |\n13 |  \
    \       if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                 \
    \                         ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41ikz7oc.rs:14:27\n\
    \   |\n14 |             boredoms.push(S[i]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41ikz7oc.rs:18:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n18 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n18 |     boredoms.len().try_into().unwrap()\n   |\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_61kf8m.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n        } else {\n            if sentence[i].is_ascii_uppercase()\
    \ {\n                i += 1;\n            } else {\n                if sentence[i].is_ascii_punctuation()\
    \ {\n                    i += 1;\n                } else {\n                 \
    \   if sentence[i].is_ascii_digit() {\n                        i += 1;\n     \
    \               } else {\n                        if sentence[i].is_ascii_whitespace()\
    \ {\n                            i += 1;\n                        } else {\n \
    \                           if sentence[i].is_ascii_lowercase() {\n          \
    \                      i += 1;\n                            } else {\n       \
    \                         if sentence[i].is_ascii_uppercase() {\n            \
    \                        i += 1;\n                                } else {\n \
    \                                   if sentence[i].is_ascii_punctuation() {\n\
    \                                        i += 1;\n                           \
    \         } else {\n                                        if sentence[i].is_ascii_digit()\
    \ {\n                                            i += 1;\n                   \
    \                     } else {\n                                            if\
    \ sentence[i].is_ascii_whitespace() {\n                                      \
    \          i += 1;\n                                            } else {\n   \
    \                                             if sentence[i].is_ascii_lowercase()\
    \ {\n                                                    i += 1;\n           \
    \                                     } else {\n                             \
    \                       if sentence[i].is_ascii_uppercase() {\n              \
    \                                          i += 1;\n                         \
    \                           } else {\n                                       \
    \                 if sentence[i].is_ascii_punctuation() {\n                  \
    \                                          i += 1;\n                         \
    \                               } else {\n                                   \
    \                         if sentence[i].is_ascii_digit() {\n                \
    \                                                i += 1;\n                   \
    \                                         } else {\n                         \
    \                                       if sentence[i].is_ascii_whitespace() {\n\
    \                                                                    i += 1;\n\
    \                                                                } else {\n  \
    \                                                                  if sentence[i].is_ascii_lowercase()\
    \ {\n                                                                        i\
    \ += 1;\n                                                                    }\
    \ else {\n                                                                   \
    \                     if sentence[i].is_ascii_uppercase() {\n                \
    \                                            i += 1;\n                       \
    \                                 } else {\n                                 \
    \                           if sentence[i].is_ascii_punctuation() {\n        \
    \                                                        i += 1;\n           \
    \                                                 } else {\n                 \
    \                                               if sentence[i].is_ascii_digit()\
    \ {\n                                                                    i +=\
    \ 1;\n                                                                } else {\n\
    \                                                                    if sentence[i].is_ascii_whitespace()\
    \ {\n                                                                        i\
    \ += 1;\n                                                                    }\
    \ else {\n                                                                   \
    \     if sentence[i].is_ascii_lowercase() {\n                                \
    \                                            i += 1;\n                       \
    \                                                 } else {\n                 \
    \                                                           if sentence[i].is_ascii_uppercase()\
    \ {\n                                                                        \
    \        i += 1;\n                                                           \
    \                 } else {\n                                                 \
    \                               if sentence[i].is_ascii_punctuation() {\n    \
    \                                                                            \
    \    i += 1;\n                                                               \
    \                 } else {\n                                                 \
    \                                   if sentence[i].is_ascii_digit() {\n      \
    \                                                                            \
    \      i += 1;\n                                                             \
    \                       } else {\n                                           \
    \                                             if sentence[i].is_ascii_whitespace()\
    \ {\n                                                                        \
    \                    i += 1;\n                                               \
    \                                         } else {\n                         \
    \                                                                   if sentence[i].is_ascii_lowercase()\
    \ {\n                                                                        \
    \                        i += 1;\n                                           \
    \                                                 } else {\n                 \
    \                                                                            \
    \   if sentence[i].is_ascii_uppercase() {\n                                  \
    \                                                                  i += 1;\n \
    \                                                                            \
    \                   } else {\n                                               \
    \                                                     if sentence[i].is_ascii_punctuation()\
    \ {\n                                                                        \
    \                                i += 1;\n                                   \
    \                                                                 } else {\n \
    \                                                                            \
    \                           if sentence[i].\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpr_6_syxe.rs:109:3\n\
    \    |\n9   | fn is_bored(S: String) -> isize {\n    |                       \
    \          - unclosed delimiter\n...\n13  |     while i < sentence.len() {\n \
    \   |                              - unclosed delimiter\n...\n16  |         }\
    \ else {\n    |                - unclosed delimiter\n...\n19  |             }\
    \ else {\n    |                    - unclosed delimiter\n...\n22  |          \
    \       } else {\n    |                        - unclosed delimiter\n...\n25 \
    \ |                     } else {\n    |                            - unclosed\
    \ delimiter\n...\n28  |                         } else {\n    |              \
    \                  - unclosed delimiter\n...\n31  |                          \
    \   } else {\n    |                                    - unclosed delimiter\n\
    ...\n34  |                                 } else {\n    |                   \
    \                     - unclosed delimiter\n...\n37  |                       \
    \              } else {\n    |                                            - unclosed\
    \ delimiter\n...\n40  |                                         } else {\n   \
    \ |                                                - unclosed delimiter\n...\n\
    43  |                                             } else {\n    |            \
    \                                        - unclosed delimiter\n...\n46  |    \
    \                                             } else {\n    |                \
    \                                        - unclosed delimiter\n...\n49  |    \
    \                                                 } else {\n    |            \
    \                                                - unclosed delimiter\n...\n52\
    \  |                                                         } else {\n    | \
    \                                                               - unclosed delimiter\n\
    ...\n55  |                                                             } else\
    \ {\n    |                                                                   \
    \ - unclosed delimiter\n...\n58  |                                           \
    \                   "
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpc27g3igv.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpc27g3igv.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredoms_len = 0;\n    let\
    \ mut boredoms_len2 = 0;\n    let mut boredoms_len3 = 0;\n    let mut boredoms_len4\
    \ = 0;\n    let mut boredoms_len5 = 0;\n    let mut boredoms_len6 = 0;\n    let\
    \ mut boredoms_len7 = 0;\n    let mut boredoms_len8 = 0;\n    let mut boredoms_len9\
    \ = 0;\n    let mut boredoms_len10 = 0;\n    let mut boredoms_len11 = 0;\n   \
    \ let mut boredoms_len12 = 0;\n    let mut boredoms_len13 = 0;\n    let mut boredoms_len14\
    \ = 0;\n    let mut boredoms_len15 = 0;\n    let mut boredoms_len16 = 0;\n   \
    \ let mut boredoms_len17 = 0;\n    let mut boredoms_len18 = 0;\n    let mut boredoms_len19\
    \ = 0;\n    let mut boredoms_len20 = 0;\n    let mut boredoms_len21 = 0;\n   \
    \ let mut boredoms_len22 = 0;\n    let mut boredoms_len23 = 0;\n    let mut boredoms_len24\
    \ = 0;\n    let mut boredoms_len25 = 0;\n    let mut boredoms_len26 = 0;\n   \
    \ let mut boredoms_len27 = 0;\n    let mut boredoms_len28 = 0;\n    let mut boredoms_len29\
    \ = 0;\n    let mut boredoms_len30 = 0;\n    let mut boredoms_len31 = 0;\n   \
    \ let mut boredoms_len32 = 0;\n    let mut boredoms_len33 = 0;\n    let mut boredoms_len34\
    \ = 0;\n    let mut boredoms_len35 = 0;\n    let mut boredoms_len36 = 0;\n   \
    \ let mut boredoms_len37 = 0;\n    let mut boredoms_len38 = 0;\n    let mut boredoms_len39\
    \ = 0;\n    let mut boredoms_len40 = 0;\n    let mut boredoms_len41 = 0;\n   \
    \ let mut boredoms_len42 = 0;\n    let mut boredoms_len43 = 0;\n    let mut boredoms_len44\
    \ = 0;\n    let mut boredoms_len45 = 0;\n    let mut boredoms_len46 = 0;\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbuoyau7t.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_word: &str = S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').next();\n    while boredom_word.len() > 0\
    \ {\n        if boredom_word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n        boredom_word = boredom_word.next();\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdoly56oy.rs:11:57\n\
    \   |\n11 |     let mut boredom_word: &str = S.chars().filter(|c| c == '.' ||\
    \ c == '?' || c == '!').next();\n   |                                        \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpdoly56oy.rs:11:69\n   |\n11 |   \
    \  let mut boredom_word: &str = S.chars().filter(|c| c == '.' || c == '?' || c\
    \ == '!').next();\n   |                                                      \
    \               ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpdoly56oy.rs:11:81\n   |\n11 |   \
    \  let mut boredom_word: &str = S.chars().filter(|c| c == '.' || c == '?' || c\
    \ == '!').next();\n   |                                                      \
    \                           ^^ no implementation for `&char == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdoly56oy.rs:11:34\n   |\n11 |     let mut boredom_word:\
    \ &str = S.chars().filter(|c| c == '.' || c == '?' || c == '!').next();\n   |\
    \                           ----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found enum `Option`\n   |                           |\n   |\
    \                           expected due to this\n   |\n   = note: expected reference\
    \ `&str`\n                   found enum `Option<char>`\n\nerror[E0599]: no method\
    \ named `next` found for reference `&str` in the current scope\n  --> /tmp/tmpdoly56oy.rs:16:37\n\
    \   |\n16 |         boredom_word = boredom_word.next();\n   |                \
    \                     ^^^^ method not found in `&str`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747037
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_count = 0;\n    for word\
    \ in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n          \
    \  boredom_count += 1;\n            boredoms.push(word);\n        }\n    }\n \
    \   boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmprvvn8hdj.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747038
