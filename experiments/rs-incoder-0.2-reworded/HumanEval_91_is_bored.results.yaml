name: HumanEval_91_is_bored
language: rs
results:
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkfhc7ejd.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkfhc7ejd.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkfhc7ejd.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence: String = S.to_string();\n\
    \    let mut idx = 0;\n    while idx < sentence.len() {\n        if sentence[idx]\
    \ == '.' || sentence[idx] == '?' || sentence[idx] == '!' {\n            boredoms\
    \ += 1;\n        }\n        idx += 1;\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp74_9xuol.rs:14:12\n\
    \   |\n14 |         if sentence[idx] == '.' || sentence[idx] == '?' || sentence[idx]\
    \ == '!' {\n   |            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp74_9xuol.rs:14:36\n   |\n14 |         if sentence[idx] == '.' ||\
    \ sentence[idx] == '?' || sentence[idx] == '!' {\n   |                       \
    \             ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp74_9xuol.rs:14:60\n\
    \   |\n14 |         if sentence[idx] == '.' || sentence[idx] == '?' || sentence[idx]\
    \ == '!' {\n   |                                                            ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeI"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n            boredom_count += 1;\n  \
    \      }\n    }\n    boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1udsw6wx.rs:18:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n18 |     boredom_count\n   |     ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     boredom_count.try_into().unwrap()\n\
    \   |                  ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for s in S.chars() {\n        if s.is_ascii()\
    \ {\n            if s.as_bytes()[0] == b'I' {\n                boredoms += 1;\n\
    \            }\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp1sa6pf5k.rs:13:18\n   |\n13 |             if s.as_bytes()[0]\
    \ == b'I' {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5gz06yys.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp5gz06yys.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn5axg6lv.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn5axg6lv.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn5axg6lv.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp4qf1sez9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp9cfc0qtm.rs:10:28\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |                            ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9cfc0qtm.rs:10:47\n\
    \    |\n10  |     S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n\
    \    |                                               ^^^^^ ------------ supplied\
    \ 1 argument\n    |                                               |\n    |   \
    \                                            expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9cfc0qtm.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I').try_into().unwrap()\n   |         \
    \                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S;\n    while let\
    \ Some(word) = sentence.split_first_word() {\n        if word == \"I\" {\n   \
    \         boredoms += 1;\n        }\n        sentence = sentence.split_last_word();\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_first_word` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmptws9vpyl.rs:12:37\n   |\n12 |     while\
    \ let Some(word) = sentence.split_first_word() {\n   |                       \
    \              ^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split_at`\n\nerror[E0599]: no method named `split_last_word` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmptws9vpyl.rs:16:29\n   |\n\
    16 |         sentence = sentence.split_last_word();\n   |                    \
    \         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split_at`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_61kf8m.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_61kf8m.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    for s in S.split_whitespace() {\n\
    \        if s.starts_with(\"I\") {\n            boredoms.push(s);\n        }\n\
    \    }\n    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1wr8umze.rs:16:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n16 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrgrkf92.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrgrkf92.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmph8jz_mp_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.iter().filter(|&b| b == 'I').count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu_k5u86g.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu_k5u86g.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu_k5u86g.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> =\
    \ vec![];\n    let mut sentence: Vec<&str> = vec![];\n    let mut sentence_words:\
    \ Vec<&str> = vec![];\n    let mut sentence_length: usize = 0;\n    let mut sentence_length2:\
    \ usize = 0;\n    let mut sentence_length3: usize = 0;\n    let mut sentence_length4:\
    \ usize = 0;\n    let mut sentence_length5: usize = 0;\n    let mut sentence_length6:\
    \ usize = 0;\n    let mut sentence_length7: usize = 0;\n    let mut sentence_length8:\
    \ usize = 0;\n    let mut sentence_length9: usize = 0;\n    let mut sentence_length10:\
    \ usize = 0;\n    let mut sentence_length11: usize = 0;\n    let mut sentence_length12:\
    \ usize = 0;\n    let mut sentence_length13: usize = 0;\n    let mut sentence_length14:\
    \ usize = 0;\n    let mut sentence_length15: usize = 0;\n    let mut sentence_length16:\
    \ usize = 0;\n    let mut sentence_length17: usize = 0;\n    let mut sentence_length18:\
    \ usize = 0;\n    let mut sentence_length19: usize = 0;\n    let mut sentence_length20:\
    \ usize = 0;\n    let mut sentence_length21: usize = 0;\n    let mut sentence_length22:\
    \ usize = 0;\n    let mut sentence_length23: usize = 0;\n    let mut sentence_length24:\
    \ usize = 0;\n    let mut sentence_length25: usize = 0;\n    let mut sentence_length26:\
    \ usize = 0;\n    let mut sentence_length27: usize = 0;\n    let mut sentence_length28:\
    \ usize = 0;\n    let mut sentence_length29: usize = 0;\n    let mut sentence_length30:\
    \ usize = 0;\n    let mut sentence_length31: usize = 0;\n    let mut sentence_length32:\
    \ usize = 0;\n    let mut sentence_length33: usize = 0;\n    let mut sentence_length34:\
    \ usize = 0;\n    let mut sentence_length35: usize = 0;\n    let mut sentence_length36:\
    \ usize = 0;\n    let mut sentence_length37: usize = 0;\n    let mut sentence_length38:\
    \ usize = 0;\n    let mut sentence_length39: usize = 0;\n    let mut sentence_length40:\
    \ usize = 0;\n    let mut sentence_length41: usize = 0;\n    let mut sentence_length42\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk12bwd2s.rs:55:30\n   |\n\
    55 |     let mut sentence_length42\n   |                              ^ help:\
    \ add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpk12bwd2s.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize {\n \
    \ |    --------               ^^^^^ expected `isize`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.starts_with(\"I\") {\n        boredoms += 1;\n        s = s.trim_start_matches(\"\
    I\");\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprqjy9zhs.rs:14:13\n   |\n\
    11 |     let mut s = S.to_string();\n   |                 ------------- expected\
    \ due to this value\n...\n14 |         s = s.trim_start_matches(\"I\");\n   |\
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |             |\n   |             expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp13_uhws8.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13_uhws8.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<String>\
    \ = vec![];\n    let mut boredom_sentence: Vec<String> = vec![];\n    let mut\
    \ boredom_sentence_index: usize = 0;\n    let mut boredom_word_index: usize =\
    \ 0;\n    let mut boredom_word_length: usize = 0;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_word_found2 = false;\n    let mut boredom_word_found3\
    \ = false;\n    let mut boredom_word_found4 = false;\n    let mut boredom_word_found5\
    \ = false;\n    let mut boredom_word_found6 = false;\n    let mut boredom_word_found7\
    \ = false;\n    let mut boredom_word_found8 = false;\n    let mut boredom_word_found9\
    \ = false;\n    let mut boredom_word_found10 = false;\n    let mut boredom_word_found11\
    \ = false;\n    let mut boredom_word_found12 = false;\n    let mut boredom_word_found13\
    \ = false;\n    let mut boredom_word_found14 = false;\n    let mut boredom_word_found15\
    \ = false;\n    let mut boredom_word_found16 = false;\n    let mut boredom_word_found17\
    \ = false;\n    let mut boredom_word_found18 = false;\n    let mut boredom_word_found19\
    \ = false;\n    let mut boredom_word_found20 = false;\n    let mut boredom_word_found21\
    \ = false;\n    let mut boredom_word_found22 = false;\n    let mut boredom_word_found23\
    \ = false;\n    let mut boredom_word_found24 = false;\n    let mut boredom_word_found25\
    \ = false;\n    let mut boredom_word_found26 = false;\n    let mut boredom_word_found27\
    \ = false;\n    let mut boredom_word_found28 = false;\n    let mut boredom_word_found29\
    \ = false;\n    let mut boredom_word_found30 = false;\n    let mut boredom_word_found31\
    \ = false;\n    let mut boredom_word_found32 = false;\n    let mut boredom_word_found33\
    \ = false;\n    let mut boredom_word_found34 = false;\n    let mut boredom_word_found35\
    \ = false;\n    let mut boredom_word_found36 = false;\n    let mut boredom_word_found37\
    \ = false;\n    let mut boredom_word_found38 = false;\n    let mut boredom_word_found39\
    \ = false;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphcekoqhu.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i + 1]);\n            i += 2;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp4kzw0s90.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp4kzw0s90.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp4kzw0s90.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4kzw0s90.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.iter().filter(|&x| x == 'I').count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7411yfki.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7411yfki.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7411yfki.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
