language: rs
name: HumanEval_86_anti_shuffle
results:
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j..]);\n                new_s_len += 1;\n     \
    \           break;\n            }\n            i += 1;\n            j += 1\n \
    \       }\n        if j == s.len() {\n            new_s.push_str(&s[i..]);\n \
    \           new_s_len += 1;\n        }\n    }\n    new_s.truncate(new_s_len);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpc15nkldd.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  while i < s.len() {\n        while j + 1 < s.len() && s[j].is_ascii_lowercase()\
    \ {\n            j += 1;\n        }\n        if j + 1 < s.len() {\n          \
    \  s.swap(i, j + 1);\n            i += 1;\n            j = 0;\n        }\n   \
    \ }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7xtqfhu1.rs:18:34\n\
    \   |\n18 |         while j + 1 < s.len() && s[j].is_ascii_lowercase() {\n   |\
    \                                  ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp7xtqfhu1.rs:22:15\n   |\n22 |          \
    \   s.swap(i, j + 1);\n   |               ^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[j..]);\n                break;\n          \
    \  }\n            j += 1\n        }\n        i += 1;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Hi\"`', /tmp/tmp3rcddryp.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxofcaye1.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxofcaye1.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            let mut c = s[j];\n            s[j] = s[k];\n  \
    \          s[k] = c;\n        }\n        i = j;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5eijw29g.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5eijw29g.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5eijw29g.rs:28:25\n\
    \   |\n28 |             let mut c = s[j];\n   |                         ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut new_s_len5 =\
    \ new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7 = new_s_len;\n\
    \    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 = new_s_len;\n  \
    \  let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 = new_s_len;\n  \
    \  let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 = new_s_len;\n  \
    \  let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 = new_s_len;\n  \
    \  let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 = new_s_len;\n  \
    \  let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 = new_s_len;\n  \
    \  let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 = new_s_len;\n  \
    \  let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 = new_s_len;\n  \
    \  let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 = new_s_len;\n  \
    \  let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 = new_s_len;\n  \
    \  let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 = new_s_len;\n  \
    \  let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 = new_s_len;\n  \
    \  let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 = new_s_len;\n  \
    \  let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 = new_s_len;\n  \
    \  let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 = new_s_len;\n  \
    \  let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 = new_s_len;\n  \
    \  let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 = new_s_len;\n  \
    \  let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 = new_s_len;\n  \
    \  let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 = new_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpclun_hhh.rs:60:31\n   |\n\
    60 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmpclun_hhh.rs:60:27\n   |\n60 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpclun_hhh.rs:13:31\n   |\n13 | fn anti_shuffle(s: String) -> String {\n\
    \   |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            }\n        }\n        if j > i {\n      \
    \      new_s.push_str(&s[i .. j]);\n            new_s_len += j - i;\n        \
    \    i = j;\n        } else {\n            new_s.push_str(&s[i .. i]);\n     \
    \       new_s_len += i - i;\n        }\n    }\n    new_s.push_str(&s[i ..]);\n\
    \    new_s_len += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp96e16rhy.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp96e16rhy.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ <\n                s.chars().next().unwrap().to_ascii_lowercase().unwrap() {\n\
    \                j = j + 1;\n            } else {\n                break;\n  \
    \          }\n        }\n        new_s.push_str(&s[i .. j]);\n        new_s_len\
    \ += j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len\
    \ += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmprqhlf07k.rs:21:63\n   |\n21 |             if s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ <\n   |                                                               ^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `char` in the current scope\n  --> /tmp/tmprqhlf07k.rs:22:64\n   |\n22\
    \ |                 s.chars().next().unwrap().to_ascii_lowercase().unwrap() {\n\
    \   |                                                                ^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j].is_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_lowercase() {\n                let mut new_char =\
    \ s[j];\n                let mut new_char_len = new_char.len();\n            \
    \    while new_char_len > 0 {\n                    let mut new_char_len = new_char_len\
    \ - 1;\n                    let mut new_char_pos = new_char.rfind(\" \");\n  \
    \                  if new_char_pos == new_char.len() {\n                     \
    \   new_char_pos = new_char.len();\n                    }\n                  \
    \  new_char = new_char.chars().nth(new_char_pos + 1).unwrap();\n             \
    \       new_char_len = new_char.len();\n                    j = j + 1;\n     \
    \           }\n                new_s.push_str(&new_char);\n            } else\
    \ {\n                new_s.push_str(&s[j]);\n            }\n            j = j\
    \ + 1;\n        }\n        i = i + 1;\n    }\n    new_s\n}\n\nfn main() {\n  \
    \  let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpje27jca6.rs:21:16\n\
    \   |\n21 |             if s[j].is_whitespace() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpje27jca6.rs:25:16\n   |\n25 |             if s[j].is_ascii_lowercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpje27jca6.rs:26:36\n\
    \   |\n26 |                 let mut new_char = s[j];\n   |                   \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <s"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        new_s.push_str(&s[i]);\n     \
    \   new_s_len += 1;\n        i += 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpezs2fb8m.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpezs2fb8m.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpezs2fb8m.rs:27:25\n   |\n27 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase().cmp(&s.chars().next().unwrap().to_ascii_lowercase())\
    \ < 0 {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s[..j]);\n        new_s.push_str(&s[j..]);\n\
    \        i = j + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp5_f3ems.rs:21:118\n   |\n\
    21 |             if s.chars().next().unwrap().to_ascii_lowercase().cmp(&s.chars().next().unwrap().to_ascii_lowercase())\
    \ < 0 {\n   |                                                                \
    \                                                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i, c)|\
    \ {\n        if c.is_whitespace() {\n            s.insert(i, ' ');\n        }\
    \ else {\n            s.insert(i, c.to_ascii_lowercase());\n        }\n    });\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp5d6lggk6.rs:15:36\n   |\n15 |     s.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     ---------             -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                     |\n   |     |                     immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n16 |     \
    \    if c.is_whitespace() {\n17 |             s.insert(i, ' ');\n   |        \
    \     - second borrow occurs due to use of `s` in closure\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] < 'A' || s[j] > 'Z' {\n                j +=\
    \ 1;\n                continue;\n            }\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s_len += 1;\n            i += 1;\n            j +=\
    \ 1;\n        }\n        new_s.push_str(&s[i .. new_s_len]);\n        new_s_len\
    \ += 1;\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphdslram3.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphdslram3.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphdslram3.rs:25:30\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>"
  stdout: ''
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[..j]);\n        new_s.push_str(&s[j..]);\n        i\
    \ = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        if j == new_s_len {\n            break;\n    \
    \    }\n        let mut k = j;\n        while k < new_s_len && s[k] == ' ' {\n\
    \            k += 1\n        }\n        if k == new_s_len {\n            break;\n\
    \        }\n        let mut new_s_char = new_s[new_s_len - k as usize];\n    \
    \    let mut new_s_char_len = new_s_char.len();\n        let mut new_s_char_i\
    \ = new_s_char.chars().nth(j as usize).unwrap();\n        let mut new_s_char_j\
    \ = new_s_char.chars().nth(k as usize).unwrap();\n        let mut new_s_char_k\
    \ = new_s_char.chars().nth(i as usize).unwrap();\n        while new_s_char_i ==\
    \ new_s_char_j {\n            new_s_char_i += 1;\n            new_s_char_j +=\
    \ 1;\n            new_s_char_k += 1;\n        }\n        new_s_char_k = new_s_char_k\
    \ + new_s_char_i;\n        new_s_char_i = new_s_char_j;\n        new_s_char_j\
    \ = new_s_char_k;\n        new_s_char_k = new_s_char_k + new_s_char_i;\n     \
    \   new_s_char_i = new_s_char_j;\n        new_s_char_j = new_s_char_k;\n     \
    \   new_s_char_k = new_s_char_k + new_s_char_i;\n        new_s_char_i = new_s_char_j;\n\
    \        new_s_char_j = new_s_char_k;\n        new_s_char_k = new_s_char_k + new_s_char_i;\n\
    \        new_s_char_i = new_s_char_j;\n        new_s_char_j = new_s_char_k;\n\
    \        new_s_char_k = new_s_char_k + new_s_char_i;\n        new_s_char_i = new_s_char_j;\n\
    \        new_s_char_j = new_s_char_k;\n        new_s_char_k = new_s_char_k + new_s_char_i;\n\
    \        new_s_char_i = new_s_char_j;\n        new_s_char_j = new_s_char_k;\n\
    \        new_s_char_k = new_s_char_k + new_s_char_i;\n        new_s_char_i = new_s_char_j;\n\
    \        new_s_char_j = new_s_char_k;\n        new_s_char_k = new_s_char_k + new_s_char_i;\n\
    \        new_s_char_i = new_s_char_j;\n        new_s_char_j = new_s_\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpo2d6keg6.rs:78:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - this delimiter might not be properly closed...\n\
    ...\n67 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    78 | }\n   |   ^\n\nerror[E0425]: cannot find value `new_s_` in this scope\n \
    \ --> /tmp/tmpo2d6keg6.rs:66:24\n   |\n66 |         new_s_char_j = new_s_\n  \
    \ |                        ^^^^^^ help: a local variable with a similar name exists:\
    \ `new_s`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpo2d6keg6.rs:20:32\n   |\n20 |         while j < new_s_len && s[j] ==\
    \ ' ' {\n   |                                ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpo2d6keg6.rs:27:32\n   |\n27 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `"
  stdout: ''
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1; // skip spaces\n        }\n        let mut new_s_char = new_s[..j];\n\
    \        let mut new_s_char_len = new_s_char.len();\n        let mut j = 0;\n\
    \        while j < new_s_char_len {\n            let mut new_s_char_char = new_s_char[j];\n\
    \            let mut new_s_char_char_len = new_s_char_char.len();\n          \
    \  let mut new_s_char_char_char_len = new_s_char_char_char.len();\n          \
    \  let mut new_s_char_char_char_char_len = new_s_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_len = new_s_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_char_len =\
    \ new_s_char_char_char_char_char_char_char_char_char_char.len();\n           \
    \ let mut new_s_char_char_char_char_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = new_s_char_char_char_char_char_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjdg0bbgd.rs:53:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n26 |         while j\
    \ < new_s_char_len {\n   |                                  - this delimiter might\
    \ not be properly closed...\n...\n42 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n53 | }\n   |   ^\n\nerror: expected `;`, found\
    \ `}`\n  --> /tmp/tmpjdg0bbgd.rs:41:147\n   |\n41 |             let mut new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_\n\
    \   |                                                                        \
    \                                                                           ^\
    \ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_char_char_char` in this scope\n  --> /tmp/tmpjdg0bbgd.rs:29:48\n\
    \   |\n29 |             let mut new_s_char_char_char_len = new_s_char_char_char.len();\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s_char_char_len`\n\nerror[E0425]:\
    \ cannot find value `new_s_char_char_char_char` in this scope\n  --> /tmp/tmpjdg0bbgd.rs:30:53\n\
    \   |\n30 |             let mut new_s_char_char_char_char_len = new_s_char_char_char_char.len();\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `new_s_char_char_char_len`\n\
    \nerror[E0425]: cannot find value `new_s_char_char_char_char_char` in this scope\n\
    \  --> /tmp/tmpjdg0bbgd.rs:31:58\n   |\n31 |             let mut new_s_char_char_char_char_char_len\
    \ = new_s_char_char_char_char_char.len();\n   |                              \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `new_s_char_char_char_char_len`\n\nerror[E0425]:\
    \ cannot find value `"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s[i .. j]);\n        new_s_len\
    \ += j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len\
    \ += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuo9f8_qy.rs:21:118\n   |\n\
    21 |             if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n   |                                                                \
    \                                                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                s[j] = s[j].to_ascii_lowercase();\n           \
    \ }\n            new_s[new_s_len] = s[j];\n            new_s_len += 1;\n     \
    \       j += 1;\n        }\n        new_s[i] = new_s[new_s_len - 1];\n       \
    \ new_s_len -= 1;\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyvokh5lt.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyvokh5lt.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyvokh5lt.rs:26:17\n   |\n26 |                 s[j] = s[j].to_ascii_lowercase();\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the "
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = j;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k\
    \ .. j]);\n            i = j;\n        } else {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. k]);\n            i = k;\n     \
    \   }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyy_s_aiq.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyy_s_aiq.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + 1;\n        new_s.push_str(&s[i\
    \ .. j]);\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz6bgpzui.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz6bgpzui.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[j..]);\n                break;\n          \
    \  }\n            j += 1\n        }\n        i += 1;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Hi\"`', /tmp/tmp3rcddryp.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                s[j] = s[j].to_ascii_lowercase();\n           \
    \ }\n            new_s[new_s_len] = s[j];\n            new_s_len += 1;\n     \
    \       j += 1;\n        }\n        i = j;\n    }\n    new_s.truncate(new_s_len);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq3e9wiy9.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq3e9wiy9.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq3e9wiy9.rs:26:17\n\
    \   |\n26 |                 s[j] = s[j].to_ascii_lowercase();\n   |          \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpq3e9wiy9.rs:26:24\n   |\n26 |  \
    \               s[j] = s[j].to_ascii_lowercase();\n   |                      \
    \  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmpq3e9wiy9.rs:28:13\n   |\n28 |        \
    \     new_s[new_s_len] = s[j];\n   |             ^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpq3e9wiy9.rs:28:32\n   |\n28 |             new_s[new_s_len]\
    \ = s[j];\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1; // skip spaces\n        }\n        if j == new_s_len {\n        \
    \    break;\n        }\n        let mut k = j;\n        while k < new_s_len &&\
    \ s[k] == ' ' {\n            k += 1; // skip spaces\n        }\n        if k ==\
    \ new_s_len {\n            break;\n        }\n        let mut new_word = String::new();\n\
    \        new_word.push_str(&s[i .. k]);\n        new_word.push_str(&s[j..new_s_len]);\n\
    \        new_s.push_str(&new_word);\n        i = k;\n    }\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9031h0ry.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9031h0ry.rs:27:32\n\
    \   |\n27 |         while k < new_s_len && s[k] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i, c)|\
    \ {\n        if c.is_whitespace() {\n            s.swap(i, i + 1);\n        }\n\
    \    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp80_rf5af.rs:17:15\n   |\n17 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j + 1 < s.len() && s[j + 1] == ' ' {\n\
    \            j += 1\n        }\n        if j + 1 < s.len() {\n            let\
    \ mut k = j;\n            while k + 1 < s.len() && s[k + 1] == ' ' {\n       \
    \         k += 1\n            }\n            if k + 1 < s.len() {\n          \
    \      let mut t = s[k];\n                s[k] = s[k + 1];\n                s[k\
    \ + 1] = t;\n            }\n        }\n        i += 1;\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpljmpdkax.rs:18:34\n\
    \   |\n18 |         while j + 1 < s.len() && s[j + 1] == ' ' {\n   |         \
    \                         ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpljmpdkax.rs:23:38\n\
    \   |\n23 |             while k + 1 < s.len() && s[k + 1] == ' ' {\n   |     \
    \                                 ^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpljmpdkax.rs:27:29\n\
    \   |\n27 |                 let mut t = s[k];\n   |                          \
    \   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpljmpdkax.rs:28:17\n   |\n28 |            \
    \     s[k] = s[k + 1];\n   |                 ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpljmpdkax.rs:28:24\n\
    \   |\n28 |                 s[k] = s[k + 1];\n   |                        ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpljmpdkax.rs:29:17\n   |\n29 |            \
    \     s[k + 1] = t;\n   |                 ^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1; // skip spaces\n        }\n        let mut new_s_char = new_s[i];\n\
    \        let mut new_s_char_len = new_s_char.len();\n        while j < new_s_len\
    \ && new_s_char[j] != ' ' {\n            new_s_char.insert(j, new_s_char[j]);\n\
    \            new_s_char_len += 1;\n            j += 1; // skip spaces\n      \
    \  }\n        new_s_char.truncate(new_s_char_len);\n        new_s.insert(i, new_s_char);\n\
    \        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0v6149ra.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0v6149ra.rs:23:30\n\
    \   |\n23 |         let mut new_s_char = new_s[i];\n   |                     \
    \         ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j..]);\n                break;\n            }\n\
    \            j += 1;\n        }\n        if j == s.len() {\n            new_s.push_str(&s[i]);\n\
    \            i += 1;\n        } else {\n            new_s.push_str(&s[i]);\n \
    \           new_s_len += 1;\n            i += 1;\n        }\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy8ht0xpf.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy8ht0xpf.rs:28:29\n   |\n28 |             new_s.push_str(&s[i]);\n\
    \   |                             ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy8ht0xpf.rs:31:29\n\
    \   |\n31 |             new_s.push_str(&s[i]);\n   |                         \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                let mut temp = s[j];\n\
    \                s[j] = s[i];\n                s[i] = temp;\n                j\
    \ = i;\n            } else {\n                j += 1;\n            }\n       \
    \ }\n        new_s.push_str(&s[i..]);\n        i = j;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx_5wsvbq.rs:20:16\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx_5wsvbq.rs:20:23\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx_5wsvbq.rs:21:32\n\
    \   |\n21 |                 let mut temp = s[j];\n   |                       \
    \         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpx_5wsvbq.rs:22:17\n   |\n22 |  \
    \               s[j] = s[i];\n   |                 ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpx_5wsvbq.rs:22:24\n   |\n22 |                 s[j] = s[i];\n   |\
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx_5wsvbq.rs:23:17\n\
    \   |\n23 |                 s[i] = temp;\n   |                 ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        if j < s.len() {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s_len += j - i;\n            i = j;\n        } else\
    \ {\n            new_s.push_str(&s[i ..]);\n            new_s_len += s.len() -\
    \ i;\n            break;\n        }\n    }\n    new_s.push_str(&s[i ..]);\n  \
    \  new_s_len += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbc89aojn.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbc89aojn.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] < 'A' || s[j] > 'Z' {\n                j +=\
    \ 1;\n                continue;\n            }\n            if s[j] < '0' || s[j]\
    \ > '9' {\n                j += 1;\n                continue;\n            }\n\
    \            new_s[new_s_len] = s[j];\n            new_s_len += 1;\n         \
    \   j += 1;\n        }\n        new_s[i] = '!';\n        new_s_len += 1;\n   \
    \     i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1_8tvyo9.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1_8tvyo9.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1_8tvyo9.rs:25:30\n\
    \   |\n25 |             if s[j] < 'a' || s[j] > 'z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp1_8tvyo9.rs:29:16\n   |\n\
    29 |             if s[j] < 'A' || s[j] > 'Z' {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp1_8tvyo9.rs:29:30\n   |\n29 |             if s[j]\
    \ < 'A' || s[j] > 'Z' {\n   |                              ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1_8tvyo9.rs:33:16\n   |\n33 |             if s[j] < '0' || s[j]\
    \ > '9' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1_8tvyo9.rs:33:30\n\
    \   |\n33 |             if s[j] < '0' || s[j] > '9' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be ind"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut new_s_len5 =\
    \ new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7 = new_s_len;\n\
    \    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 = new_s_len;\n  \
    \  let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 = new_s_len;\n  \
    \  let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 = new_s_len;\n  \
    \  let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 = new_s_len;\n  \
    \  let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 = new_s_len;\n  \
    \  let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 = new_s_len;\n  \
    \  let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 = new_s_len;\n  \
    \  let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 = new_s_len;\n  \
    \  let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 = new_s_len;\n  \
    \  let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 = new_s_len;\n  \
    \  let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 = new_s_len;\n  \
    \  let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 = new_s_len;\n  \
    \  let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 = new_s_len;\n  \
    \  let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 = new_s_len;\n  \
    \  let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 = new_s_len;\n  \
    \  let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 = new_s_len;\n  \
    \  let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 = new_s_len;\n  \
    \  let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 = new_s_len;\n  \
    \  let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 = new_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpclun_hhh.rs:60:31\n   |\n\
    60 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmpclun_hhh.rs:60:27\n   |\n60 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpclun_hhh.rs:13:31\n   |\n13 | fn anti_shuffle(s: String) -> String {\n\
    \   |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        let mut k = i;\n        while\
    \ k < s.len() {\n            if s[k] != ' ' {\n                new_s.push_str(&s[k]);\n\
    \                new_s_len += 1;\n            }\n            k += 1\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8w24fx74.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8w24fx74.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8w24fx74.rs:29:16\n\
    \   |\n29 |             if s[k] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8w24fx74.rs:30:33\n   |\n30 |                 new_s.push_str(&s[k]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + j - i;\n        new_s.push_str(&s[i\
    \ .. j]);\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphm6h21bp.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphm6h21bp.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            break;\n            }\n            j += 1; // skip space\n      \
    \  }\n        let mut new_s_len = new_s_len + j - i;\n        let mut new_s_char\
    \ = String::new();\n        for j in i..i + j {\n            new_s_char.push(s[j]);\n\
    \        }\n        new_s_char.push(s[s.len() - 1]);\n        new_s_char.push(s[new_s_len\
    \ - 1]);\n        new_s_char.push(s[new_s_len - 2]);\n        new_s_char.push(s[new_s_len\
    \ - 3]);\n        new_s_char.push(s[new_s_len - 4]);\n        new_s_char.push(s[new_s_len\
    \ - 5]);\n        new_s_char.push(s[new_s_len - 6]);\n        new_s_char.push(s[new_s_len\
    \ - 7]);\n        new_s_char.push(s[new_s_len - 8]);\n        new_s_char.push(s[new_s_len\
    \ - 9]);\n        new_s_char.push(s[new_s_len - 10]);\n        new_s_char.push(s[new_s_len\
    \ - 11]);\n        new_s_char.push(s[new_s_len - 12]);\n        new_s_char.push(s[new_s_len\
    \ - 13]);\n        new_s_char.push(s[new_s_len - 14]);\n        new_s_char.push(s[new_s_len\
    \ - 15]);\n        new_s_char.push(s[new_s_len - 16]);\n        new_s_char.push(s[new_s_len\
    \ - 17]);\n        new_s_char.push(s[new_s_len - 18]);\n        new_s_char.push(s[new_s_len\
    \ - 19]);\n        new_s_char.push(s[new_s_len - 20]);\n        new_s_char.push(s[new_s_len\
    \ - 1]);\n        new_s_char.push(s[new_s_len - 2]);\n        new_s_char.push(s[new_s_len\
    \ - 3]);\n        new_s_char.push(s[new_s_len - 4]);\n        new_s_char.push(s[new_s_len\
    \ - 5]);\n        new_s_char.push(s[new_s_len - 6]);\n        new_s_char.push(s[new_s_len\
    \ - 7]);\n        new_s_char.push(s[new_s_len - 8]);\n        new_s_char.push(s[new_s_len\
    \ - 9]);\n        new_s_char.push(s[new_s_len - 10]);\n        new_s_char.push(s[new_s_len\
    \ - 11]);\n        new_s_char.push(s[new_s_len - 12]);\n        new_s_char.push(s[\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwfs38c14.rs:76:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    65 | }\n   | - ...as it matches this but it has different indentation\n...\n76\
    \ | }\n   |   ^\n\nerror: expected expression, found `]`\n  --> /tmp/tmpwfs38c14.rs:65:1\n\
    \   |\n65 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpwfs38c14.rs:64:26\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |                                      - closing delimiter possibly\
    \ meant for this\n...\n64 |         new_s_char.push(s[\n   |                 \
    \         ^ unclosed delimiter\n65 | }\n   | ^ mismatched closing delimiter\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwfs38c14.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwfs38c14.rs:29:29\n   |\n29 |             new_s_char.push(s[j]);\n\
    \   |                             ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwfs38c14.rs:31:25\n\
    \   |\n31 |         new_s_char.push(s[s.len() - 1]);\n   |                   \
    \      ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwfs38c14.rs:32:25\n\
    \   |\n32 |         new_s_char.push(s[new_s_len - 1]);\n   |                 \
    \        ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be ind"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut k = i;\n        while k < s.len() {\n   \
    \         if s[k] > s[i] {\n                k = k + 1;\n            } else {\n\
    \                break;\n            }\n        }\n        if j < k {\n      \
    \      new_s.push_str(&s[i .. k]);\n            new_s_len += k - i;\n        \
    \    i = k;\n        } else {\n            new_s.push_str(&s[i .. j]);\n     \
    \       new_s_len += j - i;\n            i = j;\n        }\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s_len += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl6dssrk_.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpl6dssrk_.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl6dssrk_.rs:29:16\n\
    \   |\n29 |             if s[k] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpl6dssrk_.rs:29:23\n   |\n29 |             if s[k] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_char = new_s[new_s_len..new_s_len +\
    \ j].to_ascii_lowercase();\n        new_s_char = new_s_char.chars().collect::<Vec<_>>();\n\
    \        new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n      \
    \  new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n        new_s_char\
    \ = new_s_char.iter().cloned().collect::<Vec<_>>();\n        new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n      \
    \  new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n        new_s_char\
    \ = new_s_char.iter().cloned().collect::<Vec<_>>();\n        new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n      \
    \  new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n        new_s_char\
    \ = new_s_char.iter().cloned().collect::<Vec<_>>();\n        new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n      \
    \  new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n        new_s_char\
    \ = new_s_char.iter().cloned().collect::<Vec<_>>();\n        new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n      \
    \  new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n        new_s_char\
    \ = new_s_char.iter().cloned().collect::<Vec<_>>();\n        new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_s_char = new_s_char\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwms_3mbh.rs:61:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    50 | }\n   | - ...as it matches this but it has different indentation\n...\n61\
    \ | }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwms_3mbh.rs:21:16\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwms_3mbh.rs:21:23\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwms_3mbh.rs:28:22\n\
    \   |\n28 |         new_s_char = new_s_char.chars().collect::<Vec<_>>();\n   |\
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n  \
    \            found struct `Vec<char>`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpwms_3mbh.rs:29:33\n\
    \   |\n29 |         new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                 ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpwms_3mbh.rs:30:33\n   |\n30 |         new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                 ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpwms_3mbh.rs:31:33\n   |\n31 |         new_s_char = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                 ^^^^ method not fo"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                s[j] = s[j] + 1;\n                j += 1;\n   \
    \             continue;\n            }\n            if s[j] > 122 {\n        \
    \        s[j] = s[j] - 1;\n                j += 1;\n                continue;\n\
    \            }\n            break;\n        }\n        if j == s.len() {\n   \
    \         new_s.push_str(&s[i .. i + 1]);\n            new_s_len += 1;\n     \
    \       i += 1;\n            continue;\n        }\n        let mut k = j;\n  \
    \      while k < s.len() {\n            if s[k] < 97 {\n                s[k] =\
    \ s[k] + 1;\n                k += 1;\n                continue;\n            }\n\
    \            if s[k] > 122 {\n                s[k] = s[k] - 1;\n             \
    \   k += 1;\n                continue;\n            }\n            break;\n  \
    \      }\n        if k == s.len() {\n            new_s.push_str(&s[i .. i + 1]);\n\
    \            new_s_len += 1;\n            i += 1;\n            continue;\n   \
    \     }\n        let mut new_word = String::new();\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[k..]);\n        new_s.push_str(&new_word);\n\
    \        new_s_len += 1;\n        i = j;\n    }\n    new_s.push_str(&s[i .. new_s_len]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprr4j9oxl.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprr4j9oxl.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmprr4j9oxl.rs:26:17\n\
    \   |\n26 |                 s[j] = s[j] + 1;\n   |                 ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmprr4j9oxl.rs:26:24\n   |\n26 |                 s[j]\
    \ = s[j] + 1;\n   |                        ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprr4j9oxl.rs:30:16\n\
    \   |\n30 |             if s[j] > 122 {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprr4j9oxl.rs:31:17\n   |\n31 |                 s[j] = s[j] - 1;\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmprr4j9oxl.rs:31:24\n\
    \   |\n31 |                 s[j] = s[j] - 1;\n   |                        ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmprr4j9oxl.rs:45:16\n   |\n45 |            \
    \ if s[k] < 97 {\n   |"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        if j == s.len() {\n            new_s.push_str(&s[i\
    \ .. i + 1]);\n            new_s_len += 1;\n            i += 1;\n        } else\
    \ {\n            new_s.push_str(&s[i .. j]);\n            new_s_len += j - i;\n\
    \            i = j;\n        }\n    }\n    new_s.push_str(&s[i .. new_s_len]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp461yzz4j.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp461yzz4j.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c| c\
    \ == ' ') {\n                j = j + 1;\n                continue;\n         \
    \   }\n            if s.chars().any(|c| c != ' ') {\n                new_s.push_str(&s[i\
    \ .. j]);\n                new_s_len += j - i;\n                new_s.push_str(&\"\
    \ \");\n                i = j;\n                break;\n            }\n      \
    \      j = j + 1;\n        }\n    }\n    new_s.push_str(&s[i .. new_s_len]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749329
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        let mut new_s_word = s.split_off(j);\n       \
    \ let mut new_s_word_len = new_s_word.len();\n        let mut new_s_word_i = 0;\n\
    \        while new_s_word_i < new_s_word_len {\n            let mut new_s_word_j\
    \ = new_s_word_i;\n            while new_s_word_j < new_s_word_len && new_s_word[new_s_word_j]\
    \ == ' ' {\n                new_s_word_j += 1\n            }\n            let\
    \ mut new_s_word_word = new_s_word.split_off(new_s_word_j);\n            let mut\
    \ new_s_word_word_len = new_s_word_word.len();\n            let mut new_s_word_word_i\
    \ = 0;\n            while new_s_word_word_i < new_s_word_word_len {\n        \
    \        let mut new_s_word_word_j = new_s_word_word_i;\n                while\
    \ new_s_word_word_j < new_s_word_word_len && new_s_word_word[new_s_word_word_j]\
    \ == ' ' {\n                    new_s_word_word_j += 1\n                }\n  \
    \              let mut new_s_word_word_word = new_s_word_word.split_off(new_s_word_word_j);\n\
    \                let mut new_s_word_word_word_len = new_s_word_word_word.len();\n\
    \                let mut new_s_word_word_word_i = 0;\n                while new_s_word_word_word_i\
    \ < new_s_word_word_word_len {\n                    let mut new_s_word_word_word_j\
    \ = new_s_word_word_word_i;\n                    while new_s_word_word_word_j\
    \ < new_s_word_word_word_len && new_s_word_word_word[new_s_word_word_word_j] ==\
    \ ' ' {\n                        new_s_word_word_word_j += 1\n               \
    \     }\n                    let mut new_s_word_word_word_word = new_s_word_word_word.split_off(new_s_word_word_word_j);\n\
    \                    new_s_word_word_word_word_len += 1;\n                   \
    \ new_s_word_word_word_i += 1;\n                }\n                new_s_word_word_word_len\
    \ += 1;\n                new_s_word_word_word_i += 1;\n            }\n       \
    \     new_s_word_word_word_len += 1;\n            new_s_word_word_i += 1;\n  \
    \      }\n        new_s_word_len += 1;\n        new_s_word_i += 1;\n    }\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `new_s_word_word_word_word_len` in this\
    \ scope\n  --> /tmp/tmpup7u8xqo.rs:48:21\n   |\n48 |                     new_s_word_word_word_word_len\
    \ += 1;\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `new_s_word_word_word_word`\n\nerror[E0425]:\
    \ cannot find value `new_s_word_word_word_len` in this scope\n  --> /tmp/tmpup7u8xqo.rs:54:13\n\
    \   |\n54 |             new_s_word_word_word_len += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `new_s_word_word_len`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpup7u8xqo.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpup7u8xqo.rs:28:52\n\
    \   |\n28 |             while new_s_word_j < new_s_word_len && new_s_word[new_s_word_j]\
    \ == ' ' {\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpup7u8xqo.rs:36:66\n   |\n36 |            \
    \     while new_s_word_word_j < new_s_word_word_len && new_s_word_word[new_s_word_word_j]\
    \ == ' ' {\n   |                                                             \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpup7u8xqo.rs:44:80\n\
    \   |\n44 |                     while new_s_word_word_word_j < new_s_word_word_word_len\
    \ && new_s_word_word_word[new_s_word_word_word_j] == ' ' {\n   |             \
    \                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1; // skip spaces\n        }\n        let mut new_word = String::new();\n\
    \        let mut new_word_len = j - i;\n        while new_word_len > 0 {\n   \
    \         let mut new_char = s.chars().nth(new_word_len).unwrap();\n         \
    \   new_word.push((new_char.ascii_code()).to_string());\n            new_word_len\
    \ -= 1;\n        }\n        new_s.push_str(new_word);\n        i += new_word_len;\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb1pfox44.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0599]: no\
    \ method named `ascii_code` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpb1pfox44.rs:27:37\n   |\n27 |             new_word.push((new_char.ascii_code()).to_string());\n\
    \   |                                     ^^^^^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb1pfox44.rs:30:24\n   |\n30 |\
    \         new_s.push_str(new_word);\n   |                        ^^^^^^^^\n  \
    \ |                        |\n   |                        expected `&str`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&new_word`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] == '\
    \ ' {\n                j += 1;\n                continue;\n            }\n   \
    \         if s[j] == ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[i] > s[j] {\n                let temp = s[i];\n\
    \                s[i] = s[j];\n                s[j] = temp;\n                i\
    \ += 1;\n                j += 1;\n                continue;\n            }\n \
    \           if s[i] > ' ' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[j] > ' ' {\n                j += 1;\n       \
    \         continue;\n            }\n            break;\n        }\n        new_s.push_str(&s[i\
    \ .. j]);\n        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphfgzkvhb.rs:21:16\n\
    \   |\n21 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphfgzkvhb.rs:25:16\n   |\n25 |             if s[j] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmphfgzkvhb.rs:29:16\n\
    \   |\n29 |             if s[i] > s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphfgzkvhb.rs:29:23\n   |\n29 |             if s[i] > s[j] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphfgzkvhb.rs:30:28\n\
    \   |\n30 |                 let temp = s[i];\n   |                           \
    \ ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmphfgzkvhb.rs:31:17\n   |\n31 |            \
    \     s[i] = s[j];\n   |                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphfgzkvhb.rs:31:24\n\
    \   |\n31 |                 s[i] = s[j];\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmphfgzkvhb.rs:32:17\n   |\n32 |                 s[j]\
    \ = temp;\n "
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[j..i]);\n                break;\n     \
    \       }\n            j += 1;\n        }\n        i += 1;\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpagzhyg4y.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpagzhyg4y.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] < 'A' || s[j] > 'Z' {\n                j = j + 1;\n               \
    \ continue;\n            }\n            new_s[new_s_len] = s[j];\n           \
    \ new_s_len += 1;\n            j = j + 1;\n        }\n        new_s[new_s_len]\
    \ = s[i];\n        new_s_len += 1;\n        i = i + 1;\n    }\n    new_s.truncate(new_s_len);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_lvkdzyj.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_lvkdzyj.rs:25:16\n   |\n25 |             if s[j] < 'A' || s[j]\
    \ > 'Z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_lvkdzyj.rs:25:30\n\
    \   |\n25 |             if s[j] < 'A' || s[j] > 'Z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_lvkdzyj.rs:29:13\n\
    \   |\n29 |             new_s[new_s_len] = s[j];\n   |             ^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp_lvkdzyj.rs:29:32\n   |\n29 |            \
    \ new_s[new_s_len] = s[j];\n   |                                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmp_lvkdzyj.rs:33:9\n   |\n33 |         new_s[new_s_len]\
    \ = s[i];\n   |         ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_lvkdzyj.rs:33:28\n\
    \   |\n33 |         new_s[new_s_len] = s[i];\n   |                           \
    \ ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 7 previous er"
  stdout: ''
  timestamp: 1659749324
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c| c\
    \ == ' ') {\n                j = s.len();\n            } else {\n            \
    \    let c = s.chars().nth(j).unwrap();\n                if c < s.chars().nth(j\
    \ - 1).unwrap() {\n                    new_s.push_str(&s.to_string());\n     \
    \               new_s_len += s.len();\n                    s = s.to_owned();\n\
    \                    break;\n                }\n                j = j - 1;\n \
    \           }\n        }\n        new_s.push_str(&s.to_string());\n        new_s_len\
    \ += s.len();\n        s = new_s;\n        new_s = String::new();\n        i +=\
    \ 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmplwsvuupz.rs:25:38

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k\
    \ .. j]);\n            i = j;\n        } else {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. k]);\n            i = k;\n     \
    \   }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphyd154hu.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphyd154hu.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                s[j] = s[j].to_ascii_lowercase();\n           \
    \ } else {\n                s[j] = s[j].to_ascii_uppercase();\n            }\n\
    \            new_s[new_s_len] = s[j];\n            new_s_len += 1;\n         \
    \   j += 1;\n        }\n        i += 1;\n    }\n    new_s.truncate(new_s_len);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptxz9j2am.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptxz9j2am.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmptxz9j2am.rs:26:17\n\
    \   |\n26 |                 s[j] = s[j].to_ascii_lowercase();\n   |          \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmptxz9j2am.rs:26:24\n   |\n26 |  \
    \               s[j] = s[j].to_ascii_lowercase();\n   |                      \
    \  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmptxz9j2am.rs:28:17\n   |\n28 |            \
    \     s[j] = s[j].to_ascii_uppercase();\n   |                 ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptxz9j2am.rs:28:24\n   |\n28 |                 s[j] = s[j].to_ascii_uppercase();\n\
    \   |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmptxz9j2am.rs:30:13\n\
    \   |\n30 |             new_s[new_s_len] = s[j];\n   |             ^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cann"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                new_s.push_str(&s[i .. j]);\n  \
    \              new_s_len += j - i;\n                i = j;\n                break;\n\
    \            }\n            j += 1; // skip the letter\n        }\n        if\
    \ j == s.len() {\n            new_s.push_str(&s[i ..]);\n            new_s_len\
    \ += s.len() - i;\n        }\n        i += 1;\n    }\n    new_s.truncate(new_s_len);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_pbvz52o.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_pbvz52o.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_pbvz52o.rs:25:30\n\
    \   |\n25 |             if s[j] < 'a' || s[j] > 'z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase().cmp(&s.chars().next().unwrap().to_ascii_lowercase())\
    \ < 0 {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s[i .. j]);\n        i = j;\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn649_t_l.rs:21:118\n   |\n\
    21 |             if s.chars().next().unwrap().to_ascii_lowercase().cmp(&s.chars().next().unwrap().to_ascii_lowercase())\
    \ < 0 {\n   |                                                                \
    \                                                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                j = j + 1;\n    \
    \            continue;\n            }\n            if s[j] > s[i] {\n        \
    \        let mut temp = s[j];\n                s[j] = s[i];\n                s[i]\
    \ = temp;\n                j = j + 1;\n                continue;\n           \
    \ }\n            j = j + 1;\n        }\n        new_s.push_str(&s[i..j]);\n  \
    \      i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphxl15eyj.rs:20:16\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphxl15eyj.rs:20:23\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphxl15eyj.rs:24:16\n\
    \   |\n24 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphxl15eyj.rs:24:23\n   |\n24 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphxl15eyj.rs:25:32\n\
    \   |\n25 |                 let mut temp = s[j];\n   |                       \
    \         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmphxl15eyj.rs:26:17\n   |\n26 |  \
    \               s[j] = s[i];\n   |                 ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmphxl15eyj.rs:26:24\n   |\n26 |                 s[j] = s[i];\n   |\
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphxl15eyj.rs:27:17\n\
    \   |\n27 |                "
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i, c)|\
    \ {\n        if c.is_whitespace() {\n            s.swap(i, s.len() - i - 1);\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpfi55zpc4.rs:17:15\n   |\n17 |             s.swap(i, s.len()\
    \ - i - 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                let mut k = j;\n                while k <\
    \ s.len() {\n                    if s[k] > s[i] {\n                        k =\
    \ k + 1;\n                        continue;\n                    }\n         \
    \           break;\n                }\n                new_s.push_str(&s[..k]);\n\
    \                new_s.push(' ');\n                new_s.push(i);\n          \
    \      new_s.push(' ');\n                new_s.push(' ');\n                new_s.push('\
    \ ');\n                new_s.push(' ');\n                new_s.push(' ');\n  \
    \              new_s.push(' ');\n                new_s.push(' ');\n          \
    \      new_s.push(' ');\n                new_s.push(' ');\n                new_s.push('\
    \ ');\n                new_s.push(' ');\n                new_s.push(' ');\n  \
    \              new_s.push(' ');\n                new_s.push(' ');\n          \
    \      new_s.push(' ');\n                new_s.push(' ');\n                new_s.push('\
    \ ');\n                new_s.push(' ');\n                new_s.push(' ');\n  \
    \              new_s.push(' ');\n                new_s.push(' ');\n          \
    \      new_s.push(' ');\n                new_s.push(' ');\n                new_s.push('\
    \ ');\n                new_s.push(' ');\n                new_s.push(' ');\n  \
    \              new_s.push(' ');\n                new_s.push(' ');\n          \
    \      new_s.push(' ');\n                new_s.push(' ');\n                new_s.push('\
    \ ');\n                new_s.push(' ');\n                new_s.push(' ');\n  \
    \              new_s.push(' ');\n                new_s.push(' ');\n          \
    \      new_s.push(' ');\n                new_s.push(' ');\n                new_s.push('\
    \ ');\n                new_s.push(' ');\n                new_s.push(' ');\n  \
    \              new_s.push(' ');\n                new_s.push(' ');\n          \
    \      new_s.push(' ');\n                new_s.push(' ');\n                new_s.push('\
    \ ');\n                new_s.push(' ');\n                new_s.push(' ');\n  \
    \              new_s.push(' ');\n                new_s.push(' ');\n          \
    \      new_s.push(' ');\n                new_s.push(' ');\n                new_s.push('\
    \ ');\n                new_s.push(' ');\n                new_s.push(' ');\n  \
    \              new_s.push(' ');\n                new_s.push(' ');\n          \
    \      new_s.push(' ');\n                new_s.push(' ');\n                new_s.push('\
    \ ');\n                new_s.push(' ');\n                new_s.push(' ');\n  \
    \              new_s.push(' ');\n                new_s.push(' ');\n          \
    \      new_s.push(' ');\n                new_s.push(' ');\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmporxjzlnj.rs:113:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < s.len() {\n\
    \    |                       - unclosed delimiter\n19  |         let mut j = i;\n\
    20  |         while j < s.len() {\n    |                           - unclosed\
    \ delimiter\n...\n25  |             if s[j] > s[i] {\n    |                  \
    \          - this delimiter might not be properly closed...\n...\n102 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n113 | }\n\
    \    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmporxjzlnj.rs:21:16\n   |\n21 |             if s[j] < s[i] {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmporxjzlnj.rs:21:23\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmporxjzlnj.rs:25:16\n   |\n25 |             if s[j]\
    \ > s[i] {\n   |                ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmporxjzlnj.rs:25:23\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmporxjzlnj.rs:28:24\n   |\n28 |                    \
    \ if s[k] > s[i] {\n   |                        ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + 1;\n        new_s.push_str(&s[i\
    \ .. j]);\n        new_s.push_str(&s[j .. i]);\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp96n6enfb.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp96n6enfb.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[j]);\n                new_s.push_str(&s[i]);\n\
    \                break;\n            }\n            j += 1;\n        }\n     \
    \   i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp21vye127.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp21vye127.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp21vye127.rs:22:33\n\
    \   |\n22 |                 new_s.push_str(&s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp21vye127.rs:23:33\n   |\n\
    23 |                 new_s.push_str(&s[i]);\n   |                            \
    \     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxofcaye1.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxofcaye1.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                j += 1;\n       \
    \     } else {\n                break;\n            }\n        }\n        if j\
    \ > i {\n            new_s.push_str(&s[i .. j]);\n            new_s.push_str(&s[j\
    \ .. i]);\n            i = j;\n        } else {\n            new_s.push_str(&s[i\
    \ .. i]);\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppfpmfq0d.rs:20:16\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppfpmfq0d.rs:20:23\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j].is_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_digit() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_upper() {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j].is_ascii_lower() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_letter() {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s[j].is_ascii_symbol()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_whitespace() {\n                j = j + 1;\n     \
    \           continue;\n            }\n            if s[j].is_ascii_lower() {\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_upper() {\n                j = j + 1;\n              \
    \  continue;\n            }\n            if s[j].is_ascii_digit() {\n        \
    \        j = j + 1;\n                continue;\n            }\n            if\
    \ s[j].is_ascii_letter() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_symbol() {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s[j].is_ascii_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_lower() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_upper() {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j].is_ascii_digit() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_letter() {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s[j].is_ascii_symbol()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_whitespace() {\n                j = j + 1;\n     \
    \           continue;\n            }\n            if s[j].is_ascii_lower() {\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_upper() {\n                j = j + 1;\n              \
    \  continue;\n            }\n            if s[j].is_ascii_digit() {\n        \
    \        j = j + 1;\n                continue;\n            }\n            if\
    \ s[j].is_ascii_letter() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_symbol() {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s[j].is_ascii_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_lower() {\n                j = j + 1;\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp38d1obuf.rs:134:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < new_s_len\
    \ {\n    |                         - unclosed delimiter\n19  |         let mut\
    \ j = i;\n20  |         while j < new_s_len {\n    |                         \
    \    - unclosed delimiter\n...\n121 |             if s[j].is_ascii_lower() {\n\
    \    |                                      - this delimiter might not be properly\
    \ closed...\n122 |                 j = j + 1;\n123 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp38d1obuf.rs:21:16\n\
    \   |\n21 |             if s[j].is_whitespace() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp38d1obuf.rs:25:16\n   |\n25 |             if s[j].is_ascii_digit()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp38d1obuf.rs:29:16\n\
    \   |\n29 |             if s[j].is_ascii_upper() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp38d1obuf.rs:33:16\n   |\n33 |             if s[j].is_ascii_lower()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp38d1obuf.rs:37:16\n\
    \   |\n37 |             if s[j].is_ascii_letter() {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemen"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] == '\
    \ ' && s[j] != ' ' {\n                s[j] = s[j].to_ascii_lowercase();\n    \
    \            j += 1;\n            }\n            i += 1;\n        }\n        new_s.push_str(&s[..j]);\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7v8xhcsw.rs:21:16\n\
    \   |\n21 |             if s[i] == ' ' && s[j] != ' ' {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp7v8xhcsw.rs:21:31\n   |\n21 |            \
    \ if s[i] == ' ' && s[j] != ' ' {\n   |                               ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp7v8xhcsw.rs:22:17\n   |\n22 |                 s[j]\
    \ = s[j].to_ascii_lowercase();\n   |                 ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp7v8xhcsw.rs:22:24\n   |\n22 |                 s[j] = s[j].to_ascii_lowercase();\n\
    \   |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv3ryiwdw.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmpv3ryiwdw.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv3ryiwdw.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k\
    \ .. j]);\n            i = j;\n        } else {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. k]);\n            i = k;\n     \
    \   }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphyd154hu.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphyd154hu.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i, c)|\
    \ {\n        if c.is_whitespace() {\n            s.swap(i, s.len() - i - 1);\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpfi55zpc4.rs:17:15\n   |\n17 |             s.swap(i, s.len()\
    \ - i - 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        if j == new_s_len {\n            break;\n\
    \        }\n        let mut k = i;\n        while k < new_s_len && s[k].is_whitespace()\
    \ {\n            k = k + 1;\n        }\n        if k == new_s_len {\n        \
    \    break;\n        }\n        let mut new_word = String::new();\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[k..new_s_len]);\n        new_s.push_str(&new_word);\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1i3hiqyt.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1i3hiqyt.rs:27:32\n\
    \   |\n27 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                j = j + 1;\n    \
    \        } else {\n                break;\n            }\n        }\n        new_s.push_str(&s[i\
    \ .. j]);\n        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu1iz_wak.rs:20:16\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu1iz_wak.rs:20:23\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().any(|c|\
    \ c == ' ' || c == '.' || c == '!') {\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[j..]);\n                break;\n          \
    \  }\n            j += 1\n        }\n        i += 1;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Hi\"`', /tmp/tmp4j2cpdnp.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j].is_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_lowercase() {\n                let mut new_word =\
    \ String::new();\n                new_word.push_str(&s[j]);\n                new_word.push_str(&s[j\
    \ + 1]);\n                new_word.push_str(&s[j + 2]);\n                new_word.push_str(&s[j\
    \ + 3]);\n                new_word.push_str(&s[j + 4]);\n                new_word.push_str(&s[j\
    \ + 5]);\n                new_word.push_str(&s[j + 6]);\n                new_word.push_str(&s[j\
    \ + 7]);\n                new_word.push_str(&s[j + 8]);\n                new_word.push_str(&s[j\
    \ + 9]);\n                new_word.push_str(&s[j + 10]);\n                new_word.push_str(&s[j\
    \ + 11]);\n                new_word.push_str(&s[j + 12]);\n                new_word.push_str(&s[j\
    \ + 13]);\n                new_word.push_str(&s[j + 14]);\n                new_word.push_str(&s[j\
    \ + 15]);\n                new_word.push_str(&s[j + 16]);\n                new_word.push_str(&s[j\
    \ + 17]);\n                new_word.push_str(&s[j + 18]);\n                new_word.push_str(&s[j\
    \ + 19]);\n                new_word.push_str(&s[j + 20]);\n                new_word.push_str(&s[j\
    \ + 21]);\n                new_word.push_str(&s[j + 22]);\n                new_word.push_str(&s[j\
    \ + 23]);\n                new_word.push_str(&s[j + 24]);\n                new_word.push_str(&s[j\
    \ + 25]);\n                new_word.push_str(&s[j + 26]);\n                new_word.push_str(&s[j\
    \ + 27]);\n                new_word.push_str(&s[j + 28]);\n                new_word.push_str(&s[j\
    \ + 29]);\n                new_word.push_str(&s[j + 30]);\n                new_word.push_str(&s[j\
    \ + 31]);\n                new_word.push_str(&s[j + 32]);\n                new_word.push_str(&s[j\
    \ + 33]);\n                new_word.push_str(&s[j + 34]);\n                new_word.push_str(&s[j\
    \ + 35]);\n                new_word.push_str(&s[j + 36]);\n                new_word.push_str(&s[j\
    \ + 37]);\n                new_word.push_str(&s[j + 38]);\n                new_word.push_str(&s[j\
    \ + 39]);\n                new_word.push_str(&s[j + 40]);\n                new_word.push_str(&s[j\
    \ + 41]);\n                new_word.push_\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpk7wb47kp.rs:81:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n19 |         let mut j = i;\n\
    20 |         while j < new_s_len {\n   |                             - unclosed\
    \ delimiter\n...\n25 |             if s[j].is_ascii_lowercase() {\n   |      \
    \                                    - this delimiter might not be properly closed...\n\
    ...\n70 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    81 | }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk7wb47kp.rs:21:16\n   |\n21 |             if s[j].is_whitespace()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk7wb47kp.rs:25:16\n\
    \   |\n25 |             if s[j].is_ascii_lowercase() {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpk7wb47kp.rs:27:36\n   |\n27 |            \
    \     new_word.push_str(&s[j]);\n   |                                    ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpk7wb47kp.rs:28:36\n   |\n28 |            \
    \     new_word.push_str(&s[j + 1]);\n   |                                    ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpk7wb47kp.rs:29:36\n   |\n29 |            \
    \     new_word.push_str(&s[j + 2]);\n   |                                    ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j].is_whitespace()\
    \ {\n                j += 1;\n                continue;\n            }\n     \
    \       if s[j].is_ascii_lowercase() {\n                let mut new_char = s[j];\n\
    \                while j > i && s[j].is_ascii_lowercase() {\n                \
    \    s[j] = s[j - 1];\n                    j -= 1;\n                }\n      \
    \          s[j] = new_char;\n                i += 1;\n                break;\n\
    \            }\n            j += 1;\n        }\n        if i == j {\n        \
    \    new_s.push_str(&s[i .. new_s_len]);\n            i += 1;\n        }\n   \
    \ }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxwg8yaf9.rs:21:16\n\
    \   |\n21 |             if s[j].is_whitespace() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpxwg8yaf9.rs:25:16\n   |\n25 |             if s[j].is_ascii_lowercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxwg8yaf9.rs:26:36\n\
    \   |\n26 |                 let mut new_char = s[j];\n   |                   \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxwg8yaf9.rs:27:32\n\
    \   |\n27 |                 while j > i && s[j].is_ascii_lowercase() {\n   | \
    \                               ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxwg8yaf9.rs:28:21\n\
    \   |\n28 |                     s[j] = s[j - 1];\n   |                     ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpxwg8yaf9.rs:28:28\n   |\n28 |            \
    \         s[j] = s[j - 1];\n   |                            ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpxwg8yaf9.rs:31:17\n   |\n31 |                 s[j]\
    \ = new_char;\n   |                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to"
  stdout: ''
  timestamp: 1659749324
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749330
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749330
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  let mut k = 0;\n    while i < s.len() {\n        while j < s.len() {\n    \
    \        if s[i].chars().max().unwrap() < s[j].chars().max().unwrap() {\n    \
    \            k = i;\n                break;\n            }\n            j += 1\n\
    \        }\n        if k == i {\n            i += 1;\n        } else {\n     \
    \       s[k] = s[i];\n            s[k].chars()\n                .sort_by(|a, b|\
    \ a.cmp(&b))\n                .collect()\n                .swap(0, k);\n     \
    \       i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa9jwzwsc.rs:20:16\n\
    \   |\n20 |             if s[i].chars().max().unwrap() < s[j].chars().max().unwrap()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa9jwzwsc.rs:20:46\n\
    \   |\n20 |             if s[i].chars().max().unwrap() < s[j].chars().max().unwrap()\
    \ {\n   |                                              ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa9jwzwsc.rs:29:13\n   |\n29 |             s[k] = s[i];\n   |  \
    \           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpa9jwzwsc.rs:29:20\n   |\n29 |  \
    \           s[k] = s[i];\n   |                    ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpa9jwzwsc.rs:30:13\n   |\n30 |             s[k].chars()\n   |   \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        if j < new_s_len {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. new_s_len]);\n            i = j;\n\
    \        } else {\n            new_s.push_str(&s[i .. new_s_len]);\n         \
    \   i = new_s_len;\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9i_r4l7c.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len.saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp6lp6fnir.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp6lp6fnir.rs:17:1663\n   |\n13 | fn anti_shuffle(s: String) -> String\
    \ {\n   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut new_s_len2 = new_s_len.saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len / 2).saturating_add((new_s_len\
    \ / 2).satur"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv3ryiwdw.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmpv3ryiwdw.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv3ryiwdw.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.sort_by_key(|&x| x.chars().count());\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpd00_3qep.rs:15:7\n   |\n15 |     s.sort_by_key(|&x|\
    \ x.chars().count());\n   |       ^^^^^^^^^^^ method not found in `String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                j = j + 1;\n    \
    \        } else {\n                break;\n            }\n        }\n        let\
    \ mut new_char = s[i..j];\n        new_char = new_char.iter().cloned().collect();\n\
    \        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char\
    \ = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char\
    \ = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char\
    \ = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char\
    \ = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char\
    \ = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char\
    \ = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char\
    \ = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n\
    \        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char\
    \ = new_char.iter().cloned().collect::<Vec<_>>();\n        new_char = new_char.iter().cloned().collect::<Vec<_>>();\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvypavvrq.rs:63:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n17 |     while i < s.len() {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    52 | }\n   | - ...as it matches this but it has different indentation\n...\n63\
    \ | }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvypavvrq.rs:20:16\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvypavvrq.rs:20:23\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0599]: no method named `iter` found for type\
    \ `str` in the current scope\n  --> /tmp/tmpvypavvrq.rs:27:29\n   |\n27 |    \
    \     new_char = new_char.iter().cloned().collect();\n   |                   \
    \          ^^^^ method not found in `str`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmpvypavvrq.rs:26:13\n\
    \   |\n26 |         let mut new_char = s[i..j];\n   |             ^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n26 |         let mut new_char = &s[i..j];\n \
    \  |                            +\n\nerror[E0599]: no method named `iter` found\
    \ for type `str` in the current scope\n  --> /tmp/tmpvypavvrq.rs:28:29\n   |\n\
    28 |         new_char = new_char.iter().cloned().collect::<Vec<_>>();\n   |  \
    \                           ^^^^ method not found in `str`\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < s.len()\
    \ {\n        let mut c = s.chars().nth(i);\n        let mut new_c = String::new();\n\
    \        while c != ' ' {\n            new_c.push(*c);\n            i += 1;\n\
    \            c = s.chars().nth(i);\n        }\n        new_s_len += 1;\n     \
    \   new_s.push(*new_c);\n        while j < new_s_len {\n            let mut c\
    \ = new_s.chars().nth(j);\n            let mut new_c = String::new();\n      \
    \      while c != ' ' {\n                new_c.push(*c);\n                j +=\
    \ 1;\n                c = new_s.chars().nth(j);\n            }\n            new_s_len\
    \ += 1;\n            new_s.push(*new_c);\n        }\n    }\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoea6g2pz.rs:22:20\n   |\n\
    22 |         while c != ' ' {\n   |                    ^^^\n   |             \
    \       |\n   |                    expected enum `Option`, found `char`\n   |\
    \                    help: try using a variant of the expected enum: `Some(' ')`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    \nerror[E0614]: type `Option<char>` cannot be dereferenced\n  --> /tmp/tmpoea6g2pz.rs:23:24\n\
    \   |\n23 |             new_c.push(*c);\n   |                        ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoea6g2pz.rs:28:20\n   |\n28 |         new_s.push(*new_c);\n\
    \   |                    ^^^^^^ expected `char`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoea6g2pz.rs:32:24\n   |\n32 |             while\
    \ c != ' ' {\n   |                        ^^^\n   |                        |\n\
    \   |                        expected enum `Option`, found `char`\n   |      \
    \                  help: try using a variant of the expected enum: `Some(' ')`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    \nerror[E0614]: type `Option<char>` cannot be dereferenced\n  --> /tmp/tmpoea6g2pz.rs:33:28\n\
    \   |\n33 |                 new_c.push(*c);\n   |                            ^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoea6g2pz.rs:38:24\n   |\n38 |\
    \             new_s.push(*new_c);\n   |                        ^^^^^^ expected\
    \ `char`, found `str`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        new_s.push_str(&s[i]);\n     \
    \   new_s_len += 1;\n        i += 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpezs2fb8m.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpezs2fb8m.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpezs2fb8m.rs:27:25\n   |\n27 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                new_s.push_char(s[j]);\n                new_s_len\
    \ += 1;\n            }\n            j += 1\n        }\n        new_s.push_str(&s[i\
    \ .. j]);\n        new_s_len += j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s_len += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0lohm2b3.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0lohm2b3.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0599]: no\
    \ method named `push_char` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp0lohm2b3.rs:26:23\n   |\n26 |                 new_s.push_char(s[j]);\n\
    \   |                       ^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `push_str`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp0lohm2b3.rs:26:33\n   |\n26 |                 new_s.push_char(s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().any(|c|\
    \ c == ' ') {\n                j = j + 1;\n                continue;\n       \
    \     }\n            if s.chars().any(|c| c == '\\n') {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\t') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\r') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\a') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\v') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\f') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\e') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\a') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\v') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\f') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\e') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\a') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\v') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\f') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\e') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `b`\n  --> /tmp/tmpxqbsm2xk.rs:37:41\n\
    \   |\n37 |             if s.chars().any(|c| c == '\\b') {\n   |             \
    \                            ^ unknown character escape\n   |\n   = help: for\
    \ more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    \nerror: unknown character escape: `a`\n  --> /tmp/tmpxqbsm2xk.rs:41:41\n   |\n\
    41 |             if s.chars().any(|c| c == '\\a') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `v`\n  --> /tmp/tmpxqbsm2xk.rs:45:41\n   |\n\
    45 |             if s.chars().any(|c| c == '\\v') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `f`\n  --> /tmp/tmpxqbsm2xk.rs:49:41\n   |\n\
    49 |             if s.chars().any(|c| c == '\\f') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `e`\n  --> /tmp/tmpxqbsm2xk.rs:53:41\n   |\n\
    53 |             if s.chars().any(|c| c == '\\e') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `b`\n  --> /tmp/tmpxqbsm2xk.rs:57:41\n   |\n\
    57 |             if s.chars().any(|c| c == '\\b') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `a`\n  --> /tmp/tmpxqbsm2xk.rs:61:41\n   |\n\
    61 |             if s.chars().any(|c| c == '\\a') {\n   |                    \
    \                     ^ unknown character escape\n   "
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxofcaye1.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxofcaye1.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        if j == new_s_len {\n            break;\n\
    \        }\n        let mut k = i;\n        while k < new_s_len && s[k].is_whitespace()\
    \ {\n            k = k + 1;\n        }\n        if k == new_s_len {\n        \
    \    break;\n        }\n        let mut new_s_char = new_s[new_s_len - 1];\n \
    \       let mut new_s_char_len = new_s_char.len();\n        let mut new_s_char_pos\
    \ = new_s_len - 1;\n        let mut new_s_char_pos_len = new_s_char_pos.len();\n\
    \        let mut new_s_char_pos_pos = new_s_char_pos_len - 1;\n        while new_s_char_pos_pos\
    \ >= 0 {\n            let mut new_s_char_pos_char = new_s_char_pos[new_s_char_pos_pos];\n\
    \            let mut new_s_char_pos_char_len = new_s_char_pos_char.len();\n  \
    \          let mut new_s_char_pos_char_pos = new_s_char_pos_pos - 1;\n       \
    \     while new_s_char_pos_char_pos >= 0 {\n                if new_s_char_pos_char\
    \ == new_s_char_char {\n                    new_s_char_pos_char_pos = new_s_char_pos_char_pos\
    \ - 1;\n                    break;\n                }\n                new_s_char_pos_char_pos\
    \ = new_s_char_pos_char_pos - 1;\n                new_s_char_pos_char = new_s_char_pos_char.chars().next().unwrap();\n\
    \                new_s_char_pos_char_len = new_s_char_pos_char.len();\n      \
    \      }\n            new_s_char_pos_pos = new_s_char_pos_pos - 1;\n         \
    \   new_s_char_pos_char = new_s_char_pos_char.chars().next().unwrap();\n     \
    \       new_s_char_pos_char_len = new_s_char_pos_char.len();\n        }\n    \
    \    new_s_char_pos_pos = new_s_char_pos_pos + 1;\n        new_s_char_pos_char\
    \ = new_s_char_pos_char.chars().next().unwrap();\n        new_s_char_pos_char_len\
    \ = new_s_char_pos_char.len();\n        new_s_char_pos_char.push_str(&s[i .. new_s_len]);\n\
    \        new_s_char_pos_char.push_str(&s[new_s_len .. j]);\n        new_s_char_pos_char.push_str(&s[j\
    \ .. k]);\n        new_s_char_pos_char.push_str(&s[k .. new_s_len]);\n       \
    \ new_s_char_pos_char.push_str(&s[new_s_len .. new_s_char_pos_pos\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5eopo93b.rs:74:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - this delimiter might not be properly closed...\n\
    ...\n63 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    74 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp5eopo93b.rs:62:40\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n62 |     \
    \    new_s_char_pos_char.push_str(&s[new_s_len .. new_s_char_pos_pos\n   |   \
    \                                     ^ unclosed delimiter\n63 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0425]: cannot find value `new_s_char_char` in this\
    \ scope\n  --> /tmp/tmp5eopo93b.rs:43:43\n   |\n43 |                 if new_s_char_pos_char\
    \ == new_s_char_char {\n   |                                           ^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `new_s_char_len`\n\nerror[E0425]:\
    \ cannot find value `new_s_char_pos_char` in this scope\n  --> /tmp/tmp5eopo93b.rs:56:9\n\
    \   |\n56 |         new_s_char_pos_char = new_s_char_pos_char.chars().next().unwrap();\n\
    \   |         ^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `new_s_char_pos_len`\n\nerror[E0425]: cannot find value `new_s_char_pos_char`\
    \ in this scope\n  --> /tmp/tmp5eopo93b.rs:56:31\n   |\n56 |         new_s_char_pos_char\
    \ = new_s_char_pos_char.chars().next().unwrap();\n   |                       \
    \        ^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `new_s_char_pos_len`\n\nerror[E0425]: cannot find value `new_s_char_pos_char_len`\
    \ in this scope\n  --> /tmp/tmp5eopo93b.rs:57:9\n   |\n57 |         new_s_char_pos_char_len\
    \ = new_s_char_pos_char.len();\n   |         ^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `new_s_char_pos_len`\n\nerror[E0425]: cannot\
    \ find value `new_s_char_pos_char` in this scope"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let j = i + 1;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                s.swap(i,\
    \ j);\n            }\n            i += 1;\n            j += 1\n        }\n   \
    \ }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpotwv_2ug.rs:20:19\n   |\n20 |                 s.swap(i,\
    \ j);\n   |                   ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s[i .. j]);\n        i = j;\n\
    \    }\n    new_s.push_str(&s[i ..]);\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp52r8rtt_.rs:21:118\n   |\n\
    21 |             if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n   |                                                                \
    \                                                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut new_s_len5 =\
    \ new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7 = new_s_len;\n\
    \    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 = new_s_len;\n  \
    \  let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 = new_s_len;\n  \
    \  let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 = new_s_len;\n  \
    \  let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 = new_s_len;\n  \
    \  let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 = new_s_len;\n  \
    \  let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 = new_s_len;\n  \
    \  let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 = new_s_len;\n  \
    \  let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 = new_s_len;\n  \
    \  let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 = new_s_len;\n  \
    \  let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 = new_s_len;\n  \
    \  let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 = new_s_len;\n  \
    \  let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 = new_s_len;\n  \
    \  let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 = new_s_len;\n  \
    \  let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 = new_s_len;\n  \
    \  let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 = new_s_len;\n  \
    \  let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 = new_s_len;\n  \
    \  let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 = new_s_len;\n  \
    \  let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 = new_s_len;\n  \
    \  let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 = new_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpclun_hhh.rs:60:31\n   |\n\
    60 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmpclun_hhh.rs:60:27\n   |\n60 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpclun_hhh.rs:13:31\n   |\n13 | fn anti_shuffle(s: String) -> String {\n\
    \   |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().nth(j).unwrap().to_ascii_lowercase()\
    \ < s.chars().nth(i).unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749330
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s.chars().any(|c| c == ' ') {\n                j\
    \ = s.len();\n            } else {\n                let c = s.chars().nth(j).unwrap();\n\
    \                new_s.push_char(c);\n                j = j + 1;\n           \
    \ }\n        }\n        new_s.push_char(s.chars().nth(i).unwrap());\n        i\
    \ = i + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_char` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpwj10kybh.rs:24:23\n   |\n24 |             \
    \    new_s.push_char(c);\n   |                       ^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `push_str`\n\nerror[E0599]: no method\
    \ named `push_char` found for struct `String` in the current scope\n  --> /tmp/tmpwj10kybh.rs:28:15\n\
    \   |\n28 |         new_s.push_char(s.chars().nth(i).unwrap());\n   |        \
    \       ^^^^^^^^^ help: there is an associated function with a similar name: `push_str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1; // skip space\n        }\n        let mut new_word = String::new();\n\
    \        while j < new_s_len && s[j] != ' ' {\n            new_word.push(s[j]);\n\
    \            j += 1; // skip space\n        }\n        new_s.push_str(new_word);\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpneltlk5g.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpneltlk5g.rs:24:32\n\
    \   |\n24 |         while j < new_s_len && s[j] != ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpneltlk5g.rs:25:27\n\
    \   |\n25 |             new_word.push(s[j]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpneltlk5g.rs:28:24\n\
    \   |\n28 |         new_s.push_str(new_word);\n   |                        ^^^^^^^^\n\
    \   |                        |\n   |                        expected `&str`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&new_word`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().sort_by(|a, b| a.cmp(b));\n \
    \   s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpl_tv3h89.rs:15:15\n   |\n15 |     s.chars().sort_by(|a,\
    \ b| a.cmp(b));\n   |               ^^^^^^^ method not found in `Chars<'_>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[j].is_whitespace()\
    \ {\n                j += 1;\n                continue;\n            }\n     \
    \       if s[j].is_ascii_lowercase() {\n                let mut new_j = j;\n \
    \               while new_j < new_s_len && new_s[j].is_ascii_lowercase() {\n \
    \                   new_j += 1;\n                }\n                new_s_len\
    \ = new_j;\n                i += 1;\n                j += 1;\n               \
    \ continue;\n            }\n            if s[j].is_ascii_uppercase() {\n     \
    \           let mut new_j = j;\n                while new_j < new_s_len && new_s[j].is_ascii_uppercase()\
    \ {\n                    new_j += 1;\n                }\n                new_s_len\
    \ = new_j;\n                i += 1;\n                j += 1;\n               \
    \ continue;\n            }\n            if s[j].is_ascii_digit() {\n         \
    \       let mut new_j = j;\n                while new_j < new_s_len && new_s[j].is_ascii_digit()\
    \ {\n                    new_j += 1;\n                }\n                new_s_len\
    \ = new_j;\n                i += 1;\n                j += 1;\n               \
    \ continue;\n            }\n            if s[j].is_ascii_punctuation() {\n   \
    \             let mut new_j = j;\n                while new_j < new_s_len && new_s[j].is_ascii_punctuation()\
    \ {\n                    new_j += 1;\n                }\n                new_s_len\
    \ = new_j;\n                i += 1;\n                j += 1;\n               \
    \ continue;\n            }\n            if s[j].is_ascii_letter() {\n        \
    \        let mut new_j = j;\n                while new_j < new_s_len && new_s[j].is_ascii_letter()\
    \ {\n                    new_j += 1;\n                }\n                new_s_len\
    \ = new_j;\n                i += 1;\n                j += 1;\n               \
    \ continue;\n            }\n            if s[j].is_ascii_whitespace() {\n    \
    \            let mut new_j = j;\n                while new_j < new_s_len && new_s[j].is_ascii_whitespace()\
    \ {\n                    new_j += 1;\n                }\n                new_s_len\
    \ = new_j;\n                i += 1;\n                j += 1;\n               \
    \ continue;\n            }\n            if s[j].is_ascii_symbol() {\n        \
    \        let mut new_j = j;\n                while new_j < new_s_len && new_s[j].is_ascii_symbol()\
    \ {\n                    new_j += 1;\n                }\n                new_s_len\
    \ = new_j;\n                i += 1;\n                j += 1;\n               \
    \ continue;\n            }\n            if s[j].is_ascii_uppercase_letter() {\n\
    \                let mut new_j = j;\n                while new_j < \n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpmzr4wo9g.rs:109:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < s.len() {\n\
    \    |                       - unclosed delimiter\n19  |         let mut j = i;\n\
    20  |         while j < s.len() {\n    |                           - unclosed\
    \ delimiter\n...\n95  |             if s[j].is_ascii_uppercase_letter() {\n  \
    \  |                                                 - this delimiter might not\
    \ be properly closed...\n...\n98  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n109 | }\n    |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmpmzr4wo9g.rs:98:1\n   |\n98 | }\n   | ^ expected expression\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmzr4wo9g.rs:21:16\n\
    \   |\n21 |             if s[j].is_whitespace() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpmzr4wo9g.rs:25:16\n   |\n25 |             if s[j].is_ascii_lowercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmzr4wo9g.rs:27:44\n\
    \   |\n27 |                 while new_j < new_s_len && new_s[j].is_ascii_lowercase()\
    \ {\n   |                                            ^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmzr4wo9g.rs:35:16\n   |\n35 |             if s[j].is_ascii_uppercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmzr4wo9g.rs:37:44"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[j]);\n                break;\n        \
    \    }\n            j += 1;\n        }\n        if j == new_s_len {\n        \
    \    new_s.push_str(&s[i]);\n        }\n        i += 1;\n    }\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1unomc45.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1unomc45.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1unomc45.rs:22:33\n\
    \   |\n22 |                 new_s.push_str(&s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp1unomc45.rs:28:29\n   |\n\
    28 |             new_s.push_str(&s[i]);\n   |                             ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j].is_whitespace()\
    \ {\n                j += 1;\n                continue;\n            }\n     \
    \       if s[j].is_ascii_lowercase() {\n                let mut new_char = s[j];\n\
    \                while new_char.is_ascii_lowercase() {\n                    new_char\
    \ = new_char.swapcase();\n                }\n                new_s.push_str(&new_char);\n\
    \                new_s_len += 1;\n                j += 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_uppercase() {\n                let\
    \ mut new_char = s[j];\n                while new_char.is_ascii_uppercase() {\n\
    \                    new_char = new_char.swapcase();\n                }\n    \
    \            new_s.push_str(&new_char);\n                new_s_len += 1;\n   \
    \             j += 1;\n                continue;\n            }\n            if\
    \ s[j].is_ascii_digit() {\n                let mut new_char = s[j];\n        \
    \        while new_char.is_ascii_digit() {\n                    new_char = new_char.swapcase();\n\
    \                }\n                new_s.push_str(&new_char);\n             \
    \   new_s_len += 1;\n                j += 1;\n                continue;\n    \
    \        }\n            if s[j].is_ascii_punctuation() {\n                let\
    \ mut new_char = s[j];\n                while new_char.is_ascii_punctuation()\
    \ {\n                    new_char = new_char.swapcase();\n                }\n\
    \                new_s.push_str(&new_char);\n                new_s_len += 1;\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s[j].is_ascii_letter() {\n                let mut new_char = s[j];\n  \
    \              while new_char.is_ascii_letter() {\n                    new_char\
    \ = new_char.swapcase();\n                }\n                new_s.push_str(&new_char);\n\
    \                new_s_len += 1;\n                j += 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_symbol() {\n                let mut\
    \ new_char = s[j];\n                while new_char.is_ascii_symbol() {\n     \
    \               new_char = new_char.swapcase();\n                }\n         \
    \       new_s.push_str(&new_char);\n                new_s_len += 1;\n        \
    \        j += 1;\n                continue;\n            }\n            if s[j].is_ascii_lowercase()\
    \ {\n                let mut new_char = s[j];\n                while new_char.is_ascii_lowercase()\
    \ {\n                    new_char = new_char.swapcase();\n                }\n\
    \                new_s.push_str(&new_char);\n                new_s_len += 1;\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s[j].is_ascii_uppercase() {\n                let mut new_char = s[j];\n\
    \n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpzmudvv96.rs:109:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < s.len() {\n\
    \    |                       - unclosed delimiter\n19  |         let mut j = i;\n\
    20  |         while j < s.len() {\n    |                           - unclosed\
    \ delimiter\n...\n95  |             if s[j].is_ascii_uppercase() {\n    |    \
    \                                      - this delimiter might not be properly\
    \ closed...\n...\n98  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n109 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpzmudvv96.rs:21:16\n   |\n21 |         \
    \    if s[j].is_whitespace() {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpzmudvv96.rs:25:16\n   |\n25 |             if s[j].is_ascii_lowercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzmudvv96.rs:26:36\n\
    \   |\n26 |                 let mut new_char = s[j];\n   |                   \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzmudvv96.rs:35:16\n\
    \   |\n35 |             if s[j].is_ascii_uppercase() {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpzmudvv96.rs:36:36\n   |\n36 |            \
    \     let mut new_char = s[j];\n   |                                    ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<u"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + 1;\n        if j\
    \ > i {\n            new_s.push_str(&s[i .. j]);\n            new_s.push_str(&s[j\
    \ .. i]);\n        }\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n \
    \   new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpr4aex3x6.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpr4aex3x6.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                new_s.push_str(&s[i .. j]);\n  \
    \              new_s_len += j - i;\n                i = j;\n                break;\n\
    \            }\n            j += 1;\n        }\n        if j == s.len() {\n  \
    \          new_s.push_str(&s[i ..]);\n            new_s_len += s.len() - i;\n\
    \            i += 1;\n        }\n    }\n    new_s.truncate(new_s_len);\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf013saqh.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf013saqh.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf013saqh.rs:25:30\n\
    \   |\n25 |             if s[j] < 'a' || s[j] > 'z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                new_s.push_str(&s[i .. j]);\n           \
    \     new_s_len += j - i;\n                i = j;\n                break;\n  \
    \          }\n            j = j + 1;\n        }\n        if j == s.len() {\n \
    \           new_s.push_str(&s[i .. i]);\n            new_s_len += i - i;\n   \
    \     }\n    }\n    new_s.truncate(new_s_len);\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuiuu27rv.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuiuu27rv.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuiuu27rv.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuiuu27rv.rs:25:23\n   |\n25 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < s.len()\
    \ {\n        let mut new_s_len = new_s_len + 1;\n        while j < s.len() {\n\
    \            if s[i] == s[j] {\n                new_s_len = new_s_len + 1;\n \
    \               j = j + 1;\n            } else {\n                break;\n   \
    \         }\n        }\n        new_s.push(' ');\n        new_s.push(&s[new_s_len..new_s_len\
    \ + new_s_len]);\n        i = i + 1;\n    }\n    new_s\n}\n\nfn main() {\n   \
    \ let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsvxemrc1.rs:22:16\n\
    \   |\n22 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsvxemrc1.rs:22:24\n   |\n22 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsvxemrc1.rs:30:20\n   |\n30 |         new_s.push(&s[new_s_len..new_s_len\
    \ + new_s_len]);\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().any(|c|\
    \ c == ' ') {\n                j = new_s_len;\n                break;\n      \
    \      }\n            if s.chars().any(|c| c == '\\n') {\n                j =\
    \ new_s_len;\n                break;\n            }\n            if s.chars().any(|c|\
    \ c == '\\t') {\n                j = new_s_len;\n                break;\n    \
    \        }\n            if s.chars().any(|c| c == '\\b') {\n                j\
    \ = new_s_len;\n                break;\n            }\n            if s.chars().any(|c|\
    \ c == '\\r') {\n                j = new_s_len;\n                break;\n    \
    \        }\n            if s.chars().any(|c| c == '\\f') {\n                j\
    \ = new_s_len;\n                break;\n            }\n            if s.chars().any(|c|\
    \ c == '\\r') {\n                j = new_s_len;\n                break;\n    \
    \        }\n            if s.chars().any(|c| c == '\\n') {\n                j\
    \ = new_s_len;\n                break;\n            }\n            if s.chars().any(|c|\
    \ c == '\\t') {\n                j = new_s_len;\n                break;\n    \
    \        }\n            if s.chars().any(|c| c == '\\b') {\n                j\
    \ = new_s_len;\n                break;\n            }\n            if s.chars().any(|c|\
    \ c == '\\f') {\n                j = new_s_len;\n                break;\n    \
    \        }\n            if s.chars().any(|c| c == '\\r') {\n                j\
    \ = new_s_len;\n                break;\n            }\n            if s.chars().any(|c|\
    \ c == '\\n') {\n                j = new_s_len;\n                break;\n    \
    \        }\n            if s.chars().any(|c| c == '\\t') {\n                j\
    \ = new_s_len;\n                break;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = new_s_len;\n                break;\n    \
    \        }\n            if s.chars().any(|c| c == '\\f') {\n                j\
    \ = new_s_len;\n                break;\n            }\n            if s.chars().any(|c|\
    \ c == '\\r') {\n                j = new_s_len;\n                break;\n    \
    \        }\n            if s.chars().any(|c| c == '\\n') {\n                j\
    \ = new_s_len;\n                break;\n            }\n            if s.chars().any(|c|\
    \ c == '\\t') {\n                j = new_s_len;\n                break;\n    \
    \        }\n            if s.chars().any(|c| c == '\\b') {\n                \n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `b`\n  --> /tmp/tmpabzre6w5.rs:33:41\n\
    \   |\n33 |             if s.chars().any(|c| c == '\\b') {\n   |             \
    \                            ^ unknown character escape\n   |\n   = help: for\
    \ more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    \nerror: unknown character escape: `f`\n  --> /tmp/tmpabzre6w5.rs:41:41\n   |\n\
    41 |             if s.chars().any(|c| c == '\\f') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `b`\n  --> /tmp/tmpabzre6w5.rs:57:41\n   |\n\
    57 |             if s.chars().any(|c| c == '\\b') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `f`\n  --> /tmp/tmpabzre6w5.rs:61:41\n   |\n\
    61 |             if s.chars().any(|c| c == '\\f') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `b`\n  --> /tmp/tmpabzre6w5.rs:77:41\n   |\n\
    77 |             if s.chars().any(|c| c == '\\b') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `f`\n  --> /tmp/tmpabzre6w5.rs:81:41\n   |\n\
    81 |             if s.chars().any(|c| c == '\\f') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `b`\n  --> /tmp/tmpabzre6w5.rs:97:41\n   |\n\
    97 |             if s.chars().any(|c| c == '\\b') {\n   |                    \
    \                     ^ unknown character escape\n   "
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ') {\n                j = j + 1;\n                continue;\n       \
    \     }\n            if s.chars().any(|c| c == '\\n') {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\t') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\r') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\f') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\r') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\n') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\t') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\f') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\f') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\n') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\t') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\f') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\r') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\n') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\t') {\n                j =\
    \ j\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `b`\n  --> /tmp/tmp57zg_9fp.rs:37:41\n\
    \   |\n37 |             if s.chars().any(|c| c == '\\b') {\n   |             \
    \                            ^ unknown character escape\n   |\n   = help: for\
    \ more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    \nerror: unknown character escape: `f`\n  --> /tmp/tmp57zg_9fp.rs:41:41\n   |\n\
    41 |             if s.chars().any(|c| c == '\\f') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `b`\n  --> /tmp/tmp57zg_9fp.rs:57:41\n   |\n\
    57 |             if s.chars().any(|c| c == '\\b') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `f`\n  --> /tmp/tmp57zg_9fp.rs:61:41\n   |\n\
    61 |             if s.chars().any(|c| c == '\\f') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `b`\n  --> /tmp/tmp57zg_9fp.rs:65:41\n   |\n\
    65 |             if s.chars().any(|c| c == '\\b') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `f`\n  --> /tmp/tmp57zg_9fp.rs:69:41\n   |\n\
    69 |             if s.chars().any(|c| c == '\\f') {\n   |                    \
    \                     ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\n\
    error: unknown character escape: `b`\n  --> /tmp/tmp57zg_9fp.rs:81:41\n   |\n\
    81 |             if s.chars().any(|c| c == '\\b') {\n   |                    \
    \                     ^ unknown character escape\n   "
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxofcaye1.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxofcaye1.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let j = i;\n        while j + 1 < s.len() && s[j + 1] == ' ' {\n    \
    \        j += 1;\n        }\n        if j + 1 < s.len() {\n            s[j] =\
    \ s[j + 1];\n            s[j + 1] = ' ';\n        }\n        i += 1;\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4rt7k8p8.rs:18:34\n\
    \   |\n18 |         while j + 1 < s.len() && s[j + 1] == ' ' {\n   |         \
    \                         ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4rt7k8p8.rs:22:13\n\
    \   |\n22 |             s[j] = s[j + 1];\n   |             ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4rt7k8p8.rs:22:20\n   |\n22 |             s[j] = s[j + 1];\n  \
    \ |                    ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4rt7k8p8.rs:23:13\n\
    \   |\n23 |             s[j + 1] = ' ';\n   |             ^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().sort_by(|a, b| a.cmp(b));\n \
    \   s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpl_tv3h89.rs:15:15\n   |\n15 |     s.chars().sort_by(|a,\
    \ b| a.cmp(b));\n   |               ^^^^^^^ method not found in `Chars<'_>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                let mut k = j;\n                while k <\
    \ s.len() {\n                    if s[k] > s[i] {\n                        k =\
    \ k + 1;\n                        continue;\n                    }\n         \
    \           new_s.push_str(&s[..k]);\n                    new_s.push_str(&s[k,\
    \ ..]);\n                    new_s_len += k - j;\n                    j = k;\n\
    \                    break;\n                }\n                break;\n     \
    \       }\n            j = j + 1;\n        }\n        new_s.push_str(&s[..i]);\n\
    \        new_s.push_str(&s[i..]);\n        new_s_len += i - j;\n        i = j;\n\
    \    }\n    new_s.push_str(&s[..i]);\n    new_s.push_str(&s[i..]);\n    new_s_len\
    \ += i - j;\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `]`, `{`, or an operator, found\
    \ `,`\n  --> /tmp/tmpwtnq3whu.rs:33:40\n   |\n33 |                     new_s.push_str(&s[k,\
    \ ..]);\n   |                                        ^ expected one of 7 possible\
    \ tokens\n\nerror[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpwtnq3whu.rs:49:22\n\
    \   |\n49 |     new_s_len += i - j;\n   |                      ^ help: a local\
    \ variable with a similar name exists: `i`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpwtnq3whu.rs:21:16\n   |\n21 |  \
    \           if s[j] < s[i] {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpwtnq3whu.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n   |\
    \                       ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwtnq3whu.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwtnq3whu.rs:25:23\n   |\n25 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwtnq3whu.rs:28:24\n\
    \   |\n28 |                     if s[k] > s[i] {\n   |                       \
    \ ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpwtnq3whu.rs:28:31\n   |\n28 |            \
    \         if s[k] > s[i] {\n   |                               ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749330
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                s[j] = s[j] + 1;\n            } else {\n      \
    \          s[j] = s[j] - 1;\n            }\n            j += 1;\n        }\n \
    \       new_s.push_str(&s[i .. (i + new_s_len)].to_lowercase());\n        new_s_len\
    \ += new_s.len() - i;\n        i = j;\n    }\n    new_s\n}\n\nfn main() {\n  \
    \  let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6uow28rp.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6uow28rp.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6uow28rp.rs:26:17\n\
    \   |\n26 |                 s[j] = s[j] + 1;\n   |                 ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp6uow28rp.rs:26:24\n   |\n26 |                 s[j]\
    \ = s[j] + 1;\n   |                        ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6uow28rp.rs:28:17\n\
    \   |\n28 |                 s[j] = s[j] - 1;\n   |                 ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp6uow28rp.rs:28:24\n   |\n28 |                 s[j]\
    \ = s[j] - 1;\n   |                        ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k\
    \ .. j]);\n            i = j;\n        } else {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. k]);\n            i = k;\n     \
    \   }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphyd154hu.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphyd154hu.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                j = j + 1;\n    \
    \        } else {\n                break;\n            }\n        }\n        let\
    \ mut new_word = String::new();\n        while j < s.len() {\n            new_word.push(s[j]);\n\
    \            j = j + 1;\n        }\n        new_s.push(new_word);\n        i =\
    \ j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpetempgit.rs:20:16\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpetempgit.rs:20:23\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpetempgit.rs:28:27\n\
    \   |\n28 |             new_word.push(s[j]);\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpetempgit.rs:31:20\n\
    \   |\n31 |         new_s.push(new_word);\n   |                    ^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                break;\n            }\n            i += 1;\n            j\
    \ += 1;\n        }\n        if j == new_s_len {\n            new_s.push_str(&s[i]);\n\
    \        } else {\n            new_s.push_str(&s[i .. j]);\n            new_s.push_str(&s[j\
    \ .. new_s_len]);\n        }\n        i += 1;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3tjqt1if.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3tjqt1if.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3tjqt1if.rs:28:29\n\
    \   |\n28 |             new_s.push_str(&s[i]);\n   |                         \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                s[j] = s[j].to_ascii_lowercase();\n           \
    \ }\n            new_s[new_s_len] = s[j];\n            new_s_len += 1;\n     \
    \       j += 1;\n        }\n        i = j;\n    }\n    new_s.truncate(new_s_len);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq3e9wiy9.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq3e9wiy9.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq3e9wiy9.rs:26:17\n\
    \   |\n26 |                 s[j] = s[j].to_ascii_lowercase();\n   |          \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpq3e9wiy9.rs:26:24\n   |\n26 |  \
    \               s[j] = s[j].to_ascii_lowercase();\n   |                      \
    \  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmpq3e9wiy9.rs:28:13\n   |\n28 |        \
    \     new_s[new_s_len] = s[j];\n   |             ^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpq3e9wiy9.rs:28:32\n   |\n28 |             new_s[new_s_len]\
    \ = s[j];\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            new_s.push_str(&s[i .. j]);\n            new_s_len\
    \ += 1;\n            i += 1;\n            j = i;\n        }\n        new_s.push_str(&s[i\
    \ .. new_s_len]);\n        new_s_len += 1;\n        i += 1;\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuoqw1pvo.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuoqw1pvo.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuoqw1pvo.rs:25:30\n\
    \   |\n25 |             if s[j] < 'a' || s[j] > 'z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[j]);\n                new_s.push_str(&s[i]);\n\
    \                break;\n            }\n            j += 1\n        }\n      \
    \  i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjame34wd.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjame34wd.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjame34wd.rs:22:33\n\
    \   |\n22 |                 new_s.push_str(&s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpjame34wd.rs:23:33\n   |\n\
    23 |                 new_s.push_str(&s[i]);\n   |                            \
    \     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] < 'A' || s[j] > 'Z' {\n                j +=\
    \ 1;\n                continue;\n            }\n            new_s[new_s_len] =\
    \ s[j];\n            new_s_len += 1;\n            j += 1;\n        }\n       \
    \ new_s[i] = new_s[new_s_len];\n        new_s_len -= 1;\n        i += 1;\n   \
    \ }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzx4ejk5b.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzx4ejk5b.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzx4ejk5b.rs:25:30\n\
    \   |\n25 |             if s[j] < 'a' || s[j] > 'z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpzx4ejk5b.rs:29:16\n   |\n\
    29 |             if s[j] < 'A' || s[j] > 'Z' {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpzx4ejk5b.rs:29:30\n   |\n29 |             if s[j]\
    \ < 'A' || s[j] > 'Z' {\n   |                              ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpzx4ejk5b.rs:33:13\n   |\n33 |             new_s[new_s_len] = s[j];\n\
    \   |             ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzx4ejk5b.rs:33:32\n\
    \   |\n33 |             new_s[new_s_len] = s[j];\n   |                       \
    \         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String` "
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            let mut c = s[j];\n            s[j] = s[k];\n  \
    \          s[k] = c;\n        }\n        i = j + 1;\n    }\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxchssm0f.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxchssm0f.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxchssm0f.rs:28:25\n\
    \   |\n28 |             let mut c = s[j];\n   |                         ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpxchssm0f.rs:29:13\n   |\n29 |             s[j] = s[k];\n\
    \   |             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxchssm0f.rs:29:20\n\
    \   |\n29 |             s[j] = s[k];\n   |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxchssm0f.rs:30:13\n   |\n30 |             s[k] = c;\n   |     \
    \        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        if s.chars().any(|c| c != ' ') {\n            s.swap(i, i + 1);\n   \
    \         i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp6aac5mkn.rs:18:15\n   |\n18 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j..]);\n                break;\n            }\n\
    \            j += 1\n        }\n        let mut k = i;\n        while k < s.len()\
    \ {\n            if s[k] != ' ' {\n                new_s.push_str(&s[k..]);\n\
    \                break;\n            }\n            k += 1\n        }\n      \
    \  let mut l = i;\n        while l < s.len() {\n            if s[l] != ' ' {\n\
    \                new_s.push_str(&s[l..]);\n                break;\n          \
    \  }\n            l += 1\n        }\n        let mut m = i;\n        while m <\
    \ s.len() {\n            if s[m] != ' ' {\n                new_s.push_str(&s[m..]);\n\
    \                break;\n            }\n            m += 1\n        }\n      \
    \  let mut n = i;\n        while n < s.len() {\n            if s[n] != ' ' {\n\
    \                new_s.push_str(&s[n..]);\n                break;\n          \
    \  }\n            n += 1\n        }\n        let mut o = i;\n        while o <\
    \ s.len() {\n            if s[o] != ' ' {\n                new_s.push_str(&s[o..]);\n\
    \                break;\n            }\n            o += 1\n        }\n      \
    \  let mut p = i;\n        while p < s.len() {\n            if s[p] != ' ' {\n\
    \                new_s.push_str(&s[p..]);\n                break;\n          \
    \  }\n            p += 1\n        }\n        let mut q = i;\n        while q <\
    \ s.len() {\n            if s[q] != ' ' {\n                new_s.push_str(&s[q..]);\n\
    \                break;\n            }\n            q += 1\n        }\n      \
    \  let mut r = i;\n        while r < s.len() {\n            if s[r] != ' ' {\n\
    \                new_s.push_str(&s[r..]);\n                break;\n          \
    \  }\n            r += 1\n        }\n        let mut s = i;\n        while s <\
    \ s.len() {\n            if s[s] != ' ' {\n                new_s.push_str(&s[s..]);\n\
    \                break;\n            }\n            s += 1\n        }\n      \
    \  let mut t = i;\n        while t < s.len() {\n            if s[t] != ' ' {\n\
    \                new_s.push_str(&s[t..]);\n                break;\n          \
    \  }\n            t += 1\n        }\n        let mut u = i;\n        while u <\
    \ s.len() {\n            if s[u] != ' ' {\n                new_s.push_str(&s[u..]);\n\
    \                break;\n            }\n            u += 1\n        }\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp23caan8j.rs:126:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < s.len() {\n\
    \    |                       - this delimiter might not be properly closed...\n\
    ...\n115 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n126 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmp23caan8j.rs:21:16\n   |\n21 |             if s[j] !=\
    \ ' ' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp23caan8j.rs:29:16\n\
    \   |\n29 |             if s[k] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp23caan8j.rs:37:16\n   |\n37 |             if s[l] != ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp23caan8j.rs:45:16\n\
    \   |\n45 |             if s[m] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp23caan8j.rs:53:16\n   |\n53 |             if s[n] != ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp23caan8j.rs:61:16\n\
    \   |\n61 |             if s[o] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `Strin"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] < 'A' || s[j] > 'Z' {\n                j +=\
    \ 1;\n                continue;\n            }\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s_len += 1;\n            i += 1;\n            j = i;\n\
    \        }\n        new_s.push_str(&s[i .. new_s_len]);\n        new_s_len +=\
    \ 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwrnl8b6y.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwrnl8b6y.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwrnl8b6y.rs:25:30\n\
    \   |\n25 |             if s[j] < 'a' || s[j] > 'z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpwrnl8b6y.rs:29:16\n   |\n\
    29 |             if s[j] < 'A' || s[j] > 'Z' {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpwrnl8b6y.rs:29:30\n   |\n29 |             if s[j]\
    \ < 'A' || s[j] > 'Z' {\n   |                              ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                new_s.push_str(&s[i .. j]);\n           \
    \     new_s.push_str(&[s[i] - s[j] as char]);\n                i = j;\n      \
    \          break;\n            }\n            j = j + 1;\n        }\n        if\
    \ j == s.len() {\n            new_s.push_str(&s[i .. i]);\n        }\n       \
    \ new_s_len = new_s.len() + new_s_len;\n        i = i + 1;\n    }\n    new_s.push_str(&s[i\
    \ .. new_s_len]);\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpet36kp5n.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpet36kp5n.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpet36kp5n.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpet36kp5n.rs:25:23\n   |\n25 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpet36kp5n.rs:27:34\n\
    \   |\n27 |                 new_s.push_str(&[s[i] - s[j] as char]);\n   |    \
    \                              ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpet36kp5n.rs:27:41\n\
    \   |\n27 |                 new_s.push_str(&[s[i] - s[j] as char]);\n   |    \
    \                                     ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpet36kp5n.rs:27:32\n   |\n27 |  \
    \               new_s.push_str(&[s[i] - s[j] as char]);\n   |                \
    \                ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found array of 1 element\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&[_;\
    \ 1]`\n\nerror: abor"
  stdout: ''
  timestamp: 1659749325
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[j..]);\n                break;\n          \
    \  }\n            j += 1;\n        }\n        i += 1;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Hi\"`', /tmp/tmpgr6iueo5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                let mut new_word = String::new();\n     \
    \           let mut new_word_len = 0;\n                while j < s.len() {\n \
    \                   if s[j] == s[i] {\n                        new_word.push(s[j]);\n\
    \                        new_word_len += 1;\n                        j = j + 1;\n\
    \                    } else {\n                        new_word.push(s[j]);\n\
    \                        new_word_len += 1;\n                        break;\n\
    \                    }\n                }\n                new_s.push_str(&new_word);\n\
    \                new_s_len += new_word_len;\n                i = j;\n        \
    \        break;\n            }\n            j = j + 1;\n        }\n        i =\
    \ i + 1;\n    }\n    new_s.push_str(&s[..new_s_len]);\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0f4uxa79.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0f4uxa79.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0f4uxa79.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0f4uxa79.rs:25:23\n   |\n25 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0f4uxa79.rs:29:24\n\
    \   |\n29 |                     if s[j] == s[i] {\n   |                      \
    \  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp0f4uxa79.rs:29:32\n   |\n29 |            \
    \         if s[j] == s[i] {\n   |                                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp0f4uxa79.rs:30:39\n   |\n30 |                    \
    \     new_word.push(s[j]);\n   |                                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tm"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                break;\n            }\n            new_s.push_str(&s[j..i]);\n\
    \            new_s_len += 1;\n            j = j + 1;\n        }\n        new_s.push_str(&s[i..j]);\n\
    \        new_s_len += 1;\n        i = j;\n    }\n    new_s.push_str(&s[..i]);\n\
    \    new_s_len += 1;\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptn5kheg5.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptn5kheg5.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptn5kheg5.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptn5kheg5.rs:25:23\n   |\n25 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            let mut new_s_len = new_s_len + 1;\n                new_s.push((s[j].to_ascii_lowercase())\
    \ as char);\n                j = j + 1;\n            } else {\n              \
    \  break;\n            }\n        }\n        let mut new_s_len = new_s_len + 1;\n\
    \        new_s.push((s[i].to_ascii_lowercase()) as char);\n        i = i + 1;\n\
    \    }\n    new_s.truncate(new_s_len);\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1aeua4zt.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1aeua4zt.rs:23:29\n   |\n23 |                 new_s.push((s[j].to_ascii_lowercase())\
    \ as char);\n   |                             ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp1aeua4zt.rs:30:21\n   |\n30 |         new_s.push((s[i].to_ascii_lowercase())\
    \ as char);\n   |                     ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        new_s.push_str(&s[i]);\n     \
    \   new_s_len += 1;\n        i += 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpezs2fb8m.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpezs2fb8m.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpezs2fb8m.rs:27:25\n   |\n27 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n        if c\
    \ < ' ' {\n            s.insert(c, ' ');\n        }\n    });\n    s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdzx766y6.rs:17:22\n   |\n\
    17 |             s.insert(c, ' ');\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ <\n                s.chars().next().unwrap().to_ascii_lowercase().unwrap() {\n\
    \                j = j + 1;\n            } else {\n                break;\n  \
    \          }\n        }\n        new_s.push_str(&s[i .. j]);\n        new_s_len\
    \ += j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len\
    \ += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmprqhlf07k.rs:21:63\n   |\n21 |             if s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ <\n   |                                                               ^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `char` in the current scope\n  --> /tmp/tmprqhlf07k.rs:22:64\n   |\n22\
    \ |                 s.chars().next().unwrap().to_ascii_lowercase().unwrap() {\n\
    \   |                                                                ^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                j = j + 1;\n    \
    \        } else {\n                break;\n            }\n        }\n        new_s.push_str(&s[0..i]);\n\
    \        new_s.push_str(&s[j..]);\n        i = j;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgbd8gplp.rs:20:16\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgbd8gplp.rs:20:23\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().nth(j).unwrap().to_ascii_lowercase()\
    \ < s.chars().nth(i).unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749330
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                break;\n            }\n            j += 1\n        }\n  \
    \      if j == new_s_len {\n            new_s.push(' ');\n        } else {\n \
    \           new_s.push(s[i]);\n            new_s.push(s[j]);\n        }\n    \
    \    i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphhyzwaf1.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphhyzwaf1.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphhyzwaf1.rs:29:24\n\
    \   |\n29 |             new_s.push(s[i]);\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmphhyzwaf1.rs:30:24\n   |\n30 |             new_s.push(s[j]);\n\
    \   |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        let mut k = i;\n        while\
    \ k < s.len() {\n            if s[k] != ' ' {\n                new_s.push_str(&s[k]);\n\
    \                new_s_len += 1;\n            }\n            k += 1\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i .. new_s_len]);\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp55lq3wol.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp55lq3wol.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp55lq3wol.rs:29:16\n\
    \   |\n29 |             if s[k] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp55lq3wol.rs:30:33\n   |\n30 |                 new_s.push_str(&s[k]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                break;\n            }\n            i += 1;\n            j\
    \ += 1;\n        }\n        if j == new_s_len {\n            new_s.push_str(&s[i]);\n\
    \        } else {\n            new_s.push_str(&s[i]);\n            new_s.push_str(&s[j]);\n\
    \        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9wqbk_dh.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9wqbk_dh.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9wqbk_dh.rs:28:29\n\
    \   |\n28 |             new_s.push_str(&s[i]);\n   |                         \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp9wqbk_dh.rs:30:29\n   |\n30 |            \
    \ new_s.push_str(&s[i]);\n   |                             ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9wqbk_dh.rs:31:29\n   |\n31 |             new_s.push_str(&s[j]);\n\
    \   |                             ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            }\n            i += 1;\n        }\n     \
    \   new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i = j;\n\
    \    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsyu0ozy9.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsyu0ozy9.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n        if c\
    \ < ' ' {\n            s.insert(c, ' ');\n        }\n    });\n    s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdzx766y6.rs:17:22\n   |\n\
    17 |             s.insert(c, ' ');\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            let mut temp = s[j];\n                s[j] = s[i];\n            \
    \    s[i] = temp;\n                j = j + 1;\n            } else {\n        \
    \        break;\n            }\n        }\n        new_s.push_str(&s[i .. j]);\n\
    \        new_s_len += j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n\
    \    new_s_len += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0fb_42sy.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0fb_42sy.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0fb_42sy.rs:22:32\n\
    \   |\n22 |                 let mut temp = s[j];\n   |                       \
    \         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp0fb_42sy.rs:23:17\n   |\n23 |  \
    \               s[j] = s[i];\n   |                 ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp0fb_42sy.rs:23:24\n   |\n23 |                 s[j] = s[i];\n   |\
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0fb_42sy.rs:24:17\n\
    \   |\n24 |                 s[i] = temp;\n   |                 ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            let mut temp = s[j];\n                s[j] = s[i];\n            \
    \    s[i] = temp;\n            }\n            j += 1\n        }\n        new_s.push_str(&s[i]);\n\
    \        new_s_len += 1;\n        i += 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu0_g6ei3.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu0_g6ei3.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu0_g6ei3.rs:22:32\n\
    \   |\n22 |                 let mut temp = s[j];\n   |                       \
    \         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpu0_g6ei3.rs:23:17\n   |\n23 |  \
    \               s[j] = s[i];\n   |                 ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpu0_g6ei3.rs:23:24\n   |\n23 |                 s[j] = s[i];\n   |\
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu0_g6ei3.rs:24:17\n\
    \   |\n24 |                 s[i] = temp;\n   |                 ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu0_g6ei3.rs:28:25\n   |\n28 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 7 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] < 'A' || s[j] > 'Z' {\n                j +=\
    \ 1;\n                continue;\n            }\n            new_s.push_str(&s[i\
    \ .. j]);\n            i += 1;\n            j += 1;\n        }\n        new_s.push_str(&s[i\
    \ .. new_s_len]);\n        new_s_len -= i;\n        i = new_s_len;\n    }\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpre6s8lx3.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpre6s8lx3.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpre6s8lx3.rs:25:30\n\
    \   |\n25 |             if s[j] < 'a' || s[j] > 'z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpre6s8lx3.rs:29:16\n   |\n\
    29 |             if s[j] < 'A' || s[j] > 'Z' {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpre6s8lx3.rs:29:30\n   |\n29 |             if s[j]\
    \ < 'A' || s[j] > 'Z' {\n   |                              ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[..j]);\n        new_s.push_str(&s[j..]);\n        i\
    \ = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            let mut c = s[j];\n            s[j] = s[k];\n  \
    \          s[k] = c;\n        }\n        i = j;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5eijw29g.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5eijw29g.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5eijw29g.rs:28:25\n\
    \   |\n28 |             let mut c = s[j];\n   |                         ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + 1;\n        new_s.push_str(&s[i\
    \ .. j]);\n        new_s.push_str(&\" \");\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_it6gg6j.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_it6gg6j.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.sort_by_key(|&c| c.to_ascii_lowercase());\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpv2g6juqd.rs:15:7\n   |\n15 |     s.sort_by_key(|&c|\
    \ c.to_ascii_lowercase());\n   |       ^^^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + 1;\n        new_s.push_str(&s[i\
    \ .. j]);\n        new_s.push_str(&\" \");\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ .. s.len()]);\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_ebdg2s3.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_ebdg2s3.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j].is_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_digit() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_upper() {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j].is_ascii_lower() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_letter() {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s[j].is_ascii_dot()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_space() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_symbol() {\n   \
    \             j = j + 1;\n                continue;\n            }\n         \
    \   if s[j].is_ascii_alphanum() {\n                j = j + 1;\n              \
    \  continue;\n            }\n            if s[j].is_ascii_hex() {\n          \
    \      j = j + 1;\n                continue;\n            }\n            if s[j].is_ascii_hexadecimal()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_upper() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_lower() {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j].is_ascii_letter() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_dot() {\n                j = j +\
    \ 1;\n                continue;\n            }\n            if s[j].is_ascii_space()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_symbol() {\n                j = j + 1;\n         \
    \       continue;\n            }\n            if s[j].is_ascii_alphanum() {\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_hex() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_hexadecimal() {\n               \
    \ j = j + 1;\n                continue;\n            }\n            if s[j].is_ascii_upper()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_lower() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_letter() {\n   \
    \             j = j + 1;\n                continue;\n            }\n         \
    \   if s[j].is_ascii_dot() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_space() {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s[j].is_ascii_symbol()\
    \ {\n                j = j + 1;\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxewq_6bn.rs:134:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < s.len() {\n\
    \    |                       - unclosed delimiter\n19  |         let mut j = i;\n\
    20  |         while j < s.len() {\n    |                           - unclosed\
    \ delimiter\n...\n121 |             if s[j].is_ascii_symbol() {\n    |       \
    \                                - this delimiter might not be properly closed...\n\
    122 |                 j = j + 1;\n123 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpxewq_6bn.rs:21:16\n   |\n\
    21 |             if s[j].is_whitespace() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpxewq_6bn.rs:25:16\n   |\n25 |             if s[j].is_ascii_digit()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxewq_6bn.rs:29:16\n\
    \   |\n29 |             if s[j].is_ascii_upper() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpxewq_6bn.rs:33:16\n   |\n33 |             if s[j].is_ascii_lower()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxewq_6bn.rs:37:16\n\
    \   |\n37 |             if s[j].is_ascii_letter() {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented fo"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.sort_by_key(|&x| x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>());\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpdbcd3o4d.rs:15:7\n   |\n15 |     s.sort_by_key(|&x|\
    \ x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>());\n   |      \
    \ ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j].is_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          let mut c = s[j];\n            let mut k = j;\n            while k\
    \ < s.len() {\n                if s[k].is_whitespace() {\n                   \
    \ k = k + 1;\n                    continue;\n                }\n             \
    \   if c < s[k] {\n                    c = s[k];\n                    k = k +\
    \ 1;\n                } else {\n                    break;\n                }\n\
    \            }\n            if k < s.len() {\n                new_s.push_str(&s[i\
    \ .. k]);\n                new_s.push_str(&[c as char]);\n                i =\
    \ k;\n            } else {\n                new_s.push_str(&s[i .. j]);\n    \
    \            new_s.push_str(&[c as char]);\n                break;\n         \
    \   }\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl44ev_1k.rs:21:16\n\
    \   |\n21 |             if s[j].is_whitespace() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpl44ev_1k.rs:25:25\n   |\n25 |             let mut\
    \ c = s[j];\n   |                         ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl44ev_1k.rs:28:20\n\
    \   |\n28 |                 if s[k].is_whitespace() {\n   |                  \
    \  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpl44ev_1k.rs:32:24\n   |\n32 |            \
    \     if c < s[k] {\n   |                        ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpl44ev_1k.rs:33:25\n   |\n33 |                     c = s[k];\n  \
    \ |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl44ev_1k.rs:41:32\n   |\n41 |              \
    \   new_s.push_str(&[c as char]);\n   |                                ^^^^^^^^^^^^\
    \ expected `str`, found array `[char; 1]`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&[char; 1]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl44ev_1k.rs:45:32\n   |\n45 |                 new_s.push_str(&[c\
    \ as char]);\n   |                                ^^^^^^^^^^^^ expected `str`,\
    \ found array `[char; 1]`\n   |\n   = note: expected reference `&str`\n      \
    \        found reference `&[char; 1]`\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have d"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] == '\
    \ ' {\n                j += 1;\n                continue;\n            }\n   \
    \         if s[j] > s[i] {\n                new_s.push_str(&s[i .. j]);\n    \
    \            new_s.push_str(&s[i .. j]);\n                i += 1;\n          \
    \      j += 1;\n                continue;\n            }\n            if s[j]\
    \ < s[i] {\n                new_s.push_str(&s[i .. j]);\n                new_s.push_str(&s[i\
    \ .. j]);\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == s[j] {\n                new_s.push_str(&s[i .. j]);\n\
    \                new_s.push_str(&s[i .. j]);\n                i += 1;\n      \
    \          j += 1;\n                continue;\n            }\n            i +=\
    \ 1;\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsef6rvx6.rs:21:16\n\
    \   |\n21 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsef6rvx6.rs:25:16\n   |\n25 |             if s[j] > s[i] {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsef6rvx6.rs:25:23\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpsef6rvx6.rs:32:16\n   |\n32 |             if s[j]\
    \ < s[i] {\n   |                ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsef6rvx6.rs:32:23\n\
    \   |\n32 |             if s[j] < s[i] {\n   |                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpsef6rvx6.rs:38:16\n   |\n38 |             if s[i]\
    \ == s[j] {\n   |                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsef6rvx6.rs:38:24\n\
    \   |\n38 |             if s[i] == s[j] {\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror: aborting due to 7 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s[i .. j]);\n        new_s_len\
    \ += j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len\
    \ += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuo9f8_qy.rs:21:118\n   |\n\
    21 |             if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n   |                                                                \
    \                                                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            new_s[new_s_len] = s[j];\n            new_s_len +=\
    \ 1;\n            j += 1;\n        }\n        new_s[i] = new_s[new_s_len - 1];\n\
    \        new_s_len -= 1;\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsds5sitm.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsds5sitm.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsds5sitm.rs:25:30\n\
    \   |\n25 |             if s[j] < 'a' || s[j] > 'z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpsds5sitm.rs:29:13\n\
    \   |\n29 |             new_s[new_s_len] = s[j];\n   |             ^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpsds5sitm.rs:29:32\n   |\n29 |            \
    \ new_s[new_s_len] = s[j];\n   |                                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpsds5sitm.rs:33:9\n   |\n33 |         new_s[i] = new_s[new_s_len\
    \ - 1];\n   |         ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpsds5sitm.rs:33:20\n\
    \   |\n33 |         new_s[i] = new_s[new_s_len - 1];\n   |                   \
    \ ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n\nerror: aborting\
    \ due "
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                new_s.push_str(&s[..j]);\n       \
    \         new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..i]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[..i]);\n                new_s.push_str(&s[..j]);\n\
    \                new_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpz399t87l.rs:79:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n19 |         let mut j = i;\n\
    20 |         while j < new_s_len {\n   |                             - unclosed\
    \ delimiter\n...\n23 |             } else {\n   |                    - this delimiter\
    \ might not be properly closed...\n...\n68 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n79 | }\n   |   ^\n\nerror[E0425]: cannot\
    \ find value `new_` in this scope\n  --> /tmp/tmpz399t87l.rs:67:17\n   |\n67 |\
    \                 new_\n   |                 ^^^^ help: a local variable with\
    \ a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz399t87l.rs:18:5\n\
    \   |\n13 |   fn anti_shuffle(s: String) -> String {\n   |                   \
    \              ------ expected `String` because of return type\n...\n18 | /  \
    \   while i < new_s_len {\n19 | |         let mut j = i;\n20 | |         while\
    \ j < new_s_len {\n21 | |             if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n...  |\n78 | |     assert_eq!(candidate(String::from(\"\
    Hi. My name is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst\
    \ .Rboot How aer ?...\n79 | | }\n   | |__^ expected struct `String`, found `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] >= ' ' && s[j]\
    \ < '!' {\n                j += 1;\n                continue;\n            }\n\
    \            if s[j] >= '!' && s[j] < '@' {\n                j += 1;\n       \
    \         continue;\n            }\n            if s[j] >= '@' && s[j] < '#' {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s[j] >= '#' && s[j] < '$' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] >= '$' && s[j] < '%' {\n                j\
    \ += 1;\n                continue;\n            }\n            if s[j] >= '%'\
    \ && s[j] < '&' {\n                j += 1;\n                continue;\n      \
    \      }\n            if s[j] >= '&' && s[j] < '\\'' {\n                j += 1;\n\
    \                continue;\n            }\n            if s[j] >= '\\'' && s[j]\
    \ < '(' {\n                j += 1;\n                continue;\n            }\n\
    \            if s[j] >= '(' && s[j] < ')' {\n                j += 1;\n       \
    \         continue;\n            }\n            if s[j] >= ')' && s[j] < '[' {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s[j] >= '[' && s[j] < ']' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] >= ']' && s[j] < '<' {\n                j\
    \ += 1;\n                continue;\n            }\n            if s[j] >= '<'\
    \ && s[j] < '>' {\n                j += 1;\n                continue;\n      \
    \      }\n            if s[j] >= '>' && s[j] < '=' {\n                j += 1;\n\
    \                continue;\n            }\n            if s[j] >= '=' && s[j]\
    \ < '?' {\n                j += 1;\n                continue;\n            }\n\
    \            if s[j] >= '?' && s[j] < '@' {\n                j += 1;\n       \
    \         continue;\n            }\n            if s[j] >= '@' && s[j] < '[' {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s[j] >= '[' && s[j] < ']' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] >= ']' && s[j] < '{' {\n                j\
    \ += 1;\n                continue;\n            }\n            if s[j] >= '{'\
    \ && s[j] < '|' {\n                j += 1;\n                continue;\n      \
    \      }\n            if \n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpnq3zoi40.rs:113:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < s.len() {\n\
    \    |                       - unclosed delimiter\n19  |         let mut j = i;\n\
    20  |         while j < s.len() {\n    |                           - this delimiter\
    \ might not be properly closed...\n...\n102 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n113 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpnq3zoi40.rs:102:1\n    |\n102 | }\n  \
    \  | ^ expected expression\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpnq3zoi40.rs:21:16\n   |\n21 |             if s[j]\
    \ >= ' ' && s[j] < '!' {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpnq3zoi40.rs:21:31\n   |\n21 |             if s[j] >= ' ' && s[j]\
    \ < '!' {\n   |                               ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpnq3zoi40.rs:25:16\n   |\n25 |             if s[j] >= '!' && s[j]\
    \ < '@' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnq3zoi40.rs:25:31\n\
    \   |\n25 |             if s[j] >= '!' && s[j] < '@' {\n   |                 \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpnq3zoi40.rs:29:16\n   |\n\
    29 |             if s[j] >= '@' && s[j] < '#' {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` i"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                let mut new_word = String::new();\n     \
    \           new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzh7ugm3v.rs:78:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - unclosed delimiter\n19 |         let mut j = i;\n\
    20 |         while j < s.len() {\n   |                           - unclosed delimiter\n\
    ...\n25 |             if s[j] > s[i] {\n   |                            - this\
    \ delimiter might not be properly closed...\n...\n67 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n78 | }\n   |   ^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzh7ugm3v.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzh7ugm3v.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzh7ugm3v.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzh7ugm3v.rs:25:23\n   |\n25 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0609]:\
    \ no field `push_` on type `String`\n  --> /tmp/tmpzh7ugm3v.rs:66:26\n   |\n66\
    \ |                 new_word.push_\n   |                          ^^^^^ unknown\
    \ field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzh7ugm3v.rs:18:5\n  \
    \ |\n13 |   fn anti_shuffle(s: String) -> String {\n   |                     \
    \            ------ expected `String` because of re"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                s.swap(i, j);\n                i =\
    \ j;\n                break;\n            }\n        }\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp8if5vrm4.rs:22:19\n   |\n22 |                 s.swap(i,\
    \ j);\n   |                   ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut new_s_char = s.chars().nth(j).unwrap();\n\
    \        while i < new_s_len && new_s_char == ' ' {\n            new_s_char =\
    \ s.chars().nth(i).unwrap();\n            i = i + 1;\n        }\n        new_s.push_str(&new_s_char);\n\
    \        i = j + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpluqw6451.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpluqw6451.rs:28:24\n   |\n28 |         new_s.push_str(&new_s_char);\n\
    \   |                        ^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        if s.chars().any(|c| c.is_ascii()) {\n            s.swap(i, i + 1);\n\
    \            i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp060gep4x.rs:18:15\n   |\n18 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv3ryiwdw.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmpv3ryiwdw.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv3ryiwdw.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                break;\n            }\n            j += 1\n        }\n  \
    \      if j == new_s_len {\n            new_s.push(' ');\n        } else {\n \
    \           new_s.push(s[i]);\n            i += 1;\n        }\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgv8olj_y.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgv8olj_y.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgv8olj_y.rs:29:24\n\
    \   |\n29 |             new_s.push(s[i]);\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] < 'A' || s[j] > 'Z' {\n                j = j + 1;\n               \
    \ continue;\n            }\n            if s[j] < 'a' || s[j] > 'z' {\n      \
    \          j = j + 1;\n                continue;\n            }\n            if\
    \ s[j] < '0' || s[j] > '9' {\n                j = j + 1;\n                continue;\n\
    \            }\n            new_s.push_str(&s[i .. j]);\n            new_s_len\
    \ = new_s_len + j - i;\n            i = j;\n            break;\n        }\n  \
    \  }\n    new_s.push_str(&s[i .. new_s_len]);\n    new_s\n}\n\nfn main() {\n \
    \   let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps_ik3ytt.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps_ik3ytt.rs:25:16\n   |\n25 |             if s[j] < 'A' || s[j]\
    \ > 'Z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps_ik3ytt.rs:25:30\n\
    \   |\n25 |             if s[j] < 'A' || s[j] > 'Z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmps_ik3ytt.rs:29:16\n   |\n\
    29 |             if s[j] < 'a' || s[j] > 'z' {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmps_ik3ytt.rs:29:30\n   |\n29 |             if s[j]\
    \ < 'a' || s[j] > 'z' {\n   |                              ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps_ik3ytt.rs:33:16\n   |\n33 |             if s[j] < '0' || s[j]\
    \ > '9' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps_ik3ytt.rs:33:30\n\
    \   |\n33 |             if s[j] < '0' || s[j] > '9' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror: aborting due\
    \ to 7 previous errors\n\nFor"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        if j == new_s_len {\n            break;\n\
    \        }\n        let mut new_s_char = new_s[new_s_len - j - 1];\n        let\
    \ mut new_s_char_len = new_s_char.len();\n        let mut new_s_char_pos = 0;\n\
    \        while new_s_char_pos < new_s_char_len {\n            let mut new_s_char_char\
    \ = new_s_char[new_s_char_pos];\n            let mut new_s_char_char_len = new_s_char_char.len();\n\
    \            let mut new_s_char_char_pos = 0;\n            while new_s_char_char_pos\
    \ < new_s_char_char_len {\n                let mut new_s_char_char_char = new_s_char_char[new_s_char_char_pos];\n\
    \                let mut new_s_char_char_char_len = new_s_char_char_char.len();\n\
    \                let mut new_s_char_char_char_pos = 0;\n                while\
    \ new_s_char_char_char_pos < new_s_char_char_char_len {\n                    let\
    \ mut new_s_char_char_char_char = new_s_char_char_char[new_s_char_char_char_pos];\n\
    \                    let mut new_s_char_char_char_char_len = new_s_char_char_char_char.len();\n\
    \                    let mut new_s_char_char_char_char_pos = 0;\n            \
    \        while new_s_char_char_char_char_pos < new_s_char_char_char_char_len {\n\
    \                        let mut new_s_char_char_char_char_char = new_s_char_char_char_char[new_s_char_char_char_char_pos];\n\
    \                        let mut new_s_char_char_char_char_char_len = new_s_char_char_char_char_char.len();\n\
    \                        let mut new_s_char_char_char_char_char_pos = 0;\n   \
    \                     while new_s_char_char_char_char_char_pos < new_s_char_char_char_char_char_len\
    \ {\n                            let mut new_s_char_char_char_char_char_char =\
    \ new_s_char_char_char_char_char[new_s_char_char_char_char_char_pos];\n      \
    \                      let mut new_s_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char.len();\n\
    \                            let mut new_s_char_char_char_char_char_char_pos =\
    \ 0;\n                            while new_s_char_char_char_char_char_char_pos\
    \ < new_s_char_char_char_char_char_char_char_len {\n                         \
    \       let mut new_s_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8u0p528u.rs:62:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n29 |         while new_s_char_pos\
    \ < new_s_char_len {\n   |                                               - unclosed\
    \ delimiter\n...\n33 |             while new_s_char_char_pos < new_s_char_char_len\
    \ {\n   |                                                             - unclosed\
    \ delimiter\n...\n37 |                 while new_s_char_char_char_pos < new_s_char_char_char_len\
    \ {\n   |                                                                    \
    \       - unclosed delimiter\n...\n41 |                     while new_s_char_char_char_char_pos\
    \ < new_s_char_char_char_char_len {\n   |                                    \
    \                                                     - unclosed delimiter\n...\n\
    45 |                         while new_s_char_char_char_char_char_pos < new_s_char_char_char_char_char_len\
    \ {\n   |                                                                    \
    \                                   - unclosed delimiter\n...\n49 |          \
    \                   while new_s_char_char_char_char_char_char_pos < new_s_char_char_char_char_char_char_char_len\
    \ {\n   |                                                                    \
    \                                                      - this delimiter might\
    \ not be properly closed...\n50 |                                 let mut new_s_\n\
    51 | }\n   | - ...as it matches this but it has different indentation\n...\n62\
    \ | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp8u0p528u.rs:50:47\n\
    \   |\n50 |                                 let mut new_s_\n   |             \
    \                                  ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `new_s_char_char_char_char_char_char_char_len`\
    \ in this scope\n  --> /tmp/tmp8u0p528u.rs:49:77\n   |\n49 | ...             \
    \      while new_s_char_"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ > s.chars().next().unwrap().to_ascii_lowercase().unwrap() {\n              \
    \  j = j + 1;\n            }\n        }\n        new_s.push_str(&s[..j]);\n  \
    \      new_s.push_str(&s[j..]);\n        i = j;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpypvdd348.rs:21:63\n   |\n21 |             if s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ > s.chars().next().unwrap().to_ascii_lowercase().unwrap() {\n   |          \
    \                                                     ^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `unwrap` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpypvdd348.rs:21:121\n   |\n21 |            \
    \ if s.chars().next().unwrap().to_ascii_lowercase().unwrap() > s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ {\n   |                                                                    \
    \                                                     ^^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + 1;\n        if new_s_len\
    \ > 3 {\n            new_s_len = 0;\n            new_s.push_str(&s[i .. j]);\n\
    \            new_s.push_str(&s[j .. s.len()]);\n            i = j;\n        }\
    \ else {\n            new_s.push_str(&s[i .. j]);\n            i = j;\n      \
    \  }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp08eso5u9.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp08eso5u9.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_char = new_s[new_s_len..new_s_len +\
    \ j].to_ascii_lowercase();\n        new_s_char = new_s_char.chars().collect::<Vec<_>>();\n\
    \        new_s_char.sort_by_key(|&x| x.to_ascii_lowercase());\n        new_s_char\
    \ = new_s_char.join(\"\");\n        new_s_len += j;\n        new_s.append(new_s_char);\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd18q40xd.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpd18q40xd.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd18q40xd.rs:28:22\n   |\n28 |         new_s_char\
    \ = new_s_char.chars().collect::<Vec<_>>();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Vec<char>`\n\nerror[E0599]: no method\
    \ named `sort_by_key` found for struct `String` in the current scope\n  --> /tmp/tmpd18q40xd.rs:29:20\n\
    \   |\n29 |         new_s_char.sort_by_key(|&x| x.to_ascii_lowercase());\n   |\
    \                    ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `join` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpd18q40xd.rs:30:33\n   |\n30 |         new_s_char = new_s_char.join(\"\
    \");\n   |                                 ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpd18q40xd.rs:32:15\n   |\n32 |         new_s.append(new_s_char);\n\
    \   |               ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j].is_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_lowercase() {\n                j = j + 1;\n      \
    \          continue;\n            }\n            if s[j].is_ascii_uppercase()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_digit() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_punctuation() {\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_letter() {\n                j = j + 1;\n             \
    \   continue;\n            }\n            if s[j].is_ascii_lowercase() {\n   \
    \             j = j + 1;\n                continue;\n            }\n         \
    \   if s[j].is_ascii_uppercase() {\n                j = j + 1;\n             \
    \   continue;\n            }\n            if s[j].is_ascii_digit() {\n       \
    \         j = j + 1;\n                continue;\n            }\n            if\
    \ s[j].is_ascii_punctuation() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_letter() {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s[j].is_ascii_lowercase()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_uppercase() {\n                j = j + 1;\n      \
    \          continue;\n            }\n            if s[j].is_ascii_digit() {\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_punctuation() {\n                j = j + 1;\n        \
    \        continue;\n            }\n            if s[j].is_ascii_letter() {\n \
    \               j = j + 1;\n                continue;\n            }\n       \
    \     if s[j].is_ascii_lowercase() {\n                j = j + 1;\n           \
    \     continue;\n            }\n            if s[j].is_ascii_uppercase() {\n \
    \               j = j + 1;\n                continue;\n            }\n       \
    \     if s[j].is_ascii_digit() {\n                j = j + 1;\n               \
    \ continue;\n            }\n            if s[j].is_ascii_punctuation() {\n   \
    \             j = j + 1;\n                continue;\n            }\n         \
    \   if s[j].is_ascii_letter() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_lowercase() {\n                j\
    \ = j + 1;\n                continue;\n            }\n            if s[j].is_ascii_uppercase()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_digit() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_punctuation() {\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_letter\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxc1l5320.rs:133:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < s.len() {\n\
    \    |                       - unclosed delimiter\n19  |         let mut j = i;\n\
    20  |         while j < s.len() {\n    |                           - this delimiter\
    \ might not be properly closed...\n...\n122 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n133 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmpxc1l5320.rs:122:1\n    |\n121 |             if\
    \ s[j].is_ascii_letter\n    |             -- this `if` expression has a condition,\
    \ but no block\n122 | }\n    | ^ expected `{`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpxc1l5320.rs:21:16\n   |\n21 |  \
    \           if s[j].is_whitespace() {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxc1l5320.rs:25:16\n   |\n25 |             if s[j].is_ascii_lowercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxc1l5320.rs:29:16\n\
    \   |\n29 |             if s[j].is_ascii_uppercase() {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpxc1l5320.rs:33:16\n   |\n33 |            \
    \ if s[j].is_ascii_digit() {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpxc1l5320.rs:37:16\n   |\n37 |             if s[j].is_ascii_punctuation()\
    \ {\n   |                ^^^^ `String` cannot b"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  while i < s.len() {\n        while j < s.len() {\n            if s.chars().nth(i).unwrap().to_ascii_lowercase()\
    \ < s.chars().nth(j).unwrap().to_ascii_lowercase() {\n                s.swap(i,\
    \ j);\n            }\n            j += 1\n        }\n        i += 1\n    }\n \
    \   s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmps3_yb5p2.rs:20:19\n   |\n20 |                 s.swap(i,\
    \ j);\n   |                   ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut new_s_len5 =\
    \ new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7 = new_s_len;\n\
    \    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 = new_s_len;\n  \
    \  let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 = new_s_len;\n  \
    \  let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 = new_s_len;\n  \
    \  let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 = new_s_len;\n  \
    \  let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 = new_s_len;\n  \
    \  let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 = new_s_len;\n  \
    \  let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 = new_s_len;\n  \
    \  let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 = new_s_len;\n  \
    \  let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 = new_s_len;\n  \
    \  let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 = new_s_len;\n  \
    \  let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 = new_s_len;\n  \
    \  let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 = new_s_len;\n  \
    \  let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 = new_s_len;\n  \
    \  let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 = new_s_len;\n  \
    \  let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 = new_s_len;\n  \
    \  let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 = new_s_len;\n  \
    \  let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 = new_s_len;\n  \
    \  let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 = new_s_len;\n  \
    \  let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 = new_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpclun_hhh.rs:60:31\n   |\n\
    60 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmpclun_hhh.rs:60:27\n   |\n60 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpclun_hhh.rs:13:31\n   |\n13 | fn anti_shuffle(s: String) -> String {\n\
    \   |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                break;\n            }\n            j += 1\n        }\n  \
    \      if j == new_s_len {\n            new_s.push_str(&s[i]);\n            i\
    \ += 1;\n        } else {\n            new_s.push_str(&s[new_s_len - j - 1]);\n\
    \            new_s.push_str(&s[i]);\n            i += 1;\n        }\n    }\n \
    \   new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn4aduj5t.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn4aduj5t.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn4aduj5t.rs:27:29\n\
    \   |\n27 |             new_s.push_str(&s[i]);\n   |                         \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpn4aduj5t.rs:30:29\n   |\n30 |            \
    \ new_s.push_str(&s[new_s_len - j - 1]);\n   |                             ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpn4aduj5t.rs:31:29\n   |\n31 |            \
    \ new_s.push_str(&s[i]);\n   |                             ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < s.len() {\n        let mut c =\
    \ s.chars().nth(i);\n        while c != ' ' {\n            new_s.push_str(&c.to_string());\n\
    \            i += 1;\n            c = s.chars().nth(i);\n        }\n        new_s.push_str(&c.to_string());\n\
    \        i += 1;\n    }\n    while j < new_s.len() {\n        let mut c = new_s.chars().nth(j);\n\
    \        while c != ' ' {\n            new_s.push_str(&c.to_string());\n     \
    \       j += 1;\n            c = new_s.chars().nth(j);\n        }\n        new_s.push_str(&c.to_string());\n\
    \        j += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpozea6o2t.rs:20:20\n   |\n\
    20 |         while c != ' ' {\n   |                    ^^^\n   |             \
    \       |\n   |                    expected enum `Option`, found `char`\n   |\
    \                    help: try using a variant of the expected enum: `Some(' ')`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    \nerror[E0599]: the method `to_string` exists for enum `Option<char>`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmpozea6o2t.rs:21:31\n    |\n21\
    \  |               new_s.push_str(&c.to_string());\n    |                    \
    \             ^^^^^^^^^ method cannot be called on `Option<char>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: std::fmt::Display`\n            which is required\
    \ by `Option<char>: ToString`\n\nerror[E0599]: the method `to_string` exists for\
    \ enum `Option<char>`, but its trait bounds were not satisfied\n   --> /tmp/tmpozea6o2t.rs:25:27\n\
    \    |\n25  |           new_s.push_str(&c.to_string());\n    |               \
    \              ^^^^^^^^^ method cannot be called on `Option<char>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: std::fmt::Display`\n            which is required\
    \ by `Option<char>: ToString`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpozea6o2t.rs:30:20\n\
    \   |\n30 |         while c != ' ' {\n   |                    ^^^\n   |      \
    \              |\n   |                    expected enum `Option`, found `char`\n\
    \   |                    help: try using a variant of the expected enum: `Some('\
    \ ')`\n   |\n   = note: expected enum `Option<char>`\n              found type\
    \ `char`\n\nerror[E0599]: the method `to_string` exists for enum `Option<char>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmpozea6o2t.rs:31:31\n\
    \    |\n31  |               new_s.push_str(&c.to_string());\n    |           \
    \                      ^^^^^^^^^ method cannot be called on `Option<char>` due\
    \ to unsatisfied trait bounds\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        if j == new_s_len {\n            break;\n\
    \        }\n        let mut k = j;\n        while k < new_s_len && s[k] == ' '\
    \ {\n            k = k + 1;\n        }\n        if k == new_s_len {\n        \
    \    break;\n        }\n        let mut new_word = String::new();\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[k..new_s_len]);\n        new_s.push_str(&new_word);\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_s9jgy9o.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_s9jgy9o.rs:27:32\n\
    \   |\n27 |         while k < new_s_len && s[k] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s.chars().any(|c| c == ' ') {\n                j\
    \ = s.len();\n            } else {\n                new_s.push_char(s.chars().nth(j).unwrap());\n\
    \                j = j + 1;\n            }\n        }\n        new_s.push_char(s.chars().nth(i).unwrap());\n\
    \        i = i + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_char` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp48c8kitq.rs:23:23\n   |\n23 |             \
    \    new_s.push_char(s.chars().nth(j).unwrap());\n   |                       ^^^^^^^^^\
    \ help: there is an associated function with a similar name: `push_str`\n\nerror[E0599]:\
    \ no method named `push_char` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp48c8kitq.rs:27:15\n   |\n27 |         new_s.push_char(s.chars().nth(i).unwrap());\n\
    \   |               ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `push_str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                j = j + 1;\n    \
    \            continue;\n            }\n            if s[j] > s[i] {\n        \
    \        let mut temp = s[j];\n                s[j] = s[i];\n                s[i]\
    \ = temp;\n                j = j + 1;\n                continue;\n           \
    \ }\n            break;\n        }\n        new_s.push_str(&s[i .. j]);\n    \
    \    i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphd8kjl56.rs:20:16\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphd8kjl56.rs:20:23\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphd8kjl56.rs:24:16\n\
    \   |\n24 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphd8kjl56.rs:24:23\n   |\n24 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphd8kjl56.rs:25:32\n\
    \   |\n25 |                 let mut temp = s[j];\n   |                       \
    \         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmphd8kjl56.rs:26:17\n   |\n26 |  \
    \               s[j] = s[i];\n   |                 ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmphd8kjl56.rs:26:24\n   |\n26 |                 s[j] = s[i];\n   |\
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphd8kjl56.rs:27:17\n\
    \   |\n27 |                "
  stdout: ''
  timestamp: 1659749326
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[j..new_s_len]);\n                break;\n \
    \           }\n            j += 1\n        }\n        i += 1;\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Hi\"`', /tmp/tmpytd6wn6o.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] > s[i] {\n                let tmp = s[j];\n\
    \                s[j] = s[i];\n                s[i] = tmp;\n            }\n  \
    \          j += 1;\n        }\n        new_s.push_str(&s[i]);\n        i += 1;\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplx1gtt85.rs:20:16\n\
    \   |\n20 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplx1gtt85.rs:20:23\n   |\n20 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplx1gtt85.rs:21:27\n\
    \   |\n21 |                 let tmp = s[j];\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmplx1gtt85.rs:22:17\n   |\n22 |            \
    \     s[j] = s[i];\n   |                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplx1gtt85.rs:22:24\n\
    \   |\n22 |                 s[j] = s[i];\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmplx1gtt85.rs:23:17\n   |\n23 |                 s[i]\
    \ = tmp;\n   |                 ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplx1gtt85.rs:27:25\n\
    \   |\n27 |         new_s.push_str(&s[i]);\n   |                         ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 7 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut new_s_len5 =\
    \ new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7 = new_s_len;\n\
    \    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 = new_s_len;\n  \
    \  let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 = new_s_len;\n  \
    \  let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 = new_s_len;\n  \
    \  let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 = new_s_len;\n  \
    \  let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 = new_s_len;\n  \
    \  let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 = new_s_len;\n  \
    \  let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 = new_s_len;\n  \
    \  let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 = new_s_len;\n  \
    \  let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 = new_s_len;\n  \
    \  let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 = new_s_len;\n  \
    \  let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 = new_s_len;\n  \
    \  let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 = new_s_len;\n  \
    \  let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 = new_s_len;\n  \
    \  let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 = new_s_len;\n  \
    \  let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 = new_s_len;\n  \
    \  let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 = new_s_len;\n  \
    \  let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 = new_s_len;\n  \
    \  let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 = new_s_len;\n  \
    \  let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 = new_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpclun_hhh.rs:60:31\n   |\n\
    60 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmpclun_hhh.rs:60:27\n   |\n60 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpclun_hhh.rs:13:31\n   |\n13 | fn anti_shuffle(s: String) -> String {\n\
    \   |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' && s[j]\
    \ != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n                new_s.push_str(&s[j]);\n\
    \                new_s_len += 1;\n            }\n            j += 1\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcxw_dltg.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' && s[j] != '\\n' && s[j] != '\\r' && s[j]\
    \ != '\\t' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcxw_dltg.rs:21:31\n\
    \   |\n21 |             if s[j] != ' ' && s[j] != '\\n' && s[j] != '\\r' && s[j]\
    \ != '\\t' {\n   |                               ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpcxw_dltg.rs:21:47\n   |\n21 |             if s[j] != ' ' && s[j]\
    \ != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n   |                         \
    \                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcxw_dltg.rs:21:63\n\
    \   |\n21 |             if s[j] != ' ' && s[j] != '\\n' && s[j] != '\\r' && s[j]\
    \ != '\\t' {\n   |                                                           \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpcxw_dltg.rs:22:33\n   |\n22 |            \
    \     new_s.push_str(&s[j]);\n   |                                 ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxofcaye1.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxofcaye1.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] > s[i] {\n                let temp = s[j];\n\
    \                s[j] = s[i];\n                s[i] = temp;\n            }\n \
    \           j += 1;\n        }\n        new_s.push_str(&s[i]);\n        i += 1;\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpblhm_pma.rs:20:16\n\
    \   |\n20 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpblhm_pma.rs:20:23\n   |\n20 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpblhm_pma.rs:21:28\n\
    \   |\n21 |                 let temp = s[j];\n   |                           \
    \ ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpblhm_pma.rs:22:17\n   |\n22 |            \
    \     s[j] = s[i];\n   |                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpblhm_pma.rs:22:24\n\
    \   |\n22 |                 s[j] = s[i];\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpblhm_pma.rs:23:17\n   |\n23 |                 s[i]\
    \ = temp;\n   |                 ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpblhm_pma.rs:27:25\n\
    \   |\n27 |         new_s.push_str(&s[i]);\n   |                         ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 7 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                j = j + 1;\n    \
    \        }\n            i += 1;\n        }\n        new_s.push_str(&s[i .. j]);\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxz6dns4c.rs:20:16\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxz6dns4c.rs:20:23\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxofcaye1.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxofcaye1.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j < s.len() {\n            if s[j] < s[i]\
    \ {\n                swap(&mut s, i, j);\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmprx1rd6j_.rs:20:17\n\
    \   |\n20 |                 swap(&mut s, i, j);\n   |                 ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprx1rd6j_.rs:19:16\n\
    \   |\n19 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprx1rd6j_.rs:19:23\n   |\n19 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j < s.len() {\n            if s[j] < s[i]\
    \ {\n                s[j] = s[i];\n                s[i] = s[j];\n            \
    \    j = i;\n            }\n            j += 1;\n        }\n        i += 1;\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8csnb3y.rs:19:16\n\
    \   |\n19 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps8csnb3y.rs:19:23\n   |\n19 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8csnb3y.rs:20:17\n\
    \   |\n20 |                 s[j] = s[i];\n   |                 ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps8csnb3y.rs:20:24\n   |\n20 |                 s[j] = s[i];\n  \
    \ |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8csnb3y.rs:21:17\n\
    \   |\n21 |                 s[i] = s[j];\n   |                 ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps8csnb3y.rs:21:24\n   |\n21 |                 s[i] = s[j];\n  \
    \ |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] < 97 {\n                s[j] = s[j] + 1;\n                j = j + 1;\n\
    \                continue;\n            }\n            if s[j] > 122 {\n     \
    \           s[j] = s[j] - 1;\n                j = j + 1;\n                continue;\n\
    \            }\n            break;\n        }\n        new_s.push_str(&s[i ..\
    \ j]);\n        new_s_len = new_s_len + j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s_len = new_s_len + s.len() - i;\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq_ljzmid.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq_ljzmid.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq_ljzmid.rs:26:17\n\
    \   |\n26 |                 s[j] = s[j] + 1;\n   |                 ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpq_ljzmid.rs:26:24\n   |\n26 |                 s[j]\
    \ = s[j] + 1;\n   |                        ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq_ljzmid.rs:30:16\n\
    \   |\n30 |             if s[j] > 122 {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq_ljzmid.rs:31:17\n   |\n31 |                 s[j] = s[j] - 1;\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq_ljzmid.rs:31:24\n\
    \   |\n31 |                 s[j] = s[j] - 1;\n   |                        ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 7 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut k = i;\n        while k < s.len() {\n   \
    \         if s[k] > s[i] {\n                k = k + 1;\n            } else {\n\
    \                break;\n            }\n        }\n        let mut new_s_char\
    \ = new_s[new_s_len..new_s_len + k].iter().cloned().collect::<Vec<_>>();\n   \
    \     new_s_char.swap(i, j);\n        new_s_len += k;\n        new_s.append(&new_s_char);\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp48tve16i.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp48tve16i.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp48tve16i.rs:29:16\n\
    \   |\n29 |             if s[k] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp48tve16i.rs:29:23\n   |\n29 |             if s[k] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0599]:\
    \ no method named `iter` found for type `str` in the current scope\n  --> /tmp/tmp48tve16i.rs:35:62\n\
    \   |\n35 |         let mut new_s_char = new_s[new_s_len..new_s_len + k].iter().cloned().collect::<Vec<_>>();\n\
    \   |                                                              ^^^^ method\
    \ not found in `str`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp48tve16i.rs:38:15\n   |\n38 | \
    \        new_s.append(&new_s_char);\n   |               ^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[j]);\n                new_s.push_str(&s[i]);\n\
    \                break;\n            }\n            j += 1;\n        }\n     \
    \   i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp21vye127.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp21vye127.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp21vye127.rs:22:33\n\
    \   |\n22 |                 new_s.push_str(&s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp21vye127.rs:23:33\n   |\n\
    23 |                 new_s.push_str(&s[i]);\n   |                            \
    \     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[j]);\n                break;\n        \
    \    }\n            i += 1;\n            j += 1;\n        }\n        if j == new_s_len\
    \ {\n            new_s.push_str(&s[i]);\n        }\n        i += 1;\n    }\n \
    \   new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsxsso2k3.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsxsso2k3.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsxsso2k3.rs:22:33\n\
    \   |\n22 |                 new_s.push_str(&s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpsxsso2k3.rs:29:29\n   |\n\
    29 |             new_s.push_str(&s[i]);\n   |                             ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < s.len()\
    \ {\n        let mut new_s_len = new_s_len + 1;\n        let mut new_s_char =\
    \ new_s.chars();\n        let mut new_s_char_len = new_s_char.len();\n       \
    \ while new_s_char_len > 0 {\n            let mut new_s_char = new_s_char.next().unwrap();\n\
    \            if new_s_char == ' ' {\n                new_s_char_len -= 1;\n  \
    \          } else {\n                new_s_char.push(new_s_char.chars().next().unwrap());\n\
    \                new_s_char_len -= 1;\n            }\n        }\n        new_s.push_str(&new_s[..new_s_len]);\n\
    \        new_s.push_str(&new_s[new_s_len..]);\n        i += 1;\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpywe8m8ir.rs:22:45\n   |\n22 |         let mut new_s_char_len\
    \ = new_s_char.len();\n   |                                             ^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0599]: no method named `push` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpywe8m8ir.rs:28:28\n   |\n28 |   \
    \              new_s_char.push(new_s_char.chars().next().unwrap());\n   |    \
    \                        ^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmpywe8m8ir.rs:28:44\n\
    \   |\n28 |                 new_s_char.push(new_s_char.chars().next().unwrap());\n\
    \   |                                            ^^^^^ method not found in `char`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            new_s[new_s_len] = s[j];\n            new_s_len +=\
    \ 1;\n            j += 1;\n        }\n        new_s[new_s_len] = ' ';\n      \
    \  new_s_len += 1;\n        i += 1;\n    }\n    new_s.truncate(new_s_len);\n \
    \   new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvjg8vp2p.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvjg8vp2p.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvjg8vp2p.rs:25:30\n\
    \   |\n25 |             if s[j] < 'a' || s[j] > 'z' {\n   |                  \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpvjg8vp2p.rs:29:13\n\
    \   |\n29 |             new_s[new_s_len] = s[j];\n   |             ^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpvjg8vp2p.rs:29:32\n   |\n29 |            \
    \ new_s[new_s_len] = s[j];\n   |                                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpvjg8vp2p.rs:33:9\n   |\n33 |         new_s[new_s_len]\
    \ = ' ';\n   |         ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        new_s.push_str(&s[i]);\n     \
    \   new_s_len += 1;\n        i += 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpezs2fb8m.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpezs2fb8m.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpezs2fb8m.rs:27:25\n   |\n27 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k\
    \ .. j]);\n            i = k;\n        } else {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. k]);\n            i = j;\n     \
    \   }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8u2ikewy.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8u2ikewy.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s[j] < 97 {\n                new_s.push_str(&s[i .. j]);\n            \
    \    i += 1;\n                j += 1;\n                continue;\n           \
    \ }\n            if s[j] < 123 {\n                new_s.push_str(&s[i .. j]);\n\
    \                i += 1;\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] < 127 {\n                new_s.push_str(&s[i\
    \ .. j]);\n                i += 1;\n                j += 1;\n                continue;\n\
    \            }\n            new_s.push_str(&s[i .. j]);\n            i += 1;\n\
    \            j += 1;\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpo0rrl_4v.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpo0rrl_4v.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpo0rrl_4v.rs:31:16\n\
    \   |\n31 |             if s[j] < 123 {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpo0rrl_4v.rs:37:16\n   |\n37 |             if s[j] < 127 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        let mut k = i;\n        while\
    \ k < s.len() {\n            if s[k] != ' ' {\n                new_s.push_str(&s[k]);\n\
    \                new_s_len += 1;\n            }\n            k += 1\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8w24fx74.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8w24fx74.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8w24fx74.rs:29:16\n\
    \   |\n29 |             if s[k] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8w24fx74.rs:30:33\n   |\n30 |                 new_s.push_str(&s[k]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j += 1;\n            } else {\n                break;\n         \
    \   }\n        }\n        let mut new_s_char = new_s[new_s_len..new_s_len + j].to_lowercase();\n\
    \        new_s_char.copy_from_slice(&s[..j]);\n        new_s_char.copy_from_slice(&s[i..]);\n\
    \        new_s.push_str(&new_s_char);\n        new_s_len += j;\n        i = j;\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwmkswtni.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwmkswtni.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0599]:\
    \ no method named `copy_from_slice` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpwmkswtni.rs:28:20\n   |\n28 |         new_s_char.copy_from_slice(&s[..j]);\n\
    \   |                    ^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `copy_from_slice` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpwmkswtni.rs:29:20\n   |\n29 |         new_s_char.copy_from_slice(&s[i..]);\n\
    \   |                    ^^^^^^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        let mut k = i;\n        while\
    \ k < s.len() {\n            if s[k] != ' ' {\n                new_s.push_str(&s[k]);\n\
    \                new_s_len += 1;\n            }\n            k += 1\n        }\n\
    \        if new_s_len > 0 {\n            new_s.push_str(&' ');\n            new_s_len\
    \ += 1;\n        }\n        new_s.push_str(&s[i]);\n        new_s_len += 1;\n\
    \        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp42hk05qv.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp42hk05qv.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp42hk05qv.rs:29:16\n\
    \   |\n29 |             if s[k] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp42hk05qv.rs:30:33\n   |\n30 |                 new_s.push_str(&s[k]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp42hk05qv.rs:36:28\n   |\n36 |  \
    \           new_s.push_str(&' ');\n   |                            ^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp42hk05qv.rs:39:25\n   |\n39 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut new_s_len5 =\
    \ new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7 = new_s_len;\n\
    \    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 = new_s_len;\n  \
    \  let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 = new_s_len;\n  \
    \  let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 = new_s_len;\n  \
    \  let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 = new_s_len;\n  \
    \  let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 = new_s_len;\n  \
    \  let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 = new_s_len;\n  \
    \  let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 = new_s_len;\n  \
    \  let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 = new_s_len;\n  \
    \  let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 = new_s_len;\n  \
    \  let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 = new_s_len;\n  \
    \  let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 = new_s_len;\n  \
    \  let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 = new_s_len;\n  \
    \  let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 = new_s_len;\n  \
    \  let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 = new_s_len;\n  \
    \  let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 = new_s_len;\n  \
    \  let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 = new_s_len;\n  \
    \  let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 = new_s_len;\n  \
    \  let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 = new_s_len;\n  \
    \  let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 = new_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpclun_hhh.rs:60:31\n   |\n\
    60 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmpclun_hhh.rs:60:27\n   |\n60 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpclun_hhh.rs:13:31\n   |\n13 | fn anti_shuffle(s: String) -> String {\n\
    \   |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv3ryiwdw.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmpv3ryiwdw.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv3ryiwdw.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749324
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749330
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] == '\
    \ ' {\n                j += 1;\n                continue;\n            }\n   \
    \         if s[j] == ' ' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] > s[j] {\n                let temp = s[i];\n\
    \                s[i] = s[j];\n                s[j] = temp;\n                i\
    \ += 1;\n                j += 1;\n                continue;\n            }\n \
    \           if s[i] > s[j] {\n                i += 1;\n                continue;\n\
    \            }\n            if s[j] > s[i] {\n                j += 1;\n      \
    \          continue;\n            }\n            i += 1;\n            j += 1;\n\
    \        }\n        new_s.push_str(&s[i .. new_s_len]);\n    }\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf_trk5d2.rs:21:16\n\
    \   |\n21 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf_trk5d2.rs:25:16\n   |\n25 |             if s[j] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf_trk5d2.rs:29:16\n\
    \   |\n29 |             if s[i] > s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf_trk5d2.rs:29:23\n   |\n29 |             if s[i] > s[j] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf_trk5d2.rs:30:28\n\
    \   |\n30 |                 let temp = s[i];\n   |                           \
    \ ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpf_trk5d2.rs:31:17\n   |\n31 |            \
    \     s[i] = s[j];\n   |                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf_trk5d2.rs:31:24\n\
    \   |\n31 |                 s[i] = s[j];\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpf_trk5d2.rs:32:17\n   |\n32 |                 s[j]\
    \ = temp;\n "
  stdout: ''
  timestamp: 1659749326
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749330
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                new_s.push_str(&s[i .. j]);\n    \
    \            new_s.push_str(&\" \");\n                i = j;\n               \
    \ break;\n            }\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749331
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k\
    \ .. j]);\n            i = k;\n        } else {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. k]);\n            i = j;\n     \
    \   }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8u2ikewy.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8u2ikewy.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k\
    \ .. j]);\n            i = k;\n        } else {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. k]);\n            i = j;\n     \
    \   }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8u2ikewy.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8u2ikewy.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[j]);\n                new_s.push_str(&s[i]);\n\
    \                break;\n            }\n            j += 1\n        }\n      \
    \  i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjame34wd.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjame34wd.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjame34wd.rs:22:33\n\
    \   |\n22 |                 new_s.push_str(&s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpjame34wd.rs:23:33\n   |\n\
    23 |                 new_s.push_str(&s[i]);\n   |                            \
    \     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749325
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ <\n                new_s.chars().next().unwrap().to_ascii_lowercase().unwrap()\n\
    \            {\n                new_s.swap(j, j + 1);\n            }\n       \
    \     j += 1\n        }\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp06069cn5.rs:21:63\n   |\n21 |             if s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ <\n   |                                                               ^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `char` in the current scope\n  --> /tmp/tmp06069cn5.rs:22:68\n   |\n22\
    \ |                 new_s.chars().next().unwrap().to_ascii_lowercase().unwrap()\n\
    \   |                                                                    ^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `swap` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp06069cn5.rs:24:23\n   |\n\
    24 |                 new_s.swap(j, j + 1);\n   |                       ^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749326
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                new_s.push_str(&s[..j]);\n       \
    \         new_s.push_str(&s[j..]);\n                new_s_len += j - i;\n    \
    \            new_s.push_str(&s[..i]);\n                new_s.push_str(&s[i..]);\n\
    \                i = j;\n                break;\n            }\n        }\n  \
    \  }\n    new_s.push_str(&s[..i]);\n    new_s.push_str(&s[i..]);\n    new_s_len\
    \ += i - s.len();\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749331
