language: rs
name: HumanEval_105_by_length
results:
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ reversed = vec![];\n\n    for i in arr {\n        if i < 1 || i > 9 {\n    \
    \        continue;\n        }\n\n        reversed.push(i);\n    }\n\n    for i\
    \ in reversed.iter().rev() {\n        let mut s = String::from(\"One\");\n\n \
    \       if i == 1 {\n            s = String::from(\"One\");\n        }\n\n   \
    \     if i == 2 {\n            s = String::from(\"Two\");\n        }\n\n     \
    \   if i == 3 {\n            s = String::from(\"Three\");\n        }\n\n     \
    \   if i == 4 {\n            s = String::from(\"Four\");\n        }\n\n      \
    \  if i == 5 {\n            s = String::from(\"Five\");\n        }\n\n       \
    \ if i == 6 {\n            s = String::from(\"Six\");\n        }\n\n        if\
    \ i == 7 {\n            s = String::from(\"Seven\");\n        }\n\n        if\
    \ i == 8 {\n            s = String::from(\"Eight\");\n        }\n\n        if\
    \ i == 9 {\n            s = String::from(\"Nine\");\n        }\n\n        result.push(s);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpsuelgnvr.rs:32:14\n\
    \   |\n32 |         if i == 1 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpsuelgnvr.rs:36:14\n   |\n36 |         if i == 2 {\n   |       \
    \       ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait\
    \ `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmpsuelgnvr.rs:40:14\n \
    \  |\n40 |         if i == 3 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpsuelgnvr.rs:44:14\n   |\n44 |         if i == 4 {\n   |       \
    \       ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait\
    \ `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut digits_reversed = vec![];\n    let mut digits_reversed_index\
    \ = 0;\n    let mut digits_reversed_index2 = 0;\n    let mut digits_reversed_index3\
    \ = 0;\n    let mut digits_reversed_index4 = 0;\n    let mut digits_reversed_index5\
    \ = 0;\n    let mut digits_reversed_index6 = 0;\n    let mut digits_reversed_index7\
    \ = 0;\n    let mut digits_reversed_index8 = 0;\n    let mut digits_reversed_index9\
    \ = 0;\n\n    for digit in arr {\n        if digit < 10 {\n            digits.push(digit);\n\
    \        } else if digit < 100 {\n            digits.push(digit / 10);\n     \
    \       digits.push(digit % 10);\n        } else if digit < 1000 {\n         \
    \   digits.push(digit / 100);\n            digits.push(digit % 100);\n       \
    \ } else if digit < 10000 {\n            digits.push(digit / 1000);\n        \
    \    digits.push(digit % 1000);\n        } else if digit < 100000 {\n        \
    \    digits.push(digit / 10000);\n            digits.push(digit % 10000);\n  \
    \      } else if digit < 1000000 {\n            digits.push(digit / 100000);\n\
    \            digits.push(digit % 100000);\n        } else if digit < 10000000\
    \ {\n            digits.push(digit / 1000000);\n            digits.push(digit\
    \ % 1000000);\n        } else if digit < 100000000 {\n            digits.push(digit\
    \ / 10000000);\n            digits.push(digit % 10000000);\n        } else if\
    \ digit < 1000000000 {\n            digits.push(digit / 100000000);\n        \
    \    digits.push(digit % 100000000);\n        } else {\n            digits.push(digit\
    \ / 1000000000);\n            digits.push(digit % 1000000000);\n        }\n  \
    \  }\n\n    for digit in digits {\n        if digit < 10 {\n            digits_reversed.push(String::from(\"\
    One\"));\n        } else if digit < 100 {\n            digits_reversed.push(String::from(\"\
    Two\"));\n        } else if digit < 1000 {\n            digits_reversed.push(String::from(\"\
    Three\"));\n        } else if digit < 10000 {\n            digits_reversed.push(String::from(\"\
    Four\"));\n        } else if digit < 100000 {\n            digits_reversed.push(String::from(\"\
    Five\"));\n        } else if digit < 1000000 {\n            digits_reversed.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            digits_reversed.\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqe8wyd_z.rs:88:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n64 |     for digit\
    \ in digits {\n   |                         - unclosed delimiter\n...\n77 |  \
    \       } else if digit < 10000000 {\n   |                                   \
    \ - this delimiter might not be properly closed...\n78 |             digits_reversed.\n\
    79 | }\n   | - ...as it matches this but it has different indentation\n...\n88\
    \ | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpqe8wyd_z.rs:79:1\n\
    \   |\n79 | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqe8wyd_z.rs:78:13\n\
    \   |\n77 |           } else if digit < 10000000 {\n   |  ________________-\n\
    78 | |             digits_reversed.\n   | |             ^^^^^^^^^^^^^^^ expected\
    \ `()`, found struct `Vec`\n79 | | }\n   | |_- expected this to be `()`\n   |\n\
    \   = note: expected unit type `()`\n                 found struct `Vec<String>`\n\
    help: you might have meant to return this value\n   |\n78 |             return\
    \ digits_reversed;.\n   |             ++++++                +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqe8wyd_z.rs:64:5\n   |\n13 |   fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                    -----------\
    \ expected `Vec<String>` because of return type\n...\n64 | /     for digit in\
    \ digits {\n65 | |         if digit < 10 {\n66 | |             digits_reversed.push(String::from(\"\
    One\"));\n67 | |         } else if digit < 100 {\n...  |\n87 | |     assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n88 | | }\n   | |__^ expected struct `Vec`, found `()`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         arr[i] = String::from(&name_to_digit(&arr[i - 1]));\n            i +=\
    \ 1;\n        }\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `name_to_digit` in this scope\n  -->\
    \ /tmp/tmp49mh835j.rs:25:36\n   |\n25 |             arr[i] = String::from(&name_to_digit(&arr[i\
    \ - 1]));\n   |                                    ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp49mh835j.rs:25:22\n\
    \   |\n25 |             arr[i] = String::from(&name_to_digit(&arr[i - 1]));\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found struct `String`\n   |             |\n   |             expected\
    \ due to the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp49mh835j.rs:29:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n29 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n      \
    \      j += 1\n        }\n        reversed.push(arr[j].to_string());\n       \
    \ i += j - i;\n    }\n    for i in 0..arr.len() {\n        arr[i] = reversed[arr.len()\
    \ - 1 - i];\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk_4ozazm.rs:30:18\n   |\n\
    30 |         arr[i] = reversed[arr.len() - 1 - i];\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |         |\n   |         expected\
    \ due to the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk_4ozazm.rs:32:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n32 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() && arr[j] < 10 {\n            j += 1\n        }\n        let mut k\
    \ = j;\n        while k < arr.len() && arr[k] > 9 {\n            k += 1\n    \
    \    }\n        if k > i {\n            result.push(String::from(&arr[i..k]));\n\
    \        }\n        i = k;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&[isize]>` is not satisfied\n\
    \  --> /tmp/tmpq19ciegw.rs:29:25\n   |\n29 |             result.push(String::from(&arr[i..k]));\n\
    \   |                         ^^^^^^^^^^^^ the trait `From<&[isize]>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digit_idx = 0;\n    let mut digit_idx2 = 0;\n   \
    \ let mut digit_idx3 = 0;\n    let mut digit_idx4 = 0;\n    let mut digit_idx5\
    \ = 0;\n    let mut digit_idx6 = 0;\n    let mut digit_idx7 = 0;\n    let mut\
    \ digit_idx8 = 0;\n\n    while digit_idx < digits_len {\n        let mut digit_len\
    \ = digits[digit_idx].len();\n        let mut digit_idx2 = 0;\n        let mut\
    \ digit_idx3 = 0;\n        let mut digit_idx4 = 0;\n        let mut digit_idx5\
    \ = 0;\n        let mut digit_idx6 = 0;\n        let mut digit_idx7 = 0;\n   \
    \     let mut digit_idx8 = 0;\n        while digit_idx2 < digit_len {\n      \
    \      let mut digit_len2 = digits[digit_idx2].len();\n            let mut digit_idx3\
    \ = 0;\n            let mut digit_idx4 = 0;\n            let mut digit_idx5 =\
    \ 0;\n            let mut digit_idx6 = 0;\n            let mut digit_idx7 = 0;\n\
    \            let mut digit_idx8 = 0;\n            while digit_idx3 < digit_len2\
    \ {\n                let mut digit_len3 = digits[digit_idx3].len();\n        \
    \        let mut digit_idx4 = 0;\n                let mut digit_idx5 = 0;\n  \
    \              let mut digit_idx6 = 0;\n                let mut digit_idx7 = 0;\n\
    \                let mut digit_idx8 = 0;\n                while digit_idx4 < digit_len3\
    \ {\n                    let mut digit_len4 = digits[digit_idx4].len();\n    \
    \                let mut digit_idx5 = 0;\n                    let mut digit_idx6\
    \ = 0;\n                    let mut digit_idx7 = 0;\n                    let mut\
    \ digit_idx8 = 0;\n                    while digit_idx5 < digit_len4 {\n     \
    \                   let mut digit_len5 = digits[digit_idx5].len();\n         \
    \               let mut digit_idx6 = 0;\n                        let mut digit_idx7\
    \ = 0;\n                        let mut digit_idx8 = 0;\n                    \
    \    while digit_idx6 < digit_len5 {\n                            let mut digit_len6\
    \ = digits[digit_idx6].len();\n                            let mut digit_idx7\
    \ = 0;\n                            let mut digit_idx8 = 0;\n                \
    \            while digit_idx7 < digit_len6 {\n                               \
    \ let mut digit_len7 = digits[digit_idx7].len();\n                           \
    \     let mut digit_idx8 = 0;\n                                \n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmphfqnjczf.rs:82:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n30 |     while digit_idx\
    \ < digits_len {\n   |                                  - unclosed delimiter\n\
    ...\n39 |         while digit_idx2 < digit_len {\n   |                       \
    \               - unclosed delimiter\n...\n47 |             while digit_idx3 <\
    \ digit_len2 {\n   |                                           - unclosed delimiter\n\
    ...\n54 |                 while digit_idx4 < digit_len3 {\n   |              \
    \                                 - unclosed delimiter\n...\n60 |            \
    \         while digit_idx5 < digit_len4 {\n   |                              \
    \                     - unclosed delimiter\n...\n65 |                        \
    \ while digit_idx6 < digit_len5 {\n   |                                      \
    \                 - unclosed delimiter\n...\n69 |                            \
    \ while digit_idx7 < digit_len6 {\n   |                                      \
    \                     - this delimiter might not be properly closed...\n...\n\
    73 | }\n   | - ...as it matches this but it has different indentation\n...\n82\
    \ | }\n   |   ^\n\nerror[E0599]: no method named `len` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmphfqnjczf.rs:31:47\n   |\n31 |         let\
    \ mut digit_len = digits[digit_idx].len();\n   |                             \
    \                  ^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `len` found for type `isize` in the current scope\n  --> /tmp/tmphfqnjczf.rs:40:53\n\
    \   |\n40 |             let mut digit_len2 = digits[digit_idx2].len();\n   | \
    \                                                    ^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `len` found for type `isize` in the current scope\n\
    \  --> /tmp/tmphfqnjczf.rs:48:57\n   |\n48 |                 let mut digit_len3\
    \ = digits[digit_idx3].len();\n   |                                          \
    \               ^^^ method not found in `isize`\n\nerror[E0599"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n\n        let mut j = i;\n        while j > 0 && arr[j - 1] > arr[j]\
    \ {\n            j -= 1;\n        }\n\n        swap(&mut arr[j], &mut arr[i]);\n\
    \        i += 1;\n    }\n\n    arr.iter().map(|x| String::from(&x[..])).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp3mzjh6eb.rs:32:9\n\
    \   |\n32 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0608]: cannot\
    \ index into a value of type `&isize`\n  --> /tmp/tmp3mzjh6eb.rs:36:38\n   |\n\
    36 |     arr.iter().map(|x| String::from(&x[..])).collect()\n   |            \
    \                          ^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        if digits[i]\
    \ < 1 || digits[i] > 9 {\n            i += 1;\n            continue;\n       \
    \ }\n\n        let mut j = i;\n        while j < digits_len && digits[j] == digits[i]\
    \ {\n            i += 1;\n            j += 1\n        }\n\n        if j == digits_len\
    \ {\n            result.push(String::from(&digits[i..]));\n            break;\n\
    \        }\n\n        let mut reversed = vec![];\n        reversed.extend_from_slice(&digits[0..i]);\n\
    \        reversed.extend_from_slice(&digits[i..j]);\n        result.push(String::from(&reversed));\n\
    \        i = j;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&[isize]>` is not satisfied\n\
    \  --> /tmp/tmpia5dhy21.rs:35:25\n   |\n35 |             result.push(String::from(&digits[i..]));\n\
    \   |                         ^^^^^^^^^^^^ the trait `From<&[isize]>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0277]: the trait bound `String: From<&Vec<isize>>` is not satisfied\n\
    \  --> /tmp/tmpia5dhy21.rs:42:21\n   |\n42 |         result.push(String::from(&reversed));\n\
    \   |                     ^^^^^^^^^^^^ the trait `From<&Vec<isize>>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut reversed = vec![];\n\n    for i in arr {\n   \
    \     if i >= 1 && i <= 9 {\n            digits.push(i);\n        } else {\n \
    \           reversed.push(i);\n        }\n    }\n\n    for i in digits {\n   \
    \     let mut index = reversed.iter().position(|&x| x == i).unwrap();\n      \
    \  let name = String::from(&reversed[index]);\n        result.push(name);\n  \
    \  }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmp4vt_e1fx.rs:32:20\n   |\n32 |         let name = String::from(&reversed[index]);\n\
    \   |                    ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| {\n        match x {\n            1 => 1,\n         \
    \   2 => 2,\n            3 => 3,\n            4 => 4,\n            5 => 5,\n \
    \           6 => 6,\n            7 => 7,\n            8 => 8,\n            9 =>\
    \ 9,\n            _ => panic!(\"Invalid number in array: {}\", x),\n        }\n\
    \    });\n    arr.iter().map(|x| {\n        match x {\n            1 => \"One\"\
    ,\n            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"\
    Four\",\n            5 => \"Five\",\n            6 => \"Six\",\n            7\
    \ => \"Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n   \
    \         _ => panic!(\"Invalid number in array: {}\", x),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpwoe8a3a8.rs:45:8\n     |\n45 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10).pow(arr.len() - 1)).unwrap());\n    arr.iter().map(|x| {\n\
    \        match x {\n            0 => \"Zero\".to_string(),\n            1 => \"\
    One\".to_string(),\n            2 => \"Two\".to_string(),\n            3 => \"\
    Three\".to_string(),\n            4 => \"Four\".to_string(),\n            5 =>\
    \ \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n            7\
    \ => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n       \
    \     9 => \"Nine\".to_string(),\n            _ => panic!(\"Invalid number {:?}\"\
    , x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpjlv9z08d.rs:19:44\n   |\n19 |     arr.sort_by_key(|x| x.checked_mul((10).pow(arr.len()\
    \ - 1)).unwrap());\n   |                                            ^^^\n   |\n\
    help: you must specify a concrete type for this numeric value, like `i32`\n  \
    \ |\n19 |     arr.sort_by_key(|x| x.checked_mul((10_i32).pow(arr.len() - 1)).unwrap());\n\
    \   |                                        ~~~~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0689`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < len {\n            if arr[j]\
    \ > arr[i] {\n                swap(&mut arr[j], &mut arr[i]);\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    arr.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp7z8jt10l.rs:28:17\n\
    \   |\n28 |                 swap(&mut arr[j], &mut arr[i]);\n   |            \
    \     ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7z8jt10l.rs:34:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n34 |\
    \     arr.iter().cloned().collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n\n    while digits_len > 0 {\n        let mut digit = digits[digits_len\
    \ - 1];\n        let mut digits_len = digits_len - 1;\n\n        while digit >\
    \ 9 {\n            digit -= 10;\n            result.push(String::from(\"Nine\"\
    ));\n        }\n\n        result.push(String::from(&names[digit]));\n    }\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpr2zenbii.rs:31:35\n\
    \   |\n31 |         result.push(String::from(&names[digit]));\n   |          \
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect::<Vec<_>>();\n    let mut len = arr.len();\n    let mut\
    \ i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n       \
    \     i += 1;\n            continue;\n        }\n\n        let mut j = i;\n  \
    \      while j < len {\n            if arr[j] > 9 {\n                j += 1;\n\
    \                continue;\n            }\n            if arr[j] < 1 {\n     \
    \           j += 1;\n                continue;\n            }\n            arr[j]\
    \ = by_length(vec![arr[j], arr[j + 1]])\n                .into_iter()\n      \
    \          .map(|x| x as isize)\n                .collect::<Vec<_>>()\n      \
    \          .len();\n            j += 1;\n        }\n        i += 1;\n    }\n\n\
    \    arr.iter().map(|x| x as String).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi7cgantt.rs:37:22\n   |\n\
    37 |               arr[j] = by_length(vec![arr[j], arr[j + 1]])\n   |  _____________------___^\n\
    \   | |             |\n   | |             expected due to the type of this binding\n\
    38 | |                 .into_iter()\n39 | |                 .map(|x| x as isize)\n\
    40 | |                 .collect::<Vec<_>>()\n41 | |                 .len();\n\
    \   | |______________________^ expected `isize`, found `usize`\n\nerror[E0605]:\
    \ non-primitive cast: `String` as `isize`\n  --> /tmp/tmpi7cgantt.rs:39:26\n \
    \  |\n39 |                 .map(|x| x as isize)\n   |                        \
    \  ^^^^^^^^^^ an `as` expression can only be used to convert between primitive\
    \ types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive\
    \ cast: `&isize` as `String`\n  --> /tmp/tmpi7cgantt.rs:47:24\n   |\n47 |    \
    \ arr.iter().map(|x| x as String).collect()\n   |                        ^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let mut\
    \ j = i;\n        while j < digits_len && digits[j] < 10 {\n            j += 1\n\
    \        }\n        let mut digit = digits[i];\n        if j == digits_len {\n\
    \            digit = digits_len;\n        }\n        result.push(String::from(&digits[digit]));\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ihdeh_m.rs:29:21\n   |\n\
    27 |         let mut digit = digits[i];\n   |                         ---------\
    \ expected due to this value\n28 |         if j == digits_len {\n29 |        \
    \     digit = digits_len;\n   |                     ^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp4ihdeh_m.rs:31:35\n   |\n31 |         result.push(String::from(&digits[digit]));\n\
    \   |                                   ^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.to_owned();\n    arr.sort_unstable();\n\
    \    arr.reverse();\n    arr.iter().map(|x| {\n        match x {\n           \
    \ 1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n    \
    \        4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\"\
    ,\n            7 => \"Seven\",\n            8 => \"Eight\",\n            9 =>\
    \ \"Nine\",\n            _ => panic!(\"Invalid number: {}\", x),\n        }\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpgqgwi6im.rs:34:8\n     |\n34 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect::<Vec<_>>();\n    arr.sort_unstable();\n    arr.iter().map(|x|\
    \ {\n        match x {\n            1 => \"One\",\n            2 => \"Two\",\n\
    \            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"Invalid\
    \ number: {}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpe5c9epo3.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.to_owned();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n\
    \        let mut j = i;\n        while j > 0 && arr[j - 1] > arr[j] {\n      \
    \      j -= 1;\n        }\n        swap(&mut arr[j], &mut arr[i]);\n        i\
    \ += 1;\n    }\n    arr.iter().map(|x| String::from(&format!(\"{}\", x)).to_owned()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpg1yjm5d5.rs:29:9\n\
    \   |\n29 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    let mut cur = String::from(\"\
    One\");\n\n    while i < len {\n        if arr[i] < 10 {\n            i += 1;\n\
    \            continue;\n        }\n\n        let mut j = i;\n        let mut cur\
    \ = String::from(\"One\");\n\n        while j > 0 && arr[j - 1] > 9 {\n      \
    \      j -= 1;\n        }\n\n        if j > 0 {\n            arr.swap(i, j);\n\
    \            i += j - 1;\n        }\n\n        cur = String::from(&arr[i - 1].to_string());\n\
    \        arr.swap(i, i);\n        i += 1;\n    }\n\n    arr\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmptprsg7_k.rs:18:35\n     |\n18   |     let mut arr =\
    \ arr.into_iter().cloned().collect::<Vec<_>>();\n     |                      \
    \             ^^^^^^ expected reference, found `isize`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `isize`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmptprsg7_k.rs:18:44\n \
    \  |\n18 |       let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         arr[i] = String::from(&names[arr[i] - 1]);\n            i += 1;\n  \
    \      }\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmplnckbqu5.rs:24:36\n\
    \   |\n24 |             arr[i] = String::from(&names[arr[i] - 1]);\n   |     \
    \                               ^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplnckbqu5.rs:24:22\n   |\n24 |             arr[i]\
    \ = String::from(&names[arr[i] - 1]);\n   |             ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplnckbqu5.rs:28:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n28 |     arr\n   |     ^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         swap(&mut arr, i, len - 1);\n            i += 1;\n        }\n    }\n\
    \    arr.iter().map(|x| String::from(&names[x])).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp5nyywpnj.rs:24:13\n\
    \   |\n24 |             swap(&mut arr, i, len - 1);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]:\
    \ cannot find value `names` in this scope\n  --> /tmp/tmp5nyywpnj.rs:28:38\n \
    \  |\n28 |     arr.iter().map(|x| String::from(&names[x])).collect()\n   |   \
    \                                   ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut digits = vec![];\n    let mut i = 0;\n    while i < arr.len()\
    \ {\n        let digit = arr[i] - 1;\n        if digit < 10 {\n            digits.push(digit);\n\
    \            i += 1;\n        } else {\n            let mut j = i;\n         \
    \   while j > 0 && digits[j - 1] > digit {\n                j -= 1;\n        \
    \    }\n            if j > 0 {\n                digits.push(digit - 10);\n   \
    \             digits.push(digits[j - 1]);\n                i += j;\n         \
    \   } else {\n                digits.push(digit - 10);\n                result.push(String::from(\"\
    One\"));\n                i += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"]`', /tmp/tmp_7ndu11h.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut digits_len = arr.len();\n    let mut i = 0;\n\
    \    while i < digits_len {\n        let digit = arr[i];\n        if digit < 10\
    \ {\n            digits.push(digit);\n        } else {\n            digits.push(digit\
    \ - 10);\n            digits.push(digit % 10);\n        }\n        i += 1;\n \
    \   }\n    digits.sort_unstable();\n    for i in 0..digits_len {\n        let\
    \ digit = digits[i];\n        let name = match digit {\n            0 => \"Zero\"\
    ,\n            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => panic!(\"Invalid digit {}\", digit),\n    \
    \    };\n        result.push(name);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaz6otbbt.rs:49:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    49 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] <\
    \ 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n \
    \       let mut j = i;\n        while j < arr.len() && arr[j] == arr[j] + 1 {\n\
    \            j += 1\n        }\n        result.push(String::from(&arr[i - j]));\n\
    \        i += j - i;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmpmh8l0cac.rs:25:21\n    |\n25  |         result.push(String::from(&arr[i\
    \ - j]));\n    |                     ^^^^^^^^^^^^ the trait `From<&isize>` is\
    \ not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let digit\
    \ = digits[i];\n        if digit < 10 {\n            result.push(String::from(&format!(\"\
    One\", digit)));\n            i += 1;\n        } else if digit < 100 {\n     \
    \       result.push(String::from(&format!(\"Two\", digit)));\n            i +=\
    \ 1;\n        } else if digit < 1000 {\n            result.push(String::from(&format!(\"\
    Three\", digit)));\n            i += 1;\n        } else if digit < 10000 {\n \
    \           result.push(String::from(&format!(\"Four\", digit)));\n          \
    \  i += 1;\n        } else if digit < 100000 {\n            result.push(String::from(&format!(\"\
    Five\", digit)));\n            i += 1;\n        } else if digit < 1000000 {\n\
    \            result.push(String::from(&format!(\"Six\", digit)));\n          \
    \  i += 1;\n        } else if digit < 10000000 {\n            result.push(String::from(&format!(\"\
    Seven\", digit)));\n            i += 1;\n        } else if digit < 100000000 {\n\
    \            result.push(String::from(&format!(\"Eight\", digit)));\n        \
    \    i += 1;\n        } else if digit < 1000000000 {\n            result.push(String::from(&format!(\"\
    Nine\", digit)));\n            i += 1;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmp7n6urr1n.rs:25:54\n   |\n25 |\
    \             result.push(String::from(&format!(\"One\", digit)));\n   |     \
    \                                          -----  ^^^^^ argument never used\n\
    \   |                                               |\n   |                  \
    \                             formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmp7n6urr1n.rs:28:54\n   |\n28 |             result.push(String::from(&format!(\"\
    Two\", digit)));\n   |                                               -----  ^^^^^\
    \ argument never used\n   |                                               |\n\
    \   |                                               formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmp7n6urr1n.rs:31:56\n   |\n31 |    \
    \         result.push(String::from(&format!(\"Three\", digit)));\n   |       \
    \                                        -------  ^^^^^ argument never used\n\
    \   |                                               |\n   |                  \
    \                             formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmp7n6urr1n.rs:34:55\n   |\n34 |             result.push(String::from(&format!(\"\
    Four\", digit)));\n   |                                               ------ \
    \ ^^^^^ argument never used\n   |                                            \
    \   |\n   |                                               formatting specifier\
    \ missing\n\nerror: argument never used\n  --> /tmp/tmp7n6urr1n.rs:37:55\n   |\n\
    37 |             result.push(String::from(&format!(\"Five\", digit)));\n   | \
    \                                              ------  ^^^^^ argument never used\n\
    \   |                                               |\n   |                  \
    \                             formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmp7n6urr1n.rs:40:54\n   |\n40 |             result.push(String::from(&format!(\"\
    Six\", digit)));\n   |                                               -----  ^^^^^\
    \ argument never used\n   |                                               |\n\
    \   |                 "
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut k = arr.len() - 1;\n    while\
    \ i < k {\n        if arr[i] < 9 {\n            i += 1;\n            continue;\n\
    \        }\n        if arr[i] > 9 {\n            j += 1;\n            i += 1;\n\
    \            continue;\n        }\n        arr[i] = String::from(&arr[j]);\n \
    \       j += 1;\n        i += 1;\n    }\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmp9ddoavep.rs:32:18\n    |\n32  |         arr[i] = String::from(&arr[j]);\n\
    \    |                  ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9ddoavep.rs:32:18\n   |\n32 |         arr[i] = String::from(&arr[j]);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9ddoavep.rs:36:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n36 |\
    \     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = vec![];\n\n    for i in arr.iter_mut() {\n        if i\
    \ <= 9 {\n            i += 10;\n            reversed.push(i);\n        } else\
    \ {\n            i += 1;\n            reversed.push(i);\n        }\n    }\n\n\
    \    for i in reversed.iter_mut() {\n        let index = arr.iter().position(|&i|\
    \ i == i).unwrap();\n        arr[index] = String::from(&names[index]);\n    }\n\
    \n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpu__3x8x6.rs:33:36\n\
    \   |\n33 |         arr[index] = String::from(&names[index]);\n   |          \
    \                          ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu__3x8x6.rs:22:17\n   |\n22 |         if i <= 9 {\n   |\
    \                 ^\n   |                 |\n   |                 expected `&mut\
    \ isize`, found integer\n   |                 help: consider mutably borrowing\
    \ here: `&mut 9`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut isize`\n  --> /tmp/tmpu__3x8x6.rs:23:13\n   |\n23 |          \
    \   i += 10;\n   |             -^^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be used on `isize`, you\
    \ can dereference `i`\n   |\n23 |             *i += 10;\n   |             +\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ isize`\n  --> /tmp/tmpu__3x8x6.rs:26:13\n   |\n26 |             i += 1;\n  \
    \ |             -^^^^^\n   |             |\n   |             cannot use `+=` on\
    \ type `&mut isize`\n   |\nhelp: `+=` can be used on `isize`, you can dereference\
    \ `i`\n   |\n26 |             *i += 1;\n   |             +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu__3x8x6.rs:33:22\n   |\n33 |         arr[index] = String::from(&names[index]);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu__3x8x6.rs:36:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n36 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n\n        let mut j = i;\n        while j < len {\n            if\
    \ arr[j] > arr[i] {\n                swap(&mut arr[j], &mut arr[i]);\n       \
    \     }\n            j += 1;\n        }\n        i += 1;\n    }\n\n    arr.iter().map(|x|\
    \ String::from(&names[x])).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmprz9f9y6t.rs:30:17\n\
    \   |\n30 |                 swap(&mut arr[j], &mut arr[i]);\n   |            \
    \     ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmprz9f9y6t.rs:37:38\n\
    \   |\n37 |     arr.iter().map(|x| String::from(&names[x])).collect()\n   |  \
    \                                    ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \n    while digits_len > 0 {\n        let mut digit = digits[digits_index];\n\
    \        let mut digits_index = 0;\n        let mut digits_len = digits.len();\n\
    \n        while digit > 9 {\n            digit /= 10;\n            digits_len--;\n\
    \        }\n\n        result.push(String::from(&names[digit]));\n    }\n\n   \
    \ result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp86jaz00n.rs:31:25\n\
    \   |\n31 |             digits_len--;\n   |                         ^ expected\
    \ expression\n\nerror[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmp86jaz00n.rs:34:35\n\
    \   |\n34 |         result.push(String::from(&names[digit]));\n   |          \
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] < 10 {\n            result.push(String::from(\"\
    One\"));\n        } else if arr[i] < 20 {\n            result.push(String::from(\"\
    Two\"));\n        } else if arr[i] < 30 {\n            result.push(String::from(\"\
    Three\"));\n        } else if arr[i] < 40 {\n            result.push(String::from(\"\
    Four\"));\n        } else if arr[i] < 50 {\n            result.push(String::from(\"\
    Five\"));\n        } else if arr[i] < 60 {\n            result.push(String::from(\"\
    Six\"));\n        } else if arr[i] < 70 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if arr[i] < 80 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if arr[i] < 90 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n        i += 1;\n    }\n    result.reverse();\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpc8gvx7bq.rs:49:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.to_owned();\n\
    \    arr.sort();\n    arr.iter().rev().for_each(|x| {\n        match x {\n   \
    \         1 => arr.push(String::from(\"One\")),\n            2 => arr.push(String::from(\"\
    Two\")),\n            3 => arr.push(String::from(\"Three\")),\n            4 =>\
    \ arr.push(String::from(\"Four\")),\n            5 => arr.push(String::from(\"\
    Five\")),\n            6 => arr.push(String::from(\"Six\")),\n            7 =>\
    \ arr.push(String::from(\"Seven\")),\n            8 => arr.push(String::from(\"\
    Eight\")),\n            9 => arr.push(String::from(\"Nine\")),\n            _\
    \ => (),\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptpaq8lvn.rs:18:27\n   |\n\
    18 |             1 => arr.push(String::from(\"One\")),\n   |                 \
    \          ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptpaq8lvn.rs:19:27\n   |\n19 |             2\
    \ => arr.push(String::from(\"Two\")),\n   |                           ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptpaq8lvn.rs:20:27\n   |\n20 |             3 => arr.push(String::from(\"\
    Three\")),\n   |                           ^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptpaq8lvn.rs:21:27\n\
    \   |\n21 |             4 => arr.push(String::from(\"Four\")),\n   |         \
    \                  ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptpaq8lvn.rs:22:27\n   |\n22 |\
    \             5 => arr.push(String::from(\"Five\")),\n   |                   \
    \        ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptpaq8lvn.rs:23:27\n   |\n23 |             6\
    \ => arr.push(String::from(\"Six\")),\n   |                           ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptpaq8lvn.rs:24:27\n   |\n24 |             7 => arr.push(String::from(\"\
    Seven\")),\n   |                           ^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptpaq8lvn.rs:25:27\n\
    \   |\n25 |             8 => arr.push(String::from(\"Eight\")),\n   |        \
    \                   ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptpaq8lvn.rs:26:27\n   |\n26 |\
    \             9 => arr.push(String::from(\"Nine\")),\n   |                   \
    \        ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptpaq8lvn.rs:30:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<Stri"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = arr.clone();\n    reversed.reverse();\n\n    let mut result\
    \ = vec![];\n    for i in &mut arr {\n        let mut digit = i as usize;\n  \
    \      let mut name = String::from(\"One\");\n        match digit {\n        \
    \    1 => name = String::from(\"One\"),\n            2 => name = String::from(\"\
    Two\"),\n            3 => name = String::from(\"Three\"),\n            4 => name\
    \ = String::from(\"Four\"),\n            5 => name = String::from(\"Five\"),\n\
    \            6 => name = String::from(\"Six\"),\n            7 => name = String::from(\"\
    Seven\"),\n            8 => name = String::from(\"Eight\"),\n            9 =>\
    \ name = String::from(\"Nine\"),\n            _ => continue,\n        }\n    \
    \    result.push(name);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&mut isize` as `usize` is invalid\n  --> /tmp/tmpsx7xh8bv.rs:24:25\n\
    \   |\n24 |         let mut digit = i as usize;\n   |                        \
    \ -^^^^^^^^^\n   |                         |\n   |                         cannot\
    \ cast `&mut isize` as `usize`\n   |                         help: dereference\
    \ the expression: `*i`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() && arr[j] < 10 {\n            j += 1\n        }\n        if j - i\
    \ > 1 {\n            result.push(String::from(&arr[i .. j]));\n        }\n   \
    \     i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&[isize]>` is not satisfied\n\
    \   --> /tmp/tmpa275fa52.rs:25:25\n    |\n25  |             result.push(String::from(&arr[i\
    \ .. j]));\n    |                         ^^^^^^^^^^^^ the trait `From<&[isize]>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j > 0 && arr[j - 1] > arr[j]\
    \ {\n            j -= 1;\n        }\n        swap(&mut arr[j], &mut arr[i]);\n\
    \        i += 1;\n    }\n    arr.iter().map(|x| String::from(&format!(\"{}\",\
    \ x)).to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp7gqwiwwl.rs:29:9\n\
    \   |\n29 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let mut\
    \ j = i;\n        while j < digits_len && digits[j] < 10 {\n            j += 1\n\
    \        }\n        let mut digit = digits[j];\n        if digit < 10 {\n    \
    \        result.push(String::from(\"One\"));\n            digits[j] = digit -\
    \ 1;\n        } else {\n            result.push(String::from(\"Two\"));\n    \
    \        digits[j] = digit - 2;\n        }\n        i += j - i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 8 but the
    index is 8'', /tmp/tmpfexjotgr.rs:26:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] < 1 || arr[i] > 9 {\n \
    \           i += 1;\n            continue;\n        }\n        let mut j = i;\n\
    \        while j < arr.len() && arr[j] == arr[j] + 1 {\n            result +=\
    \ vec![String::from(\"One\")];\n            j += 1;\n        }\n        i += 1;\n\
    \        if j > i {\n            result += vec![String::from(&arr[j - 1])];\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<_>`\n  --> /tmp/tmprsk7i04d.rs:26:13\n   |\n26 |             result +=\
    \ vec![String::from(\"One\")];\n   |             ------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `Vec<_>`\n\nerror[E0277]:\
    \ the trait bound `String: From<&isize>` is not satisfied\n   --> /tmp/tmprsk7i04d.rs:31:28\n\
    \    |\n31  |             result += vec![String::from(&arr[j - 1])];\n    |  \
    \                          ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmprsk7i04d.rs:31:13\n\
    \   |\n31 |             result += vec![String::from(&arr[j - 1])];\n   |     \
    \        ------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             |\n   | \
    \            cannot use `+=` on type `Vec<_>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| {\n        if x < 1 || x > 9 {\n            0\n     \
    \   } else {\n            x\n        }\n    });\n    arr.reverse();\n    let mut\
    \ res = vec![];\n    for x in arr {\n        let mut s = String::from(\"One\"\
    );\n        if x < 10 {\n            s = String::from(\"Zero\");\n        }\n\
    \        res.push(s.to_string());\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5kzslb1p.rs:19:16\n   |\n\
    19 |         if x < 1 || x > 9 {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5kzslb1p.rs:19:25\n\
    \   |\n19 |         if x < 1 || x > 9 {\n   |                         ^\n   |\
    \                         |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmp5kzslb1p.rs:22:13\n\
    \   |\n19 | /         if x < 1 || x > 9 {\n20 | |             0\n   | |      \
    \       - expected because of this\n21 | |         } else {\n22 | |          \
    \   x\n   | |             ^ expected integer, found `&isize`\n23 | |         }\n\
    \   | |_________- `if` and `else` have incompatible types\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |             *x\n   |             +\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n\
    \n    let mut i = 0;\n    while i < reversed.len() {\n        let mut j = i;\n\
    \        while j < reversed.len() && reversed[j] < 10 {\n            j += 1\n\
    \        }\n\n        let mut digit = reversed[j];\n        reversed.swap(j, i);\n\
    \        result.push(String::from(&digits[digit]));\n        i += 1;\n    }\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpr_x6d71_.rs:31:35\n\
    \   |\n31 |         result.push(String::from(&digits[digit]));\n   |         \
    \                          ^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         swap(&mut arr[i], &mut arr[i + 1]);\n            i += 2;\n        }\n\
    \        len -= 1;\n    }\n    arr.iter().map(|x| String::from(&x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpzm62ks2u.rs:25:13\n\
    \   |\n25 |             swap(&mut arr[i], &mut arr[i + 1]);\n   |            \
    \ ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]:\
    \ the trait bound `String: From<&&isize>` is not satisfied\n   --> /tmp/tmpzm62ks2u.rs:30:24\n\
    \    |\n30  |     arr.iter().map(|x| String::from(&x)).collect()\n    |      \
    \                  ^^^^^^^^^^^^ the trait `From<&&isize>` is not implemented for\
    \ `String`\n    |\n    = help: the following implementations were found:\n   \
    \           <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.to_owned();\n\
    \    arr.sort_unstable();\n    arr.reverse();\n    arr.iter().map(|x| {\n    \
    \    match x {\n            1 => \"One\",\n            2 => \"Two\",\n       \
    \     3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n\
    \            6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\"\
    ,\n            9 => \"Nine\",\n            _ => panic!(\"Invalid number in vector:\
    \ {}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpz22816bl.rs:30:8\n   |\n30 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut digits_len = arr.len();\n    let mut i = 0;\n\
    \    while i < digits_len {\n        let digit = arr[i] - 1;\n        if digit\
    \ < 10 {\n            digits.push(digit);\n        } else {\n            let mut\
    \ j = i;\n            while j > 0 && digits[j - 1] > 9 {\n                j -=\
    \ 1;\n            }\n            digits.push(digits[j - 1] + 10);\n        }\n\
    \        i += 1;\n    }\n\n    let mut i = 0;\n    while i < digits_len {\n  \
    \      let digit = digits[i];\n        let digit = digit as usize;\n        let\
    \ digit = digit as usize;\n        let digit = digit as usize;\n        let digit\
    \ = digit as usize;\n        let digit = digit as usize;\n        let digit =\
    \ digit as usize;\n        let digit = digit as usize;\n        let digit = digit\
    \ as usize;\n        let digit = digit as usize;\n        let digit = digit as\
    \ usize;\n        let digit = digit as usize;\n        let digit = digit as usize;\n\
    \        let digit = digit as usize;\n        let digit = digit as usize;\n  \
    \      let digit = digit as usize;\n        let digit = digit as usize;\n    \
    \    let digit = digit as usize;\n        let digit = digit as usize;\n      \
    \  let digit = digit as usize;\n        let digit = digit as usize;\n        let\
    \ digit = digit as usize;\n        let digit = digit as usize;\n        let digit\
    \ = digit as usize;\n        let digit = digit as usize;\n        let digit =\
    \ digit as usize;\n        let digit = digit as usize;\n        let digit = digit\
    \ as usize;\n        let digit = digit as usize;\n        let digit = digit as\
    \ usize;\n        let digit = digit as usize;\n        let digit = digit as usize;\n\
    \        let digit = digit as usize;\n        let digit = digit as usize;\n  \
    \      let digit = digit as usize;\n        let digit = digit as usize;\n    \
    \    let digit = digit as usize;\n        let digit = digit as usize;\n      \
    \  let digit = digit as usize;\n        let digit = digit as usize;\n        let\
    \ digit = digit as usize;\n        let digit = digit as usize;\n        let digit\
    \ = digit as usize;\n        let digit = digit as usize;\n        let digit =\
    \ digit as usize;\n        let digit = digit as usize;\n        let digit = digit\
    \ as usize;\n        let digit = digit as usize;\n        let digit = \n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcayxmvbx.rs:96:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n37 |     while i\
    \ < digits_len {\n   |                          - this delimiter might not be\
    \ properly closed...\n...\n87 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n96 | }\n   |   ^\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmpcayxmvbx.rs:87:1\n   |\n87 | }\n   | ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcayxmvbx.rs:13:34\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------             \
    \        ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.to_owned();\n    arr.sort_unstable_by_key(|x|\
    \ x.checked_mul(10).ok());\n    arr.iter().map(|x| {\n        match x {\n    \
    \        0 => \"Zero\".to_string(),\n            1 => \"One\".to_string(),\n \
    \           2 => \"Two\".to_string(),\n            3 => \"Three\".to_string(),\n\
    \            4 => \"Four\".to_string(),\n            5 => \"Five\".to_string(),\n\
    \            6 => \"Six\".to_string(),\n            7 => \"Seven\".to_string(),\n\
    \            8 => \"Eight\".to_string(),\n            9 => \"Nine\".to_string(),\n\
    \            _ => panic!(\"Unexpected number {:?}\", x),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmprt6hvakr.rs:18:52\n   |\n18 |     arr.sort_unstable_by_key(|x|\
    \ x.checked_mul(10).ok());\n   |                                             \
    \       ^^ help: there is an associated function with a similar name: `or`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() && arr[j] < 10 {\n            j += 1\n        }\n        if j == i\
    \ {\n            break;\n        }\n        let mut k = i;\n        while k >\
    \ 0 && arr[k] > 9 {\n            k -= 1\n        }\n        if k == i {\n    \
    \        break;\n        }\n        result.push(by_length(arr.split_off(i).rev().collect()));\n\
    \        i = k;\n    }\n    result.push(by_length(arr.split_off(i).collect()));\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `rev` exists for struct `Vec<isize>`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmp0h5jjq3i.rs:34:48\n    |\n34\
    \  |           result.push(by_length(arr.split_off(i).rev().collect()));\n   \
    \ |                                                  ^^^ method cannot be called\
    \ on `Vec<isize>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Vec<isize>`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmp0h5jjq3i.rs:37:44\n    |\n37  |       result.push(by_length(arr.split_off(i).collect()));\n\
    \    |                                              ^^^^^^^ method cannot be called\
    \ on `Vec<isize>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0h5jjq3i.rs:38:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n38 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_sub(1));\n    arr.reverse();\n    arr.iter().map(|x|\
    \ {\n        match x {\n            0 => \"Zero\".to_string(),\n            1\
    \ => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n           \
    \ 3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n      \
    \      5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n   \
    \         7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => panic!(\"Unexpected\
    \ number {}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Unexpected number 55'', /tmp/tmpfuv5jhl0.rs:33:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut digits = vec![];\n    let mut i = 0;\n    while i < arr.len()\
    \ {\n        let digit = arr[i] - 1;\n        if digit < 10 {\n            digits.push(digit\
    \ as isize);\n        } else {\n            digits.push(digit % 10 as isize);\n\
    \            digits.push(digit / 10 as isize);\n        }\n        i += 1;\n \
    \   }\n    digits.sort_unstable();\n    for digit in digits {\n        let index\
    \ = digit as usize;\n        let name = match index {\n            0 => \"One\"\
    ,\n            1 => \"Two\",\n            2 => \"Three\",\n            3 => \"\
    Four\",\n            4 => \"Five\",\n            5 => \"Six\",\n            6\
    \ => \"Seven\",\n            7 => \"Eight\",\n            8 => \"Nine\",\n   \
    \         _ => unreachable!(),\n        };\n        result.push(name);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc27hbpjt.rs:44:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    44 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let len = arr[i] - 1;\n        if\
    \ len < 1 || len > 9 {\n            i += 1;\n            continue;\n        }\n\
    \        result.push(String::from(&arr[i as usize]));\n        i += len;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmp1xjfjc95.rs:25:21\n    |\n25  |         result.push(String::from(&arr[i\
    \ as usize]));\n    |                     ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1xjfjc95.rs:26:14\n   |\n26 |         i += len;\n\
    \   |              ^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add-assign `isize` to `usize`\n  --> /tmp/tmp1xjfjc95.rs:26:11\n   |\n26 | \
    \        i += len;\n   |           ^^ no implementation for `usize += isize`\n\
    \   |\n   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] < 1 || arr[i] > 9 {\n \
    \           i += 1;\n            continue;\n        }\n        let mut j = i;\n\
    \        while j < arr.len() && arr[j] < 1 {\n            j += 1\n        }\n\
    \        let mut k = j;\n        while k < arr.len() && arr[k] > 9 {\n       \
    \     k += 1\n        }\n        let mut reversed = vec![];\n        reversed.extend_from_slice(&arr[i..k]);\n\
    \        reversed.extend_from_slice(&arr[k..j]);\n        reversed.extend_from_slice(&arr[j..i]);\n\
    \        result.extend_from_slice(&reversed);\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ascu6mq.rs:39:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    39 |     result\n   |     ^^^^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digit\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj_3m70mx.rs:72:18\n   |\n\
    72 |     let mut digit\n   |                  ^ help: add `;` here\n73 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj_3m70mx.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut digits_len = arr.len();\n\n    while digits_len\
    \ > 0 {\n        let mut digit = arr.pop().unwrap();\n        if digit < 10 {\n\
    \            digits.push(digit);\n        } else {\n            digits.push(digit\
    \ - 10);\n        }\n        digits_len -= 1;\n    }\n\n    let mut reversed =\
    \ vec![];\n    let mut reversed_len = digits_len;\n\n    while reversed_len >\
    \ 0 {\n        let mut reversed_digit = digits.pop().unwrap();\n        reversed.push(reversed_digit);\n\
    \        reversed_len -= 1;\n    }\n\n    for digit in reversed.iter_mut() {\n\
    \        if digit < 10 {\n            result.push(String::from(\"One\"));\n  \
    \      } else if digit < 100 {\n            result.push(String::from(\"Two\"));\n\
    \        } else if digit < 1000 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if digit < 10000 {\n            result.push(String::from(\"\
    Four\"));\n        } else if digit < 100000 {\n            result.push(String::from(\"\
    Five\"));\n        } else if digit < 1000000 {\n            result.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if digit < 100000000 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if digit < 1000000000 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkqcfhp0z.rs:42:20\n   |\n\
    42 |         if digit < 10 {\n   |                    ^^\n   |               \
    \     |\n   |                    expected `&mut isize`, found integer\n   |  \
    \                  help: consider mutably borrowing here: `&mut 10`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkqcfhp0z.rs:44:27\n   |\n44 |         } else\
    \ if digit < 100 {\n   |                           ^^^\n   |                 \
    \          |\n   |                           expected `&mut isize`, found integer\n\
    \   |                           help: consider mutably borrowing here: `&mut 100`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkqcfhp0z.rs:46:27\n   |\n46 |\
    \         } else if digit < 1000 {\n   |                           ^^^^\n   |\
    \                           |\n   |                           expected `&mut isize`,\
    \ found integer\n   |                           help: consider mutably borrowing\
    \ here: `&mut 1000`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkqcfhp0z.rs:48:27\n\
    \   |\n48 |         } else if digit < 10000 {\n   |                          \
    \ ^^^^^\n   |                           |\n   |                           expected\
    \ `&mut isize`, found integer\n   |                           help: consider mutably\
    \ borrowing here: `&mut 10000`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkqcfhp0z.rs:50:27\n\
    \   |\n50 |         } else if digit < 100000 {\n   |                         \
    \  ^^^^^^\n   |                           |\n   |                           expected\
    \ `&mut isize`, found integer\n   |                           help: consider mutably\
    \ borrowing here: `&mut 100000`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkqcfhp0z.rs:52:27\n\
    \   |\n52 |         } else if digit < 1000000 {\n   |                        \
    \   ^^^^^^^\n   |                           |\n   |                          \
    \ expected `&mut isize`, found integer\n   |                           help: consider\
    \ mutably borrowing here: `&mut 1000000`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpkqcfhp0z.rs:54:27\n   |\n54 |         } else if digit < 10000000\
    \ {\n   |    "
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| {\n        if x <= 9 {\n            x.to_string()\n \
    \       } else {\n            x.to_string().parse().unwrap()\n        }\n    });\n\
    \    arr.iter().map(|x| {\n        if x <= 9 {\n            String::from(\"One\"\
    )\n        } else {\n            String::from(\"Nine\")\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpumred40l.rs:19:17\n   |\n\
    19 |         if x <= 9 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpumred40l.rs:26:17\n\
    \   |\n26 |         if x <= 9 {\n   |                 ^\n   |                \
    \ |\n   |                 expected `&isize`, found integer\n   |             \
    \    help: consider borrowing here: `&9`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] <\
    \ 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n \
    \       result.push(String::from(&arr[i as usize]));\n        i += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmp5tuf5u00.rs:21:21\n    |\n21  |         result.push(String::from(&arr[i\
    \ as usize]));\n    |                     ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| {\n        if x < 1 || x > 9 {\n            0\n     \
    \   } else {\n            x\n        }\n    });\n    arr.reverse();\n    arr.iter().map(|x|\
    \ {\n        match x {\n            x if x < 10 => String::from(\"One\"),\n  \
    \          x if x < 20 => String::from(\"Two\"),\n            x if x < 30 => String::from(\"\
    Three\"),\n            x if x < 40 => String::from(\"Four\"),\n            x if\
    \ x < 50 => String::from(\"Five\"),\n            x if x < 60 => String::from(\"\
    Six\"),\n            x if x < 70 => String::from(\"Seven\"),\n            x if\
    \ x < 80 => String::from(\"Eight\"),\n            x if x < 90 => String::from(\"\
    Nine\"),\n            _ => String::from(\"Zero\"),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk7qv5wlp.rs:20:16\n   |\n\
    20 |         if x < 1 || x > 9 {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk7qv5wlp.rs:20:25\n\
    \   |\n20 |         if x < 1 || x > 9 {\n   |                         ^\n   |\
    \                         |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpk7qv5wlp.rs:23:13\n\
    \   |\n20 | /         if x < 1 || x > 9 {\n21 | |             0\n   | |      \
    \       - expected because of this\n22 | |         } else {\n23 | |          \
    \   x\n   | |             ^ expected integer, found `&isize`\n24 | |         }\n\
    \   | |_________- `if` and `else` have incompatible types\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |             *x\n   |             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpk7qv5wlp.rs:29:22\n   |\n29 |  \
    \           x if x < 10 => String::from(\"One\"),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&10`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpk7qv5wlp.rs:30:22\n   |\n30 |  \
    \           x if x < 20 => String::from(\"Two\"),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&20`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpk7qv5wlp.rs:31:22\n   |\n31 |  \
    \           x if x < 30 => String::from(\"Three\"),\n   |                    \
    \  ^^\n   |                      |\n   |                      expected `&isize`,\
    \ found integer\n   |                      help: consider borrowing here: `&30`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk7qv5wlp.rs:32:22\n   |\n32 |\
    \             x if x < 40 => String::from(\"Four\"),\n   |               "
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] < 1 || arr[i]\
    \ > 9 {\n            i += 1;\n            continue;\n        }\n        let mut\
    \ j = i;\n        while j < arr.len() && arr[j] == arr[j - 1] {\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpmrnsdmoa.rs:143:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n19  |     while\
    \ i < arr.len() {\n    |                         - unclosed delimiter\n...\n25\
    \  |         while j < arr.len() && arr[j] == arr[j - 1] {\n    |            \
    \                                         - this delimiter might not be properly\
    \ closed...\n...\n134 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n143 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpmrnsdmoa.rs:19:5\n    |\n13  |   fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n    |                                    ----------- expected `Vec<String>`\
    \ because of return type\n...\n19  | /     while i < arr.len() {\n20  | |    \
    \     if arr[i] < 1 || arr[i] > 9 {\n21  | |             i += 1;\n22  | |    \
    \         continue;\n...   |\n142 | |     assert_eq!(candidate(vec![9, 4, 8]),\
    \ vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"Four\"\
    )]);\n143 | | }\n    | |__^ expected struct `Vec`, found `()`\n    |\n    = note:\
    \ expected struct `Vec<String>`\n            found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n\n    for digit in arr {\n        if digit < 10 {\n      \
    \      digits.push(digit);\n        } else {\n            let index = digit -\
    \ 10;\n            let digit = digits.pop();\n            result.push(by_length(vec![digit,\
    \ index]));\n        }\n    }\n\n    if digits.is_empty() {\n        result.push(by_length(vec![0]));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw5uduj0_.rs:27:40\n   |\n\
    27 |             result.push(by_length(vec![digit, index]));\n   |           \
    \                             ^^^^^ expected `isize`, found enum `Option`\n  \
    \ |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw5uduj0_.rs:35:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n35 |\
    \     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digit_pos = 0;\n    let mut digit_len = 0;\n\n  \
    \  while digit_pos < digits_len {\n        let mut digit_len = digits[digit_pos].len();\n\
    \        let mut digit_pos = 0;\n\n        while digit_pos < digits_len {\n  \
    \          if digits[digit_pos] < 10 {\n                digit_len += 1;\n    \
    \        }\n            digit_pos += 1;\n        }\n\n        if digit_len > 0\
    \ {\n            result.push(String::from(&digits[digit_pos - digit_len..digit_pos]));\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpd62c0ewz.rs:25:47\n   |\n25 |         let mut digit_len\
    \ = digits[digit_pos].len();\n   |                                           \
    \    ^^^ method not found in `isize`\n\nerror[E0277]: the trait bound `String:\
    \ From<&[isize]>` is not satisfied\n   --> /tmp/tmpd62c0ewz.rs:36:25\n    |\n\
    36  |             result.push(String::from(&digits[digit_pos - digit_len..digit_pos]));\n\
    \    |                         ^^^^^^^^^^^^ the trait `From<&[isize]>` is not\
    \ implemented for `String`\n    |\n    = help: the following implementations were\
    \ found:\n              <String as From<&String>>\n              <String as From<&mut\
    \ str>>\n              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as usize).collect::<Vec<_>>();\n    arr.sort_unstable();\n    arr.reverse();\n\
    \    let mut result = vec![];\n    for i in arr {\n        let mut s = String::from(\"\
    One\");\n        if i <= 9 {\n            s.push_str(&format!(\"{}\", i));\n \
    \       } else {\n            s.push_str(&format!(\"{}\", i - 10));\n        }\n\
    \        result.push(s);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One8\", \"One5\", \"One4\", \"One3\", \"One2\", \"One2\", \"One1\", \"One1\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmptzqtt4o1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        if digits[i]\
    \ > 9 {\n            digits_len = i;\n            break;\n        }\n        i\
    \ += 1;\n    }\n    let mut j = digits_len;\n    while j > 0 {\n        let mut\
    \ digit = digits[j - 1];\n        if digit < 10 {\n            let mut digit =\
    \ digits[j - 1];\n            digits[j - 1] = digit - 10;\n            digits[j]\
    \ = String::from(\"One\");\n        }\n        j -= 1;\n    }\n    for i in 0..(digits_len\
    \ - 1) {\n        result.push(digits[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmbca5c1o.rs:34:25\n   |\n\
    34 |             digits[j] = String::from(\"One\");\n   |                    \
    \     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmbca5c1o.rs:41:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n41 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found `isize`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] <\
    \ 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n \
    \       let mut j = i;\n        while j < arr.len() && arr[j] == arr[j - 1] +\
    \ 1 {\n            j += 1\n        }\n        let mut k = j;\n        while k\
    \ < arr.len() && arr[k] == arr[k - 1] + 2 {\n            k += 1\n        }\n \
    \       let mut l = k;\n        while l < arr.len() && arr[l] == arr[k - 1] +\
    \ 3 {\n            l += 1\n        }\n        let mut m = l;\n        while m\
    \ < arr.len() && arr[m] == arr[k - 1] + 4 {\n            m += 1\n        }\n \
    \       let mut n = m;\n        while n < arr.len() && arr[n] == arr[k - 1] +\
    \ 5 {\n            n += 1\n        }\n        let mut o = n;\n        while o\
    \ < arr.len() && arr[o] == arr[k - 1] + 6 {\n            o += 1\n        }\n \
    \       let mut p = o;\n        while p < arr.len() && arr[p] == arr[k - 1] +\
    \ 7 {\n            p += 1\n        }\n        let mut q = p;\n        while q\
    \ < arr.len() && arr[q] == arr[k - 1] + 8 {\n            q += 1\n        }\n \
    \       let mut r = q;\n        while r < arr.len() && arr[r] == arr[k - 1] +\
    \ 9 {\n            r += 1\n        }\n        result.push(String::from(&arr[i..j]));\n\
    \        i = j;\n        k = l;\n        m = n;\n        o = p;\n        p = q;\n\
    \        r = r\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&[isize]>` is not satisfied\n\
    \   --> /tmp/tmpw4hfhm_6.rs:57:21\n    |\n57  |         result.push(String::from(&arr[i..j]));\n\
    \    |                     ^^^^^^^^^^^^ the trait `From<&[isize]>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i;\n     \
    \   while j < arr.len() && arr[j] < 10 {\n            j += 1\n        }\n    \
    \    swap(&mut arr[i..j], &mut arr[j..]);\n        i += j - i;\n    }\n    arr.iter().map(|x|\
    \ String::from(&format!(\"{}\", x)).to_string()).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpo00oh3li.rs:24:9\n\
    \   |\n24 |         swap(&mut arr[i..j], &mut arr[j..]);\n   |         ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect();\n    arr.sort_unstable();\n    arr.iter().map(|x| {\n\
    \        match x {\n            x if x <= 9 => String::from(\"One\"),\n      \
    \      x if x <= 99 => String::from(\"Two\"),\n            x if x <= 999 => String::from(\"\
    Three\"),\n            x if x <= 9999 => String::from(\"Four\"),\n           \
    \ x if x <= 99999 => String::from(\"Five\"),\n            x if x <= 999999 =>\
    \ String::from(\"Six\"),\n            x if x <= 9999999 => String::from(\"Seven\"\
    ),\n            x if x <= 999999999 => String::from(\"Eight\"),\n            x\
    \ if x <= 99999999999 => String::from(\"Nine\"),\n            _ => String::from(\"\
    Unknown\"),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpmqgsjfed.rs:18:5\n\
    \   |\n17 |     let mut arr = arr.into_iter().map(|x| x as isize).collect();\n\
    \   |         ------- consider giving `arr` a type\n18 |     arr.sort_unstable();\n\
    \   |     ^^^ cannot infer type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10).pow(arr.len() - 1)).unwrap());\n    arr.iter_mut().for_each(|x|\
    \ {\n        if *x < 10 {\n            *x = String::from(\"One\");\n        }\
    \ else if *x < 100 {\n            *x = String::from(\"Two\");\n        } else\
    \ if *x < 1000 {\n            *x = String::from(\"Three\");\n        } else if\
    \ *x < 10000 {\n            *x = String::from(\"Four\");\n        } else if *x\
    \ < 100000 {\n            *x = String::from(\"Five\");\n        } else if *x <\
    \ 1000000 {\n            *x = String::from(\"Six\");\n        } else if *x < 10000000\
    \ {\n            *x = String::from(\"Seven\");\n        } else if *x < 100000000\
    \ {\n            *x = String::from(\"Eight\");\n        } else if *x < 1000000000\
    \ {\n            *x = String::from(\"Nine\");\n        } else {\n            *x\
    \ = String::from(\"Ten\");\n        }\n    });\n    arr\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpxwvni0ku.rs:20:44\n   |\n20 |     arr.sort_by_key(|x| x.checked_mul((10).pow(arr.len()\
    \ - 1)).unwrap());\n   |                                            ^^^\n   |\n\
    help: you must specify a concrete type for this numeric value, like `i32`\n  \
    \ |\n20 |     arr.sort_by_key(|x| x.checked_mul((10_i32).pow(arr.len() - 1)).unwrap());\n\
    \   |                                        ~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxwvni0ku.rs:23:18\n   |\n23 |             *x = String::from(\"\
    One\");\n   |                  ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwvni0ku.rs:25:18\n\
    \   |\n25 |             *x = String::from(\"Two\");\n   |                  ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxwvni0ku.rs:27:18\n   |\n27 |             *x = String::from(\"\
    Three\");\n   |                  ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwvni0ku.rs:29:18\n\
    \   |\n29 |             *x = String::from(\"Four\");\n   |                  ^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxwvni0ku.rs:31:18\n   |\n31 |             *x = String::from(\"\
    Five\");\n   |                  ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwvni0ku.rs:33:18\n\
    \   |\n33 |             *x = String::from(\"Six\");\n   |                  ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxwvni0ku.rs:35:18\n   |\n35 |             *x = String::from(\"\
    Seven\");\n   |                  ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwvni0ku.rs:37:18\n\
    \   |\n37 |             *x = String::from(\"Eight\");\n   |                  ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mis"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n    let mut last_digit = \n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpvawawa5f.rs:59:1\n\
    \   |\n59 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.to_owned();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n            arr[i]\
    \ = String::from(&name[arr[i] - 1]);\n            i += 1;\n        }\n    }\n\
    \    arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmpnhptw9o0.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&name[arr[i] - 1]);\n   |      \
    \                              ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnhptw9o0.rs:25:22\n   |\n25 |             arr[i] = String::from(&name[arr[i]\
    \ - 1]);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnhptw9o0.rs:29:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n29 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         arr[i] = String::from(&name[arr[i] - 1]);\n            i += 1;\n   \
    \     }\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n  \
    \  assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmptz3bj6fs.rs:24:36\n\
    \   |\n24 |             arr[i] = String::from(&name[arr[i] - 1]);\n   |      \
    \                              ^^^^ not found in this scope\n\nerror[E0271]: type\
    \ mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n \
    \ --> /tmp/tmptz3bj6fs.rs:17:35\n   |\n17 |     let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                   ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmptz3bj6fs.rs:17:44\n \
    \  |\n17 |       let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] < 1 || arr[i]\
    \ > 9 {\n            i += 1;\n            continue;\n        }\n\n        let\
    \ mut j = i;\n        while j < arr.len() && arr[j] == arr[j - 1] + 1 {\n    \
    \        i += 1;\n            j += 1;\n        }\n\n        if j == arr.len()\
    \ {\n            i += 1;\n            continue;\n        }\n\n        let mut\
    \ k = j;\n        while k < arr.len() && arr[k] == arr[k - 1] + 2 {\n        \
    \    i += 1;\n            k += 1;\n        }\n\n        if k == arr.len() {\n\
    \            i += 1;\n            continue;\n        }\n\n        let mut l =\
    \ k;\n        while l < arr.len() && arr[l] == arr[k - 1] + 3 {\n            i\
    \ += 1;\n            l += 1;\n        }\n\n        if l == arr.len() {\n     \
    \       i += 1;\n            continue;\n        }\n\n        let mut m = l;\n\
    \        while m < arr.len() && arr[m] == arr[k - 1] + 4 {\n            i += 1;\n\
    \            m += 1;\n        }\n\n        if m == arr.len() {\n            i\
    \ += 1;\n            continue;\n        }\n\n        let mut n = m;\n        while\
    \ n < arr.len() && arr[n] == arr[k - 1] + 5 {\n            i += 1;\n         \
    \   n += 1;\n        }\n\n        if n == arr.len() {\n            i += 1;\n \
    \           continue;\n        }\n\n        let mut o = n;\n        while o <\
    \ arr.len() && arr[o] == arr[k - 1] + 6 {\n            i += 1;\n            o\
    \ += 1;\n        }\n\n        if o == arr.len() {\n            i += 1;\n     \
    \       continue;\n        }\n\n        let mut p = o;\n        while p < arr.len()\
    \ && arr[p] == arr[k - 1] + 7 {\n            i += 1;\n            p += 1;\n  \
    \      }\n\n        if p == arr.len() {\n            i += 1;\n            continue;\n\
    \        }\n\n        let mut q = p;\n        while q < arr.len() && arr[q] ==\
    \ arr[k - 1] + 8 {\n            i += 1;\n            q += 1;\n        }\n\n  \
    \      if q == arr.len() {\n            i += 1;\n            continue;\n     \
    \   }\n\n        let mut r = q;\n        while r < arr.len() && arr[r] == arr[k\
    \ - 1] + 9 {\n            i += 1;\n            r += 1;\n        }\n\n        if\
    \ r == arr.len() {\n            i += 1;\n            continue;\n        }\n\n\
    \        arr[i] = String::from(&arr[k - 1]);\n        i += 1;\n    }\n\n\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmpgkq3t2sl.rs:125:18\n    |\n125 |         arr[i] = String::from(&arr[k\
    \ - 1]);\n    |                  ^^^^^^^^^^^^ the trait `From<&isize>` is not\
    \ implemented for `String`\n    |\n    = help: the following implementations were\
    \ found:\n              <String as From<&String>>\n              <String as From<&mut\
    \ str>>\n              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror[E0308]: mismatched\
    \ types\n   --> /tmp/tmpgkq3t2sl.rs:125:18\n    |\n125 |         arr[i] = String::from(&arr[k\
    \ - 1]);\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpgkq3t2sl.rs:20:5\n\
    \    |\n13  |   fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |        \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n20  | /     while i < arr.len() {\n21  | |         if arr[i] < 1\
    \ || arr[i] > 9 {\n22  | |             i += 1;\n23  | |             continue;\n\
    ...   |\n126 | |         i += 1;\n127 | |     }\n    | |_____^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<String>`\n      \
    \      found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<isize>>();\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n\n    while digits_len > 0 {\n\
    \        let mut digit = digits[digits_index];\n        let mut digit_name = \"\
    \";\n\n        // Find the first digit that is between 1 and 9 inclusive.\n  \
    \      while digit > 9 {\n            digit /= 10;\n            digit_name +=\
    \ \"Zero\";\n        }\n\n        // Find the first digit that is between 1 and\
    \ 9 inclusive.\n        while digit < 1 {\n            digit *= 10;\n        \
    \    digit_name += \"One\";\n        }\n\n        // Find the first digit that\
    \ is between 1 and 9 inclusive.\n        while digit > 0 {\n            digit\
    \ /= 10;\n            digit_name += \"Two\";\n        }\n\n        // Find the\
    \ first digit that is between 1 and 9 inclusive.\n        while digit < 10 {\n\
    \            digit *= 10;\n            digit_name += \"Three\";\n        }\n\n\
    \        // Find the first digit that is between 1 and 9 inclusive.\n        while\
    \ digit > 99 {\n            digit /= 10;\n            digit_name += \"Four\";\n\
    \        }\n\n        // Find the first digit that is between 1 and 9 inclusive.\n\
    \        while digit < 100 {\n            digit *= 10;\n            digit_name\
    \ += \"Five\";\n        }\n\n        // Find the first digit that is between 1\
    \ and 9 inclusive.\n        while digit > 999 {\n            digit /= 10;\n  \
    \          digit_name += \"Six\";\n        }\n\n        // Find the first digit\
    \ that is between 1 and 9 inclusive.\n        while digit < 1000 {\n         \
    \   digit *= 10;\n            digit_name += \"Seven\";\n        }\n\n        //\
    \ Find the first digit that is between 1 and 9 inclusive.\n        while digit\
    \ > 9999 {\n            digit /= 10;\n            digit_name += \"Eight\";\n \
    \       }\n\n        // Find the first digit that is between 1 and 9 inclusive.\n\
    \        while digit < 10000 {\n            digit *= 10;\n            digit_name\
    \ += \"Nine\";\n        }\n\n        result.push(digit_name);\n        digits_index\
    \ += 1;\n        digits_len -= 1;\n    }\n\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpe8_3bjtl.rs:30:13\n   |\n30 |             digit_name +=\
    \ \"Zero\";\n   |             ----------^^^^^^^^^^\n   |             |\n   | \
    \            cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpe8_3bjtl.rs:36:13\n\
    \   |\n36 |             digit_name += \"One\";\n   |             ----------^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpe8_3bjtl.rs:42:13\n\
    \   |\n42 |             digit_name += \"Two\";\n   |             ----------^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpe8_3bjtl.rs:48:13\n\
    \   |\n48 |             digit_name += \"Three\";\n   |             ----------^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpe8_3bjtl.rs:54:13\n\
    \   |\n54 |             digit_name += \"Four\";\n   |             ----------^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpe8_3bjtl.rs:60:13\n\
    \   |\n60 |             digit_name += \"Five\";\n   |             ----------^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpe8_3bjtl.rs:66:13\n\
    \   |\n66 |             digit_name += \"Six\";\n   |             ----------^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpe8_3bjtl.rs:72:13\n\
    \   |\n72 |             digit_name += \"Seven\";\n   |             ----------^^^^^^^^^^^\n\
    \   |             |\n   "
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        let\
    \ digit = arr[i] - 1;\n        if digit < 10 {\n            digits.push(digit\
    \ as char);\n        } else {\n            result.push(String::from(digits[digits.len()\
    \ - 1]));\n            digits.clear();\n        }\n        i += 1;\n    }\n  \
    \  if digits.is_empty() {\n        result.push(String::from(\"One\"));\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp4n6a_udg.rs:23:25\n\
    \   |\n23 |             digits.push(digit as char);\n   |                    \
    \     ^^^^^^^^^^^^^ invalid cast\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0604`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    for num in arr {\n        if num < 1 || num > 9 {\n           \
    \ continue;\n        }\n        let mut reversed = num.to_string().rev();\n  \
    \      reversed.chars().for_each(|c| {\n            result.push(String::from(&c.to_string()));\n\
    \        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `rev` exists for struct `String`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp077s1wp8.rs:19:44\n    |\n19  |  \
    \         let mut reversed = num.to_string().rev();\n    |                   \
    \                           ^^^ method cannot be called on `String` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() && arr[j] >= 10 {\n            j += 1; // skip over any numbers that\
    \ are greater than 9\n        }\n        if j == i {\n            // The vector\
    \ is all numbers between 1 and 9 inclusive\n            result.push(String::from(\"\
    One\"));\n            i += 1;\n        } else {\n            result.push(String::from(arr[i\
    \ as usize].to_string()));\n            i += j - i;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpijtupmps.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let mut\
    \ j = i;\n        while j < digits_len && digits[j] < 10 {\n            j += 1\n\
    \        }\n        if j == digits_len {\n            break;\n        }\n    \
    \    let mut digit = digits[j];\n        let mut digits_len = digits_len;\n  \
    \      while digit > 9 {\n            digit /= 10;\n            digits_len -=\
    \ 1;\n        }\n        result.push(String::from(&digits[digits_len]));\n   \
    \     i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmpy20k4vih.rs:36:21\n    |\n36  |         result.push(String::from(&digits[digits_len]));\n\
    \    |                     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut digits_len = arr.len();\n    let mut i = 0;\n\
    \    while i < digits_len {\n        let digit = arr[i] - 1;\n        if digit\
    \ < 0 || digit > 9 {\n            break;\n        }\n        digits.push(digit);\n\
    \        i += 1;\n    }\n    if i == digits_len {\n        return result;\n  \
    \  }\n    let mut i = 0;\n    while i < digits_len {\n        let digit = arr[i]\
    \ - 1;\n        if digit < 0 || digit > 9 {\n            break;\n        }\n \
    \       let digit = digits[digit];\n        let digit = match digit {\n      \
    \      0 => \"Zero\",\n            1 => \"One\",\n            2 => \"Two\",\n\
    \            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => unreachable!(),\n\
    \        };\n        result.push(digit);\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpszp4h34v.rs:38:21\n\
    \   |\n38 |         let digit = digits[digit];\n   |                     ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpszp4h34v.rs:52:21\n   |\n52 |\
    \         result.push(digit);\n   |                     ^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                     |\n   |      \
    \               expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.reverse();\n  \
    \  let mut result = vec![];\n    for i in arr {\n        let mut s = String::new();\n\
    \        if i > 0 && i <= 9 {\n            s.push_str(&format!(\"{}\", i));\n\
    \        } else {\n            s.push_str(&format!(\"{}\", i));\n        }\n \
    \       result.push(s);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"3\", \"2\", \"8\", \"5\", \"4\", \"1\", \"1\", \"2\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpmqkm0hnh.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         swap(&mut arr, i, len - 1);\n            i += 1;\n        }\n    }\n\
    \    arr.iter().map(|x| String::from(&names[x])).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpac_qlct3.rs:25:13\n\
    \   |\n25 |             swap(&mut arr, i, len - 1);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]:\
    \ cannot find value `names` in this scope\n  --> /tmp/tmpac_qlct3.rs:29:38\n \
    \  |\n29 |     arr.iter().map(|x| String::from(&names[x])).collect()\n   |   \
    \                                   ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect();\n    arr.sort_unstable();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        0 => \"Zero\",\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => panic!(\"Invalid number {}\", x),\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpe1zhgd0r.rs:18:5\n\
    \   |\n17 |     let mut arr = arr.into_iter().map(|x| x as isize).collect();\n\
    \   |         ------- consider giving `arr` a type\n18 |     arr.sort_unstable();\n\
    \   |     ^^^ cannot infer type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect::<Vec<_>>();\n    arr.sort_unstable();\n    arr.reverse();\n\
    \n    let mut result = vec![];\n    for i in arr {\n        let mut s = String::from(\"\
    One\");\n        if i < 10 {\n            s = String::from(\"One\");\n       \
    \ } else if i < 20 {\n            s = String::from(\"Two\");\n        } else if\
    \ i < 30 {\n            s = String::from(\"Three\");\n        } else if i < 40\
    \ {\n            s = String::from(\"Four\");\n        } else if i < 50 {\n   \
    \         s = String::from(\"Five\");\n        } else if i < 60 {\n          \
    \  s = String::from(\"Six\");\n        } else if i < 70 {\n            s = String::from(\"\
    Seven\");\n        } else if i < 80 {\n            s = String::from(\"Eight\"\
    );\n        } else if i < 90 {\n            s = String::from(\"Nine\");\n    \
    \    }\n        result.push(s);\n    }\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpkxvbk_fz.rs:52:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut i = 0;\n    while i < digits.len() {\n        let mut j = i;\n     \
    \   while j < digits.len() && digits[j] < 10 {\n            j += 1\n        }\n\
    \        if j == i {\n            i += 1;\n            continue;\n        }\n\
    \        let mut reversed = digits[..j].iter().cloned().collect::<Vec<_>>();\n\
    \        reversed.reverse();\n        let mut j = 0;\n        while j < reversed.len()\
    \ {\n            let mut k = j;\n            while k < reversed.len() && reversed[k]\
    \ < 10 {\n                k += 1\n            }\n            if k == j {\n   \
    \             j += 1;\n                continue;\n            }\n            let\
    \ mut reversed_name = reversed[j..k].iter().cloned().collect::<Vec<_>>();\n  \
    \          reversed_name.reverse();\n            let mut k = 0;\n            while\
    \ k < reversed_name.len() {\n                let mut l = k;\n                while\
    \ l < reversed_name.len() && reversed_name[l] < 10 {\n                    l +=\
    \ 1\n                }\n                if l == k {\n                    k +=\
    \ 1;\n                    continue;\n                }\n                let mut\
    \ reversed_name_name = reversed_name[k..l].iter().cloned().collect::<Vec<_>>();\n\
    \                reversed_name_name.reverse();\n                let mut l = 0;\n\
    \                while l < reversed_name_name.len() {\n                    let\
    \ mut m = l;\n                    while m < reversed_name_name.len() && reversed_name_name[m]\
    \ < 10 {\n                        m += 1\n                    }\n            \
    \        if m == l {\n                        l += 1;\n                      \
    \  continue;\n                    }\n                    let mut reversed_name_name_name\
    \ = reversed_name_name[m..k].iter().cloned().collect::<Vec<_>>();\n          \
    \          reversed_name_name_name.reverse();\n                    let mut m =\
    \ 0;\n                    while m < reversed_name_name_name.len() {\n        \
    \                let mut n = m;\n                        while n < reversed_name_name_name.len()\
    \ && reversed_name_name_name[n] < 10 {\n                            n += 1\n \
    \                       }\n                        if n == m {\n             \
    \               m += 1;\n                            continue;\n             \
    \           }\n                        let mut reversed_name_name_name_name =\
    \ reversed_name_name_name[n..l].iter().cloned().collect::<Vec<_>>();\n       \
    \                 reversed_name_name_name_name.reverse();\n                  \
    \      let mut n = 0;\n                        while n < reversed_\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1_frr7co.rs:87:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n17 |     while i\
    \ < digits.len() {\n   |                            - unclosed delimiter\n...\n\
    29 |         while j < reversed.len() {\n   |                                \
    \  - unclosed delimiter\n...\n41 |             while k < reversed_name.len() {\n\
    \   |                                           - unclosed delimiter\n...\n53\
    \ |                 while l < reversed_name_name.len() {\n   |               \
    \                                     - unclosed delimiter\n...\n65 |        \
    \             while m < reversed_name_name_name.len() {\n   |                \
    \                                             - this delimiter might not be properly\
    \ closed...\n...\n78 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n87 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp1_frr7co.rs:78:1\n\
    \   |\n78 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1_frr7co.rs:17:5\n\
    \   |\n13 |   fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n17 | /     while i < digits.len() {\n18 | |         let mut j = i;\n\
    19 | |         while j < digits.len() && digits[j] < 10 {\n20 | |            \
    \ j += 1\n...  |\n86 | |     assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n87 | | }\n   | |__^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_div(10).unwrap());\n    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_div(10).unwrap());\n    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_div(10).unwrap());\n    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_div(10).unwrap());\n    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_div(10\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpk3la8cv_.rs:43:38\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n43 |     arr.sort_by_key(|x| x.checked_div(10\n   |                     \
    \                 ^ unclosed delimiter\n44 | }\n   | ^ mismatched closing delimiter\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpk3la8cv_.rs:20:39\n\
    \   |\n20 |     arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \   |                                       ^^^^^^^^^^^^^ help: remove these parentheses\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmpk3la8cv_.rs:22:39\n   |\n\
    22 |     arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n   |   \
    \                                    ^^^^^^^^^^^^^ help: remove these parentheses\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpk3la8cv_.rs:24:39\n\
    \   |\n24 |     arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \   |                                       ^^^^^^^^^^^^^ help: remove these parentheses\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpk3la8cv_.rs:26:39\n\
    \   |\n26 |     arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \   |                                       ^^^^^^^^^^^^^ help: remove these parentheses\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpk3la8cv_.rs:28:39\n\
    \   |\n28 |     arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \   |                                       ^^^^^^^^^^^^^ help: remove these parentheses\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpk3la8cv_.rs:30:39\n\
    \   |\n30 |     arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \   |                                       ^^^^^^^^^^^^^ help: remove these parentheses\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpk3la8cv_.rs:32:39\n\
    \   |\n32 |     arr."
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while len > 0 {\n     \
    \   if len % 10 == 0 {\n            arr.swap(i, len / 10);\n            i += len\
    \ / 10;\n            len -= len % 10;\n        } else {\n            i += 1;\n\
    \            len -= 1;\n        }\n    }\n\n    let mut result = vec![];\n   \
    \ for i in arr {\n        result.push(String::from(&names[i]))\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpndpv2slx.rs:34:35\n\
    \   |\n34 |         result.push(String::from(&names[i]))\n   |               \
    \                    ^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let mut\
    \ j = i;\n        while j < digits_len && digits[j] < 10 {\n            j += 1\n\
    \        }\n        if j - i > 1 {\n            result.push(by_length(digits.iter().skip(i).take(j\
    \ - i).collect()));\n        }\n        i = j;\n    }\n    result.push(by_length(digits.iter().skip(i).collect()));\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n  --> /tmp/tmp3r850xk8.rs:27:35\n   |\n27 |\
    \             result.push(by_length(digits.iter().skip(i).take(j - i).collect()));\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \   |\n   = help: the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n  --> /tmp/tmp3r850xk8.rs:31:27\n   |\n31 |\
    \     result.push(by_length(digits.iter().skip(i).collect()));\n   |         \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n   |\n   = help: the\
    \ trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3r850xk8.rs:32:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n32 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        let mut j =\
    \ i;\n        while j < arr.len() && arr[j] < 10 {\n            j += 1\n     \
    \   }\n        if j == i {\n            break;\n        }\n        let mut k =\
    \ j;\n        while k < arr.len() && arr[k] > 9 {\n            k += 1\n      \
    \  }\n        if k == j {\n            break;\n        }\n        result.push(String::from(&arr[i..k]));\n\
    \        i = k;\n    }\n    if i == arr.len() {\n        result\n    } else {\n\
    \        result.push(String::from(&arr[i..]));\n        result\n    }\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&[isize]>` is not satisfied\n\
    \   --> /tmp/tmpqqd9teju.rs:31:21\n    |\n31  |         result.push(String::from(&arr[i..k]));\n\
    \    |                     ^^^^^^^^^^^^ the trait `From<&[isize]>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror[E0277]: the trait\
    \ bound `String: From<&[isize]>` is not satisfied\n   --> /tmp/tmpqqd9teju.rs:37:21\n\
    \    |\n37  |         result.push(String::from(&arr[i..]));\n    |           \
    \          ^^^^^^^^^^^^ the trait `From<&[isize]>` is not implemented for `String`\n\
    \    |\n    = help: the following implementations were found:\n              <String\
    \ as From<&String>>\n              <String as From<&mut str>>\n              <String\
    \ as From<&str>>\n              <String as From<Box<str>>>\n            and 2\
    \ others\nnote: required by `from`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digits_len = digits_len.saturating_add((9 - digits_len)\
    \ % 9);\n    let mut i = 0;\n    while i < digits_len {\n        let mut j = i;\n\
    \        while j < digits_len && digits[j] < 10 {\n            j += 1\n      \
    \  }\n        let mut digit = digits[j];\n        if digit < 10 {\n          \
    \  digit = digit as usize;\n        }\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit % 10;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptz3zd0zd.rs:80:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n23 |     while i\
    \ < digits_len {\n   |                          - this delimiter might not be\
    \ properly closed...\n...\n71 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n80 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptz3zd0zd.rs:30:21\n   |\n30 |             digit = digit as usize;\n\
    \   |                     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptz3zd0zd.rs:13:34\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |    ---------                     ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        swap(&mut arr, i, len - 1);\n        i += 1;\n    }\n    arr.iter().map(|x|\
    \ String::from(&names[x as usize])).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpx5ewsb2u.rs:26:9\n\
    \   |\n26 |         swap(&mut arr, i, len - 1);\n   |         ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find value `names` in this scope\n  --> /tmp/tmpx5ewsb2u.rs:29:38\n   |\n29\
    \ |     arr.iter().map(|x| String::from(&names[x as usize])).collect()\n   | \
    \                                     ^^^^^ not found in this scope\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmpx5ewsb2u.rs:29:44\n  \
    \ |\n29 |     arr.iter().map(|x| String::from(&names[x as usize])).collect()\n\
    \   |                                            -^^^^^^^^^\n   |            \
    \                                |\n   |                                     \
    \       cannot cast `&isize` as `usize`\n   |                                \
    \            help: dereference the expression: `*x`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0425, E0606.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let mut\
    \ digit = digits[i];\n        if digit < 10 {\n            result.push(String::from(\"\
    One\"));\n        } else if digit < 100 {\n            result.push(String::from(\"\
    Two\"));\n        } else if digit < 1000 {\n            result.push(String::from(\"\
    Three\"));\n        } else if digit < 10000 {\n            result.push(String::from(\"\
    Four\"));\n        } else if digit < 100000 {\n            result.push(String::from(\"\
    Five\"));\n        } else if digit < 1000000 {\n            result.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if digit < 100000000 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if digit < 1000000000 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n        i += 1;\n    }\n    let mut reversed = result.iter().cloned().collect::<Vec<_>>();\n\
    \    reversed.reverse();\n    for digit in reversed {\n        let mut i = 0;\n\
    \        while i < digits_len {\n            if digits[i] == digit {\n       \
    \         digits[i] = reversed[digits_len - i - 1];\n                break;\n\
    \            }\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe_9wy4t3.rs:51:29\n   |\n\
    51 |             if digits[i] == digit {\n   |                             ^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe_9wy4t3.rs:52:29\n   |\n52 |                 digits[i] = reversed[digits_len\
    \ - i - 1];\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    while digits_index < digits_len {\n      \
    \  let mut digit = digits[digits_index];\n        let mut digits_index = 0;\n\
    \        while digit > 9 {\n            digit /= 10;\n            digits_index\
    \ += 1;\n        }\n        result.push(String::from(&names[digit]));\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpremdahix.rs:30:35\n\
    \   |\n30 |         result.push(String::from(&names[digit]));\n   |          \
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n    while\
    \ i < digits.len() {\n        let mut j = i;\n        while j < digits.len() &&\
    \ digits[j] < 10 {\n            j += 1\n        }\n        let mut k = j;\n  \
    \      while k < digits.len() && digits[k] > 9 {\n            k += 1\n       \
    \ }\n        if k > i {\n            result.push(String::from(&digits[i..k]));\n\
    \        }\n        i = k;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&[isize]>` is not satisfied\n\
    \   --> /tmp/tmp30ojjdt8.rs:30:25\n    |\n30  |             result.push(String::from(&digits[i..k]));\n\
    \    |                         ^^^^^^^^^^^^ the trait `From<&[isize]>` is not\
    \ implemented for `String`\n    |\n    = help: the following implementations were\
    \ found:\n              <String as From<&String>>\n              <String as From<&mut\
    \ str>>\n              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.to_owned();\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j < len {\n            if arr[j] == arr[i] {\n         \
    \       j += 1;\n                continue;\n            }\n            break;\n\
    \        }\n        let mut k = i;\n        while k > j {\n            arr[k -\
    \ 1] = arr[k];\n            k -= 1;\n        }\n        arr[j] = String::from(&name[arr[i]\
    \ - 1]);\n        i += 1;\n    }\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmpibptd2jz.rs:38:32\n\
    \   |\n38 |         arr[j] = String::from(&name[arr[i] - 1]);\n   |          \
    \                      ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpibptd2jz.rs:38:18\n   |\n38 |         arr[j] = String::from(&name[arr[i]\
    \ - 1]);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpibptd2jz.rs:41:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n41 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect::<Vec<_>>();\n    arr.sort_unstable();\n    arr.reverse();\n\
    \n    let mut result = vec![];\n    for i in arr {\n        let mut s = String::from(\"\
    One\");\n        if i < 10 {\n            s = String::from(\"One\");\n       \
    \ } else if i < 20 {\n            s = String::from(\"Two\");\n        } else if\
    \ i < 30 {\n            s = String::from(\"Three\");\n        } else if i < 40\
    \ {\n            s = String::from(\"Four\");\n        } else if i < 50 {\n   \
    \         s = String::from(\"Five\");\n        } else if i < 60 {\n          \
    \  s = String::from(\"Six\");\n        } else if i < 70 {\n            s = String::from(\"\
    Seven\");\n        } else if i < 80 {\n            s = String::from(\"Eight\"\
    );\n        } else if i < 90 {\n            s = String::from(\"Nine\");\n    \
    \    }\n        result.push(s);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpjp5vd4fl.rs:51:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while len > 0 {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         arr.swap(i, len - 1);\n            len -= 1;\n        }\n    }\n\n \
    \   arr.iter().map(|x| String::from(&names[x as usize])).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmp_ysnxz9j.rs:30:38\n\
    \   |\n30 |     arr.iter().map(|x| String::from(&names[x as usize])).collect()\n\
    \   |                                      ^^^^^ not found in this scope\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmp_ysnxz9j.rs:30:44\n  \
    \ |\n30 |     arr.iter().map(|x| String::from(&names[x as usize])).collect()\n\
    \   |                                            -^^^^^^^^^\n   |            \
    \                                |\n   |                                     \
    \       cannot cast `&isize` as `usize`\n   |                                \
    \            help: dereference the expression: `*x`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0606.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = vec![];\n    let mut digits = vec![];\n    let mut i =\
    \ 0;\n    while i < arr.len() {\n        let digit = arr[i] - 1;\n        if digit\
    \ < 10 {\n            digits.push(digit as char);\n        } else {\n        \
    \    reversed.push(reverse_digit(digit));\n            digits.clear();\n     \
    \   }\n        i += 1;\n    }\n    reversed.reverse();\n    for digit in reversed\
    \ {\n        arr.push(digit as isize);\n    }\n    arr.iter().map(|x| String::from(&x.to_string())).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse_digit` in this scope\n  -->\
    \ /tmp/tmpqna50ijt.rs:27:27\n   |\n27 |             reversed.push(reverse_digit(digit));\n\
    \   |                           ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0271]:\
    \ type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpqna50ijt.rs:18:35\n   |\n18 |     let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                   ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpqna50ijt.rs:18:44\n \
    \  |\n18 |       let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.to_owned();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         swap(&mut arr, i, len - 1);\n            i += 1;\n        }\n    }\n\
    \    arr.iter().map(|x| String::from(&format!(\"{}\", x)).to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmplqtw43_n.rs:21:13\n\
    \   |\n21 |             swap(&mut arr, i, len - 1);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.to_owned();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n\
    \        swap(&mut arr, i, len - 1);\n        i += 1;\n    }\n    arr.iter().map(|x|\
    \ String::from(&names[x])).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpryiyezvw.rs:26:9\n\
    \   |\n26 |         swap(&mut arr, i, len - 1);\n   |         ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find value `names` in this scope\n  --> /tmp/tmpryiyezvw.rs:29:38\n   |\n29\
    \ |     arr.iter().map(|x| String::from(&names[x])).collect()\n   |          \
    \                            ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digit\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj_3m70mx.rs:72:18\n   |\n\
    72 |     let mut digit\n   |                  ^ help: add `;` here\n73 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj_3m70mx.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect::<Vec<_>>();\n    arr.sort_unstable();\n    arr.reverse();\n\
    \    let mut result = vec![];\n    for i in arr {\n        let mut s = String::new();\n\
    \        if i < 10 {\n            s.push_str(&format!(\"One\", i));\n        }\
    \ else if i < 20 {\n            s.push_str(&format!(\"Two\", i));\n        } else\
    \ if i < 30 {\n            s.push_str(&format!(\"Three\", i));\n        } else\
    \ if i < 40 {\n            s.push_str(&format!(\"Four\", i));\n        } else\
    \ if i < 50 {\n            s.push_str(&format!(\"Five\", i));\n        } else\
    \ if i < 60 {\n            s.push_str(&format!(\"Six\", i));\n        } else if\
    \ i < 70 {\n            s.push_str(&format!(\"Seven\", i));\n        } else if\
    \ i < 80 {\n            s.push_str(&format!(\"Eight\", i));\n        } else if\
    \ i < 90 {\n            s.push_str(&format!(\"Nine\", i));\n        } else {\n\
    \            continue;\n        }\n        result.push(s);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmpgihobn3b.rs:24:40\n   |\n24 |\
    \             s.push_str(&format!(\"One\", i));\n   |                        \
    \         -----  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpgihobn3b.rs:26:40\n   |\n26 |             s.push_str(&format!(\"\
    Two\", i));\n   |                                 -----  ^ argument never used\n\
    \   |                                 |\n   |                                \
    \ formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpgihobn3b.rs:28:42\n\
    \   |\n28 |             s.push_str(&format!(\"Three\", i));\n   |            \
    \                     -------  ^ argument never used\n   |                   \
    \              |\n   |                                 formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmpgihobn3b.rs:30:41\n   |\n30 |    \
    \         s.push_str(&format!(\"Four\", i));\n   |                           \
    \      ------  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpgihobn3b.rs:32:41\n   |\n32 |             s.push_str(&format!(\"\
    Five\", i));\n   |                                 ------  ^ argument never used\n\
    \   |                                 |\n   |                                \
    \ formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpgihobn3b.rs:34:40\n\
    \   |\n34 |             s.push_str(&format!(\"Six\", i));\n   |              \
    \                   -----  ^ argument never used\n   |                       \
    \          |\n   |                                 formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmpgihobn3b.rs:36:42\n   |\n36 |    \
    \         s.push_str(&format!(\"Seven\", i));\n   |                          \
    \       -------  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmp"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    for n in arr {\n        if n >= 1 && n <= 9 {\n            result.push(by_digit(n));\n\
    \        } else {\n            result.push(by_name(n));\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpn_sefn2k.rs:17:25\n\
    \   |\n17 |             result.push(by_digit(n));\n   |                      \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `by_name`\
    \ in this scope\n  --> /tmp/tmpn_sefn2k.rs:19:25\n   |\n19 |             result.push(by_name(n));\n\
    \   |                         ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         arr[i] = String::from(&name[arr[i] - 1]);\n            i += 1;\n   \
    \     }\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n  \
    \  assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmpzfeicny3.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&name[arr[i] - 1]);\n   |      \
    \                              ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzfeicny3.rs:25:22\n   |\n25 |             arr[i] = String::from(&name[arr[i]\
    \ - 1]);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzfeicny3.rs:29:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n29 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() && arr[j] < 10 {\n            j += 1\n        }\n        if j - i\
    \ > 1 {\n            result.push(by_length(arr.split_off(j - i).collect()));\n\
    \        }\n        result.push(String::from(&arr[i..j]));\n        i = j;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `collect` exists for struct `Vec<isize>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpi4_9_4yk.rs:25:56\n    |\n\
    25  |               result.push(by_length(arr.split_off(j - i).collect()));\n\
    \    |                                                          ^^^^^^^ method\
    \ cannot be called on `Vec<isize>` due to unsatisfied trait bounds\n    |\n  \
    \  = note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror[E0277]: the trait bound `String: From<&[isize]>` is not satisfied\n\
    \   --> /tmp/tmpi4_9_4yk.rs:27:21\n    |\n27  |         result.push(String::from(&arr[i..j]));\n\
    \    |                     ^^^^^^^^^^^^ the trait `From<&[isize]>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi4_9_4yk.rs:27:21\n   |\n27 |         result.push(String::from(&arr[i..j]));\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `String`\n   |\n   = note: expected struct `Vec<String>`\n          \
    \    found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi4_9_4yk.rs:30:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n30 |     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = arr.len() - 1;\n\n    while i <=\
    \ k {\n        if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n          \
    \  continue;\n        }\n\n        let mut tmp = vec![];\n        while j <= i\
    \ {\n            tmp.append(&String::from(&arr[j]));\n            j += 1;\n  \
    \      }\n        result.append(&tmp);\n        i += 1;\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmp7c6cx8m8.rs:31:25\n    |\n31  |             tmp.append(&String::from(&arr[j]));\n\
    \    |                         ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7c6cx8m8.rs:31:24\n   |\n31 |             tmp.append(&String::from(&arr[j]));\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \     found reference `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7c6cx8m8.rs:34:23\n\
    \   |\n34 |         result.append(&tmp);\n   |                       ^^^^ types\
    \ differ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n\
    \                      found reference `&Vec<_>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < reversed.len() {\n        if reversed[i] <\
    \ 10 {\n            result.push(String::from(\"One\"));\n        } else if reversed[i]\
    \ < 20 {\n            result.push(String::from(\"Two\"));\n        } else if reversed[i]\
    \ < 30 {\n            result.push(String::from(\"Three\"));\n        } else if\
    \ reversed[i] < 40 {\n            result.push(String::from(\"Four\"));\n     \
    \   } else if reversed[i] < 50 {\n            result.push(String::from(\"Five\"\
    ));\n        } else if reversed[i] < 60 {\n            result.push(String::from(\"\
    Six\"));\n        } else if reversed[i] < 70 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if reversed[i] < 80 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if reversed[i] < 90 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(reversed[i].to_string()));\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmp5xubmbgx.rs:50:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ reversed = arr\n        .iter()\n        .cloned()\n        .map(|x| x.checked_mul(10).ok())\n\
    \        .collect::<Vec<_>>();\n    reversed.sort_by_key(|x| x.checked_mul(10).ok());\n\
    \    for i in 0..10 {\n        let mut digit = reversed[i];\n        let mut digit\
    \ = digit.checked_mul(10).ok();\n        let mut digit = digit.checked_add(1).ok();\n\
    \        let mut digit = digit.checked_mul(10).ok();\n        let mut digit =\
    \ digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let mut digit = digit.checked_add(1).ok();\n        let mut digit = digit.checked_mul(10).ok();\n\
    \        let \n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpy8rbi7lt.rs:68:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n25 |     for i in\
    \ 0..10 {\n   |                    - this delimiter might not be properly closed...\n\
    ...\n59 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    68 | }\n   |   ^\n\nerror: expected pattern, found `}`\n  --> /tmp/tmpy8rbi7lt.rs:59:1\n\
    \   |\n59 | }\n   | ^ expected pattern\n\nerror[E0599]: no method named `ok` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpy8rbi7lt.rs:22:36\n  \
    \ |\n22 |         .map(|x| x.checked_mul(10).ok())\n   |                     \
    \               ^^ help: there is an associated function with a similar name:\
    \ `or`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy8rbi7lt.rs:13:34\n  \
    \ |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------  \
    \                   ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n\n    let\
    \ mut digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len\
    \ = digits.len();\n\n    let mut last_digit = digits_len % 10;\n    let mut last_digit\
    \ = digits_len % 10;\n\n    while digits_len > 0 {\n        let mut digit = digits[digits_len\
    \ - 1];\n        digits_len -= 1;\n\n        if digit < 1 || digit > 9 {\n   \
    \         continue;\n        }\n\n        let mut digit = digits[digits_len -\
    \ 1];\n        digits_len -= 1;\n\n        if digit < 1 || digit > 9 {\n     \
    \       continue;\n        }\n\n        let mut digit = digits[digits_len - 1];\n\
    \        digits_len -= 1;\n\n        if digit < 1 || digit > 9 {\n           \
    \ continue;\n        }\n\n        let mut digit = digits[digits_len - 1];\n  \
    \      digits_len -= 1;\n\n        if digit < 1 || digit > 9 {\n            continue;\n\
    \        }\n\n        let mut digit = digits[digits_len - 1];\n        digits_len\
    \ -= 1;\n\n        if digit < 1 || digit > 9 {\n            continue;\n      \
    \  }\n\n        let mut digit = digits[digits_len - 1];\n        digits_len -=\
    \ 1;\n\n        if digit < 1 || digit > 9 {\n            continue;\n        }\n\
    \n        let mut digit = digits[digits_len - 1];\n        digits_len -= 1;\n\n\
    \        if digit < 1 || digit > 9 {\n            continue;\n        }\n\n   \
    \     let mut digit = digits[digits_len - 1];\n        digits_len -= 1;\n\n  \
    \      if digit < 1 || digit > 9 {\n            continue;\n        }\n\n     \
    \   let mut digit = digits[digits_len - 1];\n        digits_len -= 1;\n\n    \
    \    if digit < 1 || digit > 9 {\n            continue;\n        }\n\n       \
    \ let mut digit = digits[digits_len - 1];\n        digits_len -= 1;\n\n      \
    \  if digit < 1 || digit > 9 {\n            continue;\n        }\n\n        let\
    \ mut digit = digits[digits_len - 1];\n        digits_len -= 1;\n\n        if\
    \ digit < 1 || digit > 9 {\n            continue;\n        }\n\n        let mut\
    \ digit = digits[digits_len - 1];\n        digits_len -= 1;\n\n        if digit\
    \ < 1 || digit > 9 {\n            continue;\n        }\n\n        let mut digit\
    \ = digits[digits_len - 1];\n        digits_len -= 1;\n\n        if digit < \n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpsxruogg8.rs:124:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n26  |     while\
    \ digits_len > 0 {\n    |                          - this delimiter might not\
    \ be properly closed...\n...\n115 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n124 | }\n    |   ^\n\nerror: expected expression,\
    \ found `}`\n   --> /tmp/tmpsxruogg8.rs:115:1\n    |\n115 | }\n    | ^ expected\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxruogg8.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digits_len = digits_len as usize;\n    let mut i\
    \ = 0;\n    while i < digits_len {\n        let mut j = i;\n        while j <\
    \ digits_len && digits[j] < 10 {\n            j += 1\n        }\n        if j\
    \ == digits_len {\n            break;\n        }\n        let mut digit = digits[j];\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mu\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_b3_zc8f.rs:80:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n22 |     while i\
    \ < digits_len {\n   |                          - this delimiter might not be\
    \ properly closed...\n...\n71 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n80 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  -->\
    \ /tmp/tmp_b3_zc8f.rs:70:15\n   |\n70 |         let mu\n   |               ^ help:\
    \ add `;` here\n71 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_b3_zc8f.rs:13:34\n   |\n13 | fn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n   |    ---------                     ^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < arr.len() {\n        if arr[i] < 10\
    \ {\n            result[j] = String::from(\"One\");\n            i += 1;\n   \
    \     } else if arr[i] < 100 {\n            result[j] = String::from(\"Two\");\n\
    \            i += 1;\n        } else if arr[i] < 1000 {\n            result[j]\
    \ = String::from(\"Three\");\n            i += 1;\n        } else if arr[i] <\
    \ 10000 {\n            result[j] = String::from(\"Four\");\n            i += 1;\n\
    \        } else if arr[i] < 100000 {\n            result[j] = String::from(\"\
    Five\");\n            i += 1;\n        } else if arr[i] < 1000000 {\n        \
    \    result[j] = String::from(\"Six\");\n            i += 1;\n        } else if\
    \ arr[i] < 10000000 {\n            result[j] = String::from(\"Seven\");\n    \
    \        i += 1;\n        } else if arr[i] < 100000000 {\n            result[j]\
    \ = String::from(\"Eight\");\n            i += 1;\n        } else if arr[i] <\
    \ 1000000000 {\n            result[j] = String::from(\"Nine\");\n            i\
    \ += 1;\n        } else {\n            result[j] = String::from(format!(\"{}\"\
    , arr[i]));\n            i += 1;\n        }\n        j += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxep96pm5.rs:23:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749522
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.to_owned();\n    let\
    \ mut result = vec![];\n\n    let mut i = 0;\n    while i < arr.len() {\n    \
    \    if arr[i] < 10 {\n            result.push(String::from(\"One\"));\n     \
    \   } else if arr[i] < 20 {\n            result.push(String::from(\"Two\"));\n\
    \        } else if arr[i] < 30 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if arr[i] < 40 {\n            result.push(String::from(\"\
    Four\"));\n        } else if arr[i] < 50 {\n            result.push(String::from(\"\
    Five\"));\n        } else if arr[i] < 60 {\n            result.push(String::from(\"\
    Six\"));\n        } else if arr[i] < 70 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if arr[i] < 80 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if arr[i] < 90 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n\n        i += 1;\n    }\n\n    result.reverse();\n    result\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmp40sm7ii8.rs:54:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while len > 0 {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n\n        let mut j = i;\n        while j < len {\n            if\
    \ arr[j] > arr[j + 1] {\n                swap(&mut arr[j], &mut arr[j + 1]);\n\
    \            }\n            j += 1;\n        }\n\n        i += 1;\n        len\
    \ -= 1;\n    }\n\n    arr.into_iter().map(|x| String::from(x)).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpvyg49xx7.rs:30:17\n\
    \   |\n30 |                 swap(&mut arr[j], &mut arr[j + 1]);\n   |        \
    \         ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0277]: the trait bound `String: From<isize>` is not satisfied\n\
    \   --> /tmp/tmpvyg49xx7.rs:39:29\n    |\n39  |     arr.into_iter().map(|x| String::from(x)).collect()\n\
    \    |                             ^^^^^^^^^^^^ the trait `From<isize>` is not\
    \ implemented for `String`\n    |\n    = help: the following implementations were\
    \ found:\n              <String as From<&String>>\n              <String as From<&mut\
    \ str>>\n              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        let\
    \ digit = arr[i] - 1;\n        if digit < 10 {\n            digits.push(digit);\n\
    \        } else {\n            result.push(String::from(&digits[digits.len() -\
    \ 1]));\n            digits.clear();\n        }\n        i += 1;\n    }\n    if\
    \ digits.is_empty() {\n        result.push(String::from(&arr[arr.len() - 1]));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmpngs3xmr0.rs:26:25\n    |\n26  |             result.push(String::from(&digits[digits.len()\
    \ - 1]));\n    |                         ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror[E0277]:\
    \ the trait bound `String: From<&isize>` is not satisfied\n   --> /tmp/tmpngs3xmr0.rs:32:21\n\
    \    |\n32  |         result.push(String::from(&arr[arr.len() - 1]));\n    | \
    \                    ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    let mut cur = String::from(\"One\");\n    while i < arr.len()\
    \ {\n        if arr[i] < 10 {\n            i += 1;\n            continue;\n  \
    \      }\n        let mut j = i;\n        while j < arr.len() && arr[j] >= 10\
    \ {\n            j += 1;\n        }\n        let mut k = j;\n        while k <\
    \ arr.len() && arr[k] <= 9 {\n            k += 1;\n        }\n        swap(&mut\
    \ arr[i], &mut arr[k]);\n        i += 1;\n    }\n    arr.reverse();\n    arr.iter().map(|x|\
    \ {\n        match x {\n            x if x > 0 && x < 10 => String::from(\"One\"\
    ),\n            x if x > 10 && x < 20 => String::from(\"Two\"),\n            x\
    \ if x > 20 && x < 30 => String::from(\"Three\"),\n            x if x > 30 &&\
    \ x < 40 => String::from(\"Four\"),\n            x if x > 40 && x < 50 => String::from(\"\
    Five\"),\n            x if x > 50 && x < 60 => String::from(\"Six\"),\n      \
    \      x if x > 60 && x < 70 => String::from(\"Seven\"),\n            x if x >\
    \ 70 && x < 80 => String::from(\"Eight\"),\n            x if x > 80 && x < 90\
    \ => String::from(\"Nine\"),\n            x if x > 90 && x < 100 => String::from(\"\
    Ten\"),\n            x if x > 100 => String::from(\"Eleven\"),\n            _\
    \ => String::from(\"Ten\"),\n        }\n    }).collect()\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpklxxzjql.rs:33:9\n\
    \   |\n33 |         swap(&mut arr[i], &mut arr[k]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpklxxzjql.rs:39:22\n   |\n39 |             x if x > 0 &&\
    \ x < 10 => String::from(\"One\"),\n   |                      ^\n   |        \
    \              |\n   |                      expected `&isize`, found integer\n\
    \   |                      help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpklxxzjql.rs:39:31\n   |\n39 |             x\
    \ if x > 0 && x < 10 => String::from(\"One\"),\n   |                         \
    \      ^^\n   |                               |\n   |                        \
    \       expected `&isize`, found integer\n   |                               help:\
    \ consider borrowing here: `&10`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpklxxzjql.rs:40:22\n\
    \   |\n40 |             x if x > 10 && x < 20 => String::from(\"Two\"),\n   |\
    \                      ^^\n   |                      |\n   |                 \
    \     expected `&isize`, found integer\n   |                      help: consider\
    \ borrowing here: `&10`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpklxxzjql.rs:40:32\n\
    \   |\n40 |             x if x > 10 && x < 20 => String::from(\"Two\"),\n   |\
    \                                ^^\n   |                                |\n \
    \  |                                expected `&isize`, found integer\n   |   \
    \                             help: consider borrowing here: `&20`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpklxxzjql.rs:41:22\n   |\n41 |             x\
    \ if x > 20 && x < 30 => String::from(\"Three\"),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&20`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpklxxzjql.rs:41:32\n   |\n41 |  \
    \           x if x > 20 && x < 30 => String::from(\"T"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digits_len = digits_len.saturating_add((9 - digits_len).abs());\n\
    \    let mut i = 0;\n    while i < digits_len {\n        let mut j = i;\n    \
    \    while j < digits_len && digits[j] < 10 {\n            j = j + 1;\n      \
    \  }\n        let mut k = i;\n        while k < digits_len && digits[k] > 9 {\n\
    \            k = k + 1;\n        }\n        let mut digit = digits[k];\n     \
    \   if digit < 10 {\n            digit = digit.to_string();\n        }\n     \
    \   if digit > 9 {\n            digit = digit.to_string();\n        }\n      \
    \  result.append(&digits[i .. j]);\n        i = j;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `abs` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpbbl79zkq.rs:20:69\n   |\n20 |     let mut digits_len =\
    \ digits_len.saturating_add((9 - digits_len).abs());\n   |                   \
    \                                                  ^^^ method not found in `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbbl79zkq.rs:33:21\n   |\n33 |\
    \             digit = digit.to_string();\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbbl79zkq.rs:36:21\n   |\n36 |             digit = digit.to_string();\n\
    \   |                     ^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbbl79zkq.rs:38:23\n   |\n38 |\
    \         result.append(&digits[i .. j]);\n   |                       ^^^^^^^^^^^^^^^\
    \ types differ in mutability\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                      found reference `&[isize]`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut reversed = vec![];\n    let mut i = 0;\n    while\
    \ i < arr.len() {\n        let digit = arr[i] - 1;\n        if digit < 10 {\n\
    \            digits.push(digit);\n        } else {\n            reversed.push(digit);\n\
    \        }\n        i += 1;\n    }\n    for i in reversed.iter_mut() {\n     \
    \   result.append(&names[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpysg1ioi9.rs:31:24\n\
    \   |\n31 |         result.append(&names[i]);\n   |                        ^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let len = arr[i] - 1;\n        if\
    \ len < 1 || len > 9 {\n            continue;\n        }\n        result.push(String::from(&arr[i\
    \ as usize]));\n        i += len;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmp5n3id_6j.rs:24:21\n    |\n24  |         result.push(String::from(&arr[i\
    \ as usize]));\n    |                     ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5n3id_6j.rs:25:14\n   |\n25 |         i += len;\n\
    \   |              ^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add-assign `isize` to `usize`\n  --> /tmp/tmp5n3id_6j.rs:25:11\n   |\n25 | \
    \        i += len;\n   |           ^^ no implementation for `usize += isize`\n\
    \   |\n   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let mut\
    \ j = i;\n        while j < digits_len && digits[j] < 10 {\n            j += 1\n\
    \        }\n        if j == digits_len {\n            break;\n        }\n    \
    \    let mut digit = digits[j];\n        if digit < 10 {\n            digit =\
    \ digit as isize;\n            result.push(String::from(&names[digit]));\n   \
    \     } else {\n            let mut reversed = digit as isize;\n            while\
    \ reversed > 0 {\n                result.push(String::from(&names[reversed % 10]));\n\
    \                reversed /= 10;\n            }\n        }\n        i = j;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpjp1d8w3u.rs:32:39\n\
    \   |\n32 |             result.push(String::from(&names[digit]));\n   |      \
    \                                 ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `names` in this scope\n  --> /tmp/tmpjp1d8w3u.rs:36:43\n \
    \  |\n36 |                 result.push(String::from(&names[reversed % 10]));\n\
    \   |                                           ^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| {\n        match x {\n            1 => 1,\n         \
    \   2 => 2,\n            3 => 3,\n            4 => 4,\n            5 => 5,\n \
    \           6 => 6,\n            7 => 7,\n            8 => 8,\n            9 =>\
    \ 9,\n            _ => panic!(\"invalid number in vector: {}\", x),\n        }\n\
    \    });\n    arr.reverse();\n    let mut result = vec![];\n    for i in arr {\n\
    \        let mut s = String::from(\"One\");\n        match i {\n            1\
    \ => s = \"One\",\n            2 => s = \"Two\",\n            3 => s = \"Three\"\
    ,\n            4 => s = \"Four\",\n            5 => s = \"Five\",\n          \
    \  6 => s = \"Six\",\n            7 => s = \"Seven\",\n            8 => s = \"\
    Eight\",\n            9 => s = \"Nine\",\n            _ => panic!(\"invalid number\
    \ in vector: {}\", i),\n        }\n        result.push(s);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7at3r0ul.rs:38:22\n   |\n\
    38 |             1 => s = \"One\",\n   |                      ^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                      |\n   |\
    \                      expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7at3r0ul.rs:39:22\n   |\n39 |             2\
    \ => s = \"Two\",\n   |                      ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                      |\n   |                  \
    \    expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7at3r0ul.rs:40:22\n   |\n40 |             3 => s = \"Three\",\n\
    \   |                      ^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                      |\n   |                      expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7at3r0ul.rs:41:22\n\
    \   |\n41 |             4 => s = \"Four\",\n   |                      ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \    |\n   |                      expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7at3r0ul.rs:42:22\n   |\n42 |             5\
    \ => s = \"Five\",\n   |                      ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                      |\n   |                  \
    \    expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7at3r0ul.rs:43:22\n   |\n43 |             6 => s = \"Six\",\n \
    \  |                      ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                      |\n   |                      expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7at3r0ul.rs:44:22\n\
    \   |\n44 |             7 => s = \"Seven\",\n   |                      ^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \    |\n   |                      expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7at3r0ul.rs:45:22\n   |\n45 |    "
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n\n    for\
    \ i in arr.iter().rev() {\n        let mut digit = String::from(\"0\");\n    \
    \    let mut remainder = i;\n\n        while remainder > 0 {\n            digit\
    \ = format!(\"{}{}\", digit, one_digit(remainder));\n            remainder -=\
    \ 1;\n        }\n\n        result.push(digit);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `one_digit` in this scope\n  --> /tmp/tmpke34i7kt.rs:25:44\n\
    \   |\n25 |             digit = format!(\"{}{}\", digit, one_digit(remainder));\n\
    \   |                                            ^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpke34i7kt.rs:24:27\n   |\n24 |\
    \         while remainder > 0 {\n   |                           ^\n   |      \
    \                     |\n   |                           expected `&isize`, found\
    \ integer\n   |                           help: consider borrowing here: `&0`\n\
    \nerror[E0368]: binary assignment operation `-=` cannot be applied to type `&isize`\n\
    \  --> /tmp/tmpke34i7kt.rs:26:13\n   |\n26 |             remainder -= 1;\n   |\
    \             ---------^^^^^\n   |             |\n   |             cannot use\
    \ `-=` on type `&isize`\n   |\nhelp: `-=` can be used on `isize`, you can dereference\
    \ `remainder`\n   |\n26 |             *remainder -= 1;\n   |             +\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.to_owned();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n\
    \        swap(&mut arr, i, len - 1);\n        i += 1;\n        len -= 1;\n   \
    \ }\n\n    let mut result = vec![];\n    for &i in arr {\n        result.push(String::from(&names[i]))\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpv3b3wowf.rs:26:9\n\
    \   |\n26 |         swap(&mut arr, i, len - 1);\n   |         ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find value `names` in this scope\n  --> /tmp/tmpv3b3wowf.rs:33:35\n   |\n33\
    \ |         result.push(String::from(&names[i]))\n   |                       \
    \            ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv3b3wowf.rs:32:9\n   |\n32 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `isize`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] < 1 || arr[i] > 9 {\n \
    \           i += 1;\n            continue;\n        }\n        let mut j = i;\n\
    \        while j < arr.len() {\n            if arr[j] == arr[i] {\n          \
    \      j += 1;\n                continue;\n            }\n            if arr[j]\
    \ > arr[i] {\n                break;\n            }\n            result.push(String::from(&arr[j\
    \ as usize]));\n            j += 1;\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmprfsqi5u9.rs:33:25\n    |\n33  |             result.push(String::from(&arr[j\
    \ as usize]));\n    |                         ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] < 1 || arr[i] > 9 {\n \
    \           i += 1;\n            continue;\n        }\n        let mut j = i;\n\
    \        while j < arr.len() && arr[j] == arr[j - 1] + 1 {\n            j += 1\n\
    \        }\n        let mut reversed = vec![];\n        while j < arr.len() {\n\
    \            reversed.push(arr[j]);\n            j += 1\n        }\n        let\
    \ mut reversed_str = String::new();\n        for &i in reversed {\n          \
    \  reversed_str.push_str(&name_to_digit(i));\n        }\n        result.push(reversed_str);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `name_to_digit` in this scope\n  -->\
    \ /tmp/tmp4gjidw4x.rs:35:36\n   |\n35 |             reversed_str.push_str(&name_to_digit(i));\n\
    \   |                                    ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4gjidw4x.rs:34:13\n   |\n34 |\
    \         for &i in reversed {\n   |             ^^    -------- this expression\
    \ has type `isize`\n   |             |\n   |             expected `isize`, found\
    \ reference\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect::<Vec<_>>();\n    arr.sort_unstable();\n    arr.iter().map(|x|\
    \ {\n        let mut s = String::new();\n        match x {\n            1 => s.push_str(\"\
    One\"),\n            2 => s.push_str(\"Two\"),\n            3 => s.push_str(\"\
    Three\"),\n            4 => s.push_str(\"Four\"),\n            5 => s.push_str(\"\
    Five\"),\n            6 => s.push_str(\"Six\"),\n            7 => s.push_str(\"\
    Seven\"),\n            8 => s.push_str(\"Eight\"),\n            9 => s.push_str(\"\
    Nine\"),\n            _ => panic!(\"Invalid number: {}\", x),\n        }\n   \
    \     s\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"Two\", \"Two\", \"Three\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp0riab9yr.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        swap(&mut arr, i, len - 1);\n        i += 1;\n    }\n    arr.iter().map(|&x|\
    \ String::from(&x[..])).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmph44f4vh_.rs:26:9\n\
    \   |\n26 |         swap(&mut arr, i, len - 1);\n   |         ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0608]: cannot\
    \ index into a value of type `isize`\n  --> /tmp/tmph44f4vh_.rs:29:39\n   |\n\
    29 |     arr.iter().map(|&x| String::from(&x[..])).collect()\n   |           \
    \                            ^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| {\n        match x {\n            1 => 1,\n         \
    \   2 => 2,\n            3 => 3,\n            4 => 4,\n            5 => 5,\n \
    \           6 => 6,\n            7 => 7,\n            8 => 8,\n            9 =>\
    \ 9,\n            _ => panic!(\"Invalid number: {}\", x),\n        }\n    });\n\
    \    arr.reverse();\n    arr.iter().map(|x| {\n        match x {\n           \
    \ 1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n    \
    \        4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\"\
    ,\n            7 => \"Seven\",\n            8 => \"Eight\",\n            9 =>\
    \ \"Nine\",\n            _ => panic!(\"Invalid number: {}\", x),\n        }\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpl1ejd0z8.rs:46:8\n   |\n46 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    for num in arr {\n        if num < 1 || num > 9 {\n           \
    \ continue;\n        }\n        let mut digits = num.to_string();\n        digits\
    \ = digits[1..].chars().collect::<String>().reverse();\n        result.push(String::from(digits));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpm13pwzdb.rs:20:58\n   |\n20 |         digits =\
    \ digits[1..].chars().collect::<String>().reverse();\n   |                   \
    \                                       ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.to_owned();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n            swap(&mut\
    \ arr, i, len - 1);\n            i += 1;\n        }\n    }\n    arr.iter().map(|x|\
    \ String::from(&names[x])).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp9dqm88mp.rs:25:13\n\
    \   |\n25 |             swap(&mut arr, i, len - 1);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]:\
    \ cannot find value `names` in this scope\n  --> /tmp/tmp9dqm88mp.rs:29:38\n \
    \  |\n29 |     arr.iter().map(|x| String::from(&names[x])).collect()\n   |   \
    \                                   ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n      \
    \      j = j + 1;\n        }\n        reversed.push((&arr[i..j]).rev().collect::<Vec<_>>());\n\
    \        i = j;\n    }\n    for r in reversed {\n        let mut i = 0;\n    \
    \    while i < r.len() {\n            let mut j = i;\n            while j < r.len()\
    \ && r[j] < 10 {\n                j = j + 1;\n            }\n            let mut\
    \ s = String::from(\"\");\n            for c in r[i..j] {\n                s =\
    \ format!(\"{}{}\", s, &names[c]);\n            }\n            reversed.push((&s[..]).rev().collect::<Vec<_>>());\n\
    \            i = j;\n        }\n    }\n    vec!(reversed)\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpf_gm9zwf.rs:38:41\n\
    \   |\n38 |                 s = format!(\"{}{}\", s, &names[c]);\n   |       \
    \                                  ^^^^^ not found in this scope\n\nerror[E0271]:\
    \ type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpf_gm9zwf.rs:18:35\n   |\n18 |     let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                   ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpf_gm9zwf.rs:18:44\n \
    \  |\n18 |       let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror[E0599]: the method `rev` exists for reference `&str`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpf_gm9zwf.rs:40:36\n   |\n40 |            \
    \ reversed.push((&s[..]).rev().collect::<Vec<_>>());\n   |                   \
    \                 ^^^ method cannot be called on `&str` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `&str: Iterator`\n           which is required by `&mut &str: Iterator`\n\
    \           `str: Iterator`\n           which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digit_index = 0;\n    let mut digit_index2 = 0;\n\
    \    let mut digit_index3 = 0;\n    let mut digit_index4 = 0;\n    let mut digit_index5\
    \ = 0;\n    let mut digit_index6 = 0;\n    let mut digit_index7 = 0;\n    let\
    \ mut digit_index8 = 0;\n    let mut digit_index9 = 0;\n    let mut digit_index10\
    \ = 0;\n    let mut digit_index11 = 0;\n    let mut digit_index12 = 0;\n    let\
    \ mut digit_index13 = 0;\n    let mut digit_index14 = 0;\n    let mut digit_index15\
    \ = 0;\n    let mut digit_index16 = 0;\n    let mut digit_index17 = 0;\n    let\
    \ mut digit_index18 = 0;\n    let mut digit_index19 = 0;\n    let mut digit_index20\
    \ = 0;\n    let mut digit_index21 = 0;\n    let mut digit_index22 = 0;\n    let\
    \ mut digit_index23 = 0;\n    let mut digit_index24 = 0;\n    let mut digit_index25\
    \ = 0;\n    let mut digit_index26 = 0;\n    let mut digit_index27 = 0;\n    let\
    \ mut digit_index28 = 0;\n    let mut digit_index29 = 0;\n    let mut digit_index30\
    \ = 0;\n    let mut digit_index31 = 0;\n    let mut digit_index32 = 0;\n    let\
    \ mut digit_index33 = 0;\n    let mut digit_index34 = 0;\n    let mut digit_index35\
    \ = 0;\n    let mut digit_index36 = 0;\n    let mut digit_index37 = 0;\n    let\
    \ mut digit_index38 = 0;\n    let mut digit_index39 = 0;\n    let mut digit_index40\
    \ = 0;\n    let mut digit_index41 = 0;\n    let mut digit_index42 = 0;\n    let\
    \ mut digit_index43 = 0;\n    let mut digit_index44 = 0;\n    let mut digit_index45\
    \ = 0;\n    let mut digit_index46 = 0;\n    let mut digit_index47 = 0;\n    let\
    \ mut digit_index48 = 0;\n    let mut digit_index49 = 0;\n    let mut digit_index50\
    \ = 0;\n    let mut digit_index51 = 0;\n    let mut digit_index52 = 0;\n    let\
    \ mut digit_index53 = 0;\n    let mut digit_index54 = 0;\n    let mut digit_index55\
    \ = 0;\n    let mut digit_index56 = 0;\n    let mut digit_index57 = 0;\n    let\
    \ mut digit_index58 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3tuf4r3p.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while len > 0 {\n     \
    \   let mut j = i;\n        while j > 0 && arr[j - 1] > 9 {\n            j -=\
    \ 1;\n        }\n        if j > 0 {\n            arr[j] = String::from(\"One\"\
    );\n            i += 1;\n        }\n        if j == 0 {\n            arr[j] =\
    \ String::from(\"Zero\");\n            i += 1;\n        }\n        if j > 0 &&\
    \ arr[j - 1] < 1 {\n            arr[j] = String::from(\"Two\");\n            i\
    \ += 1;\n        }\n        if j > 0 && arr[j - 1] < 2 {\n            arr[j] =\
    \ String::from(\"Three\");\n            i += 1;\n        }\n        if j > 0 &&\
    \ arr[j - 1] < 3 {\n            arr[j] = String::from(\"Four\");\n           \
    \ i += 1;\n        }\n        if j > 0 && arr[j - 1] < 4 {\n            arr[j]\
    \ = String::from(\"Five\");\n            i += 1;\n        }\n        if j > 0\
    \ && arr[j - 1] < 5 {\n            arr[j] = String::from(\"Six\");\n         \
    \   i += 1;\n        }\n        if j > 0 && arr[j - 1] < 6 {\n            arr[j]\
    \ = String::from(\"Seven\");\n            i += 1;\n        }\n        if j > 0\
    \ && arr[j - 1] < 7 {\n            arr[j] = String::from(\"Eight\");\n       \
    \     i += 1;\n        }\n        if j > 0 && arr[j - 1] < 8 {\n            arr[j]\
    \ = String::from(\"Nine\");\n            i += 1;\n        }\n        if j > 0\
    \ && arr[j - 1] < 9 {\n            arr[j] = String::from(\"Ten\");\n         \
    \   i += 1;\n        }\n        len -= 1;\n    }\n    arr\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2gnt9nqp.rs:26:22\n   |\n\
    26 |             arr[j] = String::from(\"One\");\n   |                      ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2gnt9nqp.rs:30:22\n   |\n30 |             arr[j] = String::from(\"\
    Zero\");\n   |                      ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2gnt9nqp.rs:34:22\n\
    \   |\n34 |             arr[j] = String::from(\"Two\");\n   |                \
    \      ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2gnt9nqp.rs:38:22\n   |\n38 |             arr[j]\
    \ = String::from(\"Three\");\n   |                      ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2gnt9nqp.rs:42:22\n   |\n42 |             arr[j] = String::from(\"\
    Four\");\n   |                      ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2gnt9nqp.rs:46:22\n\
    \   |\n46 |             arr[j] = String::from(\"Five\");\n   |               \
    \       ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2gnt9nqp.rs:50:22\n   |\n50 |             arr[j]\
    \ = String::from(\"Six\");\n   |                      ^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2gnt9nqp.rs:54:22\n\
    \   |\n54 |             arr[j] = String::from(\"Seven\");\n   |              \
    \        ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2gnt9nqp.rs:58:22\n   |\n58 |             arr[j]\
    \ = String::from(\"Eight\");\n   |                      ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2gnt9nqp.rs:62:22\n   |\n62 |             arr[j] = String::from(\"\
    Nine\");\n   |                      ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] < 1 || arr[i] > 9 {\n \
    \           break;\n        }\n        let mut j = i;\n        while j < arr.len()\
    \ {\n            if arr[j] == arr[i] {\n                j += 1;\n            \
    \    continue;\n            }\n            break;\n        }\n        let mut\
    \ k = i;\n        while k > 0 && arr[k - 1] > arr[k] {\n            k -= 1;\n\
    \        }\n        result.push(String::from(&arr[k]));\n        i = j;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmpdfittiqs.rs:35:21\n    |\n35  |         result.push(String::from(&arr[k]));\n\
    \    |                     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = arr.len();\n\
    \n    while i < l {\n        if arr[i] < 10 {\n            result.push(String::from(\"\
    One\"));\n            i += 1;\n        } else {\n            result.push(String::from(\"\
    Ten\"));\n            i += 1;\n        }\n\n        if arr[i] < 10 {\n       \
    \     result.push(String::from(\"Two\"));\n            i += 1;\n        } else\
    \ {\n            result.push(String::from(\"Eleven\"));\n            i += 1;\n\
    \        }\n\n        if arr[i] < 10 {\n            result.push(String::from(\"\
    Three\"));\n            i += 1;\n        } else {\n            result.push(String::from(\"\
    Twelve\"));\n            i += 1;\n        }\n\n        if arr[i] < 10 {\n    \
    \        result.push(String::from(\"Four\"));\n            i += 1;\n        }\
    \ else {\n            result.push(String::from(\"Fifteen\"));\n            i +=\
    \ 1;\n        }\n\n        if arr[i] < 10 {\n            result.push(String::from(\"\
    Five\"));\n            i += 1;\n        } else {\n            result.push(String::from(\"\
    Fifty\"));\n            i += 1;\n        }\n\n        if arr[i] < 10 {\n     \
    \       result.push(String::from(\"Six\"));\n            i += 1;\n        } else\
    \ {\n            result.push(String::from(\"Seventy\"));\n            i += 1;\n\
    \        }\n\n        if arr[i] < 10 {\n            result.push(String::from(\"\
    Eight\"));\n            i += 1;\n        } else {\n            result.push(String::from(\"\
    Eighty\"));\n            i += 1;\n        }\n\n        if arr[i] < 10 {\n    \
    \        result.push(String::from(\"Nine\"));\n            i += 1;\n        }\
    \ else {\n            result.push(String::from(\"Ninety\"));\n            i +=\
    \ 1;\n        }\n\n        if arr[i] < 10 {\n            result.push(String::from(\"\
    Ten\"));\n            i += 1;\n        } else {\n            result.push(String::from(\"\
    Eleven\"));\n            i += 1;\n        }\n\n        if arr[i] < 10 {\n    \
    \        result.push(String::from(\"Twelve\"));\n            i += 1;\n       \
    \ } else {\n            result.push(String::from(\"Twelvety\"));\n           \
    \ i += 1;\n        }\n\n        if arr[i] < 10 {\n            result.push(String::from(\"\
    Fifteen\"));\n            i += 1;\n        } else {\n            result.push(String::from(\"\
    Fifteenty\"));\n            i += 1;\n        }\n\n        if arr[i] < 10 {\n \
    \           result.push(String::from(\"Fifty\"));\n            i += 1;\n     \
    \   } else {\n            result.\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpr02fzw1i.rs:128:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n25  |     while\
    \ i < l {\n    |                 - unclosed delimiter\n...\n117 |         } else\
    \ {\n    |                - this delimiter might not be properly closed...\n118\
    \ |             result.\n119 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n128 | }\n    |   ^\n\nerror: unexpected token: `}`\n   -->\
    \ /tmp/tmpr02fzw1i.rs:119:1\n    |\n119 | }\n    | ^\n\nerror[E0308]: mismatched\
    \ types\n   --> /tmp/tmpr02fzw1i.rs:118:13\n    |\n114 | /         if arr[i] <\
    \ 10 {\n115 | |             result.push(String::from(\"Fifty\"));\n116 | |   \
    \          i += 1;\n117 | |         } else {\n118 | |             result.\n  \
    \  | |             ^^^^^^ expected `()`, found struct `Vec`\n119 | | }\n    |\
    \ |_- expected this to be `()`\n    |\n    = note: expected unit type `()`\n \
    \                 found struct `Vec<String>`\nhelp: you might have meant to return\
    \ this value\n    |\n118 |             return result;.\n    |             ++++++\
    \       +\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpr02fzw1i.rs:25:5\n\
    \    |\n13  |   fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |        \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n25  | /     while i < l {\n26  | |         if arr[i] < 10 {\n27 \
    \ | |             result.push(String::from(\"One\"));\n28  | |             i +=\
    \ 1;\n...   |\n127 | |     assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n128 | | }\n    |\
    \ |__^ expected struct `Vec`, found `()`\n    |\n    = note: expected struct `Vec<String>`\n\
    \            found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut reversed = vec![];\n    let\
    \ mut digits = vec![];\n    let mut ones = vec![];\n    let mut twos = vec![];\n\
    \    let mut threes = vec![];\n    let mut fours = vec![];\n    let mut fives\
    \ = vec![];\n    let mut sixes = vec![];\n    let mut sevens = vec![];\n    let\
    \ mut eights = vec![];\n    let mut nines = vec![];\n\n    let mut i = 0;\n  \
    \  while i < arr.len() {\n        let digit = arr[i];\n        let mut digit =\
    \ digit;\n        let mut digit = digit;\n        let mut digit = digit;\n   \
    \     let mut digit = digit;\n        let mut digit = digit;\n        let mut\
    \ digit = digit;\n        let mut digit = digit;\n        let mut digit = digit;\n\
    \        let mut digit = digit;\n        let mut digit = digit;\n        let mut\
    \ digit = digit;\n        let mut digit = digit;\n        let mut digit = digit;\n\
    \        let mut digit = digit;\n        let mut digit = digit;\n        let mut\
    \ digit = digit;\n        let mut digit = digit;\n        let mut digit = digit;\n\
    \        let mut digit = digit;\n        let mut digit = digit;\n        let mut\
    \ digit = digit;\n        let mut digit = digit;\n        let mut digit = digit;\n\
    \        let mut digit = digit;\n        let mut digit = digit;\n        let mut\
    \ digit = digit;\n        let mut digit = digit;\n        let mut digit = digit;\n\
    \        let mut digit = digit;\n        let mut digit = digit;\n        let mut\
    \ digit = digit;\n        let mut digit = digit;\n        let mut digit = digit;\n\
    \        let mut digit = digit;\n        let mut digit = digit;\n        let mut\
    \ digit = digit;\n        let mut digit = digit;\n        let mut digit = digit;\n\
    \        let mut digit = digit;\n        let mut digit = digit;\n        let mut\
    \ digit = digit;\n        let mut digit = digit;\n        let mut digit = digit;\n\
    \        let mut digit = digit;\n        let mut digit = digit;\n        let mut\
    \ digit = digit;\n        let mut digit = digit;\n        let mut \n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpaoc51cno.rs:90:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n31 |     while i\
    \ < arr.len() {\n   |                         - this delimiter might not be properly\
    \ closed...\n...\n81 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n90 | }\n   |   ^\n\nerror: expected identifier, found `}`\n  --> /tmp/tmpaoc51cno.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpaoc51cno.rs:13:34\n   |\n13 | fn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n   |    ---------                     ^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n\n    while digits_len > 0 {\n        let mut digit = digits.remove(0);\n\
    \        let mut digits_len = digits.len();\n\n        while digit > 9 {\n   \
    \         digit /= 10;\n            digits_len -= 1;\n        }\n\n        result.push(String::from(&names[digit]));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmp2cmiivpa.rs:31:35\n\
    \   |\n31 |         result.push(String::from(&names[digit]));\n   |          \
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as usize).collect::<Vec<_>>();\n    arr.sort_unstable();\n    arr.reverse();\n\
    \    let mut result = vec![];\n    for x in arr {\n        let mut s = String::new();\n\
    \        if x < 10 {\n            s.push_str(&format!(\"One\", x));\n        }\
    \ else if x < 20 {\n            s.push_str(&format!(\"Two\", x - 10));\n     \
    \   } else if x < 30 {\n            s.push_str(&format!(\"Three\", x - 20));\n\
    \        } else if x < 40 {\n            s.push_str(&format!(\"Four\", x - 30));\n\
    \        } else if x < 50 {\n            s.push_str(&format!(\"Five\", x - 40));\n\
    \        } else if x < 60 {\n            s.push_str(&format!(\"Six\", x - 50));\n\
    \        } else if x < 70 {\n            s.push_str(&format!(\"Seven\", x - 60));\n\
    \        } else if x < 80 {\n            s.push_str(&format!(\"Eight\", x - 70));\n\
    \        } else if x < 90 {\n            s.push_str(&format!(\"Nine\", x - 80));\n\
    \        } else {\n            s.push_str(&format!(\"Ten\", x - 90));\n      \
    \  }\n        result.push(s);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmpl0bagu34.rs:24:40\n   |\n24 |\
    \             s.push_str(&format!(\"One\", x));\n   |                        \
    \         -----  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpl0bagu34.rs:26:40\n   |\n26 |             s.push_str(&format!(\"\
    Two\", x - 10));\n   |                                 -----  ^^^^^^ argument\
    \ never used\n   |                                 |\n   |                   \
    \              formatting specifier missing\n\nerror: argument never used\n  -->\
    \ /tmp/tmpl0bagu34.rs:28:42\n   |\n28 |             s.push_str(&format!(\"Three\"\
    , x - 20));\n   |                                 -------  ^^^^^^ argument never\
    \ used\n   |                                 |\n   |                         \
    \        formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpl0bagu34.rs:30:41\n\
    \   |\n30 |             s.push_str(&format!(\"Four\", x - 30));\n   |        \
    \                         ------  ^^^^^^ argument never used\n   |           \
    \                      |\n   |                                 formatting specifier\
    \ missing\n\nerror: argument never used\n  --> /tmp/tmpl0bagu34.rs:32:41\n   |\n\
    32 |             s.push_str(&format!(\"Five\", x - 40));\n   |               \
    \                  ------  ^^^^^^ argument never used\n   |                  \
    \               |\n   |                                 formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmpl0bagu34.rs:34:40\n   |\n34 |    \
    \         s.push_str(&format!(\"Six\", x - 50));\n   |                       \
    \          -----  ^^^^^^ argument never used\n   |                           \
    \      |\n   |                                 formatting specifier missing\n\n\
    error: argument never used\n  --> /tmp/tmpl0bagu34.rs:36:42\n   |\n36 |      \
    \       s.push_str(&format!(\"Seven\", x - 60));\n   |                       \
    \          -------  ^^^^^^ argument never used\n   |                         \
    \        |\n   |                                 formatting "
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = arr.len()\
    \ - 1;\n\n    while i < k {\n        let mut digit = arr[i];\n        if digit\
    \ < 10 {\n            digits.push(digit);\n            i += 1;\n        } else\
    \ {\n            digits.push(digit - 10);\n            i += 1;\n            digits.push(digit\
    \ % 10);\n        }\n    }\n\n    while i < k {\n        let mut digit = arr[i];\n\
    \        if digit < 10 {\n            digits.push(digit);\n            i += 1;\n\
    \        } else {\n            digits.push(digit - 10);\n            i += 1;\n\
    \            digits.push(digit % 10);\n        }\n    }\n\n    while j >= 0 {\n\
    \        let mut digit = digits[j];\n        if digit < 10 {\n            result.append(&String::from(\"\
    One\"));\n            j -= 1;\n        } else {\n            result.append(&String::from(\"\
    Two\"));\n            j -= 1;\n            result.append(&String::from(\"Three\"\
    ));\n            j -= 1;\n            result.append(&String::from(\"Four\"));\n\
    \            j -= 1;\n            result.append(&String::from(\"Five\"));\n  \
    \          j -= 1;\n            result.append(&String::from(\"Six\"));\n     \
    \       j -= 1;\n            result.append(&String::from(\"Seven\"));\n      \
    \      j -= 1;\n            result.append(&String::from(\"Eight\"));\n       \
    \     j -= 1;\n            result.append(&String::from(\"Nine\"));\n         \
    \   j -= 1;\n            result.append(&String::from(digit as char));\n      \
    \  }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvzgooew8.rs:51:27\n   |\n\
    51 |             result.append(&String::from(\"One\"));\n   |                \
    \           ^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<_>`\n                      found reference\
    \ `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvzgooew8.rs:54:27\n\
    \   |\n54 |             result.append(&String::from(\"Two\"));\n   |         \
    \                  ^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n   |\n   =\
    \ note: expected mutable reference `&mut Vec<_>`\n                      found\
    \ reference `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvzgooew8.rs:56:27\n\
    \   |\n56 |             result.append(&String::from(\"Three\"));\n   |       \
    \                    ^^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n   |\n\
    \   = note: expected mutable reference `&mut Vec<_>`\n                      found\
    \ reference `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvzgooew8.rs:58:27\n\
    \   |\n58 |             result.append(&String::from(\"Four\"));\n   |        \
    \                   ^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n   |\n \
    \  = note: expected mutable reference `&mut Vec<_>`\n                      found\
    \ reference `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvzgooew8.rs:60:27\n\
    \   |\n60 |             result.append(&String::from(\"Five\"));\n   |        \
    \                   ^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n   |\n \
    \  = note: expected mutable reference `&mut Vec<_>`\n                      found\
    \ reference `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvzgooew8.rs:62:27\n\
    \   |\n62 |             result.append(&String::from(\"Six\"));\n   |         \
    \                  ^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n   |\n   =\
    \ note: expected mutable reference `&mut Vec<_>`\n                      found\
    \ reference `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvzgooew8.rs:64:27\n\
    \   |\n64 |             result.append(&String::from(\"Seven\"));\n   |       \
    \                    ^^^^^^^^^^^^^^^^^^^^^^ types differ in muta"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] < 1 || arr[i] > 9 {\n \
    \           break;\n        }\n        let digit = arr[i] - 1;\n        let name\
    \ = match digit {\n            1 => \"One\",\n            2 => \"Two\",\n    \
    \        3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\"\
    ,\n            6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"\
    Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"Invalid digit\
    \ in array: {}\", digit),\n        };\n        result.push(name);\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n  \
    \  assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdqa4cjk9.rs:39:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    39 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] <\
    \ 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n \
    \       result.push(String::from(&arr[i as usize]));\n        i += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmp5tuf5u00.rs:21:21\n    |\n21  |         result.push(String::from(&arr[i\
    \ as usize]));\n    |                     ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let mut\
    \ j = i;\n        while j < digits_len && digits[j] < 10 {\n            j += 1\n\
    \        }\n        let mut digit = digits[j];\n        if digit < 10 {\n    \
    \        result.push(String::from(\"One\"));\n            i += 1;\n        } else\
    \ {\n            result.push(String::from(\"Two\"));\n            i += 1;\n  \
    \          result.push(String::from(\"Three\"));\n            i += 1;\n      \
    \      result.push(String::from(\"Four\"));\n            i += 1;\n           \
    \ result.push(String::from(\"Five\"));\n            i += 1;\n            result.push(String::from(\"\
    Six\"));\n            i += 1;\n            result.push(String::from(\"Seven\"\
    ));\n            i += 1;\n            result.push(String::from(\"Eight\"));\n\
    \            i += 1;\n            result.push(String::from(\"Nine\"));\n     \
    \       i += 1;\n        }\n        while j < digits_len && digits[j] == digit\
    \ {\n            j += 1\n        }\n        if j == digits_len {\n           \
    \ result.push(String::from(format!(\"{}\", digit)));\n            i += 1;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 8 but the
    index is 8'', /tmp/tmpdesfrst8.rs:26:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut len = arr.len();\n    let mut i = 0;\n    while i < len\
    \ {\n        if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < len {\n            if arr[j]\
    \ == arr[i] {\n                j += 1;\n                continue;\n          \
    \  }\n            if arr[j] > arr[i] {\n                break;\n            }\n\
    \            result.push(String::from(&arr[j as usize]));\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmpwhjs9cfj.rs:31:25\n    |\n31  |             result.push(String::from(&arr[j\
    \ as usize]));\n    |                         ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digits_reversed = digits.clone();\n    digits_reversed.reverse();\n\
    \    let mut i = 0;\n    while i < digits_len {\n        let mut j = i;\n    \
    \    while j < digits_len && digits[j] < 10 {\n            digits_reversed[j]\
    \ -= 10;\n            j += 1\n        }\n        let digit = digits_reversed[i];\n\
    \        let name = match digit {\n            0 => \"Zero\",\n            1 =>\
    \ \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n         \
    \   4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\",\n  \
    \          7 => \"Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\"\
    ,\n            _ => unreachable!(),\n        };\n        result.push(name);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgha8ybz6.rs:46:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    46 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as usize).collect::<Vec<usize>>();\n    arr.sort_unstable();\n    let mut\
    \ arr = arr.into_iter().map(|x| x as usize).collect::<Vec<usize>>();\n    arr.reverse();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect::<Vec<usize>>();\n\
    \    arr.iter().map(|x| {\n        match x {\n            1 => \"One\".to_string(),\n\
    \            2 => \"Two\".to_string(),\n            3 => \"Three\".to_string(),\n\
    \            4 => \"Four\".to_string(),\n            5 => \"Five\".to_string(),\n\
    \            6 => \"Six\".to_string(),\n            7 => \"Seven\".to_string(),\n\
    \            8 => \"Eight\".to_string(),\n            9 => \"Nine\".to_string(),\n\
    \            _ => panic!(\"Invalid number: {}\", x),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid number: 18446744073709551615'', /tmp/tmpunbxpi3d.rs:33:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < reversed.len() {\n        let mut j = reversed.len()\
    \ - 1;\n        while j >= i && reversed[j] > 9 {\n            j -= 1;\n     \
    \   }\n        result.push(by_digit(digits[reversed[j]]));\n        i = j;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpgjmwx2sd.rs:26:21\n\
    \   |\n26 |         result.push(by_digit(digits[reversed[j]]));\n   |        \
    \             ^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgjmwx2sd.rs:26:30\n   |\n26 |  \
    \       result.push(by_digit(digits[reversed[j]]));\n   |                    \
    \          ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect::<Vec<_>>();\n    let mut len = arr.len();\n    let mut\
    \ i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n       \
    \     i += 1;\n            continue;\n        }\n        swap(&mut arr, i, len\
    \ - 1);\n        i += 1;\n    }\n    arr.into_iter().map(|x| x as String).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmppqnj4pla.rs:25:9\n\
    \   |\n25 |         swap(&mut arr, i, len - 1);\n   |         ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0605]: non-primitive\
    \ cast: `isize` as `String`\n  --> /tmp/tmppqnj4pla.rs:28:29\n   |\n28 |     arr.into_iter().map(|x|\
    \ x as String).collect()\n   |                             ^^^^^^^^^^^ an `as`\
    \ expression can only be used to convert between primitive types or to coerce\
    \ to a specific trait object\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0605.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let mut\
    \ j = i;\n        while j < digits_len && digits[j] < 10 {\n            j += 1\n\
    \        }\n        if j == digits_len {\n            break;\n        }\n    \
    \    let digit = digits[j];\n        let mut reversed_digit = digit as isize;\n\
    \        reversed_digit *= 10;\n        reversed_digit -= 1;\n        result.push(by_digit(reversed_digit));\n\
    \        i += j - i;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpkbjo_l4t.rs:34:21\n\
    \   |\n34 |         result.push(by_digit(reversed_digit));\n   |             \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n\
    \n    for digit in &mut reversed {\n        let index = digit as usize;\n    \
    \    let name = match index {\n            0 => \"One\",\n            1 => \"\
    Two\",\n            2 => \"Three\",\n            3 => \"Four\",\n            4\
    \ => \"Five\",\n            5 => \"Six\",\n            6 => \"Seven\",\n     \
    \       7 => \"Eight\",\n            8 => \"Nine\",\n            _ => unreachable!(),\n\
    \        };\n        result.push(name);\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6oy44wsq.rs:39:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    39 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror[E0606]: casting `&mut isize` as `usize` is invalid\n  --> /tmp/tmp6oy44wsq.rs:23:21\n\
    \   |\n23 |         let index = digit as usize;\n   |                     -----^^^^^^^^^\n\
    \   |                     |\n   |                     cannot cast `&mut isize`\
    \ as `usize`\n   |                     help: dereference the expression: `*digit`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut i = 0;\n    let mut j = 0;\n\n    while i < arr.len()\
    \ {\n        if arr[i] < 10 {\n            digits.push(String::from(format!(\"\
    {}\", arr[i])));\n            i += 1;\n        } else {\n            if j == 0\
    \ {\n                result.push(String::from(\"One\"));\n                j +=\
    \ 1;\n            } else {\n                result.push(String::from(\"Two\"));\n\
    \                j += 1;\n            }\n            i += 1;\n        }\n    }\n\
    \n    if j == 0 {\n        result.push(String::from(\"One\"));\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\"]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"]`', /tmp/tmpvqzflzqx.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|&x| x.checked_div(10).unwrap());\n    arr.sort_by_key(|&x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|&x| x.checked_add((10\
    \ as isize)).unwrap());\n    arr.iter().map(|&x| {\n        match x {\n      \
    \      0 => \"Zero\".to_string(),\n            1 => \"One\".to_string(),\n   \
    \         2 => \"Two\".to_string(),\n            3 => \"Three\".to_string(),\n\
    \            4 => \"Four\".to_string(),\n            5 => \"Five\".to_string(),\n\
    \            6 => \"Six\".to_string(),\n            7 => \"Seven\".to_string(),\n\
    \            8 => \"Eight\".to_string(),\n            9 => \"Nine\".to_string(),\n\
    \            _ => panic!(\"Invalid number {:?}\", x),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"Two\", \"Two\", \"Three\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpoaqio6yw.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.to_owned();\n\
    \    arr.sort_unstable();\n    arr.reverse();\n    arr.iter().map(|x| {\n    \
    \    match x {\n            1 => \"One\".into(),\n            2 => \"Two\".into(),\n\
    \            3 => \"Three\".into(),\n            4 => \"Four\".into(),\n     \
    \       5 => \"Five\".into(),\n            6 => \"Six\".into(),\n            7\
    \ => \"Seven\".into(),\n            8 => \"Eight\".into(),\n            9 => \"\
    Nine\".into(),\n            _ => panic!(\"Invalid number in array: {}\", x),\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid number in array: 55'', /tmp/tmp1wd9hfcx.rs:28:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| {\n        if x < 1 || x > 9 {\n            0\n     \
    \   } else {\n            x\n        }\n    });\n    arr.reverse();\n    arr.iter().map(|x|\
    \ {\n        match x {\n            x if x < 10 => \"One\".to_string(),\n    \
    \        x if x < 20 => \"Two\".to_string(),\n            x if x < 30 => \"Three\"\
    .to_string(),\n            x if x < 40 => \"Four\".to_string(),\n            x\
    \ if x < 50 => \"Five\".to_string(),\n            x if x < 60 => \"Six\".to_string(),\n\
    \            x if x < 70 => \"Seven\".to_string(),\n            x if x < 80 =>\
    \ \"Eight\".to_string(),\n            x if x < 90 => \"Nine\".to_string(),\n \
    \           _ => panic!(\"Invalid number {:?}\", x),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoll98_ir.rs:19:16\n   |\n\
    19 |         if x < 1 || x > 9 {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoll98_ir.rs:19:25\n\
    \   |\n19 |         if x < 1 || x > 9 {\n   |                         ^\n   |\
    \                         |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpoll98_ir.rs:22:13\n\
    \   |\n19 | /         if x < 1 || x > 9 {\n20 | |             0\n   | |      \
    \       - expected because of this\n21 | |         } else {\n22 | |          \
    \   x\n   | |             ^ expected integer, found `&isize`\n23 | |         }\n\
    \   | |_________- `if` and `else` have incompatible types\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |             *x\n   |             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoll98_ir.rs:28:22\n   |\n28 |  \
    \           x if x < 10 => \"One\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&10`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoll98_ir.rs:29:22\n   |\n29 |  \
    \           x if x < 20 => \"Two\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&20`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoll98_ir.rs:30:22\n   |\n30 |  \
    \           x if x < 30 => \"Three\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&30`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoll98_ir.rs:31:22\n   |\n31 |  \
    \           x if x < 40 => \"Four\".to_string(),\n   |                      ^"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    let mut digits = arr.len();\n\n    while i < digits {\n        let\
    \ mut j = i;\n        let mut digit = arr[i];\n\n        while j > 0 && digit\
    \ > 9 {\n            result.push(by_length(arr.split_off(j).collect()));\n   \
    \         j -= 1;\n        }\n\n        result.push(by_name(digit));\n       \
    \ i += 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_name` in this scope\n  --> /tmp/tmp6ki3ou6j.rs:31:21\n\
    \   |\n31 |         result.push(by_name(digit));\n   |                     ^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Vec<isize>`, but its trait bounds were not satisfied\n   --> /tmp/tmp6ki3ou6j.rs:27:52\n\
    \    |\n27  |               result.push(by_length(arr.split_off(j).collect()));\n\
    \    |                                                      ^^^^^^^ method cannot\
    \ be called on `Vec<isize>` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6ki3ou6j.rs:35:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n35 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_add(1).unwrap());\n\
    \    arr.iter().map(|x| {\n        let mut s = String::new();\n        match x\
    \ {\n            0 => s.push_str(\"Zero\"),\n            1 => s.push_str(\"One\"\
    ),\n            2 => s.push_str(\"Two\"),\n            3 => s.push_str(\"Three\"\
    ),\n            4 => s.push_str(\"Four\"),\n            5 => s.push_str(\"Five\"\
    ),\n            6 => s.push_str(\"Six\"),\n            7 => s.push_str(\"Seven\"\
    ),\n            8 => s.push_str(\"Eight\"),\n            9 => s.push_str(\"Nine\"\
    ),\n            _ => panic!(\"Invalid number {:?}\", x),\n        }\n        s\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"Two\", \"Two\", \"Three\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpoeowf_oy.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let mut\
    \ j = i;\n        while j < digits_len && digits[j] < 10 {\n            j += 1;\
    \ // skip leading zeroes\n        }\n        if j == digits_len {\n          \
    \  break;\n        }\n        let digit = digits[j];\n        if digit < 10 {\n\
    \            result.push(String::from(\"One\"));\n        } else if digit < 20\
    \ {\n            result.push(String::from(\"Two\"));\n        } else if digit\
    \ < 30 {\n            result.push(String::from(\"Three\"));\n        } else if\
    \ digit < 40 {\n            result.push(String::from(\"Four\"));\n        } else\
    \ if digit < 50 {\n            result.push(String::from(\"Five\"));\n        }\
    \ else if digit < 60 {\n            result.push(String::from(\"Six\"));\n    \
    \    } else if digit < 70 {\n            result.push(String::from(\"Seven\"));\n\
    \        } else if digit < 80 {\n            result.push(String::from(\"Eight\"\
    ));\n        } else if digit < 90 {\n            result.push(String::from(\"Nine\"\
    ));\n        } else {\n            result.push(String::from(\"Ten\"));\n     \
    \   }\n        i = j;\n    }\n    result.reverse();\n    for digit in digits {\n\
    \        if digit < 10 {\n            result.push(String::from(\"One\"));\n  \
    \      } else if digit < 20 {\n            result.push(String::from(\"Two\"));\n\
    \        } else if digit < 30 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if digit < 40 {\n            result.push(String::from(\"Four\"\
    ));\n        } else if digit < 50 {\n            result.push(String::from(\"Five\"\
    ));\n        } else if digit < 60 {\n            result.push(String::from(\"Six\"\
    ));\n        } else if digit < 70 {\n            result.push(String::from(\"Seven\"\
    ));\n        } else if digit < 80 {\n            result.push(String::from(\"Eight\"\
    ));\n        } else if digit < 90 {\n            result.push(String::from(\"Nine\"\
    ));\n        } else {\n            result.push(String::from(\"Ten\"));\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmp3p4k5wf_.rs:82:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_unstable_by_key(|x| x.checked_div(10).unwrap());\n    arr.iter_mut().for_each(|x|\
    \ {\n        if *x < 10 {\n            *x = String::from(\"One\");\n        }\
    \ else if *x < 20 {\n            *x = String::from(\"Two\");\n        } else if\
    \ *x < 30 {\n            *x = String::from(\"Three\");\n        } else if *x <\
    \ 40 {\n            *x = String::from(\"Four\");\n        } else if *x < 50 {\n\
    \            *x = String::from(\"Five\");\n        } else if *x < 60 {\n     \
    \       *x = String::from(\"Six\");\n        } else if *x < 70 {\n           \
    \ *x = String::from(\"Seven\");\n        } else if *x < 80 {\n            *x =\
    \ String::from(\"Eight\");\n        } else if *x < 90 {\n            *x = String::from(\"\
    Nine\");\n        } else {\n            *x = String::from(\"Ten\");\n        }\n\
    \    });\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3pkb3kl9.rs:21:18\n   |\n\
    21 |             *x = String::from(\"One\");\n   |                  ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3pkb3kl9.rs:23:18\n   |\n23 |             *x = String::from(\"\
    Two\");\n   |                  ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pkb3kl9.rs:25:18\n\
    \   |\n25 |             *x = String::from(\"Three\");\n   |                  ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3pkb3kl9.rs:27:18\n   |\n27 |             *x = String::from(\"\
    Four\");\n   |                  ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pkb3kl9.rs:29:18\n\
    \   |\n29 |             *x = String::from(\"Five\");\n   |                  ^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3pkb3kl9.rs:31:18\n   |\n31 |             *x = String::from(\"\
    Six\");\n   |                  ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pkb3kl9.rs:33:18\n\
    \   |\n33 |             *x = String::from(\"Seven\");\n   |                  ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3pkb3kl9.rs:35:18\n   |\n35 |             *x = String::from(\"\
    Eight\");\n   |                  ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pkb3kl9.rs:37:18\n\
    \   |\n37 |             *x = String::from(\"Nine\");\n   |                  ^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3pkb3kl9.rs:39:18\n   |\n39 |             *x = String::from(\"\
    Ten\");\n   |                  ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pkb3kl9.rs:42:5\n\
    \   |\n13 | fn by_length(arr: "
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while len > 0 {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         arr[i] = String::from(&names[arr[i] - 1]);\n            len -= 1;\n\
    \        }\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpk_0trswc.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&names[arr[i] - 1]);\n   |     \
    \                               ^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk_0trswc.rs:25:22\n   |\n25 |             arr[i]\
    \ = String::from(&names[arr[i] - 1]);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk_0trswc.rs:29:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n29 |     arr\n   |     ^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| {\n        match x {\n            1 => 1,\n         \
    \   2 => 2,\n            3 => 3,\n            4 => 4,\n            5 => 5,\n \
    \           6 => 6,\n            7 => 7,\n            8 => 8,\n            9 =>\
    \ 9,\n            _ => panic!(\"Invalid number: {}\", x),\n        }\n    });\n\
    \    arr.reverse();\n    arr.iter().map(|x| {\n        match x {\n           \
    \ 1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n    \
    \        4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\"\
    ,\n            7 => \"Seven\",\n            8 => \"Eight\",\n            9 =>\
    \ \"Nine\",\n            _ => panic!(\"Invalid number: {}\", x),\n        }\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpl1ejd0z8.rs:46:8\n   |\n46 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        let mut\
    \ digit = digits[i];\n        if digit < 1 || digit > 9 {\n            i += 1;\n\
    \            continue;\n        }\n        let mut j = i;\n        while j < digits_len\
    \ {\n            if digits[j] < digit {\n                break;\n            }\n\
    \            i += 1;\n        }\n        if j == digits_len {\n            result.push(String::from(&digits[digits_len\
    \ - 1]));\n            i += 1;\n        } else {\n            result.push(String::from(&digits[j]));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmpep1yv5ix.rs:35:25\n    |\n35  |             result.push(String::from(&digits[digits_len\
    \ - 1]));\n    |                         ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror[E0277]:\
    \ the trait bound `String: From<&isize>` is not satisfied\n   --> /tmp/tmpep1yv5ix.rs:38:25\n\
    \    |\n38  |             result.push(String::from(&digits[j]));\n    |      \
    \                   ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for\
    \ `String`\n    |\n    = help: the following implementations were found:\n   \
    \           <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        if\
    \ arr[i] < 10 {\n            digits.push(String::from(format!(\"{}\", arr[i])));\n\
    \        } else {\n            if digits.len() > 0 {\n                result.push(&digits[digits.len()\
    \ - 1]);\n                digits.clear();\n            }\n            result.push(String::from(format!(\"\
    {}\", arr[i])));\n        }\n        i += 1;\n    }\n    if digits.len() > 0 {\n\
    \        result.push(&digits[digits.len() - 1]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9uru67xy.rs:29:25\n   |\n\
    29 |             result.push(String::from(format!(\"{}\", arr[i])));\n   |   \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             \
    \            |\n   |                         expected `&String`, found struct\
    \ `String`\n   |                         help: consider borrowing here: `&String::from(format!(\"\
    {}\", arr[i]))`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9uru67xy.rs:36:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n36 |     result\n   |     ^^^^^^ expected struct `String`, found `&String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.to_owned();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n\
    \n        let mut j = i;\n        while j > 0 && arr[j - 1] > arr[j] {\n     \
    \       j -= 1;\n        }\n\n        swap(&mut arr[j], &mut arr[i]);\n      \
    \  i += 1;\n    }\n\n    arr.iter().map(|x| String::from(&format!(\"{}\", x)).to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpppa1bqp_.rs:32:9\n\
    \   |\n32 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut res = vec![];\n    let mut i =\
    \ 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j < arr.len()\
    \ && arr[j] < 10 {\n            j += 1\n        }\n        let mut k = i;\n  \
    \      while k < j && arr[k] > 9 {\n            k += 1\n        }\n        if\
    \ k > j {\n            res.extend_from_slice(&arr[i..k]);\n            i = k;\n\
    \        } else {\n            res.extend_from_slice(&arr[i..j]);\n          \
    \  i = j;\n        }\n    }\n    res.extend_from_slice(&arr[i..]);\n    res\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmmebxeef.rs:37:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    37 |     res\n   |     ^^^ expected struct `String`, found `isize`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut digits_len = arr.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = arr.len();\n    let mut digits_index = 0;\n \
    \   let mut digits_len = arr.len();\n    let mut digits_index = 0;\n    let mut\
    \ digits_len = arr.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = arr.len();\n    let mut digits_index = 0;\n    let mut digits_len = arr.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = arr.len();\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = arr.len();\n    let mut digits_index = 0;\n \
    \   let mut digits_len = arr.len();\n    let mut digits_index = 0;\n    let mut\
    \ digits_len = arr.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = arr.len();\n    let mut digits_index = 0;\n    let mut digits_len = arr.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = arr.len();\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = arr.len();\n    let mut digits_index = 0;\n \
    \   let mut digits_len = arr.len();\n    let mut digits_index = 0;\n    let mut\
    \ digits_len = arr.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = arr.len();\n    let mut digits_index = 0;\n    let mut digits_len = arr.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = arr.len();\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = arr.len();\n    let mut digits_index = 0;\n \
    \   let mut digits_len = arr.len();\n    let mut digits_index = 0;\n    let mut\
    \ digits_len = arr.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = arr.len();\n    let mut digits_index = 0;\n    let mut digits_len = arr.len();\n\
    \    let mut digit\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3cqmdrkr.rs:72:18\n   |\n\
    72 |     let mut digit\n   |                  ^ help: add `;` here\n73 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3cqmdrkr.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    let mut digit = reversed.pop();\n    while digit != 0\
    \ {\n        let mut name = String::from(\"One\");\n        if digit % 10 == 0\
    \ {\n            name = String::from(\"One\");\n        }\n        if digit %\
    \ 10 == 1 {\n            name = String::from(\"Two\");\n        }\n        if\
    \ digit % 10 == 2 {\n            name = String::from(\"Three\");\n        }\n\
    \        if digit % 10 == 3 {\n            name = String::from(\"Four\");\n  \
    \      }\n        if digit % 10 == 4 {\n            name = String::from(\"Five\"\
    );\n        }\n        if digit % 10 == 5 {\n            name = String::from(\"\
    Six\");\n        }\n        if digit % 10 == 6 {\n            name = String::from(\"\
    Seven\");\n        }\n        if digit % 10 == 7 {\n            name = String::from(\"\
    Eight\");\n        }\n        if digit % 10 == 8 {\n            name = String::from(\"\
    Nine\");\n        }\n        if digit % 10 == 9 {\n            name = String::from(\"\
    Ten\");\n        }\n        result.push(name);\n        i += 1;\n        digit\
    \ = reversed.pop();\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjwrk_whu.rs:23:20\n   |\n\
    23 |     while digit != 0 {\n   |                    ^\n   |                 \
    \   |\n   |                    expected enum `Option`, found integer\n   |   \
    \                 help: try using a variant of the expected enum: `Some(0)`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `{integer}`\n\
    \nerror[E0369]: cannot mod `Option<isize>` by `{integer}`\n  --> /tmp/tmpjwrk_whu.rs:25:18\n\
    \   |\n25 |         if digit % 10 == 0 {\n   |            ----- ^ -- {integer}\n\
    \   |            |\n   |            Option<isize>\n\nerror[E0369]: cannot mod\
    \ `Option<isize>` by `{integer}`\n  --> /tmp/tmpjwrk_whu.rs:28:18\n   |\n28 |\
    \         if digit % 10 == 1 {\n   |            ----- ^ -- {integer}\n   |   \
    \         |\n   |            Option<isize>\n\nerror[E0369]: cannot mod `Option<isize>`\
    \ by `{integer}`\n  --> /tmp/tmpjwrk_whu.rs:31:18\n   |\n31 |         if digit\
    \ % 10 == 2 {\n   |            ----- ^ -- {integer}\n   |            |\n   | \
    \           Option<isize>\n\nerror[E0369]: cannot mod `Option<isize>` by `{integer}`\n\
    \  --> /tmp/tmpjwrk_whu.rs:34:18\n   |\n34 |         if digit % 10 == 3 {\n  \
    \ |            ----- ^ -- {integer}\n   |            |\n   |            Option<isize>\n\
    \nerror[E0369]: cannot mod `Option<isize>` by `{integer}`\n  --> /tmp/tmpjwrk_whu.rs:37:18\n\
    \   |\n37 |         if digit % 10 == 4 {\n   |            ----- ^ -- {integer}\n\
    \   |            |\n   |            Option<isize>\n\nerror[E0369]: cannot mod\
    \ `Option<isize>` by `{integer}`\n  --> /tmp/tmpjwrk_whu.rs:40:18\n   |\n40 |\
    \         if digit % 10 == 5 {\n   |            ----- ^ -- {integer}\n   |   \
    \         |\n   |            Option<isize>\n\nerror[E0369]: cannot mod `Option<isize>`\
    \ by `{integer}`\n  --> /tmp/tmpjwrk_whu.rs:43:18\n   |\n43 |         if digit\
    \ % 10 == 6 {\n   |            ----- ^ -- {integer}\n   |            |\n   | \
    \           Option<isize>\n\nerror[E0369]: cannot mod `Option<isize>` by `{integer}`\n\
    \  --> /tmp/tmpjwrk_whu.rs:46:18\n   |\n46 |         if digit % 10 == 7 {\n  \
    \ |            ----- ^ -- {integer}\n   |            |"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = arr.clone();\n    reversed.reverse();\n    for &i in &mut\
    \ arr {\n        if i >= 1 && i <= 9 {\n            i = String::from(&format!(\"\
    {}\", i));\n        }\n    }\n    arr.extend(reversed);\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgl2fqeyq.rs:21:9\n   |\n\
    21 |     for &i in &mut arr {\n   |         ^^    -------- this expression has\
    \ type `&mut isize`\n   |         |\n   |         types differ in mutability\n\
    \   |\n   = note: expected mutable reference `&mut isize`\n                  \
    \    found reference `&_`\n\nerror[E0277]: can't compare `String` with `{integer}`\n\
    \  --> /tmp/tmpgl2fqeyq.rs:22:14\n   |\n22 |         if i >= 1 && i <= 9 {\n \
    \  |              ^^ no implementation for `String < {integer}` and `String >\
    \ {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0277]: can't compare `String` with `{integer}`\n  -->\
    \ /tmp/tmpgl2fqeyq.rs:22:24\n   |\n22 |         if i >= 1 && i <= 9 {\n   |  \
    \                      ^^ no implementation for `String < {integer}` and `String\
    \ > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgl2fqeyq.rs:27:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n27 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = arr.len()\
    \ - 1;\n\n    while i <= k {\n        if arr[i] < 10 {\n            digits.push(String::from(\"\
    0\".to_string()));\n        }\n        digits.push(String::from(&arr[i as usize]));\n\
    \        i += 1;\n    }\n\n    while j >= 0 {\n        if j > 0 {\n          \
    \  result.push(digits[j - 1]);\n        }\n        j -= 1;\n    }\n\n    for digit\
    \ in digits {\n        result.push(digit);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmpmwd6_4b2.rs:28:21\n    |\n28  |         digits.push(String::from(&arr[i\
    \ as usize]));\n    |                     ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] < 1 || arr[i] > 9 {\n \
    \           i += 1;\n            continue;\n        }\n        let mut j = i;\n\
    \        while j < arr.len() && arr[j] == arr[j - 1] + 1 {\n            j += 1\n\
    \        }\n        result.push(String::from(&arr[i - j]));\n        i = j;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmpnusrkcsn.rs:28:21\n    |\n28  |         result.push(String::from(&arr[i\
    \ - j]));\n    |                     ^^^^^^^^^^^^ the trait `From<&isize>` is\
    \ not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < len {\n            if arr[j]\
    \ < 1 || arr[j] > 9 {\n                j += 1;\n                continue;\n  \
    \          }\n            if arr[j] == arr[i] {\n                arr[j] = arr[j].to_string()\
    \ + String::from(\"One\");\n            }\n            j += 1;\n        }\n  \
    \      i += 1;\n    }\n    arr.iter().cloned().collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ebfzboi.rs:32:47\n   |\n\
    32 |                 arr[j] = arr[j].to_string() + String::from(\"One\");\n  \
    \ |                                               ^^^^^^^^^^^^^^^^^^^\n   |  \
    \                                             |\n   |                        \
    \                       expected `&str`, found struct `String`\n   |         \
    \                                      help: consider borrowing here: `&String::from(\"\
    One\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ebfzboi.rs:32:26\n \
    \  |\n32 |                 arr[j] = arr[j].to_string() + String::from(\"One\"\
    );\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ebfzboi.rs:38:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n38 |     arr.iter().cloned().collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| {\n        match x {\n            0 => 0,\n         \
    \   1 => 1,\n            2 => 2,\n            3 => 3,\n            4 => 4,\n \
    \           5 => 5,\n            6 => 6,\n            7 => 7,\n            8 =>\
    \ 8,\n            9 => 9,\n            _ => panic!(\"Invalid number: {}\", x),\n\
    \        }\n    });\n    arr.reverse();\n    arr.iter().map(|x| {\n        match\
    \ x {\n            0 => \"One\",\n            1 => \"Two\",\n            2 =>\
    \ \"Three\",\n            3 => \"Four\",\n            4 => \"Five\",\n       \
    \     5 => \"Six\",\n            6 => \"Seven\",\n            7 => \"Eight\",\n\
    \            8 => \"Nine\",\n            9 => \"Ten\",\n            _ => panic!(\"\
    Invalid number: {}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpr98mzdye.rs:49:8\n   |\n49 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect::<Vec<_>>();\n    arr.sort_unstable();\n    arr.reverse();\n\
    \    arr.iter().map(|x| {\n        match x {\n            1 => \"One\",\n    \
    \        2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => panic!(\"Invalid number: {}\", x),\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpdlj5j1sh.rs:33:8\n   |\n33 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digits_len = digits_len.saturating_add((digits_len\
    \ % 10).unwrap());\n    let mut digits_len = digits_len.saturating_add(10);\n\
    \    let mut digits_len = digits_len.saturating_add(10);\n    let mut digits_len\
    \ = digits_len.saturating_add(10);\n    let mut digits_len = digits_len.saturating_add(10);\n\
    \    let mut digits_len = digits_len.saturating_add(10);\n    let mut digits_len\
    \ = digits_len.saturating_add(10);\n    let mut digits_len = digits_len.saturating_add(10);\n\
    \    let mut digits_len = digits_len.saturating_add(10);\n    let mut digits_len\
    \ = digits_len.saturating_add(10);\n    let mut digits_len = digits_len.saturating_add(10);\n\
    \    let mut digits_len = digits_len.saturating_add(10);\n    let mut digits_len\
    \ = digits_len.saturating_add(10);\n    let mut digits_len = digits_len.saturating_add(10);\n\
    \    let mut digits_len = digits_len.saturating_add(10);\n    let mut digits_len\
    \ = digits_len.saturating_add(10);\n    let mut digits_len = digits_len.saturating_add(10);\n\
    \    let mut digits_len = digits_len.saturating_add(10);\n    let mut digits_len\
    \ = digits_len.saturating_add(10);\n    let mut digits_len = digits_len.saturating_add(10);\n\
    \    let mut digits_len = digits_len.saturating_add(10);\n    let mut digits_len\
    \ = digits_len.saturating_add(10);\n    let mut digits_len = digits_len.saturating_add(10);\n\
    \    let mut digits_len = digits_len.saturating_add(10);\n    let mut digits_len\
    \ = digits_len.saturating_add(10);\n    let mut digits_len = digits_len.saturating_add(10);\n\
    \    let mut digits_len = digits_len.saturating_add(10);\n    let mut digits_len\
    \ = digits_len.saturating_add(10);\n    let mut digits_len = digits_len.saturating_add(10);\n\
    \    let mut digits_len = digits_len.saturating_add(10);\n    let mut digit\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4g33_5f5.rs:51:18\n   |\n\
    51 |     let mut digit\n   |                  ^ help: add `;` here\n52 | }\n \
    \  | - unexpected token\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `usize` in the current scope\n  --> /tmp/tmp4g33_5f5.rs:21:70\n   |\n21 |  \
    \   let mut digits_len = digits_len.saturating_add((digits_len % 10).unwrap());\n\
    \   |                                                                      ^^^^^^\
    \ method not found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4g33_5f5.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut i = 0;\n    let mut j = 0;\n\n    while i < arr.len()\
    \ {\n        if arr[i] < 10 {\n            digits.push(String::from(\"0\".to_string()));\n\
    \            digits.push(String::from(format!(\"{}\", arr[i])));\n           \
    \ i += 1;\n        } else {\n            digits.push(String::from(format!(\"{}\"\
    , arr[i])));\n            i += 1;\n        }\n    }\n\n    while j < digits.len()\
    \ {\n        let mut i = 0;\n        while i < digits.len() {\n            if\
    \ digits[j] == String::from(format!(\"{}\", i)) {\n                result.push(String::from(format!(\"\
    {}\", i)));\n                i += 1;\n            } else {\n                break;\n\
    \            }\n        }\n        j += 1;\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpxbx8kgg7.rs:52:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.reverse();\n  \
    \  arr.iter().map(|x| {\n        match x {\n            0 => \"Zero\".to_string(),\n\
    \            1 => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n\
    \            3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n\
    \            5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n\
    \            7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => panic!(\"Invalid number\
    \ {:?}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpk4f3vgdo.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.reverse();\n  \
    \  let mut res = vec![];\n    for i in arr {\n        let mut s = String::from(\"\
    One\");\n        if i <= 9 {\n            s = String::from(format!(\"{}\", i));\n\
    \        }\n        res.push(s);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"3\", \"2\", \"8\", \"5\", \"4\", \"1\", \"1\", \"2\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpczzd0dqy.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.to_owned();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    let mut cur = String::from(\"\
    One\");\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n        \
    \    i += 1;\n            continue;\n        }\n        let mut j = i;\n     \
    \   while j < len && arr[j] < 10 {\n            i += 1;\n            len -= 1;\n\
    \            j += 1;\n        }\n        let mut k = i;\n        while k < len\
    \ && arr[k] > 9 {\n            i += 1;\n            len -= 1;\n            k +=\
    \ 1;\n        }\n        swap(&mut arr[i], &mut arr[k]);\n        i += 1;\n  \
    \      len -= 1;\n    }\n    arr.truncate(len);\n    arr.iter().map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp5h7bnxv3.rs:39:9\n\
    \   |\n39 |         swap(&mut arr[i], &mut arr[k]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.to_owned();\n    arr.sort_unstable_by_key(|x|\
    \ {\n        match x {\n            1 => 0,\n            2 => 1,\n           \
    \ 3 => 2,\n            4 => 3,\n            5 => 4,\n            6 => 5,\n   \
    \         7 => 6,\n            8 => 7,\n            9 => 8,\n            _ =>\
    \ panic!(\"Invalid number: {}\", x),\n        }\n    });\n    arr.iter().map(|x|\
    \ {\n        match x {\n            0 => \"One\",\n            1 => \"Two\",\n\
    \            2 => \"Three\",\n            3 => \"Four\",\n            4 => \"\
    Five\",\n            5 => \"Six\",\n            6 => \"Seven\",\n            7\
    \ => \"Eight\",\n            8 => \"Nine\",\n            _ => panic!(\"Invalid\
    \ number: {}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpoopvyqb0.rs:45:8\n   |\n45 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    let mut cur = String::from(\"\
    One\");\n    let mut last = String::from(\"One\");\n\n    while i < len {\n  \
    \      if arr[i] < 10 {\n            i += 1;\n            continue;\n        }\n\
    \n        let mut j = i;\n        let mut cur = String::from(\"One\");\n     \
    \   let mut last = String::from(\"One\");\n\n        while j < len {\n       \
    \     if arr[j] < 10 {\n                j += 1;\n                continue;\n \
    \           }\n\n            if arr[j] < 100 {\n                cur = String::from(\"\
    One\");\n                last = String::from(\"One\");\n            }\n\n    \
    \        if arr[j] < 1000 {\n                cur = String::from(\"Two\");\n  \
    \              last = String::from(\"Two\");\n            }\n\n            if\
    \ arr[j] < 10000 {\n                cur = String::from(\"Three\");\n         \
    \       last = String::from(\"Three\");\n            }\n\n            if arr[j]\
    \ < 100000 {\n                cur = String::from(\"Four\");\n                last\
    \ = String::from(\"Four\");\n            }\n\n            if arr[j] < 1000000\
    \ {\n                cur = String::from(\"Five\");\n                last = String::from(\"\
    Five\");\n            }\n\n            if arr[j] < 10000000 {\n              \
    \  cur = String::from(\"Six\");\n                last = String::from(\"Six\");\n\
    \            }\n\n            if arr[j] < 100000000 {\n                cur = String::from(\"\
    Seven\");\n                last = String::from(\"Seven\");\n            }\n\n\
    \            if arr[j] < 1000000000 {\n                cur = String::from(\"Eight\"\
    );\n                last = String::from(\"Eight\");\n            }\n\n       \
    \     if arr[j] < 10000000000 {\n                cur = String::from(\"Nine\");\n\
    \                last = String::from(\"Nine\");\n            }\n\n           \
    \ if arr[j] < 100000000000 {\n                cur = String::from(\"Ten\");\n \
    \               last = String::from(\"Ten\");\n            }\n\n            if\
    \ arr[j] < 1000000000000 {\n                cur = String::from(\"Eleven\");\n\
    \                last = String::from(\"Eleven\");\n            }\n\n         \
    \   if arr[j] < 10000000000000 {\n                cur = String::from(\"Twelve\"\
    );\n                last = String::from(\"Twelve\");\n            }\n\n      \
    \      if arr[j] < 100000000000000 {\n                cur\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3vvuv6nq.rs:111:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n24  |     while\
    \ i < len {\n    |                   - unclosed delimiter\n...\n34  |        \
    \ while j < len {\n    |                       - unclosed delimiter\n...\n100\
    \ |             if arr[j] < 100000000000000 {\n    |                         \
    \                - this delimiter might not be properly closed...\n101 |     \
    \            cur\n102 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n111 | }\n    |   ^\n\nerror[E0271]: type mismatch resolving\
    \ `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n  --> /tmp/tmp3vvuv6nq.rs:18:35\n\
    \   |\n18 |     let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                   ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp3vvuv6nq.rs:18:44\n \
    \  |\n18 |       let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror[E0308]: mismatched types\n   --> /tmp/tmp3vvuv6nq.rs:101:17\n    |\n100\
    \ | /             if arr[j] < 100000000000000 {\n101 | |                 cur\n\
    \    | |                 ^^^ expected `()`, found struct `String`\n102 | | }\n\
    \    | |_- expected this to be `()`\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmp3vvuv6nq.rs:24:5\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n\n    let\
    \ mut digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed\
    \ = digits.iter().cloned().rev().collect::<Vec<_>>();\n\n    let mut i = 0;\n\
    \    while i < reversed.len() {\n        let digit = reversed[i];\n        let\
    \ index = digit as usize;\n        let digit = digits[index];\n        let name\
    \ = match digit {\n            1 => \"One\",\n            2 => \"Two\",\n    \
    \        3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\"\
    ,\n            6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"\
    Eight\",\n            9 => \"Nine\",\n            _ => unreachable!(),\n     \
    \   };\n        result.push(name);\n        i += 1;\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjlru6e72.rs:44:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    44 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        let\
    \ digit = arr[i] - 1;\n        if digit < 10 {\n            digits.push(digit);\n\
    \        } else {\n            let mut j = i;\n            while j > 0 && digits[j\
    \ - 1] > digit {\n                j -= 1;\n            }\n            if j > 0\
    \ {\n                digits.push(digit - 10);\n                digits.push(digits[j\
    \ - 1]);\n            } else {\n                digits.push(digit - 10);\n   \
    \         }\n        }\n        i += 1;\n    }\n    for digit in digits {\n  \
    \      result.push(String::from(\"One\"));\n        result.push(String::from(\"\
    Two\"));\n        result.push(String::from(\"Three\"));\n        result.push(String::from(\"\
    Four\"));\n        result.push(String::from(\"Five\"));\n        result.push(String::from(\"\
    Six\"));\n        result.push(String::from(\"Seven\"));\n        result.push(String::from(\"\
    Eight\"));\n        result.push(String::from(\"Nine\"));\n        result.push(String::from(format!(\"\
    {}\", digit)));\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\"\
    , \"Nine\", \"1\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"\
    Seven\", \"Eight\", \"Nine\", \"0\", \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"0\", \"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"3\", \"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    , \"4\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\",\
    \ \"Eight\", \"Nine\", \"7\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\", \"1\", \"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"2\"]`,\n right:\
    \ `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]`', /tmp/tmpptih3z5v.rs:55:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_unstable();\n    arr.reverse();\n    let mut result = vec![];\n\
    \    for &i in arr {\n        let index = i as usize;\n        let name = match\
    \ index {\n            1 => \"One\",\n            2 => \"Two\",\n            3\
    \ => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n    \
    \        6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\"\
    ,\n            9 => \"Nine\",\n            _ => return vec![],\n        };\n \
    \       result.push(name);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprtjwoq3u.rs:21:9\n   |\n\
    21 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprtjwoq3u.rs:37:5\n   |\n13 | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |                                  ----------- expected\
    \ `Vec<String>` because of return type\n...\n37 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while len > 0 {\n     \
    \   let mut j = i;\n        while j > 0 && arr[j - 1] > 9 {\n            j -=\
    \ 1;\n        }\n        arr[i] = arr[j];\n        i += 1;\n        len -= 1;\n\
    \    }\n    arr.rev().iter().map(|x| String::from(&format!(\"{}\", x)))\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `rev` exists for struct `Vec<isize>`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmph7dvkvkn.rs:30:9\n    |\n30\
    \  |       arr.rev().iter().map(|x| String::from(&format!(\"{}\", x)))\n    |\
    \           ^^^ method cannot be called on `Vec<isize>` due to unsatisfied trait\
    \ bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut i = 0;\n    while i < digits_len {\n        if digits[i]\
    \ < 10 {\n            result.push(String::from(\"One\"));\n        } else if digits[i]\
    \ < 20 {\n            result.push(String::from(\"Two\"));\n        } else if digits[i]\
    \ < 30 {\n            result.push(String::from(\"Three\"));\n        } else if\
    \ digits[i] < 40 {\n            result.push(String::from(\"Four\"));\n       \
    \ } else if digits[i] < 50 {\n            result.push(String::from(\"Five\"));\n\
    \        } else if digits[i] < 60 {\n            result.push(String::from(\"Six\"\
    ));\n        } else if digits[i] < 70 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if digits[i] < 80 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if digits[i] < 90 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n        i += 1;\n    }\n    result.reverse();\n    for digit in result\
    \ {\n        digits[digits.len() - digits_len + i] = digit;\n    }\n    digits\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy15353_w.rs:48:49\n   |\n\
    48 |         digits[digits.len() - digits_len + i] = digit;\n   |            \
    \                                     ^^^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy15353_w.rs:50:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n50 |\
    \     digits\n   |     ^^^^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n     \
    \   if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n   \
    \         swap(&mut arr, i, len - 1);\n            i += 1;\n        }\n    }\n\
    \n    arr.iter().map(|x| String::from(&names[*x % 10])).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpyaptgecg.rs:25:13\n\
    \   |\n25 |             swap(&mut arr, i, len - 1);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]:\
    \ cannot find value `names` in this scope\n  --> /tmp/tmpyaptgecg.rs:30:38\n \
    \  |\n30 |     arr.iter().map(|x| String::from(&names[*x % 10])).collect()\n \
    \  |                                      ^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut digits = vec![];\n    let mut i = 0;\n    while i < arr.len()\
    \ {\n        let digit = arr[i] - 1;\n        if digit < 10 {\n            digits.push(digit\
    \ as char);\n        } else {\n            digits.push(digit as char);\n     \
    \       digits.push(digit as char);\n        }\n        i += 1;\n    }\n    digits.reverse();\n\
    \    for i in 0..digits.len() {\n        let digit = digits[i];\n        let name\
    \ = match digit {\n            1 => \"One\",\n            2 => \"Two\",\n    \
    \        3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\"\
    ,\n            6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"\
    Eight\",\n            9 => \"Nine\",\n            _ => unreachable!(),\n     \
    \   };\n        result.push(name);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphlajhlrn.rs:31:13\n   |\n\
    30 |         let name = match digit {\n   |                          ----- this\
    \ expression has type `char`\n31 |             1 => \"One\",\n   |           \
    \  ^ expected `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphlajhlrn.rs:32:13\n\
    \   |\n30 |         let name = match digit {\n   |                          -----\
    \ this expression has type `char`\n31 |             1 => \"One\",\n32 |      \
    \       2 => \"Two\",\n   |             ^ expected `char`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphlajhlrn.rs:33:13\n   |\n30 |         let name\
    \ = match digit {\n   |                          ----- this expression has type\
    \ `char`\n...\n33 |             3 => \"Three\",\n   |             ^ expected `char`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphlajhlrn.rs:34:13\n\
    \   |\n30 |         let name = match digit {\n   |                          -----\
    \ this expression has type `char`\n...\n34 |             4 => \"Four\",\n   |\
    \             ^ expected `char`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphlajhlrn.rs:35:13\n   |\n30 |         let name = match digit {\n\
    \   |                          ----- this expression has type `char`\n...\n35\
    \ |             5 => \"Five\",\n   |             ^ expected `char`, found integer\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphlajhlrn.rs:36:13\n   |\n30 |\
    \         let name = match digit {\n   |                          ----- this expression\
    \ has type `char`\n...\n36 |             6 => \"Six\",\n   |             ^ expected\
    \ `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphlajhlrn.rs:37:13\n\
    \   |\n30 |         let name = match digit {\n   |                          -----\
    \ this expression has type `char`\n...\n37 |             7 => \"Seven\",\n   |\
    \             ^ expected `char`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphlajhlrn.rs:38:13\n   |\n30 |         let name = match digit {\n\
    \   |                          ----- this expression has type `char`\n...\n38\
    \ |             8 => \"Eight\",\n   |  "
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digit\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj_3m70mx.rs:72:18\n   |\n\
    72 |     let mut digit\n   |                  ^ help: add `;` here\n73 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj_3m70mx.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mut digits_len = arr.len() as usize;\n    let mut\
    \ digits_index = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9732zkc3.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9732zkc3.rs:13:34\n \
    \  |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    --------- \
    \                    ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len =\
    \ digits.len();\n    let mut digit_idx = 1;\n    let mut digit_idx2 = 1;\n   \
    \ let mut digit_idx3 = 1;\n    let mut digit_idx4 = 1;\n    let mut digit_idx5\
    \ = 1;\n    let mut digit_idx6 = 1;\n    let mut digit_idx7 = 1;\n    let mut\
    \ digit_idx8 = 1;\n    let mut digit_idx9 = 1;\n    let mut digit_idx10 = 1;\n\
    \    let mut digit_idx11 = 1;\n    let mut digit_idx12 = 1;\n    let mut digit_idx13\
    \ = 1;\n    let mut digit_idx14 = 1;\n    let mut digit_idx15 = 1;\n    let mut\
    \ digit_idx16 = 1;\n    let mut digit_idx17 = 1;\n    let mut digit_idx18 = 1;\n\
    \    let mut digit_idx19 = 1;\n    let mut digit_idx20 = 1;\n    let mut digit_idx21\
    \ = 1;\n    let mut digit_idx22 = 1;\n    let mut digit_idx23 = 1;\n    let mut\
    \ digit_idx24 = 1;\n    let mut digit_idx25 = 1;\n    let mut digit_idx26 = 1;\n\
    \    let mut digit_idx27 = 1;\n    let mut digit_idx28 = 1;\n    let mut digit_idx29\
    \ = 1;\n    let mut digit_idx30 = 1;\n    let mut digit_idx31 = 1;\n    let mut\
    \ digit_idx32 = 1;\n    let mut digit_idx33 = 1;\n    let mut digit_idx34 = 1;\n\
    \    let mut digit_idx35 = 1;\n    let mut digit_idx36 = 1;\n    let mut digit_idx37\
    \ = 1;\n    let mut digit_idx38 = 1;\n    let mut digit_idx39 = 1;\n    let mut\
    \ digit_idx40 = 1;\n    let mut digit_idx41 = 1;\n    let mut digit_idx42 = 1;\n\
    \    let mut digit_idx43 = 1;\n    let mut digit_idx44 = 1;\n    let mut digit_idx45\
    \ = 1;\n    let mut digit_idx46 = 1;\n    let mut digit_idx47 = 1;\n    let mut\
    \ digit_idx48 = 1;\n    let mut digit_idx49 = 1;\n    let mut digit_idx50 = 1;\n\
    \    let mut digit_idx51 = 1;\n    let mut digit_idx52 = 1;\n    let mut digit_idx53\
    \ = 1;\n    let mut digit_idx54 = 1;\n    let mut digit_idx55 = 1;\n    let mut\
    \ digit_idx56 = 1;\n    let mut digit_idx57 = 1;\n    let mut digit_\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb6ogpb4z.rs:77:19\n   |\n\
    77 |     let mut digit_\n   |                   ^ help: add `;` here\n78 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb6ogpb4z.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut res = vec![];\n    let mut digits\
    \ = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len = digits.len();\n\
    \    let mut i = 0;\n    while i < digits_len {\n        let mut j = i;\n    \
    \    while j < digits_len && digits[j] < 10 {\n            j += 1\n        }\n\
    \        if j == digits_len {\n            break;\n        }\n        let mut\
    \ digit = digits[j];\n        let mut digits_len = digits_len;\n        while\
    \ digit > 9 {\n            digit /= 10;\n            digits_len -= 1\n       \
    \ }\n        res.push(by_digit(digit));\n        i = j;\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp5vg80y3a.rs:35:18\n\
    \   |\n35 |         res.push(by_digit(digit));\n   |                  ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let len = arr[i] - 1;\n        if\
    \ len < 1 || len > 9 {\n            i += 1;\n            continue;\n        }\n\
    \        result.push(String::from(&arr[i as usize]));\n        i += len;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmp1xjfjc95.rs:25:21\n    |\n25  |         result.push(String::from(&arr[i\
    \ as usize]));\n    |                     ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n    |\n    = help: the following implementations\
    \ were found:\n              <String as From<&String>>\n              <String\
    \ as From<&mut str>>\n              <String as From<&str>>\n              <String\
    \ as From<Box<str>>>\n            and 2 others\nnote: required by `from`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1xjfjc95.rs:26:14\n   |\n26 |         i += len;\n\
    \   |              ^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add-assign `isize` to `usize`\n  --> /tmp/tmp1xjfjc95.rs:26:11\n   |\n26 | \
    \        i += len;\n   |           ^^ no implementation for `usize += isize`\n\
    \   |\n   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749521
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n\n    let\
    \ mut digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n\n    while digits_len > 0 {\n\
    \        let mut digit = digits[digits_index];\n        let mut digit_len = digits_len;\n\
    \n        while digit_len > 0 {\n            if digit < 10 {\n               \
    \ result.push(String::from(\"One\"));\n                break;\n            }\n\
    \            if digit < 20 {\n                result.push(String::from(\"Two\"\
    ));\n                break;\n            }\n            if digit < 30 {\n    \
    \            result.push(String::from(\"Three\"));\n                break;\n \
    \           }\n            if digit < 40 {\n                result.push(String::from(\"\
    Four\"));\n                break;\n            }\n            if digit < 50 {\n\
    \                result.push(String::from(\"Five\"));\n                break;\n\
    \            }\n            if digit < 60 {\n                result.push(String::from(\"\
    Six\"));\n                break;\n            }\n            if digit < 70 {\n\
    \                result.push(String::from(\"Seven\"));\n                break;\n\
    \            }\n            if digit < 80 {\n                result.push(String::from(\"\
    Eight\"));\n                break;\n            }\n            if digit < 90 {\n\
    \                result.push(String::from(\"Nine\"));\n                break;\n\
    \            }\n            digit_len -= 1;\n        }\n        digits_index +=\
    \ 1;\n        digits_len -= 1;\n    }\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpfit7yfaz.rs:76:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < reversed.len() {\n        let digit = reversed[i];\n\
    \        if digit < 10 {\n            result.push(String::from(\"One\"));\n  \
    \      } else if digit < 100 {\n            result.push(String::from(\"Two\"));\n\
    \        } else if digit < 1000 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if digit < 10000 {\n            result.push(String::from(\"\
    Four\"));\n        } else if digit < 100000 {\n            result.push(String::from(\"\
    Five\"));\n        } else if digit < 1000000 {\n            result.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if digit < 100000000 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if digit < 1000000000 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpo5mscc6q.rs:51:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() && arr[j] <= 9 {\n            j += 1\n        }\n        result.push(String::from(&arr[i..j]));\n\
    \        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&[isize]>` is not satisfied\n\
    \   --> /tmp/tmp5e__hxbf.rs:24:21\n    |\n24  |         result.push(String::from(&arr[i..j]));\n\
    \    |                     ^^^^^^^^^^^^ the trait `From<&[isize]>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n\n    let\
    \ mut i = 0;\n    while i < arr.len() {\n        if arr[i] < 1 || arr[i] > 9 {\n\
    \            i += 1;\n            continue;\n        }\n\n        let mut j =\
    \ i;\n        while j < arr.len() {\n            if arr[j] < 1 || arr[j] > 9 {\n\
    \                j += 1;\n                continue;\n            }\n\n       \
    \     if arr[j] < i {\n                result.push(by_length(arr.iter().cloned().skip(j).take(i).collect()));\n\
    \                break;\n            }\n\n            if arr[j] > i {\n      \
    \          result.push(by_length(arr.iter().cloned().skip(j).take(i).collect()));\n\
    \                break;\n            }\n\n            j += 1;\n        }\n\n \
    \       i += 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxexrx89w.rs:34:25\n   |\n\
    34 |             if arr[j] < i {\n   |                         ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n34 |             if arr[j] < i.try_into().unwrap()\
    \ {\n   |                         ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxexrx89w.rs:39:25\n   |\n39 |             if arr[j] > i\
    \ {\n   |                         ^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n39 |             if arr[j] > i.try_into().unwrap() {\n   |      \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxexrx89w.rs:50:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n50 |     result\n   |     ^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<Vec<String>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_sub(1));\n    arr.iter().map(|x| {\n      \
    \  match x {\n            0 => \"Zero\".to_string(),\n            1 => \"One\"\
    .to_string(),\n            2 => \"Two\".to_string(),\n            3 => \"Three\"\
    .to_string(),\n            4 => \"Four\".to_string(),\n            5 => \"Five\"\
    .to_string(),\n            6 => \"Six\".to_string(),\n            7 => \"Seven\"\
    .to_string(),\n            8 => \"Eight\".to_string(),\n            9 => \"Nine\"\
    .to_string(),\n            _ => panic!(\"Invalid number in by_length: {}\", x),\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"Two\", \"Two\", \"Three\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp69mcjh4x.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n    arr.iter().map(|x|\
    \ {\n        match x {\n            0 => \"Zero\".to_string(),\n            1\
    \ => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n           \
    \ 3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n      \
    \      5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n   \
    \         7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => panic!(\"Invalid number\
    \ {:?}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"Two\", \"Two\", \"Three\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpb5rapuqh.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut i = 0;\n\n    while i < arr.len() {\n        let\
    \ digit = arr[i] - 1;\n        if digit < 10 {\n            digits.push(digit);\n\
    \        } else {\n            let mut j = i;\n            while j > 0 && digits[j\
    \ - 1] > digit {\n                j -= 1;\n            }\n            digits.push(digit\
    \ - 10 + digits[j]);\n        }\n        i += 1;\n    }\n\n    for i in 0..digits.len()\
    \ {\n        let mut j = i;\n        while j > 0 && digits[j - 1] > 9 {\n    \
    \        j -= 1;\n        }\n        result.push(String::from(&digits[j]));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \   --> /tmp/tmp54btc4_e.rs:41:21\n    |\n41  |         result.push(String::from(&digits[j]));\n\
    \    |                     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i;\n        while j <\
    \ arr.len() && arr[j] < 10 {\n            j += 1\n        }\n        let mut k\
    \ = i;\n        while k < j {\n            result.push(by_digit(arr[k]));\n  \
    \          k += 1\n        }\n        i = j;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpve2mud_8.rs:26:25\n\
    \   |\n26 |             result.push(by_digit(arr[k]));\n   |                 \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = arr.clone();\n    reversed.reverse();\n    let mut result\
    \ = vec![];\n    for num in &mut arr {\n        let digit = num % 10;\n      \
    \  let name = match digit {\n            1 => \"One\",\n            2 => \"Two\"\
    ,\n            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => unreachable!(),\n\
    \        };\n        result.push(name);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmpjszo0eo5.rs:22:25\n\
    \   |\n22 |         let digit = num % 10;\n   |                     --- ^ -- {integer}\n\
    \   |                     |\n   |                     &mut isize\n   |\nhelp:\
    \ `%` can be used on `isize`, you can dereference `num`\n   |\n22 |         let\
    \ digit = *num % 10;\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjszo0eo5.rs:37:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n37 |     result\n   |     ^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n   \
    \           found struct `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| {\n        if x < 1 || x > 9 {\n            0\n     \
    \   } else {\n            x - 1\n        }\n    });\n    arr.reverse();\n    arr.iter().map(|x|\
    \ {\n        match x {\n            x if x < 10 => \"Zero\".to_string(),\n   \
    \         x if x < 20 => \"One\".to_string(),\n            x if x < 30 => \"Two\"\
    .to_string(),\n            x if x < 40 => \"Three\".to_string(),\n           \
    \ x if x < 50 => \"Four\".to_string(),\n            x if x < 60 => \"Five\".to_string(),\n\
    \            x if x < 70 => \"Six\".to_string(),\n            x if x < 80 => \"\
    Seven\".to_string(),\n            x if x < 90 => \"Eight\".to_string(),\n    \
    \        x if x < 100 => \"Nine\".to_string(),\n            _ => panic!(\"Invalid\
    \ number {:?}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp51thzrwa.rs:19:16\n   |\n\
    19 |         if x < 1 || x > 9 {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp51thzrwa.rs:19:25\n\
    \   |\n19 |         if x < 1 || x > 9 {\n   |                         ^\n   |\
    \                         |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp51thzrwa.rs:28:22\n   |\n28 |  \
    \           x if x < 10 => \"Zero\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&10`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp51thzrwa.rs:29:22\n   |\n29 |  \
    \           x if x < 20 => \"One\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&20`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp51thzrwa.rs:30:22\n   |\n30 |  \
    \           x if x < 30 => \"Two\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&30`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp51thzrwa.rs:31:22\n   |\n31 |  \
    \           x if x < 40 => \"Three\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&40`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp51thzrwa.rs:32:22\n   |\n32 |  \
    \           x if x < 50 => \"Four\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&50`\n\n\
    err"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().map(|x|\
    \ x as isize).collect();\n    arr.sort_unstable();\n    let mut result = vec![];\n\
    \    for i in arr {\n        let mut s = String::from(\"One\");\n        if i\
    \ <= 9 {\n            s = String::from(\"One\");\n        } else if i <= 99 {\n\
    \            s = String::from(\"Two\");\n        } else if i <= 999 {\n      \
    \      s = String::from(\"Three\");\n        } else if i <= 9999 {\n         \
    \   s = String::from(\"Four\");\n        } else if i <= 99999 {\n            s\
    \ = String::from(\"Five\");\n        } else if i <= 999999 {\n            s =\
    \ String::from(\"Six\");\n        } else if i <= 9999999 {\n            s = String::from(\"\
    Seven\");\n        } else if i <= 999999999 {\n            s = String::from(\"\
    Eight\");\n        } else if i <= 99999999999 {\n            s = String::from(\"\
    Nine\");\n        }\n        result.push(s);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpc5vdr4ja.rs:18:5\n\
    \   |\n17 |     let mut arr = arr.into_iter().map(|x| x as isize).collect();\n\
    \   |         ------- consider giving `arr` a type\n18 |     arr.sort_unstable();\n\
    \   |     ^^^ cannot infer type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr.sort_by_key(|x| x.checked_div(10).unwrap());\n    arr.reverse();\n  \
    \  arr.iter_mut().for_each(|x| {\n        match x {\n            0 => x.to_string(),\n\
    \            x => x.to_string().replace(x.to_string().chars().nth(1).unwrap(),\
    \ '0'),\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5rz8yw9k.rs:24:79\n   |\n\
    24 |             x => x.to_string().replace(x.to_string().chars().nth(1).unwrap(),\
    \ '0'),\n   |                                                                \
    \               ^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5rz8yw9k.rs:22:9\n   |\n22 | /         match x {\n23 |\
    \ |             0 => x.to_string(),\n24 | |             x => x.to_string().replace(x.to_string().chars().nth(1).unwrap(),\
    \ '0'),\n25 | |         }\n   | |         ^- help: consider using a semicolon\
    \ here: `;`\n   | |_________|\n   |           expected `()`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5rz8yw9k.rs:27:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n27 |\
    \     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < reversed.len() {\n        if reversed[i] <\
    \ 10 {\n            result.push(String::from(\"One\"));\n        } else if reversed[i]\
    \ < 20 {\n            result.push(String::from(\"Two\"));\n        } else if reversed[i]\
    \ < 30 {\n            result.push(String::from(\"Three\"));\n        } else if\
    \ reversed[i] < 40 {\n            result.push(String::from(\"Four\"));\n     \
    \   } else if reversed[i] < 50 {\n            result.push(String::from(\"Five\"\
    ));\n        } else if reversed[i] < 60 {\n            result.push(String::from(\"\
    Six\"));\n        } else if reversed[i] < 70 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if reversed[i] < 80 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if reversed[i] < 90 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpjxu2bwa3.rs:50:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749524
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = vec![];\n    let mut digits_len = arr.len();\n    let mut i = 0;\n\
    \    while i < digits_len {\n        let digit = arr[i];\n        if digit < 10\
    \ {\n            digits.push(digit);\n        } else {\n            let digit\
    \ = digit - 10;\n            if digit < 0 {\n                digits.push(-digit);\n\
    \            } else {\n                digits.push(digit);\n            }\n  \
    \      }\n        i += 1;\n    }\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        let digit = digits[i];\n        let digit = digit as usize;\n   \
    \     if digit < 10 {\n            result.push(String::from(\"One\"));\n     \
    \   } else if digit < 20 {\n            result.push(String::from(\"Two\"));\n\
    \        } else if digit < 30 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if digit < 40 {\n            result.push(String::from(\"Four\"\
    ));\n        } else if digit < 50 {\n            result.push(String::from(\"Five\"\
    ));\n        } else if digit < 60 {\n            result.push(String::from(\"Six\"\
    ));\n        } else if digit < 70 {\n            result.push(String::from(\"Seven\"\
    ));\n        } else if digit < 80 {\n            result.push(String::from(\"Eight\"\
    ));\n        } else if digit < 90 {\n            result.push(String::from(\"Nine\"\
    ));\n        } else {\n            result.push(String::from(\"Ten\"));\n     \
    \   }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmp7u5aboui.rs:67:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749524
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.to_owned();\n\
    \    arr.sort_unstable();\n    arr.iter().rev().for_each(|x| {\n        match\
    \ x {\n            1 => arr.push(String::from(\"One\")),\n            2 => arr.push(String::from(\"\
    Two\")),\n            3 => arr.push(String::from(\"Three\")),\n            4 =>\
    \ arr.push(String::from(\"Four\")),\n            5 => arr.push(String::from(\"\
    Five\")),\n            6 => arr.push(String::from(\"Six\")),\n            7 =>\
    \ arr.push(String::from(\"Seven\")),\n            8 => arr.push(String::from(\"\
    Eight\")),\n            9 => arr.push(String::from(\"Nine\")),\n            _\
    \ => (),\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc6okuypi.rs:18:27\n   |\n\
    18 |             1 => arr.push(String::from(\"One\")),\n   |                 \
    \          ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc6okuypi.rs:19:27\n   |\n19 |             2\
    \ => arr.push(String::from(\"Two\")),\n   |                           ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc6okuypi.rs:20:27\n   |\n20 |             3 => arr.push(String::from(\"\
    Three\")),\n   |                           ^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc6okuypi.rs:21:27\n\
    \   |\n21 |             4 => arr.push(String::from(\"Four\")),\n   |         \
    \                  ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc6okuypi.rs:22:27\n   |\n22 |\
    \             5 => arr.push(String::from(\"Five\")),\n   |                   \
    \        ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc6okuypi.rs:23:27\n   |\n23 |             6\
    \ => arr.push(String::from(\"Six\")),\n   |                           ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc6okuypi.rs:24:27\n   |\n24 |             7 => arr.push(String::from(\"\
    Seven\")),\n   |                           ^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc6okuypi.rs:25:27\n\
    \   |\n25 |             8 => arr.push(String::from(\"Eight\")),\n   |        \
    \                   ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc6okuypi.rs:26:27\n   |\n26 |\
    \             9 => arr.push(String::from(\"Nine\")),\n   |                   \
    \        ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc6okuypi.rs:30:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<Stri"
  stdout: ''
  timestamp: 1659749524
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut len = arr.len();\n    let mut i = 0;\n    let mut cur = String::from(\"\
    One\");\n    let mut last = String::from(\"One\");\n    while i < len {\n    \
    \    if arr[i] < 10 {\n            arr[i] = String::from(\"One\");\n        }\
    \ else {\n            arr[i] = String::from(&arr[i / 10]);\n            i %= 10;\n\
    \        }\n        i += 1;\n    }\n    arr.sort_unstable();\n    arr.iter().for_each(|x|\
    \ {\n        if x < 10 {\n            cur.push_str(&format!(\"{}\", x));\n   \
    \     } else {\n            cur.push_str(&format!(\"{}\", &arr[x / 10]));\n  \
    \      }\n    });\n    last = cur;\n    vec![last]\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmp1vx9c32v.rs:18:35\n   |\n18 |     let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                   ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp1vx9c32v.rs:18:44\n \
    \  |\n18 |       let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.to_owned();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n\
    \n        let mut j = i;\n        while j > 0 && arr[j - 1] > arr[j] {\n     \
    \       j -= 1;\n        }\n\n        swap(&mut arr[j], &mut arr[i]);\n      \
    \  i += 1;\n    }\n\n    let mut result = vec![];\n    for i in arr {\n      \
    \  result.push(String::from(&names[i]))\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmppxdbkmeq.rs:32:9\n\
    \   |\n32 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find value `names` in this scope\n  --> /tmp/tmppxdbkmeq.rs:38:35\n   |\n38\
    \ |         result.push(String::from(&names[i]))\n   |                       \
    \            ^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.to_owned();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            i += 1;\n        } else {\n            arr[i]\
    \ = String::from(&name[arr[i] - 1]);\n            i += 1;\n        }\n    }\n\
    \    arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmpnhptw9o0.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&name[arr[i] - 1]);\n   |      \
    \                              ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnhptw9o0.rs:25:22\n   |\n25 |             arr[i] = String::from(&name[arr[i]\
    \ - 1]);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnhptw9o0.rs:29:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n29 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749522
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.to_owned();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n\
    \        let mut j = i;\n        while j < len {\n            if arr[j] < 1 ||\
    \ arr[j] > 9 {\n                break;\n            }\n            i += 1;\n \
    \       }\n        swap(&mut arr[i], &mut arr[j]);\n    }\n    let mut result\
    \ = vec![];\n    for i in 0..len {\n        result.push(String::from(&arr[i]));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp747bysga.rs:32:9\n\
    \   |\n32 |         swap(&mut arr[i], &mut arr[j]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]: the\
    \ trait bound `String: From<&isize>` is not satisfied\n   --> /tmp/tmp747bysga.rs:36:21\n\
    \    |\n36  |         result.push(String::from(&arr[i]));\n    |             \
    \        ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \    |\n    = help: the following implementations were found:\n              <String\
    \ as From<&String>>\n              <String as From<&mut str>>\n              <String\
    \ as From<&str>>\n              <String as From<Box<str>>>\n            and 2\
    \ others\nnote: required by `from`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749523
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = digits.iter().cloned().rev();\n\
    \    let mut i = 0;\n    while i < digits.len() {\n        let digit = reversed.next().unwrap();\n\
    \        if digit < 10 {\n            result.push(String::from(\"One\"));\n  \
    \      } else if digit < 100 {\n            result.push(String::from(\"Two\"));\n\
    \        } else if digit < 1000 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if digit < 10000 {\n            result.push(String::from(\"\
    Four\"));\n        } else if digit < 100000 {\n            result.push(String::from(\"\
    Five\"));\n        } else if digit < 1000000 {\n            result.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if digit < 100000000 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if digit < 1000000000 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpm83pmvj9.rs:51:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749524
