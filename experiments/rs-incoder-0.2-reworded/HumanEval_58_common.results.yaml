name: HumanEval_58_common
language: rs
results:
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.extend(l2.into_iter().cloned());\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwe0vfi9l.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwe0vfi9l.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpwe0vfi9l.rs:18:30\n     |\n18   |\
    \     l1.extend(l2.into_iter().cloned());\n     |                            \
    \  ^^^^^^ expected reference, found `isize`\n     |\n     = note: expected reference\
    \ `&_`\n                     found type `isize`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmpwe0vfi9l.rs:18:15\n    |\n18  |  \
    \   l1.extend(l2.into_iter().cloned());\n    |        ------ ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |        |\n    |        required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&_`\n\
    \                    found type `isize`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\nnote: required\
    \ by a bound in `extend`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmpwe0vfi9l.rs:18:15\n    |\n18  |  \
    \   l1.extend(l2.into_iter().cloned());\n    |        ------ ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |        |\n    |        required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&_`\n\
    \                    found type `isize`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `Cloned<std::vec::IntoIter<isize>>`\n\
    note: required by a bound in `extend`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations:"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        let mut i = 0;\n        let\
    \ mut j = 0;\n        while l1.len() > 0 && l2.len() > 0 {\n            if l1[0]\
    \ > l2[0] {\n                i += 1;\n                l1.remove(0);\n        \
    \    } else {\n                j += 1;\n                l2.remove(0);\n      \
    \      }\n        }\n        if l1.len() > 0 {\n            i += 1;\n        \
    \    l1.remove(0);\n        }\n        if l2.len() > 0 {\n            j += 1;\n\
    \            l2.remove(0);\n        }\n        if i == j {\n            result.push(l1[0]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpz_230z5i.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(*l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(*l1.pop());\n        } else {\n            if l1.len()\
    \ == l2.len() {\n                if l1[l1.len() - 1] == l2[l2.len() - 1] {\n \
    \                   l1.pop();\n                    l2.pop();\n               \
    \ } else {\n                    result.push(*l1.pop());\n                    result.push(*l2.pop());\n\
    \                }\n            } else {\n                if l1[l1.len() - 1]\
    \ < l2[l2.len() - 1] {\n                    l1.pop();\n                } else\
    \ {\n                    l2.pop();\n                }\n            }\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp6kqrm6s4.rs:12:25\n\
    \   |\n12 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmp6kqrm6s4.rs:14:25\n   |\n14 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp6kqrm6s4.rs:21:33\n   |\n21 |        \
    \             result.push(*l1.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp6kqrm6s4.rs:22:33\n\
    \   |\n22 |                     result.push(*l2.pop());\n   |                \
    \                 ^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = vec![];\n    while l1.len() != 0 ||\
    \ l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.to_vec();\n            let mut l2 =\
    \ l2.to_vec();\n            let mut i = 0;\n            let mut j = 0;\n     \
    \       while i < l1.len() && j < l2.len() {\n                if l1[i] < l2[j]\
    \ {\n                    i += 1;\n                } else if l1[i] > l2[j] {\n\
    \                    j += 1;\n                } else {\n                    result.push(l1[i]);\n\
    \                    i += 1;\n                    j += 1;\n                }\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplhxlyyjm.rs:26:33\n   |\n\
    26 |                     result.push(l1[i]);\n   |                           \
    \      ^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found type `isize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n26 |                     result.push(Some(l1[i]));\n\
    \   |                                 +++++     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplhxlyyjm.rs:33:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n33 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut i = 0;\n    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any()\
    \ && l2_iter.any() {\n            if l1_iter.peek() == l2_iter.peek() {\n    \
    \            result.push(*l1_iter.next());\n                i += 1;\n        \
    \    } else {\n                i += 1;\n            }\n        } else if l1_iter.any()\
    \ {\n            result.push(*l1_iter.next());\n            i += 1;\n        }\
    \ else if l2_iter.any() {\n            result.push(*l2_iter.next());\n       \
    \     i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpiacveo5l.rs:11:19\n     |\n11   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpiacveo5l.rs:11:36\n\
    \     |\n11   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpiacveo5l.rs:12:20\n\
    \     |\n12   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpiacveo5l.rs:12:37\n     |\n12   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpiacveo5l.rs:13:24\n   |\n13 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `peek` found for struct `Cloned` in the current scope\n  --> /tmp/tmpiacveo5l.rs:13:42\n\
    \   |\n13 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0614]: type `Option<isize>` canno"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == 1 {\n            if l2.len() == 1 {\n         \
    \       l3.pop();\n                l4.pop();\n            } else {\n         \
    \       l3.pop();\n                l4.pop();\n            }\n        } else if\
    \ l2.len() == 1 {\n            l3.pop();\n            l4.pop();\n        } else\
    \ {\n            let mut l5 = l1.clone();\n            let mut l6 = l2.clone();\n\
    \            while l5.len() != 0 || l6.len() != 0 {\n                if l5.len()\
    \ == 0 {\n                    l6.pop();\n                    l5.pop();\n     \
    \           } else if l6.len() == 0 {\n                    l5.pop();\n       \
    \             l6.pop();\n                } else if l5.len() == 1 {\n         \
    \           if l6.len() == 1 {\n                        l6.pop();\n          \
    \              l5.pop();\n                    } else {\n                     \
    \   l6.pop();\n                        l5.pop();\n                    }\n    \
    \            } else {\n                    let mut l7 = l5.clone();\n        \
    \            let mut l8 = l6.clone();\n                    while l7.len() != 0\
    \ || l8.len() != 0 {\n                        if l7.len() == 0 {\n           \
    \                 l8.pop();\n                            l7.pop();\n         \
    \               } else if l8.len() == 0 {\n                            l7.pop();\n\
    \                            l8.pop();\n                        } else if l7.len()\
    \ == 1 {\n                            if l8.len() == 1 {\n                   \
    \             l8.pop();\n                                l7.pop();\n         \
    \                   } else {\n                                l8.pop();\n    \
    \                            l7.pop();\n                            }\n      \
    \                  } else {\n                            let mut l9 = l7.clone();\n\
    \                            let mut l10 = l8.clone();\n                     \
    \       while l9.len() != 0 || l10.len() != 0 {\n                            \
    \    if l9.len() == 0 {\n                                    l10.pop();\n    \
    \                                l9.pop();\n                                }\
    \ else if l10.len() == 0 {\n                                    l9.pop();\n  \
    \                                  l10.pop();\n                              \
    \  } else if l9.len() == 1 {\n                                    if l10.len()\
    \ == 1 {\n                                        l10.pop();\n               \
    \                         l9.pop();\n                                    } else\
    \ {\n                                        l\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxd6t5mvc.rs:89:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n29 |         } else {\n   |\
    \                - unclosed delimiter\n...\n32 |             while l5.len() !=\
    \ 0 || l6.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n47 |                 } else {\n   |             \
    \           - unclosed delimiter\n...\n50 |                     while l7.len()\
    \ != 0 || l8.len() != 0 {\n   |                                              \
    \            - unclosed delimiter\n...\n65 |                         } else {\n\
    \   |                                - unclosed delimiter\n...\n68 |         \
    \                    while l9.len() != 0 || l10.len() != 0 {\n   |           \
    \                                                        - unclosed delimiter\n\
    ...\n75 |                                 } else if l9.len() == 1 {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    79 |                                     } else {\n   |                      \
    \                      - this delimiter might not be properly closed...\n80 |\
    \                                         l\n81 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n89 | }\n   |   ^\n\nerror[E0425]: cannot\
    \ find value `l` in this scope\n  --> /tmp/tmpxd6t5mvc.rs:80:41\n   |\n80 | ...\
    \                   l\n   |                       ^ help: a local variable with\
    \ a similar name exists: `l1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxd6t5mvc.rs:11:5\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n11 | /     while l1.len() != 0 || l2.len() != 0\
    \ {\n12 | |         if l1.len() == 0 {\n13 | |             l3.pop();\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = Vec::new();\n    while l1.len() != 0\
    \ || l2.len() != 0 {\n        if l1.len() == 0 {\n            l1.push(0);\n  \
    \          result.push(0);\n            l2.push(0);\n            result.push(0);\n\
    \        } else if l2.len() == 0 {\n            l2.push(0);\n            result.push(0);\n\
    \            l1.push(0);\n            result.push(0);\n        } else {\n    \
    \        let mut l1_element = l1.pop();\n            let mut l2_element = l2.pop();\n\
    \            if l1_element == l2_element {\n                result.push(l1_element);\n\
    \            } else {\n                result.push(l1_element);\n            \
    \    result.push(l2_element);\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv6qh0xvj.rs:25:29\n   |\n\
    25 |                 result.push(l1_element);\n   |                          \
    \   ^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected\
    \ type `{integer}`\n              found enum `Option<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv6qh0xvj.rs:27:29\n   |\n27 |              \
    \   result.push(l1_element);\n   |                             ^^^^^^^^^^ expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpv6qh0xvj.rs:28:29\n   |\n28 |                 result.push(l2_element);\n\
    \   |                             ^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n\
    \    while l3.len() != 0 || l4.len() != 0 {\n        if l3.len() == 0 {\n    \
    \        l3.push(0);\n            l4.push(0);\n        }\n        if l4.len()\
    \ == 0 {\n            l4.push(0);\n            l3.push(0);\n        }\n      \
    \  let mut l3_iter = l3.iter();\n        let mut l4_iter = l4.iter();\n      \
    \  if l3_iter.next().unwrap() != l4_iter.next().unwrap() {\n            l3.push(0);\n\
    \            l4.push(0);\n        }\n        if l3_iter.next().unwrap() == l4_iter.next().unwrap()\
    \ {\n            l3.push(l3_iter.next().unwrap());\n            l4.push(l4_iter.next().unwrap());\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzyvlce4a.rs:27:21\n   |\n\
    27 |             l3.push(l3_iter.next().unwrap());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n27 |             l3.push(*l3_iter.next().unwrap());\n   |             \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzyvlce4a.rs:28:21\n\
    \   |\n28 |             l4.push(l4_iter.next().unwrap());\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n28 |             l4.push(*l4_iter.next().unwrap());\n\
    \   |                     +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.push(l2[0]);\n            l2.pop();\n\
    \        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n            l1.pop();\n\
    \        } else {\n            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n\
    \                l1.pop();\n            } else {\n                l3.push(l2[0]);\n\
    \                l2.pop();\n            }\n        }\n    }\n    l3.extend(l1.clone());\n\
    \    l3.extend(l2.clone());\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5]`,\n right:\
    \ `[1, 5, 653]`', /tmp/tmpp3q99frt.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = vec![];\n    while l1.len() != 0 ||\
    \ l2.len() != 0 {\n        if l1.len() == 0 {\n            l2.pop();\n       \
    \ } else if l2.len() == 0 {\n            l1.pop();\n        } else {\n       \
    \     let mut l1 = l1.to_vec();\n            let mut l2 = l2.to_vec();\n     \
    \       if l1.len() == l2.len() {\n                while l1.len() != 0 {\n   \
    \                 result.push(l1.pop());\n                }\n                while\
    \ l2.len() != 0 {\n                    result.push(l2.pop());\n              \
    \  }\n            } else {\n                while l1.len() != l2.len() {\n   \
    \                 l1.pop();\n                    l2.pop();\n                }\n\
    \                while l1.len() != 0 {\n                    result.push(l1.pop());\n\
    \                }\n                while l2.len() != 0 {\n                  \
    \  result.push(l2.pop());\n                }\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9lcae7r.rs:39:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n39 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    while l3.len() > 0 && l4.len()\
    \ > 0 {\n        if l3[0] != l4[0] {\n            break;\n        }\n        l3.remove(0);\n\
    \        l4.remove(0);\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmp7wvsifp6.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        let mut i =\
    \ 0;\n        while l1.len() > 0 && l2.len() > 0 {\n            if l1[0] < l2[0]\
    \ {\n                result.push(*l1.pop());\n            } else {\n         \
    \       result.push(*l2.pop());\n            }\n            i += 1;\n        }\n\
    \        if l1.len() > 0 {\n            result.push(*l1.pop());\n        }\n \
    \       if l2.len() > 0 {\n            result.push(*l2.pop());\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp355u3bn9.rs:14:29\n\
    \   |\n14 |                 result.push(*l1.pop());\n   |                    \
    \         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmp355u3bn9.rs:16:29\n   |\n16 |                 result.push(*l2.pop());\n\
    \   |                             ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp355u3bn9.rs:21:25\n   |\n21 |        \
    \     result.push(*l1.pop());\n   |                         ^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp355u3bn9.rs:24:25\n\
    \   |\n24 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.into_iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmi830vvp.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmi830vvp.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpmi830vvp.rs:18:20\n     |\n18   |\
    \     l1.into_iter().cloned().collect::<Vec<_>>()\n     |                    ^^^^^^\
    \ expected reference, found `isize`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `isize`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpmi830vvp.rs:18:29\n \
    \  |\n18 |       l1.into_iter().cloned().collect::<Vec<_>>()\n   |           \
    \                    ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_next = l1.iter().cloned().next();\n    let mut l2_next = l2.iter().cloned().next();\n\
    \    while l1_next != l2_next {\n        if *l1_iter == *l2_iter {\n         \
    \   result.push(*l1_iter);\n            l1_iter.next();\n            l2_iter.next();\n\
    \        } else if *l1_iter < *l2_iter {\n            result.push(*l1_iter);\n\
    \            l1_iter.next();\n        } else {\n            result.push(*l2_iter);\n\
    \            l2_iter.next();\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmply34tie1.rs:13:12\n   |\n13 |         if *l1_iter == *l2_iter {\n\
    \   |            ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>`\
    \ cannot be dereferenced\n  --> /tmp/tmply34tie1.rs:13:24\n   |\n13 |        \
    \ if *l1_iter == *l2_iter {\n   |                        ^^^^^^^^\n\nerror[E0614]:\
    \ type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n  --> /tmp/tmply34tie1.rs:14:25\n\
    \   |\n14 |             result.push(*l1_iter);\n   |                         ^^^^^^^^\n\
    \nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmply34tie1.rs:17:19\n   |\n17 |         } else if *l1_iter < *l2_iter\
    \ {\n   |                   ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmply34tie1.rs:17:30\n   |\n17 |\
    \         } else if *l1_iter < *l2_iter {\n   |                              ^^^^^^^^\n\
    \nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmply34tie1.rs:18:25\n   |\n18 |             result.push(*l1_iter);\n\
    \   |                         ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmply34tie1.rs:21:25\n   |\n21 |\
    \             result.push(*l2_iter);\n   |                         ^^^^^^^^\n\n\
    error: aborting due to 7 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n\
    \                if l1.front() == l2.front() {\n                    l1.pop();\n\
    \                    l2.pop();\n                } else {\n                   \
    \ i += 1;\n                }\n            }\n            if l1.len() == 0 {\n\
    \                result.push(l2.pop());\n            } else if l2.len() == 0 {\n\
    \                result.push(l1.pop());\n            } else {\n              \
    \  result.push(l1.pop());\n                result.push(l2.pop());\n          \
    \  }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpjz3xam0q.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpjz3xam0q.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjz3xam0q.rs:37:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n37 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1.front() == l2.front() {\n                    l1.pop();\n      \
    \              l2.pop();\n                } else {\n                    i += 1;\n\
    \                }\n            }\n            if l1.len() == 0 {\n          \
    \      result.push(l2.pop());\n            } else if l2.len() == 0 {\n       \
    \         result.push(l1.pop());\n            } else {\n                result.push(l1.pop());\n\
    \                result.push(l2.pop());\n            }\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp8cwz_6k4.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp8cwz_6k4.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8cwz_6k4.rs:37:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n37 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        if l1.len() == 0\
    \ {\n            break;\n        }\n        if l2.len() == 0 {\n            break;\n\
    \        }\n        if l1[0] < l2[0] {\n            result.remove(0);\n      \
    \      l1.remove(0);\n        } else {\n            result.remove(0);\n      \
    \      l2.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpir0v56lz.rs:18:13\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n18 |             l1.remove(0);\n   |             ^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n           \
    \     l1.pop();\n            } else {\n                l3.push(l2[0]);\n     \
    \           l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpjetwnru2.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l3_el\
    \ = l1_el;\n                l1_el = l1.pop();\n                l2_el = l2.pop();\n\
    \            }\n            l3.push(l3_el);\n        }\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `l3_el` in this scope\n  --> /tmp/tmpboa1gluf.rs:19:17\n\
    \   |\n19 |                 l3_el = l1_el;\n   |                 ^^^^^ help: a\
    \ local variable with a similar name exists: `l1_el`\n\nerror[E0425]: cannot find\
    \ value `l3_el` in this scope\n  --> /tmp/tmpboa1gluf.rs:23:21\n   |\n23 |   \
    \          l3.push(l3_el);\n   |                     ^^^^^ help: a local variable\
    \ with a similar name exists: `l1_el`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpboa1gluf.rs:26:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n26 |     l3\n   |     ^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            if l3[0]\
    \ == l2[0] {\n                l3.remove(0);\n                l4.remove(0);\n \
    \           } else {\n                l3.remove(0);\n                l4.push(l3.pop());\n\
    \            }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzg4dykmq.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzg4dykmq.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzg4dykmq.rs:22:25\n   |\n22 |  \
    \               l4.push(l3.pop());\n   |                         ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
