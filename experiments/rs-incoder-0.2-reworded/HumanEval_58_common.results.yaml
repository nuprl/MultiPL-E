language: rs
name: HumanEval_58_common
results:
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.extend(l2.into_iter().cloned());\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwe0vfi9l.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwe0vfi9l.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpwe0vfi9l.rs:18:30\n     |\n18   |\
    \     l1.extend(l2.into_iter().cloned());\n     |                            \
    \  ^^^^^^ expected reference, found `isize`\n     |\n     = note: expected reference\
    \ `&_`\n                     found type `isize`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmpwe0vfi9l.rs:18:15\n    |\n18  |  \
    \   l1.extend(l2.into_iter().cloned());\n    |        ------ ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |        |\n    |        required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&_`\n\
    \                    found type `isize`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\nnote: required\
    \ by a bound in `extend`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmpwe0vfi9l.rs:18:15\n    |\n18  |  \
    \   l1.extend(l2.into_iter().cloned());\n    |        ------ ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |        |\n    |        required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&_`\n\
    \                    found type `isize`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `Cloned<std::vec::IntoIter<isize>>`\n\
    note: required by a bound in `extend`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations:"
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        let mut i = 0;\n        let\
    \ mut j = 0;\n        while l1.len() > 0 && l2.len() > 0 {\n            if l1[0]\
    \ > l2[0] {\n                i += 1;\n                l1.remove(0);\n        \
    \    } else {\n                j += 1;\n                l2.remove(0);\n      \
    \      }\n        }\n        if l1.len() > 0 {\n            i += 1;\n        \
    \    l1.remove(0);\n        }\n        if l2.len() > 0 {\n            j += 1;\n\
    \            l2.remove(0);\n        }\n        if i == j {\n            result.push(l1[0]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpz_230z5i.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(*l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(*l1.pop());\n        } else {\n            if l1.len()\
    \ == l2.len() {\n                if l1[l1.len() - 1] == l2[l2.len() - 1] {\n \
    \                   l1.pop();\n                    l2.pop();\n               \
    \ } else {\n                    result.push(*l1.pop());\n                    result.push(*l2.pop());\n\
    \                }\n            } else {\n                if l1[l1.len() - 1]\
    \ < l2[l2.len() - 1] {\n                    l1.pop();\n                } else\
    \ {\n                    l2.pop();\n                }\n            }\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp6kqrm6s4.rs:12:25\n\
    \   |\n12 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmp6kqrm6s4.rs:14:25\n   |\n14 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp6kqrm6s4.rs:21:33\n   |\n21 |        \
    \             result.push(*l1.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp6kqrm6s4.rs:22:33\n\
    \   |\n22 |                     result.push(*l2.pop());\n   |                \
    \                 ^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = vec![];\n    while l1.len() != 0 ||\
    \ l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.to_vec();\n            let mut l2 =\
    \ l2.to_vec();\n            let mut i = 0;\n            let mut j = 0;\n     \
    \       while i < l1.len() && j < l2.len() {\n                if l1[i] < l2[j]\
    \ {\n                    i += 1;\n                } else if l1[i] > l2[j] {\n\
    \                    j += 1;\n                } else {\n                    result.push(l1[i]);\n\
    \                    i += 1;\n                    j += 1;\n                }\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplhxlyyjm.rs:26:33\n   |\n\
    26 |                     result.push(l1[i]);\n   |                           \
    \      ^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found type `isize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n26 |                     result.push(Some(l1[i]));\n\
    \   |                                 +++++     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplhxlyyjm.rs:33:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n33 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut i = 0;\n    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any()\
    \ && l2_iter.any() {\n            if l1_iter.peek() == l2_iter.peek() {\n    \
    \            result.push(*l1_iter.next());\n                i += 1;\n        \
    \    } else {\n                i += 1;\n            }\n        } else if l1_iter.any()\
    \ {\n            result.push(*l1_iter.next());\n            i += 1;\n        }\
    \ else if l2_iter.any() {\n            result.push(*l2_iter.next());\n       \
    \     i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpiacveo5l.rs:11:19\n     |\n11   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpiacveo5l.rs:11:36\n\
    \     |\n11   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpiacveo5l.rs:12:20\n\
    \     |\n12   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpiacveo5l.rs:12:37\n     |\n12   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpiacveo5l.rs:13:24\n   |\n13 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `peek` found for struct `Cloned` in the current scope\n  --> /tmp/tmpiacveo5l.rs:13:42\n\
    \   |\n13 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0614]: type `Option<isize>` canno"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == 1 {\n            if l2.len() == 1 {\n         \
    \       l3.pop();\n                l4.pop();\n            } else {\n         \
    \       l3.pop();\n                l4.pop();\n            }\n        } else if\
    \ l2.len() == 1 {\n            l3.pop();\n            l4.pop();\n        } else\
    \ {\n            let mut l5 = l1.clone();\n            let mut l6 = l2.clone();\n\
    \            while l5.len() != 0 || l6.len() != 0 {\n                if l5.len()\
    \ == 0 {\n                    l6.pop();\n                    l5.pop();\n     \
    \           } else if l6.len() == 0 {\n                    l5.pop();\n       \
    \             l6.pop();\n                } else if l5.len() == 1 {\n         \
    \           if l6.len() == 1 {\n                        l6.pop();\n          \
    \              l5.pop();\n                    } else {\n                     \
    \   l6.pop();\n                        l5.pop();\n                    }\n    \
    \            } else {\n                    let mut l7 = l5.clone();\n        \
    \            let mut l8 = l6.clone();\n                    while l7.len() != 0\
    \ || l8.len() != 0 {\n                        if l7.len() == 0 {\n           \
    \                 l8.pop();\n                            l7.pop();\n         \
    \               } else if l8.len() == 0 {\n                            l7.pop();\n\
    \                            l8.pop();\n                        } else if l7.len()\
    \ == 1 {\n                            if l8.len() == 1 {\n                   \
    \             l8.pop();\n                                l7.pop();\n         \
    \                   } else {\n                                l8.pop();\n    \
    \                            l7.pop();\n                            }\n      \
    \                  } else {\n                            let mut l9 = l7.clone();\n\
    \                            let mut l10 = l8.clone();\n                     \
    \       while l9.len() != 0 || l10.len() != 0 {\n                            \
    \    if l9.len() == 0 {\n                                    l10.pop();\n    \
    \                                l9.pop();\n                                }\
    \ else if l10.len() == 0 {\n                                    l9.pop();\n  \
    \                                  l10.pop();\n                              \
    \  } else if l9.len() == 1 {\n                                    if l10.len()\
    \ == 1 {\n                                        l10.pop();\n               \
    \                         l9.pop();\n                                    } else\
    \ {\n                                        l\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxd6t5mvc.rs:89:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n29 |         } else {\n   |\
    \                - unclosed delimiter\n...\n32 |             while l5.len() !=\
    \ 0 || l6.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n47 |                 } else {\n   |             \
    \           - unclosed delimiter\n...\n50 |                     while l7.len()\
    \ != 0 || l8.len() != 0 {\n   |                                              \
    \            - unclosed delimiter\n...\n65 |                         } else {\n\
    \   |                                - unclosed delimiter\n...\n68 |         \
    \                    while l9.len() != 0 || l10.len() != 0 {\n   |           \
    \                                                        - unclosed delimiter\n\
    ...\n75 |                                 } else if l9.len() == 1 {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    79 |                                     } else {\n   |                      \
    \                      - this delimiter might not be properly closed...\n80 |\
    \                                         l\n81 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n89 | }\n   |   ^\n\nerror[E0425]: cannot\
    \ find value `l` in this scope\n  --> /tmp/tmpxd6t5mvc.rs:80:41\n   |\n80 | ...\
    \                   l\n   |                       ^ help: a local variable with\
    \ a similar name exists: `l1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxd6t5mvc.rs:11:5\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n11 | /     while l1.len() != 0 || l2.len() != 0\
    \ {\n12 | |         if l1.len() == 0 {\n13 | |             l3.pop();\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = Vec::new();\n    while l1.len() != 0\
    \ || l2.len() != 0 {\n        if l1.len() == 0 {\n            l1.push(0);\n  \
    \          result.push(0);\n            l2.push(0);\n            result.push(0);\n\
    \        } else if l2.len() == 0 {\n            l2.push(0);\n            result.push(0);\n\
    \            l1.push(0);\n            result.push(0);\n        } else {\n    \
    \        let mut l1_element = l1.pop();\n            let mut l2_element = l2.pop();\n\
    \            if l1_element == l2_element {\n                result.push(l1_element);\n\
    \            } else {\n                result.push(l1_element);\n            \
    \    result.push(l2_element);\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv6qh0xvj.rs:25:29\n   |\n\
    25 |                 result.push(l1_element);\n   |                          \
    \   ^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected\
    \ type `{integer}`\n              found enum `Option<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv6qh0xvj.rs:27:29\n   |\n27 |              \
    \   result.push(l1_element);\n   |                             ^^^^^^^^^^ expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpv6qh0xvj.rs:28:29\n   |\n28 |                 result.push(l2_element);\n\
    \   |                             ^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n\
    \    while l3.len() != 0 || l4.len() != 0 {\n        if l3.len() == 0 {\n    \
    \        l3.push(0);\n            l4.push(0);\n        }\n        if l4.len()\
    \ == 0 {\n            l4.push(0);\n            l3.push(0);\n        }\n      \
    \  let mut l3_iter = l3.iter();\n        let mut l4_iter = l4.iter();\n      \
    \  if l3_iter.next().unwrap() != l4_iter.next().unwrap() {\n            l3.push(0);\n\
    \            l4.push(0);\n        }\n        if l3_iter.next().unwrap() == l4_iter.next().unwrap()\
    \ {\n            l3.push(l3_iter.next().unwrap());\n            l4.push(l4_iter.next().unwrap());\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzyvlce4a.rs:27:21\n   |\n\
    27 |             l3.push(l3_iter.next().unwrap());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n27 |             l3.push(*l3_iter.next().unwrap());\n   |             \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzyvlce4a.rs:28:21\n\
    \   |\n28 |             l4.push(l4_iter.next().unwrap());\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n28 |             l4.push(*l4_iter.next().unwrap());\n\
    \   |                     +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.push(l2[0]);\n            l2.pop();\n\
    \        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n            l1.pop();\n\
    \        } else {\n            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n\
    \                l1.pop();\n            } else {\n                l3.push(l2[0]);\n\
    \                l2.pop();\n            }\n        }\n    }\n    l3.extend(l1.clone());\n\
    \    l3.extend(l2.clone());\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5]`,\n right:\
    \ `[1, 5, 653]`', /tmp/tmpp3q99frt.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = vec![];\n    while l1.len() != 0 ||\
    \ l2.len() != 0 {\n        if l1.len() == 0 {\n            l2.pop();\n       \
    \ } else if l2.len() == 0 {\n            l1.pop();\n        } else {\n       \
    \     let mut l1 = l1.to_vec();\n            let mut l2 = l2.to_vec();\n     \
    \       if l1.len() == l2.len() {\n                while l1.len() != 0 {\n   \
    \                 result.push(l1.pop());\n                }\n                while\
    \ l2.len() != 0 {\n                    result.push(l2.pop());\n              \
    \  }\n            } else {\n                while l1.len() != l2.len() {\n   \
    \                 l1.pop();\n                    l2.pop();\n                }\n\
    \                while l1.len() != 0 {\n                    result.push(l1.pop());\n\
    \                }\n                while l2.len() != 0 {\n                  \
    \  result.push(l2.pop());\n                }\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9lcae7r.rs:39:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n39 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    while l3.len() > 0 && l4.len()\
    \ > 0 {\n        if l3[0] != l4[0] {\n            break;\n        }\n        l3.remove(0);\n\
    \        l4.remove(0);\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmp7wvsifp6.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        let mut i =\
    \ 0;\n        while l1.len() > 0 && l2.len() > 0 {\n            if l1[0] < l2[0]\
    \ {\n                result.push(*l1.pop());\n            } else {\n         \
    \       result.push(*l2.pop());\n            }\n            i += 1;\n        }\n\
    \        if l1.len() > 0 {\n            result.push(*l1.pop());\n        }\n \
    \       if l2.len() > 0 {\n            result.push(*l2.pop());\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp355u3bn9.rs:14:29\n\
    \   |\n14 |                 result.push(*l1.pop());\n   |                    \
    \         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmp355u3bn9.rs:16:29\n   |\n16 |                 result.push(*l2.pop());\n\
    \   |                             ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp355u3bn9.rs:21:25\n   |\n21 |        \
    \     result.push(*l1.pop());\n   |                         ^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp355u3bn9.rs:24:25\n\
    \   |\n24 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.into_iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmi830vvp.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmi830vvp.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpmi830vvp.rs:18:20\n     |\n18   |\
    \     l1.into_iter().cloned().collect::<Vec<_>>()\n     |                    ^^^^^^\
    \ expected reference, found `isize`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `isize`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpmi830vvp.rs:18:29\n \
    \  |\n18 |       l1.into_iter().cloned().collect::<Vec<_>>()\n   |           \
    \                    ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_next = l1.iter().cloned().next();\n    let mut l2_next = l2.iter().cloned().next();\n\
    \    while l1_next != l2_next {\n        if *l1_iter == *l2_iter {\n         \
    \   result.push(*l1_iter);\n            l1_iter.next();\n            l2_iter.next();\n\
    \        } else if *l1_iter < *l2_iter {\n            result.push(*l1_iter);\n\
    \            l1_iter.next();\n        } else {\n            result.push(*l2_iter);\n\
    \            l2_iter.next();\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmply34tie1.rs:13:12\n   |\n13 |         if *l1_iter == *l2_iter {\n\
    \   |            ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>`\
    \ cannot be dereferenced\n  --> /tmp/tmply34tie1.rs:13:24\n   |\n13 |        \
    \ if *l1_iter == *l2_iter {\n   |                        ^^^^^^^^\n\nerror[E0614]:\
    \ type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n  --> /tmp/tmply34tie1.rs:14:25\n\
    \   |\n14 |             result.push(*l1_iter);\n   |                         ^^^^^^^^\n\
    \nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmply34tie1.rs:17:19\n   |\n17 |         } else if *l1_iter < *l2_iter\
    \ {\n   |                   ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmply34tie1.rs:17:30\n   |\n17 |\
    \         } else if *l1_iter < *l2_iter {\n   |                              ^^^^^^^^\n\
    \nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmply34tie1.rs:18:25\n   |\n18 |             result.push(*l1_iter);\n\
    \   |                         ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmply34tie1.rs:21:25\n   |\n21 |\
    \             result.push(*l2_iter);\n   |                         ^^^^^^^^\n\n\
    error: aborting due to 7 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n\
    \                if l1.front() == l2.front() {\n                    l1.pop();\n\
    \                    l2.pop();\n                } else {\n                   \
    \ i += 1;\n                }\n            }\n            if l1.len() == 0 {\n\
    \                result.push(l2.pop());\n            } else if l2.len() == 0 {\n\
    \                result.push(l1.pop());\n            } else {\n              \
    \  result.push(l1.pop());\n                result.push(l2.pop());\n          \
    \  }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpjz3xam0q.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpjz3xam0q.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjz3xam0q.rs:37:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n37 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1.front() == l2.front() {\n                    l1.pop();\n      \
    \              l2.pop();\n                } else {\n                    i += 1;\n\
    \                }\n            }\n            if l1.len() == 0 {\n          \
    \      result.push(l2.pop());\n            } else if l2.len() == 0 {\n       \
    \         result.push(l1.pop());\n            } else {\n                result.push(l1.pop());\n\
    \                result.push(l2.pop());\n            }\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp8cwz_6k4.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp8cwz_6k4.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8cwz_6k4.rs:37:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n37 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        if l1.len() == 0\
    \ {\n            break;\n        }\n        if l2.len() == 0 {\n            break;\n\
    \        }\n        if l1[0] < l2[0] {\n            result.remove(0);\n      \
    \      l1.remove(0);\n        } else {\n            result.remove(0);\n      \
    \      l2.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpir0v56lz.rs:18:13\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n18 |             l1.remove(0);\n   |             ^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n           \
    \     l1.pop();\n            } else {\n                l3.push(l2[0]);\n     \
    \           l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpjetwnru2.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l3_el\
    \ = l1_el;\n                l1_el = l1.pop();\n                l2_el = l2.pop();\n\
    \            }\n            l3.push(l3_el);\n        }\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `l3_el` in this scope\n  --> /tmp/tmpboa1gluf.rs:19:17\n\
    \   |\n19 |                 l3_el = l1_el;\n   |                 ^^^^^ help: a\
    \ local variable with a similar name exists: `l1_el`\n\nerror[E0425]: cannot find\
    \ value `l3_el` in this scope\n  --> /tmp/tmpboa1gluf.rs:23:21\n   |\n23 |   \
    \          l3.push(l3_el);\n   |                     ^^^^^ help: a local variable\
    \ with a similar name exists: `l1_el`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpboa1gluf.rs:26:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n26 |     l3\n   |     ^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            if l3[0]\
    \ == l2[0] {\n                l3.remove(0);\n                l4.remove(0);\n \
    \           } else {\n                l3.remove(0);\n                l4.push(l3.pop());\n\
    \            }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzg4dykmq.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzg4dykmq.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzg4dykmq.rs:22:25\n   |\n22 |  \
    \               l4.push(l3.pop());\n   |                         ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  if l1.len() == l2.len() {\n                while l1.len() != 0 {\n        \
    \            result.push(l1.pop());\n                }\n                while\
    \ l2.len() != 0 {\n                    result.push(l2.pop());\n              \
    \  }\n            } else {\n                while l1.len() != l2.len() {\n   \
    \                 l1.pop();\n                    l2.pop();\n                }\n\
    \                while l1.len() != 0 {\n                    result.push(l1.pop());\n\
    \                }\n                while l2.len() != 0 {\n                  \
    \  result.push(l2.pop());\n                }\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj0kh2t6c.rs:39:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n39 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1;\n    let mut l1_iter\
    \ = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_next = l1_iter.next();\n\
    \    let mut l2_next = l2_iter.next();\n    while l1_next && l2_next {\n     \
    \   if l1_next.unwrap() == l2_next.unwrap() {\n            result.push(l1_next.unwrap());\n\
    \            l1_next = l1_iter.next();\n            l2_next = l2_iter.next();\n\
    \        } else if l1_next.unwrap() < l2_next.unwrap() {\n            result.push(l1_next.unwrap());\n\
    \            l1_next = l1_iter.next();\n        } else {\n            result.push(l2_next.unwrap());\n\
    \            l2_next = l2_iter.next();\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoiv6gc3g.rs:12:11\n   |\n\
    12 |     while l1_next && l2_next {\n   |           ^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoiv6gc3g.rs:12:22\n\
    \   |\n12 |     while l1_next && l2_next {\n   |                      ^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoiv6gc3g.rs:14:25\n   |\n14 |             result.push(l1_next.unwrap());\n\
    \   |                         ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |             result.push(*l1_next.unwrap());\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoiv6gc3g.rs:18:25\n\
    \   |\n18 |             result.push(l1_next.unwrap());\n   |                 \
    \        ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |             result.push(*l1_next.unwrap());\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoiv6gc3g.rs:21:25\n\
    \   |\n21 |             result.push(l2_next.unwrap());\n   |                 \
    \        ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |             result.push(*l2_next.unwrap());\n\
    \   |                         +\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    l1.iter().zip(l2.iter()).filter(|&(a,\
    \ b)| a == b).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n  --> /tmp/tmpt5qi5pxb.rs:11:55\n\
    \   |\n11 |     l1.iter().zip(l2.iter()).filter(|&(a, b)| a == b).collect()\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \   |\n   = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l4.len() == 0 {\n            l4.push(0);\n            l3.push(0);\n\
    \        }\n        if l3[0] == l2[0] {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            l3.pop();\n            l4.pop();\n        }\n \
    \   }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmprcylb26g.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwkce5gc4.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = l1.len();\n    while i < k {\n        if l1[i] ==\
    \ l2[j] {\n            i += 1;\n            j += 1;\n        } else {\n      \
    \      if l1[i] < l2[j] {\n                i += 1;\n            } else {\n   \
    \             j += 1;\n            }\n        }\n    }\n    l1.drain(..k);\n \
    \   l2.drain(..k);\n    l1\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpjn4iwp3i.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort_unstable();\n\
    \    l2.sort_unstable();\n    let mut l3 = Vec::new();\n    while l1.len() !=\
    \ 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            l3.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n        }\
    \ else {\n            if l1.pop() == l2.pop() {\n                l3.push(l1.pop());\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8oqgcw2l.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    l2.sort();\n    l3.sort();\n    while l1.len() != 0 || l2.len() != 0 {\n\
    \        if l1.len() == 0 {\n            l3.push(l2[0]);\n            l2.pop();\n\
    \        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n            l1.pop();\n\
    \        } else {\n            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n\
    \                l1.pop();\n            } else {\n                l3.push(l2[0]);\n\
    \                l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right:\
    \ `[1, 5, 653]`', /tmp/tmpvezn8b6b.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() ==\
    \ 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l1_el\
    \ = l1.pop();\n                l2_el = l2.pop();\n            }\n            result.push(l1_el);\n\
    \            result.push(l2_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu0qsy86w.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l3 = l2.clone();\n    while l3.len() > 0 {\n        let mut l4 = l3.clone();\n\
    \        while l4.len() > 0 {\n            if l4[0] < result[0] {\n          \
    \      result.swap(0, l4[0]);\n                l4.swap(0, 1);\n            }\n\
    \            if l4[0] < result[l4.len() - 1] {\n                l4.swap(l4.len()\
    \ - 1, l4.len() - 1);\n            }\n        }\n        l3.swap(0, l3.len() -\
    \ 1);\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp91dhdwxh.rs:13:32\n   |\n\
    13 |                 result.swap(0, l4[0]);\n   |                            \
    \    ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n13 |      \
    \           result.swap(0, l4[0].try_into().unwrap());\n   |                 \
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] < l2[i] {\n      \
    \      l1.remove(&l1[i]);\n        } else {\n            l2.remove(&l2[i]);\n\
    \        }\n        i += 1;\n    }\n    l1.extend(l2.into_iter().cloned());\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0bnzhatt.rs:12:23\n   |\n\
    12 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0bnzhatt.rs:14:23\n\
    \   |\n14 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmp0bnzhatt.rs:18:30\n   |\n18 |     l1.extend(l2.into_iter().cloned());\n\
    \   |                              ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmp0bnzhatt.rs:18:8\n   |\n18 |     l1.extend(l2.into_iter().cloned());\n\
    \   |        ^^^^^^ expected `isize`, found reference\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n   = note: required because of\
    \ the requirements on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        let mut i\
    \ = 0;\n        let mut j = 0;\n        while i < l1.len() && j < l2.len() {\n\
    \            if l1[i] < l2[j] {\n                i += 1;\n            } else if\
    \ l1[i] > l2[j] {\n                j += 1;\n            } else {\n           \
    \     result.push(l1[i]);\n                i += 1;\n                j += 1;\n\
    \            }\n        }\n        if l1.len() != 0 {\n            result.push(l1[i]);\n\
    \        }\n        if l2.len() != 0 {\n            result.push(l2[j]);\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 7 but the
    index is 7'', /tmp/tmpkxwt7_5t.rs:25:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort_unstable();\n\
    \    l2.sort_unstable();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpw85pqz_a.rs:88:1\n   |\n88\
    \ | }\n   | ^\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1.iter().next().unwrap()\
    \ == l2.iter().next().unwrap() {\n                    l3.push(l1.pop());\n   \
    \                 l3.push(l2.pop());\n                } else {\n             \
    \       l3.push(l1.pop());\n                }\n            } else {\n        \
    \        let mut i = 0;\n                while i < l1.len() && i < l2.len() {\n\
    \                    if l1.iter().next().unwrap() == l2.iter().next().unwrap()\
    \ {\n                        l3.push(l1.pop());\n                        l3.push(l2.pop());\n\
    \                    } else {\n                        i += 1;\n             \
    \       }\n                }\n            }\n        }\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp89rt5pdl.rs:36:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n36 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1;\n    let mut l1_iter\
    \ = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_next = l1_iter.next();\n\
    \    let mut l2_next = l2_iter.next();\n    while l1_next && l2_next {\n     \
    \   if l1_next.unwrap() == l2_next.unwrap() {\n            result.push(l1_next.unwrap());\n\
    \            l1_next = l1_iter.next();\n            l2_next = l2_iter.next();\n\
    \        } else {\n            if l1_next.unwrap() < l2_next.unwrap() {\n    \
    \            l1_next = l1_iter.next();\n            } else {\n               \
    \ l2_next = l2_iter.next();\n            }\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwyanmtma.rs:12:11\n   |\n\
    12 |     while l1_next && l2_next {\n   |           ^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyanmtma.rs:12:22\n\
    \   |\n12 |     while l1_next && l2_next {\n   |                      ^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwyanmtma.rs:14:25\n   |\n14 |             result.push(l1_next.unwrap());\n\
    \   |                         ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |             result.push(*l1_next.unwrap());\n\
    \   |                         +\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(*l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(*l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            if l1.len() == l2.len() {\n                while l1.len() > 0 &&\
    \ l2.len() > 0 {\n                    if l1.pop() == l2.pop() {\n            \
    \            result.push(*l1.pop());\n                    } else {\n         \
    \               break;\n                    }\n                }\n           \
    \     while l1.len() > 0 {\n                    result.push(*l1.pop());\n    \
    \            }\n                while l2.len() > 0 {\n                    result.push(*l2.pop());\n\
    \                }\n            } else {\n                while l1.len() > 0 &&\
    \ l2.len() > 0 {\n                    if l1.pop() == l2.pop() {\n            \
    \            break;\n                    }\n                }\n              \
    \  while l1.len() > 0 {\n                    result.push(*l1.pop());\n       \
    \         }\n                while l2.len() > 0 {\n                    result.push(*l2.pop());\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp2jgxfsqm.rs:12:25\n\
    \   |\n12 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmp2jgxfsqm.rs:14:25\n   |\n14 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp2jgxfsqm.rs:21:37\n   |\n21 |        \
    \                 result.push(*l1.pop());\n   |                              \
    \       ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmp2jgxfsqm.rs:27:33\n   |\n27 |                     result.push(*l1.pop());\n\
    \   |                                 ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp2jgxfsqm.rs:30:33\n   |\n30 |        \
    \             result.push(*l2.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp2jgxfsqm.rs:39:33\n\
    \   |\n39 |                     result.push(*l1.pop());\n   |                \
    \                 ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmp2jgxfsqm.rs:42:33\n   |\n42 |                     result.push(*l2.pop());\n\
    \   |                                 ^^^^^^^^^\n\nerror: aborting due to 7 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 1 {\n     \
    \           l3.pop();\n                l4.pop();\n            } else {\n     \
    \           l3.pop();\n            }\n        } else if l2.len() == 1 {\n    \
    \        l3.pop();\n        } else {\n            let mut l5 = l1.clone();\n \
    \           let mut l6 = l2.clone();\n            while l5.len() != 0 || l6.len()\
    \ != 0 {\n                if l5.len() == 0 {\n                    l6.pop();\n\
    \                    l5.pop();\n                }\n                if l6.len()\
    \ == 0 {\n                    l5.pop();\n                    l6.pop();\n     \
    \           }\n                if l5.len() == 0 && l6.len() == 0 {\n         \
    \           break;\n                }\n                if l5.len() == 1 {\n  \
    \                  if l6.len() == 1 {\n                        l5.pop();\n   \
    \                     l6.pop();\n                    } else {\n              \
    \          l5.pop();\n                    }\n                } else if l6.len()\
    \ == 1 {\n                    l5.pop();\n                } else {\n          \
    \          let mut l7 = l5.clone();\n                    let mut l8 = l6.clone();\n\
    \                    while l7.len() != 0 || l8.len() != 0 {\n                \
    \        if l7.len() == 0 {\n                            l8.pop();\n         \
    \                   l7.pop();\n                        }\n                   \
    \     if l8.len() == 0 {\n                            l7.pop();\n            \
    \                l8.pop();\n                        }\n                      \
    \  if l7.len() == 0 && l8.len() == 0 {\n                            break;\n \
    \                       }\n                        if l7.len() == 1 {\n      \
    \                      if l8.len() == 1 {\n                                l7.pop();\n\
    \                                l8.pop();\n                            } else\
    \ {\n                                l7.pop();\n                            }\n\
    \                        } else if l8.len() == 1 {\n                         \
    \   l7.pop();\n                        } else {\n                            let\
    \ mut l9 = l7.clone();\n                            let mut l10 = l8.clone();\n\
    \                            while l9.len() != 0 || l10.len() != 0 {\n       \
    \                         if l9.len() == 0 {\n                               \
    \     l10.pop();\n                                    l9.pop\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvpl5dd5d.rs:95:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n32 |         } else {\n   |\
    \                - unclosed delimiter\n...\n35 |             while l5.len() !=\
    \ 0 || l6.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n56 |                 } else {\n   |             \
    \           - unclosed delimiter\n...\n59 |                     while l7.len()\
    \ != 0 || l8.len() != 0 {\n   |                                              \
    \            - unclosed delimiter\n...\n80 |                         } else {\n\
    \   |                                - unclosed delimiter\n...\n83 |         \
    \                    while l9.len() != 0 || l10.len() != 0 {\n   |           \
    \                                                        - unclosed delimiter\n\
    84 |                                 if l9.len() == 0 {\n   |                \
    \                                  - this delimiter might not be properly closed...\n\
    ...\n87 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    95 | }\n   |   ^\n\nerror[E0615]: attempted to take value of method `pop` on type\
    \ `Vec<isize>`\n  --> /tmp/tmpvpl5dd5d.rs:86:40\n   |\n86 | ...              \
    \     l9.pop\n   |                          ^^^ method, not a field\n   |\nhelp:\
    \ use parentheses to call the method\n   |\n86 |                             \
    \        l9.pop()\n   |                                           ++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvpl5dd5d.rs:11:5\n   |\n6  |   fn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                          \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n11 | /     while l1.len() != 0 || l2.len() != 0 {\n12 | |         if l1.len()\
    \ == 0 {\n13 | |             l3.pop();\n14 | |             l4.pop();\n...  "
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          result.push(l1_el);\n                l1_el = l1.pop();\n          \
    \      l2_el = l2.pop();\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkpgde7yu.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwkce5gc4.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() {\n    \
    \        if l2_iter.any() {\n                if l1_iter == l2_iter {\n       \
    \             l1_iter.next();\n                    l2_iter.next();\n         \
    \       } else {\n                    let mut l1_iter = l1.iter().cloned();\n\
    \                    let mut l2_iter = l2.iter().cloned();\n                 \
    \   while l1_iter.any() || l2_iter.any() {\n                        if l1_iter.any()\
    \ {\n                            if l2_iter.any() {\n                        \
    \        if l1_iter == l2_iter {\n                                    l1_iter.next();\n\
    \                                    l2_iter.next();\n                       \
    \         } else {\n                                    result.push(*l1_iter);\n\
    \                                    l1_iter.next();\n                       \
    \             l2_iter.next();\n                                }\n           \
    \                 } else {\n                                result.push(*l1_iter);\n\
    \                                l1_iter.next();\n                           \
    \ }\n                        } else {\n                            result.push(*l2_iter);\n\
    \                            l2_iter.next();\n                        }\n    \
    \                }\n                }\n            } else {\n                result.push(*l1_iter);\n\
    \                l1_iter.next();\n            }\n        } else {\n          \
    \  result.push(*l2_iter);\n            l2_iter.next();\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp3cnw7iko.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmp3cnw7iko.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmp3cnw7iko.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmp3cnw7iko.rs:14:24\n\
    \     |\n14   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0369]: binary operation `==` cannot be applied to type `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmp3cnw7iko.rs:15:28\n   |\n15 |                 if l1_iter\
    \ == l2_iter {\n   |                    ------- ^^ ------- Cloned<std::slice::Iter<'_,\
    \ isize>>\n   |                    |\n   |                    Cloned<std::slice::Iter<'_,\
    \ isize>>\n\nerror[E0061]: this function takes 1 argument but 0 arguments were\
    \ supplied\n    --> /tmp/tmp3cnw7iko.rs:21:35\n     |\n21   |                \
    \     while l1_iter.any() || l2_iter.any() {\n     |                         \
    \          ^^^- supplied 0 arguments\n     |                                 \
    \  |\n     |                 "
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        if l1.len() == 0\
    \ {\n            break;\n        }\n        if l2.len() == 0 {\n            break;\n\
    \        }\n        if l1[0] < l2[0] {\n            result.remove(0);\n      \
    \      l1.remove(0);\n        } else {\n            result.remove(l2.len());\n\
    \            l2.remove(l2.len());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpfsjs0ltj.rs:18:13\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n18 |             l1.remove(0);\n   |             ^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 &&\
    \ l1.front() == l2.front() {\n                l1.pop();\n                l2.pop();\n\
    \                i += 1;\n            }\n            result.push(l1.pop());\n\
    \            result.push(l2.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpdj1ocsbv.rs:19:54\n   |\n19 |             while\
    \ l1.len() > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |           \
    \                                           ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpdj1ocsbv.rs:19:68\n   |\n19 |             while l1.len()\
    \ > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |                    \
    \                                                ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdj1ocsbv.rs:28:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n28 |     result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.into_iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmi830vvp.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmi830vvp.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpmi830vvp.rs:18:20\n     |\n18   |\
    \     l1.into_iter().cloned().collect::<Vec<_>>()\n     |                    ^^^^^^\
    \ expected reference, found `isize`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `isize`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpmi830vvp.rs:18:29\n \
    \  |\n18 |       l1.into_iter().cloned().collect::<Vec<_>>()\n   |           \
    \                    ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1_iter\
    \ = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n    let mut\
    \ l1_next = l1.iter().cloned();\n    let mut l2_next = l2.iter().cloned();\n \
    \   while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() {\n     \
    \       if l2_iter.any() {\n                if l1_iter.next().unwrap() == l2_iter.next().unwrap()\
    \ {\n                    result.push(l1_iter.next().unwrap());\n             \
    \       l1_iter.next();\n                    l2_iter.next();\n               \
    \ } else {\n                    l1_iter.next();\n                }\n         \
    \   } else {\n                l1_iter.next();\n            }\n        } else {\n\
    \            l2_iter.next();\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpymbqtlex.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpymbqtlex.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpymbqtlex.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpymbqtlex.rs:14:24\n\
    \     |\n14   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut i =\
    \ 0;\n            let mut j = 0;\n            while i < l1.len() && j < l2.len()\
    \ {\n                if l1[i] < l2[j] {\n                    i += 1;\n       \
    \         } else if l1[i] > l2[j] {\n                    j += 1;\n           \
    \     } else {\n                    result.push(l1[i]);\n                    i\
    \ += 1;\n                    j += 1;\n                }\n            }\n     \
    \       if i < l1.len() {\n                result.push(l1[i]);\n            }\n\
    \            if j < l2.len() {\n                result.push(l2[j]);\n        \
    \    }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzdolluog.rs:24:33\n   |\n\
    24 |                     result.push(l1[i]);\n   |                           \
    \      ^^^^^\n   |                                 |\n   |                   \
    \              expected enum `Option`, found `isize`\n   |                   \
    \              help: try using a variant of the expected enum: `Some(l1[i])`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzdolluog.rs:30:29\n   |\n30 |\
    \                 result.push(l1[i]);\n   |                             ^^^^^\n\
    \   |                             |\n   |                             expected\
    \ enum `Option`, found `isize`\n   |                             help: try using\
    \ a variant of the expected enum: `Some(l1[i])`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzdolluog.rs:33:29\n   |\n33 |                 result.push(l2[j]);\n\
    \   |                             ^^^^^\n   |                             |\n\
    \   |                             expected enum `Option`, found `isize`\n   |\
    \                             help: try using a variant of the expected enum:\
    \ `Some(l2[j])`\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzdolluog.rs:37:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n37 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            let mut\
    \ l3_iter = l3.iter().cloned();\n            let mut l4_iter = l4.iter().cloned();\n\
    \            let mut l3_next = l3_iter.next();\n            let mut l4_next =\
    \ l4_iter.next();\n            while l3_next.unwrap() == l4_next.unwrap() {\n\
    \                l3_next = l3_iter.next();\n                l4_next = l4_iter.next();\n\
    \            }\n            l3.push(l3_next.unwrap());\n            l4.push(l4_next.unwrap());\n\
    \        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7t37xezr.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7t37xezr.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2[0]);\n            l2.remove(l2[0]);\n        } else if\
    \ l2.len() == 0 {\n            result.push(l1[0]);\n            l1.remove(l1[0]);\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0 && l1.front()\
    \ == l2.front() {\n                result.push(l1[i]);\n                l1.remove(l1[i]);\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkvgpknsc.rs:13:23\n   |\n\
    13 |             l2.remove(l2[0]);\n   |                       ^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |             l2.remove(l2[0].try_into().unwrap());\n\
    \   |                       ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkvgpknsc.rs:16:23\n   |\n16 |             l1.remove(l1[0]);\n\
    \   |                       ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n16 |             l1.remove(l1[0].try_into().unwrap());\n   |    \
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named\
    \ `front` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpkvgpknsc.rs:21:56\n\
    \   |\n21 |             while l1.len() != 0 && l2.len() != 0 && l1.front() ==\
    \ l2.front() {\n   |                                                        ^^^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found\
    \ for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpkvgpknsc.rs:21:70\n\
    \   |\n21 |             while l1.len() != 0 && l2.len() != 0 && l1.front() ==\
    \ l2.front() {\n   |                                                         \
    \             ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkvgpknsc.rs:23:27\n   |\n23 |                 l1.remove(l1[i]);\n\
    \   |                           ^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n23 |                 l1.remove(l1[i].try_into().unwrap());\n\
    \   |                           ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = 0;\n    let mut common = Vec::new();\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            common.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else {\n            if l1[i]\
    \ < l2[j] {\n                i += 1;\n            } else {\n                j\
    \ += 1;\n            }\n        }\n    }\n    common\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0 {\n      \
    \          if l1.len() == 0 {\n                    result.push(l2.pop());\n  \
    \                  i += 1;\n                } else if l2.len() == 0 {\n      \
    \              result.push(l1.pop());\n                    i += 1;\n         \
    \       } else {\n                    if l1.len() == l2.len() {\n            \
    \            if l1.len() == 1 {\n                            result.push(l1.pop());\n\
    \                        } else {\n                            result.push(l1.pop());\n\
    \                            result.push(l2.pop());\n                        }\n\
    \                    } else {\n                        if l1.len() > l2.len()\
    \ {\n                            result.push(l1.pop());\n                    \
    \    } else {\n                            result.push(l2.pop());\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbgwg3xcp.rs:45:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n45 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut i\
    \ = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n\
    \            result.push(l1[i]);\n            i += 1;\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpifx2f0ey.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            if l3[0]\
    \ == l4[0] {\n                l3.remove(0);\n                l4.remove(0);\n \
    \           } else {\n                break;\n            }\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4noqqfwb.rs:15:21\n   |\n\
    15 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4noqqfwb.rs:17:21\n   |\n17 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l3 = Vec::new();\n            while l1.len() > 0 || l2.len() > 0 {\n\
    \                if l1.len() == 0 {\n                    l3.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n  \
    \                  let mut l3 = Vec::new();\n                    while l1.len()\
    \ > 0 || l2.len() > 0 {\n                        if l1.len() == 0 {\n        \
    \                    l3.push(l2.pop());\n                        } else if l2.len()\
    \ == 0 {\n                            l3.push(l1.pop());\n                   \
    \     } else {\n                            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                            let mut l3 = Vec::new();\n                      \
    \      while l1.len() > 0 || l2.len() > 0 {\n                                if\
    \ l1.len() == 0 {\n                                    l3.push(l2.pop());\n  \
    \                              } else if l2.len() == 0 {\n                   \
    \                 l3.push(l1.pop());\n                                } else {\n\
    \                                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                    let mut l3 = Vec::new();\n              \
    \                      while l1.len() > 0 || l2.len() > 0 {\n                \
    \                        if l1.len() == 0 {\n                                \
    \            l3.push(l2.pop());\n                                        } else\
    \ if l2.len() == 0 {\n                                            l3.push(l1.pop());\n\
    \                                        } else {\n                          \
    \                  let mut l1 = l1.\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpt6bq0cmb.rs:61:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n15 |         } else {\n   |   \
    \             - unclosed delimiter\n...\n19 |             while l1.len() > 0 ||\
    \ l2.len() > 0 {\n   |                                                - unclosed\
    \ delimiter\n...\n24 |                 } else {\n   |                        -\
    \ unclosed delimiter\n...\n28 |                     while l1.len() > 0 || l2.len()\
    \ > 0 {\n   |                                                        - unclosed\
    \ delimiter\n...\n33 |                         } else {\n   |                \
    \                - unclosed delimiter\n...\n37 |                             while\
    \ l1.len() > 0 || l2.len() > 0 {\n   |                                       \
    \                         - unclosed delimiter\n...\n42 |                    \
    \             } else {\n   |                                        - unclosed\
    \ delimiter\n...\n46 |                                     while l1.len() > 0\
    \ || l2.len() > 0 {\n   |                                                    \
    \                    - unclosed delimiter\n...\n51 |                         \
    \                } else {\n   |                                              \
    \  - this delimiter might not be properly closed...\n52 |                    \
    \                         let mut l1 = l1.\n53 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n61 | }\n   |   ^\n\nerror: unexpected\
    \ token: `}`\n  --> /tmp/tmpt6bq0cmb.rs:53:1\n   |\n53 | }\n   | ^\n\nerror: expected\
    \ `;`, found `}`\n  --> /tmp/tmpt6bq0cmb.rs:52:61\n   |\n52 |                \
    \                             let mut l1 = l1.\n   |                         \
    \                                    ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt6bq0cmb.rs:10:5\n  \
    \ |\n6  |  "
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l3_el\
    \ = l1_el;\n                l1_el = l1.pop();\n                l2_el = l2.pop();\n\
    \            }\n            l3.push(l3_el);\n        }\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `l3_el` in this scope\n  --> /tmp/tmpzgjsu__r.rs:19:17\n\
    \   |\n19 |                 l3_el = l1_el;\n   |                 ^^^^^ help: a\
    \ local variable with a similar name exists: `l1_el`\n\nerror[E0425]: cannot find\
    \ value `l3_el` in this scope\n  --> /tmp/tmpzgjsu__r.rs:23:21\n   |\n23 |   \
    \          l3.push(l3_el);\n   |                     ^^^^^ help: a local variable\
    \ with a similar name exists: `l1_el`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzgjsu__r.rs:26:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n26 |     l3\n   |     ^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.extend(l2.into_iter().cloned());\n\
    \    l1.sort_unstable();\n    l1\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5f_zp5r7.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5f_zp5r7.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmp5f_zp5r7.rs:18:30\n   |\n18 |     l1.extend(l2.into_iter().cloned());\n\
    \   |                              ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmp5f_zp5r7.rs:18:8\n   |\n18 |     l1.extend(l2.into_iter().cloned());\n\
    \   |        ^^^^^^ expected `isize`, found reference\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n   = note: required because of\
    \ the requirements on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n\
    \    while l3.len() > 0 || l4.len() > 0 {\n        if l3.len() == 0 {\n      \
    \      l3.push(0);\n            l4.push(0);\n        }\n        if l4.len() ==\
    \ 0 {\n            l4.push(0);\n            l3.push(0);\n        }\n        if\
    \ l3[0] == l2[0] {\n            l3.pop();\n            l4.pop();\n        } else\
    \ {\n            l3.pop();\n            l4.pop();\n        }\n    }\n    l3\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpo2x_6fz5.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0\
    \ && l1.front() == l2.front() {\n                l1.pop();\n                l2.pop();\n\
    \                i += 1;\n            }\n            if l1.len() == 0 {\n    \
    \            result.push(l2.pop());\n            } else if l2.len() == 0 {\n \
    \               result.push(l1.pop());\n            } else {\n               \
    \ result.push(l1.pop());\n                result.push(l2.pop());\n           \
    \ }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp61jwbluz.rs:19:56\n   |\n19 |             while\
    \ l1.len() != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |         \
    \                                               ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp61jwbluz.rs:19:70\n   |\n19 |             while l1.len()\
    \ != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |                  \
    \                                                    ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp61jwbluz.rs:34:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n34 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort_unstable();\n\
    \    l2.sort_unstable();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpw85pqz_a.rs:88:1\n   |\n88\
    \ | }\n   | ^\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            let mut\
    \ l3_iter = l3.iter().cloned().collect::<Vec<_>>();\n            let mut l4_iter\
    \ = l4.iter().cloned().collect::<Vec<_>>();\n            let mut l3_iter = l3_iter.into_iter();\n\
    \            let mut l4_iter = l4_iter.into_iter();\n            let mut l3_iter\
    \ = l3_iter.zip2(&mut l4_iter).map(|(_, v)| v);\n            let mut l3_iter =\
    \ l3_iter.filter(|&(_, v)| v == &l3_iter.next().unwrap());\n            l3.extend(l3_iter.cloned());\n\
    \        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb6l5cmt0.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb6l5cmt0.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0599]: no method named `zip2` found for struct `std::vec::IntoIter` in\
    \ the current scope\n  --> /tmp/tmpb6l5cmt0.rs:21:39\n   |\n21 |             let\
    \ mut l3_iter = l3_iter.zip2(&mut l4_iter).map(|(_, v)| v);\n   |            \
    \                           ^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          let mut l3_iter = l3.iter_mut();\n            if l3_iter.next().unwrap()\
    \ == l1[0] {\n                l3_iter.next_mut().unwrap().push(l2[0]);\n     \
    \           l2.pop();\n            } else {\n                l3_iter.next_mut().unwrap().push(l1[0]);\n\
    \                l1.pop();\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next_mut` found for struct `std::slice::IterMut`\
    \ in the current scope\n  --> /tmp/tmpxncr50_1.rs:20:25\n   |\n20 |          \
    \       l3_iter.next_mut().unwrap().push(l2[0]);\n   |                       \
    \  ^^^^^^^^ method not found in `std::slice::IterMut<'_, isize>`\n\nerror[E0277]:\
    \ can't compare `&mut isize` with `isize`\n  --> /tmp/tmpxncr50_1.rs:19:40\n \
    \  |\n19 |             if l3_iter.next().unwrap() == l1[0] {\n   |           \
    \                             ^^ no implementation for `&mut isize == isize`\n\
    \   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&mut isize`\n\
    \nerror[E0599]: no method named `next_mut` found for struct `std::slice::IterMut`\
    \ in the current scope\n  --> /tmp/tmpxncr50_1.rs:23:25\n   |\n23 |          \
    \       l3_iter.next_mut().unwrap().push(l1[0]);\n   |                       \
    \  ^^^^^^^^ method not found in `std::slice::IterMut<'_, isize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1[l1.len()\
    \ - 1] == l2[l2.len() - 1] {\n                    l3.push(l1.pop());\n       \
    \             l3.push(l2.pop());\n                } else {\n                 \
    \   l3.push(l1.pop());\n                }\n            } else {\n            \
    \    if l1[l1.len() - 1] < l2[l2.len() - 1] {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    l3.push(l2.pop());\n          \
    \      }\n            }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp979xd16n.rs:32:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n32 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        let mut l1_next = l1_iter.next();\n\
    \        let mut l2_next = l2_iter.next();\n        while l1_next.unwrap() ==\
    \ l2_next.unwrap() {\n            result.remove(l1_next.unwrap());\n         \
    \   l1_next = l1_iter.next();\n            l2_next = l2_iter.next();\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `any` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpgpzcj4yz.rs:10:19\n   |\n10 |     while l1_iter.any()\
    \ || l2_iter.any() {\n   |                   ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `any` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpgpzcj4yz.rs:10:36\n   |\n10 |     while l1_iter.any() ||\
    \ l2_iter.any() {\n   |                                    ^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpgpzcj4yz.rs:11:35\n   |\n11 |         let\
    \ mut l1_next = l1_iter.next();\n   |                                   ^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpgpzcj4yz.rs:12:35\n\
    \   |\n12 |         let mut l2_next = l2_iter.next();\n   |                  \
    \                 ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `next` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpgpzcj4yz.rs:15:31\n\
    \   |\n15 |             l1_next = l1_iter.next();\n   |                      \
    \         ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named\
    \ `next` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpgpzcj4yz.rs:16:31\n\
    \   |\n16 |             l2_next = l2_iter.next();\n   |                      \
    \         ^^^^ method not found in `Vec<isize>`\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp5sgimv5e.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp5sgimv5e.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5sgimv5e.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    result.push(l1.pop());\n\
    \                } else {\n                    if l1.len() == l2.len() {\n   \
    \                     if l1.len() == i {\n                            result.push(l1.pop());\n\
    \                        } else {\n                            result.push(l2.pop());\n\
    \                        }\n                    } else {\n                   \
    \     if l1.len() < l2.len() {\n                            result.push(l1.pop());\n\
    \                        } else {\n                            result.push(l2.pop());\n\
    \                        }\n                    }\n                }\n       \
    \         i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp033kipu1.rs:43:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n43 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            if l1.pop()\
    \ == l2.pop() {\n                result.push(l1.pop());\n            } else {\n\
    \                break;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc0iesonj.rs:23:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() == 0 {\n            l3.pop();\n        }\n        if l4.len()\
    \ == 0 {\n            l4.pop();\n        }\n        if l3[0] == l4[0] {\n    \
    \        l3.pop();\n            l4.pop();\n        } else {\n            l3.pop();\n\
    \            l4.pop();\n        }\n    }\n    l1.iter().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpq88jl3gk.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l2.sort();\n    let mut l4 = l1.clone();\n    l4.sort();\n\
    \    while l3.len() != 0 || l4.len() != 0 {\n        if l3.len() == 0 {\n    \
    \        l4.push(l2[0]);\n            l2.remove(0);\n        } else if l4.len()\
    \ == 0 {\n            l3.push(l1[0]);\n            l1.remove(0);\n        } else\
    \ {\n            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n       \
    \         l1.remove(0);\n            } else {\n                l4.push(l2[0]);\n\
    \                l2.remove(0);\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpipr3ddmy.rs:22:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1[l1[0]]\
    \ == l2[l2[0]] {\n                    l3.pop();\n                    l4.pop();\n\
    \                } else {\n                    l3.pop();\n                   \
    \ l4.pop();\n                }\n            } else {\n                if l1[l1[0]]\
    \ < l2[l2[0]] {\n                    l3.pop();\n                    l4.pop();\n\
    \                } else {\n                    l3.pop();\n                   \
    \ l4.pop();\n                }\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpaws7bpl8.rs:20:20\n\
    \   |\n20 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \    ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpaws7bpl8.rs:20:33\n   |\n20 |                 if l1[l1[0]] == l2[l2[0]]\
    \ {\n   |                                 ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpaws7bpl8.rs:28:20\n   |\n28 |  \
    \               if l1[l1[0]] < l2[l2[0]] {\n   |                    ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpaws7bpl8.rs:28:32\n\
    \   |\n28 |                 if l1[l1[0]] < l2[l2[0]] {\n   |                 \
    \               ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_end =\
    \ l1.end();\n    let mut l2_end = l2.end();\n    while l1_iter.next() && l2_iter.next()\
    \ {\n        if *l1_iter == *l2_iter {\n            result.push(*l1_iter);\n \
    \           l1_iter.next();\n            l2_iter.next();\n        } else if *l1_iter\
    \ < *l2_iter {\n            result.push(*l1_iter);\n            l1_iter.next();\n\
    \        } else {\n            result.push(*l2_iter);\n            l2_iter.next();\n\
    \        }\n    }\n    if l1_end < l2_end {\n        result.extend(l2.iter().take(l2_end\
    \ - l1_end));\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `end` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp_cg51np1.rs:10:25\n   |\n10 |     let mut l1_end\
    \ = l1.end();\n   |                         ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `end` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp_cg51np1.rs:11:25\n   |\n11 |     let mut l2_end = l2.end();\n\
    \   |                         ^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_cg51np1.rs:12:11\n   |\n12 |     while l1_iter.next()\
    \ && l2_iter.next() {\n   |           ^^^^^^^^^^^^^^ expected `bool`, found enum\
    \ `Option`\n   |\n   = note: expected type `bool`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_cg51np1.rs:12:29\n   |\n12 |\
    \     while l1_iter.next() && l2_iter.next() {\n   |                         \
    \    ^^^^^^^^^^^^^^ expected `bool`, found enum `Option`\n   |\n   = note: expected\
    \ type `bool`\n              found enum `Option<&isize>`\n\nerror[E0614]: type\
    \ `std::slice::Iter<'_, isize>` cannot be dereferenced\n  --> /tmp/tmp_cg51np1.rs:13:12\n\
    \   |\n13 |         if *l1_iter == *l2_iter {\n   |            ^^^^^^^^\n\nerror[E0614]:\
    \ type `std::slice::Iter<'_, isize>` cannot be dereferenced\n  --> /tmp/tmp_cg51np1.rs:13:24\n\
    \   |\n13 |         if *l1_iter == *l2_iter {\n   |                        ^^^^^^^^\n\
    \nerror[E0614]: type `std::slice::Iter<'_, isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmp_cg51np1.rs:14:25\n   |\n14 |             result.push(*l1_iter);\n \
    \  |                         ^^^^^^^^\n\nerror[E0614]: type `std::slice::Iter<'_,\
    \ isize>` cannot be dereferenced\n  --> /tmp/tmp_cg51np1.rs:17:19\n   |\n17 |\
    \         } else if *l1_iter < *l2_iter {\n   |                   ^^^^^^^^\n\n\
    error[E0614]: type `std::slice::Iter<'_, isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmp_cg51np1.rs:17:30\n   |\n17 |         } else if *l1_iter < *l2_iter\
    \ {\n   |                              ^^^^^^^^\n\nerror[E0614]: type `std::slice::Iter<'_,\
    \ isize>` cannot be dereferenced\n  --> /tmp/tmp_cg51np1.rs:18:25\n   |\n18 |"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n           \
    \     l1.pop();\n            } else {\n                l3.push(l2[0]);\n     \
    \           l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpjetwnru2.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmph304806g.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any()\
    \ || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any() {\n          \
    \  if l1_iter.peek() == l2_iter.peek() {\n                result.push(*l1_iter.next());\n\
    \                result.push(*l2_iter.next());\n            } else {\n       \
    \         let mut l1_peek = l1_iter.peek();\n                let mut l2_peek =\
    \ l2_iter.peek();\n                while l1_peek != l2_peek {\n              \
    \      result.push(*l1_iter.next());\n                    result.push(*l2_iter.next());\n\
    \                    l1_peek = l1_iter.peek();\n                    l2_peek =\
    \ l2_iter.peek();\n                }\n            }\n        } else if l1_iter.any()\
    \ {\n            result.push(*l1_iter.next());\n        } else {\n           \
    \ result.push(*l2_iter.next());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp575vsrdu.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmp575vsrdu.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmp575vsrdu.rs:11:20\n\
    \     |\n11   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp575vsrdu.rs:11:37\n     |\n11   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp575vsrdu.rs:12:24\n   |\n12 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp575vsrdu.rs:12:42\n\
    \   |\n12 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0614]: type `Option<&isize>` "
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1.iter().next().unwrap()\
    \ == l2.iter().next().unwrap() {\n                    l3.push(l1.pop());\n   \
    \                 l3.push(l2.pop());\n                } else {\n             \
    \       l3.push(l1.pop());\n                }\n            } else {\n        \
    \        if l1.iter().next().unwrap() < l2.iter().next().unwrap() {\n        \
    \            l3.push(l1.pop());\n                } else {\n                  \
    \  l3.push(l2.pop());\n                }\n            }\n        }\n    }\n  \
    \  l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps1d3_iox.rs:32:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n32 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            if l1.len() == l2.len() {\n                while l1.len() != 0 {\n\
    \                    result.push(l1.pop());\n                }\n             \
    \   while l2.len() != 0 {\n                    result.push(l2.pop());\n      \
    \          }\n            } else {\n                while l1.len() != l2.len()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      }\n                while l1.len() != 0 {\n                    result.push(l1.pop());\n\
    \                }\n                while l2.len() != 0 {\n                  \
    \  result.push(l2.pop());\n                }\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_14zg0oj.rs:39:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n39 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = l1.len();\n    while i < k {\n        while\
    \ j < k {\n            if l1[i] == l2[j] {\n                l1.remove(&i);\n \
    \               l2.remove(&j);\n                i += 1;\n                j +=\
    \ 1;\n                k -= 1;\n            } else {\n                j += 1;\n\
    \            }\n        }\n        i += 1;\n        j = 0;\n        k -= 1;\n\
    \    }\n    l1.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplgaluqmd.rs:15:27\n   |\n\
    15 |                 l1.remove(&i);\n   |                           ^^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n15\
    \ -                 l1.remove(&i);\n15 +                 l1.remove(i);\n   | \n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplgaluqmd.rs:16:27\n   |\n16 |\
    \                 l2.remove(&j);\n   |                           ^^ expected `usize`,\
    \ found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n16 -       \
    \          l2.remove(&j);\n16 +                 l2.remove(j);\n   | \n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                let\
    \ mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n                let mut l2\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n                while l1.len() >\
    \ 0 || l2.len() > 0 {\n                    if l1.len() == 0 {\n              \
    \          l3.push(l2.pop());\n                    } else if l2.len() == 0 {\n\
    \                        l3.push(l1.pop());\n                    } else {\n  \
    \                      if l1.len() == l2.len() {\n                           \
    \ let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n                     \
    \       let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n               \
    \         }\n                    }\n                }\n            } else {\n\
    \                let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n      \
    \          let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n            \
    \    while l1.len() > 0 || l2.len() > 0 {\n                    if l1.len() ==\
    \ 0 {\n                        l3.push(l2.pop());\n                    } else\
    \ if l2.len() == 0 {\n                        l3.push(l1.pop());\n           \
    \         } else {\n                        if l1.len() == l2.len() {\n      \
    \                      let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc83i3v_v.rs:49:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n49 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  if l1.len() == 1 {\n                l2.pop();\n            } else if l2.len()\
    \ == 1 {\n                l1.pop();\n            } else {\n                if\
    \ l1.len() == l2.len() {\n                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n  \
    \                  while l1.len() > 0 && l2.len() > 0 {\n                    \
    \    if l1.len() == 1 {\n                            l2.pop();\n             \
    \           } else if l2.len() == 1 {\n                            l1.pop();\n\
    \                        } else {\n                            if l1.len() ==\
    \ l2.len() {\n                                let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                                let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                while l1.len() > 0 && l2.len() > 0 {\n      \
    \                              if l1.len() == 1 {\n                          \
    \              l2.pop();\n                                    } else if l2.len()\
    \ == 1 {\n                                        l1.pop();\n                \
    \                    } else {\n                                        if l1.len()\
    \ == l2.len() {\n                                            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                                            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                            while l1.len() > 0 && l2.len() >\
    \ 0 {\n                                                if l1.len() == 1 {\n  \
    \                                                  l2.pop();\n               \
    \                                 } else if l2.len() == 1 {\n                \
    \                                    l1.pop();\n                             \
    \                   } else {\n                                               \
    \     if l1.len() == l2.len() {\n                                            \
    \            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n          \
    \                                              let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                                        while l1.len() > 0 &&\
    \ l2.len() > 0 {\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpf3cy7shy.rs:62:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n15 |         } else {\n   |   \
    \             - unclosed delimiter\n...\n22 |             } else {\n   |     \
    \               - unclosed delimiter\n23 |                 if l1.len() == l2.len()\
    \ {\n   |                                         - unclosed delimiter\n...\n\
    26 |                     while l1.len() > 0 && l2.len() > 0 {\n   |          \
    \                                              - unclosed delimiter\n...\n31 |\
    \                         } else {\n   |                                - unclosed\
    \ delimiter\n32 |                             if l1.len() == l2.len() {\n   |\
    \                                                     - unclosed delimiter\n...\n\
    35 |                                 while l1.len() > 0 && l2.len() > 0 {\n  \
    \ |                                                                    - unclosed\
    \ delimiter\n...\n40 |                                     } else {\n   |    \
    \                                        - unclosed delimiter\n41 |          \
    \                               if l1.len() == l2.len() {\n   |              \
    \                                                   - unclosed delimiter\n...\n\
    44 |                                             while l1.len() > 0 && l2.len()\
    \ > 0 {\n   |                                                                \
    \                - unclosed delimiter\n...\n49 |                             \
    \                    } else {\n   |                                          \
    \              - unclosed delimiter\n50 |                                    \
    \                 if l1.len() == l2.len() {\n   |                            \
    \                                                 - unclosed delimiter\n...\n\
    53 |                                                         while l1.len() >\
    \ 0 "
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_next = l1.iter().cloned();\n    let mut l2_next = l2.iter().cloned();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() {\n    \
    \        if l2_iter.any() {\n                if l1_iter.peek() == l2_iter.peek()\
    \ {\n                    l1_iter.next();\n                    l2_iter.next();\n\
    \                    l1_next.next();\n                    l2_next.next();\n  \
    \              } else {\n                    l1_iter.next();\n               \
    \     l1_next.next();\n                }\n            } else {\n             \
    \   l1_iter.next();\n                l1_next.next();\n            }\n        }\
    \ else {\n            l2_iter.next();\n            l2_next.next();\n        }\n\
    \        if l1_iter.peek() == l2_iter.peek() {\n            result.push(*l1_iter.peek());\n\
    \            l1_iter.next();\n            l1_next.next();\n        } else {\n\
    \            result.push(*l2_iter.peek());\n            l2_iter.next();\n    \
    \        l2_next.next();\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpf02aplcx.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpf02aplcx.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpf02aplcx.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpf02aplcx.rs:14:24\n\
    \     |\n14   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no method named `peek` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpf02aplcx.rs:15:28\n   |\n15 |                 if\
    \ l1_iter.peek() == l2_iter.peek() {\n   |                            ^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `peek` found for struct `Cloned` in the current scope\n  --> /tmp/tmpf02aplcx.rs:15:46\n\
    \   |\n15 |                 if l1_iter.peek() == l2_iter.peek() {\n   |      \
    \                                        ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `peek` found for struct `Cloned` in\
    \ the current scope\n  --> /tm"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          l1_el = l1.pop();\n                l2_el = l2.pop();\n            }\n\
    \            result.push(l1_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpex_ok5sk.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    let mut i = 0;\n    while i < l1.len() && i < l2.len()\
    \ {\n        if l1[i] == l2[i] {\n            i += 1;\n        } else {\n    \
    \        result.swap_remove(l1[i]);\n            result.swap_remove(l2[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1vliojs.rs:14:32\n   |\n\
    14 |             result.swap_remove(l1[i]);\n   |                            \
    \    ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n14 |      \
    \       result.swap_remove(l1[i].try_into().unwrap());\n   |                 \
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy1vliojs.rs:15:32\n   |\n15 |             result.swap_remove(l2[i]);\n\
    \   |                                ^^^^^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |             result.swap_remove(l2[i].try_into().unwrap());\n\
    \   |                                ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          if l1[0] < l2[0] {\n                l3.push(l1[0]);\n             \
    \   l1.pop();\n            } else {\n                l3.push(l2[0]);\n       \
    \         l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpkrngwmj9.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l4.len() == 0 {\n            l4.push(0);\n            l3.push(0);\n\
    \        }\n        let mut l3_iter = l3.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut l4_iter = l4.iter().cloned().collect::<Vec<_>>();\n        let\
    \ mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n        let\
    \ mut l4_iter = l4_iter.into_iter().cloned().collect::<Vec<_>>();\n        if\
    \ l3_iter.iter().any(|&x| l4_iter.iter().any(|&y| x == y)) {\n            l3_iter.push(0);\n\
    \            l4_iter.push(0);\n        }\n        if l3_iter.iter().any(|&x| l4_iter.iter().any(|&y|\
    \ x == y)) {\n            l3_iter.push(0);\n            l4_iter.push(0);\n   \
    \     }\n        if l3_iter.iter().any(|&x| l4_iter.iter().any(|&y| x == y)) {\n\
    \            l3_iter.push(0);\n            l4_iter.push(0);\n        }\n     \
    \   if l3_iter.iter().any(|&x| l4_iter.iter().any(|&y| x == y)) {\n          \
    \  l3_iter.push(0);\n            l4_iter.push(0);\n        }\n        if l3_iter.iter().any(|&x|\
    \ l4_iter.iter().any(|&y| x == y)) {\n            l3_iter.push(0);\n         \
    \   l4_iter.push(0);\n        }\n        if l3_iter.iter().any(|&x| l4_iter.iter().any(|&y|\
    \ x == y)) {\n            l3_iter.push(0);\n            l4_iter.push(0);\n   \
    \     }\n        if l3_iter.iter().any(|&x| l4_iter.iter().any(|&y| x == y)) {\n\
    \            l3_iter.push(0);\n            l4_iter.push(0);\n        }\n     \
    \   if l3_iter.iter().any(|&x| l4_iter.iter().any(|&y| x == y)) {\n          \
    \  l3_iter.push(0);\n            l4_iter.push(0);\n        }\n        if l\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpch2067or.rs:65:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l3.len() != 0 || l4.len() != 0 {\n   |                   \
    \                       - this delimiter might not be properly closed...\n...\n\
    57 | }\n   | - ...as it matches this but it has different indentation\n...\n65\
    \ | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpch2067or.rs:57:1\n\
    \   |\n56 |         if l\n   |         -- this `if` expression has a condition,\
    \ but no block\n57 | }\n   | ^ expected `{`\n\nerror[E0271]: type mismatch resolving\
    \ `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n  --> /tmp/tmpch2067or.rs:22:47\n\
    \   |\n22 |         let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                               ^^^^^^ expected `isize`, found\
    \ reference\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpch2067or.rs:22:56\n \
    \  |\n22 |           let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                                          ^^^^^^^ method\
    \ cannot be called on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<std::vec::IntoIter<isize> as Iterator>::Item = &_`\n           which\
    \ is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           which is required by `&mut Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmpch2067or.rs:23:47\n   |\n23 |     \
    \    let mut l4_iter = l4_iter.into_iter().cloned().collect::<Vec<_>>();\n   |\
    \                                               ^"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    result.sort();\n\
    \    result.dedup();\n    result.sort();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpp126ienc.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1;\n    let mut l1_iter\
    \ = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut i = 0;\n    while\
    \ i < result.len() && l1_iter.any() && l2_iter.any() {\n        if *l1_iter ==\
    \ *l2_iter {\n            result.swap(i, i);\n            i += 1;\n        }\n\
    \        l1_iter.next();\n        l2_iter.next();\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpjd3hm_ar.rs:11:39\n     |\n11   |     while i < result.len()\
    \ && l1_iter.any() && l2_iter.any() {\n     |                                \
    \       ^^^- supplied 0 arguments\n     |                                    \
    \   |\n     |                                       expected 1 argument\n    \
    \ |\nnote: associated function defined here\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n    --> /tmp/tmpjd3hm_ar.rs:11:56\n\
    \     |\n11   |     while i < result.len() && l1_iter.any() && l2_iter.any() {\n\
    \     |                                                        ^^^- supplied 0\
    \ arguments\n     |                                                        |\n\
    \     |                                                        expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0614]: type `std::slice::Iter<'_,\
    \ isize>` cannot be dereferenced\n  --> /tmp/tmpjd3hm_ar.rs:12:12\n   |\n12 |\
    \         if *l1_iter == *l2_iter {\n   |            ^^^^^^^^\n\nerror[E0614]:\
    \ type `std::slice::Iter<'_, isize>` cannot be dereferenced\n  --> /tmp/tmpjd3hm_ar.rs:12:24\n\
    \   |\n12 |         if *l1_iter == *l2_iter {\n   |                        ^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0614.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    let mut i = 0;\n    while i < l1.len() && i\
    \ < l2.len() {\n        if l1[i] == l2[i] {\n            l3.push(l1[i]);\n   \
    \         l4.push(l2[i]);\n            i += 1;\n        } else {\n           \
    \ if l1[i] < l2[i] {\n                l3.push(l1[i]);\n                l4.push(l2[i]);\n\
    \                i += 1;\n            } else {\n                l3.push(l2[i]);\n\
    \                l4.push(l1[i]);\n                i += 1;\n            }\n   \
    \     }\n    }\n    l3.extend(l4.into_iter().cloned());\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmppbd_wjns.rs:29:30\n   |\n29 |     l3.extend(l4.into_iter().cloned());\n\
    \   |                              ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmppbd_wjns.rs:29:8\n   |\n29 |     l3.extend(l4.into_iter().cloned());\n\
    \   |        ^^^^^^ expected `isize`, found reference\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n   = note: required because of\
    \ the requirements on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    let mut i = 0;\n    while i < l1.len() && i < l2.len()\
    \ {\n        if l1[i] == l2[i] {\n            result.push(i);\n            i +=\
    \ 1;\n        } else {\n            if l1[i] < l2[i] {\n                i += 1;\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpavgvp3h_.rs:12:25\n   |\n\
    12 |             result.push(i);\n   |                         ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n12 |             result.push(i.try_into().unwrap());\n\
    \   |                         ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(*l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(*l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.clone();\n            let mut l2 = l2.clone();\n            while l1.len()\
    \ != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n              \
    \      result.push(*l2.pop());\n                } else if l2.len() == 0 {\n  \
    \                  result.push(*l1.pop());\n                } else {\n       \
    \             if l1.len() == l2.len() {\n                        let mut l1 =\
    \ l1.clone();\n                        let mut l2 = l2.clone();\n            \
    \            while l1.len() != 0 || l2.len() != 0 {\n                        \
    \    if l1.len() == 0 {\n                                result.push(*l2.pop());\n\
    \                            } else if l2.len() == 0 {\n                     \
    \           result.push(*l1.pop());\n                            } else {\n  \
    \                              if l1.len() == l2.len() {\n                   \
    \                 let mut l1 = l1.clone();\n                                 \
    \   let mut l2 = l2.clone();\n                                    while l1.len()\
    \ != 0 || l2.len() != 0 {\n                                        if l1.len()\
    \ == 0 {\n                                            result.push(*l2.pop());\n\
    \                                        } else if l2.len() == 0 {\n         \
    \                                   result.push(*l1.pop());\n                \
    \                        } else {\n                                          \
    \  if l1.len() == l2.len() {\n                                               \
    \ let mut l1 = l1.clone();\n                                                let\
    \ mut l2 = l2.clone();\n                                            }\n      \
    \                                  }\n                                    }\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp95kv52ra.rs:11:25\n\
    \   |\n11 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmp95kv52ra.rs:13:25\n   |\n13 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp95kv52ra.rs:19:33\n   |\n19 |        \
    \             result.push(*l2.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp95kv52ra.rs:21:33\n\
    \   |\n21 |                     result.push(*l1.pop());\n   |                \
    \                 ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmp95kv52ra.rs:28:45\n   |\n28 | ...                   result.push(*l2.pop());\n\
    \   |                                   ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp95kv52ra.rs:30:45\n   |\n30 | ...    \
    \               result.push(*l1.pop());\n   |                                \
    \   ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n \
    \ --> /tmp/tmp95kv52ra.rs:37:57\n   |\n37 | ...                   result.push(*l2.pop());\n\
    \   |                                   ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp95kv52ra.rs:39:57\n   |\n39 | ...    \
    \               result.push(*l1.pop());\n   |                                \
    \   ^^^^^^^^^\n\nerror: aborting due to 8 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l4.len() == 0 {\n            l4.push(0);\n            l3.push(0);\n\
    \        }\n        let mut l3_iter = l3.iter();\n        let mut l4_iter = l4.iter();\n\
    \        if l3_iter.next().unwrap() != l4_iter.next().unwrap() {\n           \
    \ l3.push(0);\n            l4.push(0);\n        }\n        if l3_iter.next().unwrap()\
    \ == l4_iter.next().unwrap() {\n            l3.push(l3_iter.next().unwrap());\n\
    \            l4.push(l4_iter.next().unwrap());\n        }\n    }\n    l3.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0q_6avja.rs:27:21\n   |\n\
    27 |             l3.push(l3_iter.next().unwrap());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n27 |             l3.push(*l3_iter.next().unwrap());\n   |             \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0q_6avja.rs:28:21\n\
    \   |\n28 |             l4.push(l4_iter.next().unwrap());\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n28 |             l4.push(*l4_iter.next().unwrap());\n\
    \   |                     +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        }\n        if l3[0] == l2[0]\
    \ {\n            l3.remove(0);\n            l4.remove(0);\n        } else {\n\
    \            l3.remove(0);\n            l4.remove(0);\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm0_4exco.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpm0_4exco.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  if l1.len() == l2.len() {\n                while l1.len() != 0 {\n        \
    \            result.push(l1.pop());\n                }\n                while\
    \ l2.len() != 0 {\n                    result.push(l2.pop());\n              \
    \  }\n            } else {\n                while l1.len() != l2.len() {\n   \
    \                 l1.pop();\n                    l2.pop();\n                }\n\
    \                while l1.len() != 0 {\n                    result.push(l1.pop());\n\
    \                }\n                while l2.len() != 0 {\n                  \
    \  result.push(l2.pop());\n                }\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj0kh2t6c.rs:39:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n39 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any()\
    \ || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any() {\n          \
    \  if l1_iter.peek() == l2_iter.peek() {\n                result.push(l1_iter.next());\n\
    \                result.push(l2_iter.next());\n            } else {\n        \
    \        let mut l1_peek = l1_iter.peek();\n                let mut l2_peek =\
    \ l2_iter.peek();\n                while l1_peek == l2_peek {\n              \
    \      l1_iter.next();\n                    l2_iter.next();\n                \
    \    l1_peek = l1_iter.peek();\n                    l2_peek = l2_iter.peek();\n\
    \                }\n                result.push(l1_peek);\n                result.push(l2_peek);\n\
    \            }\n        } else if l1_iter.any() {\n            result.push(l1_iter.next());\n\
    \        } else {\n            result.push(l2_iter.next());\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmphcabbxpi.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmphcabbxpi.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmphcabbxpi.rs:11:20\n\
    \     |\n11   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmphcabbxpi.rs:11:37\n     |\n11   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmphcabbxpi.rs:12:24\n   |\n12 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmphcabbxpi.rs:12:42\n\
    \   |\n12 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0308]: mismatched types\n  -->"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut common = vec![];\n    while l1.len() != 0 ||\
    \ l2.len() != 0 {\n        if l1.len() == 0 {\n            l1.push(0);\n     \
    \   }\n        if l2.len() == 0 {\n            l2.push(0);\n        }\n      \
    \  let mut i = 0;\n        while l1.len() != 0 && l2.len() != 0 && l1.get(0) <\
    \ l2.get(0) {\n            i += 1;\n            l1.pop();\n            l2.pop();\n\
    \        }\n        if l1.len() != 0 || l2.len() != 0 {\n            common.push(i);\n\
    \        }\n    }\n    common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpel3i8n01.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: -1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == 1 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l2.len() == 1 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == l2.len() {\n            l3.pop();\n           \
    \ l4.pop();\n        } else if l1.len() < l2.len() {\n            l3.pop();\n\
    \            l4.pop();\n        } else {\n            l3.pop();\n            l4.pop();\n\
    \        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747517
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    let mut i = 0;\n    while i < l1.len() && i\
    \ < l2.len() {\n        if l1[i] < l2[i] {\n            l3.push(l1[i]);\n    \
    \        l4.push(l2[i]);\n            i += 1;\n        } else {\n            l3.push(l2[i]);\n\
    \            l4.push(l1[i]);\n            i += 1;\n        }\n    }\n    while\
    \ i < l1.len() {\n        l3.push(l1[i]);\n        i += 1;\n    }\n    while i\
    \ < l2.len() {\n        l3.push(l2[i]);\n        i += 1;\n    }\n    l3\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 1, 4, 1, 5, 9, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp9pg1ywa0.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != l4.len() {\n        if l3[l3.len()\
    \ - 1] < l4[l4.len() - 1] {\n            l3.pop();\n            l4.pop();\n  \
    \      } else {\n            l3.pop();\n            l4.pop();\n        }\n   \
    \ }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp5wlxdeiw.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut i = 0;\n    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any()\
    \ {\n            if l2_iter.any() {\n                if l1_iter.peek() == l2_iter.peek()\
    \ {\n                    result.remove(i);\n                    i += 1;\n    \
    \            } else {\n                    l1_iter.next();\n                 \
    \   l2_iter.next();\n                }\n            } else {\n               \
    \ l1_iter.next();\n            }\n        } else {\n            l2_iter.next();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpwd7wovgl.rs:11:19\n     |\n11   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpwd7wovgl.rs:11:36\n\
    \     |\n11   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpwd7wovgl.rs:12:20\n\
    \     |\n12   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpwd7wovgl.rs:13:24\n\
    \     |\n13   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no method named `peek` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpwd7wovgl.rs:14:28\n   |\n14 |                 if\
    \ l1_iter.peek() == l2_iter.peek() {\n   |                            ^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `peek` found for struct `Cloned` in the current scope\n  --> /tmp/tmpwd7wovgl.rs:14:46\n\
    \   |\n14 |                 if l1_iter.peek() == l2_iter.peek() {\n   |      \
    \                                        ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E059"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          let mut l1_el = l1[0];\n            let mut l2_el = l2[0];\n      \
    \      while l1_el == l2_el {\n                l1_el = l1[0];\n              \
    \  l2_el = l2[0];\n            }\n            l3.push(l1_el);\n            l1.pop();\n\
    \            l2.pop();\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmponqaa2ii.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    l1.iter().zip(l2.iter()).filter(|&(a,\
    \ b)| a == b).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n  --> /tmp/tmpt5qi5pxb.rs:11:55\n\
    \   |\n11 |     l1.iter().zip(l2.iter()).filter(|&(a, b)| a == b).collect()\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \   |\n   = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut i = 0;\n    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any()\
    \ && l2_iter.any() {\n            if l1_iter.peek() == l2_iter.peek() {\n    \
    \            result.push(*l1_iter.next());\n                i += 1;\n        \
    \    } else {\n                i += 1;\n            }\n        } else if l1_iter.any()\
    \ {\n            result.push(*l1_iter.next());\n            i += 1;\n        }\
    \ else if l2_iter.any() {\n            result.push(*l2_iter.next());\n       \
    \     i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpiacveo5l.rs:11:19\n     |\n11   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpiacveo5l.rs:11:36\n\
    \     |\n11   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpiacveo5l.rs:12:20\n\
    \     |\n12   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpiacveo5l.rs:12:37\n     |\n12   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpiacveo5l.rs:13:24\n   |\n13 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `peek` found for struct `Cloned` in the current scope\n  --> /tmp/tmpiacveo5l.rs:13:42\n\
    \   |\n13 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0614]: type `Option<isize>` canno"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          l1_el = l1.pop();\n                l2_el = l2.pop();\n            }\n\
    \            result.push(l1_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnyhgai4g.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != l2.len() {\n        if l1.len() == 0 {\n            break;\n\
    \        }\n        if l2.len() == 0 {\n            break;\n        }\n      \
    \  if l1[0] < l2[0] {\n            result.remove(l1[0]);\n            l1.remove(0);\n\
    \        } else {\n            result.remove(l2[0]);\n            l2.remove(0);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzpfkkcof.rs:18:27\n   |\n\
    18 |             result.remove(l1[0]);\n   |                           ^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |             result.remove(l1[0].try_into().unwrap());\n\
    \   |                           ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzpfkkcof.rs:21:27\n   |\n21 |             result.remove(l2[0]);\n\
    \   |                           ^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n21 |             result.remove(l2[0].try_into().unwrap());\n\
    \   |                           ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          l1_el = l1.pop();\n                l2_el = l2.pop();\n            }\n\
    \            result.push(l1_el);\n            result.push(l2_el);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm2ztw4am.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1;\n    let mut l1_iter\
    \ = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any() || l2_iter.any()\
    \ {\n        if l1_iter.any() && l2_iter.any() {\n            if l1_iter.peek()\
    \ == l2_iter.peek() {\n                l1_iter.next();\n                l2_iter.next();\n\
    \            } else {\n                result.push(*l1_iter.next());\n       \
    \         result.push(*l2_iter.next());\n            }\n        } else if l1_iter.any()\
    \ {\n            result.push(*l1_iter.next());\n        } else if l2_iter.any()\
    \ {\n            result.push(*l2_iter.next());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpi1q5yl12.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpi1q5yl12.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpi1q5yl12.rs:11:20\n\
    \     |\n11   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpi1q5yl12.rs:11:37\n     |\n11   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpi1q5yl12.rs:12:24\n   |\n12 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpi1q5yl12.rs:12:42\n\
    \   |\n12 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0614]: type `Option<&isize>` "
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort_unstable();\n\
    \    l2.sort_unstable();\n    let mut l3 = vec![];\n    while l1.len() > 0 ||\
    \ l2.len() > 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n  \
    \          l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            let mut l3_iter = l3.iter_mut();\n\
    \            let mut l3_iter = l3_iter.next_mut();\n            let mut l3_iter\
    \ = l3_iter.next_mut();\n            let mut l3_iter = l3_iter.next_mut();\n \
    \           let mut l3_iter = l3_iter.next_mut();\n            let mut l3_iter\
    \ = l3_iter.next_mut();\n            let mut l3_iter = l3_iter.next_mut();\n \
    \           let mut l3_iter = l3_iter.next_mut();\n            let mut l3_iter\
    \ = l3_iter.next_mut();\n            let mut l3_iter = l3_iter.next_mut();\n \
    \           let mut l3_iter = l3_iter.next_mut();\n            let mut l3_iter\
    \ = l3_iter.next_mut();\n            let mut l3_iter = l3_iter.next_mut();\n \
    \           let mut l3_iter = l3_iter.next_mut();\n            let mut l3_iter\
    \ = l3_iter.next_mut();\n            let mut l3_iter = l3_iter.next_mut();\n \
    \           let mut l3_iter = l3_iter.next_mut();\n            let mut l3_iter\
    \ = l3_iter.next_mut();\n            let mut l3_iter = l3_iter.next_mut();\n \
    \           let mut l3_iter = l3_iter.next_mut();\n            let mut l3_iter\
    \ = l3_iter.next_mut();\n            let mut l3_iter = l3_iter.next_mut();\n \
    \           let mut l3_iter = l3_iter.next_mut();\n            let mut l3_iter\
    \ = l3_iter.next_mut();\n            let mut l3_iter = l3_iter.next_mut();\n \
    \           let mut l3_iter = l3_iter.next_mut();\n            let mut l3_iter\
    \ = l3_iter.next_mut();\n            let mut l3_iter = l3_iter.next_mut();\n \
    \           let mut l3_iter = l3_iter.next_mut();\n            let mut l3_iter\
    \ = l3_iter.next_mut();\n            let mut l3_iter = l\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7f_enz2_.rs:59:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n12 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n19 |         } else {\n   |   \
    \             - this delimiter might not be properly closed...\n...\n51 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n59 | }\n\
    \   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp7f_enz2_.rs:50:32\n\
    \   |\n50 |             let mut l3_iter = l\n   |                            \
    \    ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `l` in this scope\n  --> /tmp/tmp7f_enz2_.rs:50:31\n   |\n50 |  \
    \           let mut l3_iter = l\n   |                               ^ help: a\
    \ local variable with a similar name exists: `l1`\n\nerror[E0599]: no method named\
    \ `next_mut` found for struct `std::slice::IterMut` in the current scope\n  -->\
    \ /tmp/tmp7f_enz2_.rs:21:39\n   |\n21 |             let mut l3_iter = l3_iter.next_mut();\n\
    \   |                                       ^^^^^^^^ method not found in `std::slice::IterMut<'_,\
    \ isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f_enz2_.rs:12:5\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n12 | /     while l1.len() > 0 || l2.len() > 0 {\n\
    13 | |         if l1.len() == 0 {\n14 | |             l3.push(l2[0]);\n15 | |\
    \             l2.pop();\n...  |\n58 | |     assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n59 | | }\n   | |__^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() == 0 {\n            l3.pop();\n        }\n        if l4.len()\
    \ == 0 {\n            l4.pop();\n        }\n        if l3[0] == l4[0] {\n    \
    \        l3.pop();\n            l4.pop();\n        } else {\n            l3.pop();\n\
    \            l4.pop();\n        }\n    }\n    l1.iter().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpq88jl3gk.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        let mut l1_next = l1_iter.next();\n\
    \        let mut l2_next = l2_iter.next();\n        if l1_next.unwrap() == l2_next.unwrap()\
    \ {\n            result.remove(l1_next.unwrap());\n            l1_iter.remove(l1_next.unwrap());\n\
    \            l2_iter.remove(l2_next.unwrap());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `any` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpt6y1o3bi.rs:10:19\n   |\n10 |     while l1_iter.any()\
    \ || l2_iter.any() {\n   |                   ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `any` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpt6y1o3bi.rs:10:36\n   |\n10 |     while l1_iter.any() ||\
    \ l2_iter.any() {\n   |                                    ^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpt6y1o3bi.rs:11:35\n   |\n11 |         let\
    \ mut l1_next = l1_iter.next();\n   |                                   ^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpt6y1o3bi.rs:12:35\n\
    \   |\n12 |         let mut l2_next = l2_iter.next();\n   |                  \
    \                 ^^^^ method not found in `Vec<isize>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n           \
    \     l1.pop();\n            } else {\n                l3.push(l2[0]);\n     \
    \           l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpjetwnru2.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any()\
    \ || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any() {\n          \
    \  if l1_iter.peek() == l2_iter.peek() {\n                l1_iter.next();\n  \
    \              l2_iter.next();\n            } else {\n                result.push(*l1_iter.next());\n\
    \                result.push(*l2_iter.next());\n            }\n        } else\
    \ if l1_iter.any() {\n            result.push(*l1_iter.next());\n        } else\
    \ {\n            result.push(*l2_iter.next());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpa14bdhgj.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpa14bdhgj.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpa14bdhgj.rs:11:20\n\
    \     |\n11   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpa14bdhgj.rs:11:37\n     |\n11   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpa14bdhgj.rs:12:24\n   |\n12 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpa14bdhgj.rs:12:42\n\
    \   |\n12 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0614]: type `Option<&isize>` "
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwkce5gc4.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != l2.len() {\n        let mut found = false;\n        for\
    \ (i, &e) in l1.iter().enumerate() {\n            if l2.contains(&e) {\n     \
    \           result.push(i);\n                l1.remove(&e);\n                l2.remove(&e);\n\
    \                found = true;\n                break;\n            }\n      \
    \  }\n        if !found {\n            result.push(i);\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpq1so2o7x.rs:22:25\n\
    \   |\n22 |             result.push(i);\n   |                         ^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1so2o7x.rs:14:29\n\
    \   |\n14 |                 result.push(i);\n   |                            \
    \ ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n14 |        \
    \         result.push(i.try_into().unwrap());\n   |                          \
    \   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1so2o7x.rs:15:27\n\
    \   |\n15 |                 l1.remove(&e);\n   |                           ^^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1so2o7x.rs:16:27\n\
    \   |\n16 |                 l2.remove(&e);\n   |                           ^^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any()\
    \ || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any() {\n          \
    \  if l1_iter.peek() == l2_iter.peek() {\n                l1_iter.next();\n  \
    \              l2_iter.next();\n            } else {\n                break;\n\
    \            }\n        } else if l1_iter.any() {\n            result.push(l1_iter.peek());\n\
    \            l1_iter.next();\n        } else if l2_iter.any() {\n            result.push(l2_iter.peek());\n\
    \            l2_iter.next();\n        } else {\n            break;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp_0mf8mqt.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmp_0mf8mqt.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmp_0mf8mqt.rs:11:20\n\
    \     |\n11   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp_0mf8mqt.rs:11:37\n     |\n11   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp_0mf8mqt.rs:12:24\n   |\n12 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp_0mf8mqt.rs:12:42\n\
    \   |\n12 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0061]: this function takes 1 "
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.push(l2.pop());\n        } else if l2.len()\
    \ == 0 {\n            l4.push(l1.pop());\n        } else {\n            if l1.pop()\
    \ == l2.pop() {\n                l3.push(l2.pop());\n            } else {\n  \
    \              l4.push(l1.pop());\n            }\n        }\n    }\n    l3.extend(l4);\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgb5_od0.rs:13:21\n   |\n\
    13 |             l3.push(l2.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprgb5_od0.rs:15:21\n   |\n15 |             l4.push(l1.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprgb5_od0.rs:18:25\n   |\n18 |  \
    \               l3.push(l2.pop());\n   |                         ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprgb5_od0.rs:20:25\n   |\n20 |                 l4.push(l1.pop());\n \
    \  |                         ^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    let mut i = 0;\n    while i < l1.len() && i\
    \ < l2.len() {\n        if l1[i] < l2[i] {\n            l3.push(l1[i]);\n    \
    \        l4.push(l2[i]);\n            i += 1;\n        } else {\n            l3.push(l2[i]);\n\
    \            l4.push(l1[i]);\n            i += 1;\n        }\n    }\n    l3.extend(l4.into_iter().cloned());\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpjcdfxq2p.rs:23:30\n   |\n23 |     l3.extend(l4.into_iter().cloned());\n\
    \   |                              ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpjcdfxq2p.rs:23:8\n   |\n23 |     l3.extend(l4.into_iter().cloned());\n\
    \   |        ^^^^^^ expected `isize`, found reference\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n   = note: required because of\
    \ the requirements on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort_unstable();\n\
    \    l2.sort_unstable();\n    let mut l3 = Vec::new();\n    while l1.len() > 0\
    \ || l2.len() > 0 {\n        if l1.len() == 0 {\n            l3.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n        }\
    \ else {\n            if l1.last().unwrap() == l2.last().unwrap() {\n        \
    \        l3.push(l1.pop());\n                l3.push(l2.pop());\n            }\
    \ else {\n                break;\n            }\n        }\n    }\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl_i_w_x8.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut result = vec![];\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2[0]);\n            l2.pop();\n        } else if l2.len()\
    \ == 0 {\n            result.push(l1[0]);\n            l1.pop();\n        } else\
    \ {\n            if l1[0] < l2[0] {\n                result.push(l1[0]);\n   \
    \             l1.pop();\n            } else {\n                result.push(l2[0]);\n\
    \                l2.pop();\n            }\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpfpsn6x5x.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          l1_el = l1.pop();\n                l2_el = l2.pop();\n            }\n\
    \            result.push(l1_el);\n            result.push(l2_el);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpksmlffcy.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = l1.len();\n    while i < k {\n        if l1[i] ==\
    \ l2[j] {\n            i += 1;\n            j += 1;\n        } else {\n      \
    \      if l1[i] < l2[j] {\n                i += 1;\n            } else {\n   \
    \             j += 1;\n            }\n        }\n    }\n    l1.drain(..k);\n \
    \   l2.drain(..k);\n    l1\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpjn4iwp3i.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_next = l1.iter().cloned();\n    let mut l2_next = l2.iter().cloned();\n\
    \    while l1_iter.next() && l2_iter.next() {\n        if *l1_iter == *l2_iter\
    \ {\n            result.push(*l1_iter);\n            l1_iter.next();\n       \
    \     l2_iter.next();\n        } else if *l1_iter < *l2_iter {\n            l1_next.next();\n\
    \        } else {\n            l2_next.next();\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe1830z11.rs:12:11\n   |\n\
    12 |     while l1_iter.next() && l2_iter.next() {\n   |           ^^^^^^^^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe1830z11.rs:12:29\n   |\n12 |     while l1_iter.next() && l2_iter.next()\
    \ {\n   |                             ^^^^^^^^^^^^^^ expected `bool`, found enum\
    \ `Option`\n   |\n   = note: expected type `bool`\n              found enum `Option<isize>`\n\
    \nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmpe1830z11.rs:13:12\n   |\n13 |         if *l1_iter == *l2_iter {\n\
    \   |            ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>`\
    \ cannot be dereferenced\n  --> /tmp/tmpe1830z11.rs:13:24\n   |\n13 |        \
    \ if *l1_iter == *l2_iter {\n   |                        ^^^^^^^^\n\nerror[E0614]:\
    \ type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n  --> /tmp/tmpe1830z11.rs:14:25\n\
    \   |\n14 |             result.push(*l1_iter);\n   |                         ^^^^^^^^\n\
    \nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmpe1830z11.rs:17:19\n   |\n17 |         } else if *l1_iter < *l2_iter\
    \ {\n   |                   ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmpe1830z11.rs:17:30\n   |\n17 |\
    \         } else if *l1_iter < *l2_iter {\n   |                              ^^^^^^^^\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        if l1.len() == 0\
    \ {\n            break;\n        }\n        if l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            result.push(*l1.pop());\n\
    \            l2.pop();\n            continue;\n        }\n        if l2.len()\
    \ == 1 {\n            result.push(*l2.pop());\n            l1.pop();\n       \
    \     continue;\n        }\n        if l1.len() == 2 {\n            if l2.len()\
    \ == 2 {\n                if l1.pop() == l2.pop() {\n                    l1.pop();\n\
    \                    l2.pop();\n                } else {\n                   \
    \ result.push(*l1.pop());\n                    l2.pop();\n                }\n\
    \            } else {\n                result.push(*l1.pop());\n             \
    \   l2.pop();\n            }\n        } else {\n            if l2.len() == 2 {\n\
    \                if l1.pop() == l2.pop() {\n                    l1.pop();\n  \
    \                  l2.pop();\n                } else {\n                    result.push(*l1.pop());\n\
    \                    l2.pop();\n                }\n            } else {\n    \
    \            result.push(*l1.pop());\n                l2.pop();\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpeaghkfo4.rs:17:25\n\
    \   |\n17 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpeaghkfo4.rs:22:25\n   |\n22 |             result.push(*l2.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpeaghkfo4.rs:32:33\n   |\n32 |        \
    \             result.push(*l1.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpeaghkfo4.rs:36:29\n\
    \   |\n36 |                 result.push(*l1.pop());\n   |                    \
    \         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmpeaghkfo4.rs:45:33\n   |\n45 |                     result.push(*l1.pop());\n\
    \   |                                 ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpeaghkfo4.rs:49:29\n   |\n49 |        \
    \         result.push(*l1.pop());\n   |                             ^^^^^^^^^\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    result.sort();\n\
    \    let mut l2 = l2.clone();\n    l2.sort();\n    let mut i = 0;\n    while i\
    \ < result.len() && i < l2.len() {\n        if result[i] == l2[i] {\n        \
    \    i += 1;\n        } else {\n            result.swap(i, result.len() - 1);\n\
    \            result.swap(i, result.len() - 1);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `result` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp2310jcfk.rs:16:28\n   |\n16 |             result.swap(i,\
    \ result.len() - 1);\n   |             ------ ----    ^^^^^^ immutable borrow\
    \ occurs here\n   |             |      |\n   |             |      mutable borrow\
    \ later used by call\n   |             mutable borrow occurs here\n\nerror[E0502]:\
    \ cannot borrow `result` as immutable because it is also borrowed as mutable\n\
    \  --> /tmp/tmp2310jcfk.rs:17:28\n   |\n17 |             result.swap(i, result.len()\
    \ - 1);\n   |             ------ ----    ^^^^^^ immutable borrow occurs here\n\
    \   |             |      |\n   |             |      mutable borrow later used\
    \ by call\n   |             mutable borrow occurs here\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        if l1.len() == 0\
    \ {\n            break;\n        }\n        if l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 1 {\n     \
    \           result.push(l1[0]);\n            } else {\n                break;\n\
    \            }\n        }\n        if l2.len() == 1 {\n            if l1.len()\
    \ == 1 {\n                result.push(l2[0]);\n            } else {\n        \
    \        break;\n            }\n        }\n        if l1[0] < l2[0] {\n      \
    \      result.push(l1[0]);\n            l1.remove(0);\n        } else {\n    \
    \        result.push(l2[0]);\n            l2.remove(0);\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpi_cc2svj.rs:32:13\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n32 |             l1.remove(0);\n   |             ^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: -1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 0 {\n     \
    \           l3.pop();\n                l4.pop();\n            }\n            l3.pop();\n\
    \            l4.pop();\n        }\n        if l2.len() == 1 {\n            if\
    \ l1.len() == 0 {\n                l3.pop();\n                l4.pop();\n    \
    \        }\n            l3.pop();\n            l4.pop();\n        }\n        if\
    \ l1.len() == l2.len() {\n            if l1.len() == 1 {\n                l3.pop();\n\
    \                l4.pop();\n            }\n            l3.pop();\n           \
    \ l4.pop();\n        }\n        if l1.len() > l2.len() {\n            l3.pop();\n\
    \            l4.pop();\n        }\n        if l1.len() < l2.len() {\n        \
    \    l3.pop();\n            l4.pop();\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747517
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut common: Vec<isize> = vec![];\n    while i < l1.len()\
    \ && j < l2.len() {\n        if l1[i] == l2[j] {\n            common.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else {\n            if l1[i]\
    \ < l2[j] {\n                i += 1;\n            } else {\n                j\
    \ += 1;\n            }\n        }\n    }\n    common\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_iter\
    \ = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any() || l2_iter.any()\
    \ {\n        if l1_iter.any() {\n            if l2_iter.any() {\n            \
    \    if l1_iter.next() == l2_iter.next() {\n                    l1_iter.next();\n\
    \                    l2_iter.next();\n                }\n            } else {\n\
    \                result.push(*l1_iter.next());\n            }\n        } else\
    \ {\n            result.push(*l2_iter.next());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpw24lb4s5.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpw24lb4s5.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpw24lb4s5.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpw24lb4s5.rs:14:24\n\
    \     |\n14   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpw24lb4s5.rs:20:29\n\
    \   |\n20 |                 result.push(*l1_iter.next());\n   |              \
    \               ^^^^^^^^^^^^^^^\n\nerror[E0614]: type `Option<&isize>` cannot\
    \ be dereferenced\n  --> /tmp/tmpw24lb4s5.rs:23:25\n   |\n23 |             result.push(*l2_iter.next());\n\
    \   |                         ^^^^^^^^^^^^^^^\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    let mut i = 0;\n    while i < l1.len() && i < l2.len()\
    \ {\n        if l1[i] == l2[i] {\n            result.push(i);\n            i +=\
    \ 1;\n        } else {\n            if l1[i] < l2[i] {\n                i += 1;\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpavgvp3h_.rs:12:25\n   |\n\
    12 |             result.push(i);\n   |                         ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n12 |             result.push(i.try_into().unwrap());\n\
    \   |                         ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    while\
    \ i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n            i +=\
    \ 1;\n        } else {\n            l1.remove(&l1[i]);\n            l2.remove(&l2[i]);\n\
    \        }\n    }\n    l1.extend(l2.into_iter().cloned());\n    l1\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxues1ya.rs:16:23\n   |\n\
    16 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxues1ya.rs:17:23\n\
    \   |\n17 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmpjxues1ya.rs:20:30\n   |\n20 |     l1.extend(l2.into_iter().cloned());\n\
    \   |                              ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpjxues1ya.rs:20:8\n   |\n20 |     l1.extend(l2.into_iter().cloned());\n\
    \   |        ^^^^^^ expected `isize`, found reference\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n   = note: required because of\
    \ the requirements on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwkce5gc4.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() ==\
    \ 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l1_el\
    \ = l1.pop();\n                l2_el = l2.pop();\n            }\n            result.push(l1_el);\n\
    \            result.push(l2_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu0qsy86w.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.push(l2.pop());\n        } else if l2.len()\
    \ == 0 {\n            l4.push(l1.pop());\n        } else {\n            let mut\
    \ l5 = l3.clone();\n            let mut l6 = l4.clone();\n            while l5.len()\
    \ != 0 || l6.len() != 0 {\n                if l5.len() == 0 {\n              \
    \      l6.push(l5.pop());\n                } else if l6.len() == 0 {\n       \
    \             l5.push(l6.pop());\n                } else {\n                 \
    \   if l5.pop() == l6.pop() {\n                        l5.push(l6.pop());\n  \
    \                  }\n                }\n            }\n        }\n    }\n   \
    \ l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpccptgnox.rs:13:21\n   |\n\
    13 |             l3.push(l2.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpccptgnox.rs:15:21\n   |\n15 |             l4.push(l1.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpccptgnox.rs:21:29\n   |\n21 |  \
    \                   l6.push(l5.pop());\n   |                             ^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpccptgnox.rs:23:29\n   |\n23 |                     l5.push(l6.pop());\n\
    \   |                             ^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpccptgnox.rs:26:33\n   |\n26 |\
    \                         l5.push(l6.pop());\n   |                           \
    \      ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<isize>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.into_iter().collect()\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw7sbjyub.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw7sbjyub.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    let mut i = 0;\n    while i < l1.len() && i < l2.len()\
    \ {\n        if l1[i] < l2[i] {\n            result.swap(i, l1.len());\n     \
    \       i += 1;\n        } else {\n            result.swap(i, l2.len());\n   \
    \         i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 7 but the
    index is 7'', /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/mod.rs:566:36

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.iter().next().unwrap() == l2.iter().next().unwrap()\
    \ {\n                l3.push(l1.pop());\n                l3.push(l2.pop());\n\
    \            } else {\n                l3.push(l1.pop());\n            }\n   \
    \     }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps70ygs4j.rs:24:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            if l3[0]\
    \ == l2[0] {\n                l3.remove(0);\n                l4.remove(0);\n \
    \           } else {\n                l3.remove(0);\n            }\n        }\n\
    \    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4fwn871t.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4fwn871t.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            while l1.len() != 0 || l2.len() != 0 {\n                if l1.len()\
    \ == 0 {\n                    result.push(l2.pop());\n                } else if\
    \ l2.len() == 0 {\n                    result.push(l1.pop());\n              \
    \  } else {\n                    if l1.last().unwrap() == l2.last().unwrap() {\n\
    \                        l1.pop();\n                        l2.pop();\n      \
    \              } else {\n                        break;\n                    }\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphmh3353u.rs:34:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n34 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                let\
    \ mut i = l1.iter().cloned().collect::<Vec<_>>();\n                let mut j =\
    \ l2.iter().cloned().collect::<Vec<_>>();\n                while i.len() != 0\
    \ || j.len() != 0 {\n                    if i.len() == 0 {\n                 \
    \       l3.push(j.pop());\n                    } else if j.len() == 0 {\n    \
    \                    l3.push(i.pop());\n                    } else {\n       \
    \                 if i.len() == j.len() {\n                            if i.len()\
    \ == 1 {\n                                l3.push(i.pop());\n                \
    \            } else if j.len() == 1 {\n                                l3.push(j.pop());\n\
    \                            } else {\n                                let mut\
    \ i = i.iter().cloned().collect::<Vec<_>>();\n                               \
    \ let mut j = j.iter().cloned().collect::<Vec<_>>();\n                       \
    \         while i.len() != 0 || j.len() != 0 {\n                             \
    \       if i.len() == 0 {\n                                        l3.push(j.pop());\n\
    \                                    } else if j.len() == 0 {\n              \
    \                          l3.push(i.pop());\n                               \
    \     } else {\n                                        if i.len() == j.len()\
    \ {\n                                            if i.len() == 1 {\n         \
    \                                       l3.push(i.pop());\n                  \
    \                          } else if j.len() == 1 {\n                        \
    \                        l3.push(j.pop());\n                                 \
    \           } else {\n                                                let mut\
    \ i = i.iter().cloned().collect::<Vec<_>>();\n                               \
    \                 let mut j = j.iter().cloned().collect::<Vec<_>>();\n       \
    \                                         while i.len() != 0 || j.len() != 0 {\n\
    \                                                    if i.len() == 0 {\n     \
    \                                                   l3.push(j.pop());\n      \
    \                                              } else if j.len() == 0 {\n    \
    \                                                    l3.push(i.pop());\n     \
    \                                               } else {\n                   \
    \                                     if i.len() == j.len() {\n              \
    \                                              if i.len() == 1 {\n           \
    \                                                     l3.push(i.pop());\n    \
    \                                                        } else if j.len() ==\
    \ 1 {\n                                                                l3.push(j.pop());\n\
    \                                                            } else {\n      \
    \                                                          let mut i = i.iter().cloned().collect::<Vec<_>>();\n\
    \                                                                let mut j = j.iter().cloned().\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmfkzznrf.rs:69:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n15 |         } else {\n   |\
    \                - unclosed delimiter\n16 |             if l1.len() == l2.len()\
    \ {\n   |                                     - unclosed delimiter\n...\n19 |\
    \                 while i.len() != 0 || j.len() != 0 {\n   |                 \
    \                                   - unclosed delimiter\n...\n24 |          \
    \           } else {\n   |                            - unclosed delimiter\n25\
    \ |                         if i.len() == j.len() {\n   |                    \
    \                           - unclosed delimiter\n...\n30 |                  \
    \           } else {\n   |                                    - unclosed delimiter\n\
    ...\n33 |                                 while i.len() != 0 || j.len() != 0 {\n\
    \   |                                                                    - unclosed\
    \ delimiter\n...\n38 |                                     } else {\n   |    \
    \                                        - unclosed delimiter\n39 |          \
    \                               if i.len() == j.len() {\n   |                \
    \                                               - unclosed delimiter\n...\n44\
    \ |                                             } else {\n   |               \
    \                                     - unclosed delimiter\n...\n47 |        \
    \                                         while i.len() != 0 || j.len() != 0 {\n\
    \   |                                                                        \
    \            - unclosed delimiter\n...\n52 |                                 \
    \                    } else {\n   |                                          \
    \                  - unclosed delimiter\n53 |                                \
    \                         if i.len() == j.len() {\n   |                      \
    \       "
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1[l1[0]]\
    \ == l2[l2[0]] {\n                    l3.pop();\n                    l4.pop();\n\
    \                } else {\n                    l3.pop();\n                   \
    \ l4.pop();\n                    l3.push(l1[l1[0]]);\n                    l4.push(l2[l2[0]]);\n\
    \                }\n            } else {\n                if l1[l1[0]] > l2[l2[0]]\
    \ {\n                    l3.pop();\n                    l4.pop();\n          \
    \          l3.push(l1[l1[0]]);\n                    l4.push(l2[l2[0]]);\n    \
    \            } else {\n                    l3.pop();\n                    l4.pop();\n\
    \                    l3.push(l1[l1[0]]);\n                    l4.push(l2[l2[0]]);\n\
    \                    l3.push(l1[l1[0]]);\n                    l4.push(l2[l2[0]]);\n\
    \                }\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1jukrgp8.rs:20:20\n\
    \   |\n20 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \    ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp1jukrgp8.rs:20:33\n   |\n20 |                 if l1[l1[0]] == l2[l2[0]]\
    \ {\n   |                                 ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp1jukrgp8.rs:26:29\n   |\n26 |  \
    \                   l3.push(l1[l1[0]]);\n   |                             ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1jukrgp8.rs:27:29\n\
    \   |\n27 |                     l4.push(l2[l2[0]]);\n   |                    \
    \         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp1jukrgp8.rs:30:20\n   |\n30 |                 if l1[l1[0]] > l2[l2[0]]\
    \ {\n   |                    ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l3_el\
    \ = l1_el;\n                l1_el = l1.pop();\n                l2_el = l2.pop();\n\
    \            }\n            l3.push(l3_el);\n        }\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `l3_el` in this scope\n  --> /tmp/tmpzgjsu__r.rs:19:17\n\
    \   |\n19 |                 l3_el = l1_el;\n   |                 ^^^^^ help: a\
    \ local variable with a similar name exists: `l1_el`\n\nerror[E0425]: cannot find\
    \ value `l3_el` in this scope\n  --> /tmp/tmpzgjsu__r.rs:23:21\n   |\n23 |   \
    \          l3.push(l3_el);\n   |                     ^^^^^ help: a local variable\
    \ with a similar name exists: `l1_el`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzgjsu__r.rs:26:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n26 |     l3\n   |     ^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == 1 {\n            if l2.len() == 1 {\n         \
    \       l3.pop();\n                l4.pop();\n            } else {\n         \
    \       l3.pop();\n                l4.pop();\n            }\n        } else if\
    \ l2.len() == 1 {\n            l3.pop();\n            l4.pop();\n        } else\
    \ {\n            let mut l5 = l1.clone();\n            let mut l6 = l2.clone();\n\
    \            while l5.len() != 0 || l6.len() != 0 {\n                if l5.len()\
    \ == 0 {\n                    l6.pop();\n                    l5.pop();\n     \
    \           } else if l6.len() == 0 {\n                    l6.pop();\n       \
    \             l5.pop();\n                } else if l5.len() == 1 {\n         \
    \           if l6.len() == 1 {\n                        l6.pop();\n          \
    \              l5.pop();\n                    } else {\n                     \
    \   l6.pop();\n                        l5.pop();\n                    }\n    \
    \            } else {\n                    let mut l7 = l5.clone();\n        \
    \            let mut l8 = l6.clone();\n                    while l7.len() != 0\
    \ || l8.len() != 0 {\n                        if l7.len() == 0 {\n           \
    \                 l8.pop();\n                            l7.pop();\n         \
    \               } else if l8.len() == 0 {\n                            l8.pop();\n\
    \                            l7.pop();\n                        } else if l7.len()\
    \ == 1 {\n                            if l8.len() == 1 {\n                   \
    \             l8.pop();\n                                l7.pop();\n         \
    \                   } else {\n                                l8.pop();\n    \
    \                            l7.pop();\n                            }\n      \
    \                  } else {\n                            let mut l9 = l7.clone();\n\
    \                            let mut l10 = l8.clone();\n                     \
    \       while l9.len() != 0 || l10.len() != 0 {\n                            \
    \    if l9.len() == 0 {\n                                    l10.pop();\n    \
    \                                l9.pop();\n                                }\
    \ else if l10.len() == 0 {\n                                    l10.pop();\n \
    \                                   l9.pop();\n                              \
    \  } else if l9.len() == 1 {\n                                    if l10.len()\
    \ == 1 {\n                                        l10.pop();\n               \
    \                         l9.pop();\n                                    } else\
    \ {\n                                        l\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpc2n2ykd8.rs:89:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n29 |         } else {\n   |\
    \                - unclosed delimiter\n...\n32 |             while l5.len() !=\
    \ 0 || l6.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n47 |                 } else {\n   |             \
    \           - unclosed delimiter\n...\n50 |                     while l7.len()\
    \ != 0 || l8.len() != 0 {\n   |                                              \
    \            - unclosed delimiter\n...\n65 |                         } else {\n\
    \   |                                - unclosed delimiter\n...\n68 |         \
    \                    while l9.len() != 0 || l10.len() != 0 {\n   |           \
    \                                                        - unclosed delimiter\n\
    ...\n75 |                                 } else if l9.len() == 1 {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    79 |                                     } else {\n   |                      \
    \                      - this delimiter might not be properly closed...\n80 |\
    \                                         l\n81 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n89 | }\n   |   ^\n\nerror[E0425]: cannot\
    \ find value `l` in this scope\n  --> /tmp/tmpc2n2ykd8.rs:80:41\n   |\n80 | ...\
    \                   l\n   |                       ^ help: a local variable with\
    \ a similar name exists: `l1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc2n2ykd8.rs:11:5\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n11 | /     while l1.len() != 0 || l2.len() != 0\
    \ {\n12 | |         if l1.len() == 0 {\n13 | |             l3.pop();\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = vec![];\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n           \
    \     l1.pop();\n            } else {\n                l3.push(l2[0]);\n     \
    \           l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmp2utmn84z.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0 {\n      \
    \          if l1.front() == l2.front() {\n                    l1.pop();\n    \
    \                l2.pop();\n                } else {\n                    i +=\
    \ 1;\n                }\n            }\n            if l1.len() != 0 {\n     \
    \           result.push(l1.pop());\n            }\n            if l2.len() !=\
    \ 0 {\n                result.push(l2.pop());\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp7spv84n5.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp7spv84n5.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7spv84n5.rs:35:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n35 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() ==\
    \ 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l1_el\
    \ = l1.pop();\n                l2_el = l2.pop();\n            }\n            result.push(l1_el);\n\
    \            result.push(l2_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu0qsy86w.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.last().unwrap() == l2.last().unwrap() {\n\
    \                l3.push(l1.pop());\n                l2.pop();\n            }\
    \ else {\n                l3.push(l1.pop());\n                l2.push(l2.pop());\n\
    \            }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyw5g15s7.rs:21:25\n   |\n\
    21 |                 l2.push(l2.pop());\n   |                         ^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyw5g15s7.rs:25:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n25 |     l3\n   |     ^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<isize>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2[0]);\n            l2.pop();\n        } else if l2.len()\
    \ == 0 {\n            result.push(l1[0]);\n            l1.pop();\n        } else\
    \ {\n            let mut i = 0;\n            let mut j = 0;\n            while\
    \ i < l1.len() && j < l2.len() {\n                if l1[i] == l2[j] {\n      \
    \              i += 1;\n                    j += 1;\n                } else if\
    \ l1[i] < l2[j] {\n                    i += 1;\n                } else {\n   \
    \                 j += 1;\n                }\n            }\n            if i\
    \ == l1.len() {\n                result.push(l2[j]);\n                l2.pop();\n\
    \            } else if j == l2.len() {\n                result.push(l1[i]);\n\
    \                l1.pop();\n            } else {\n                result.push(l1[i]);\n\
    \                l1.pop();\n                result.push(l2[j]);\n            \
    \    l2.pop();\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 6 but the
    index is 6'', /tmp/tmp35sbro33.rs:31:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_len = l1.len();\n    let mut l2_len = l2.len();\n    while l1_iter.any()\
    \ || l2_iter.any() {\n        if l1_iter.any() {\n            if l2_iter.any()\
    \ {\n                if l1_iter.pop() == l2_iter.pop() {\n                   \
    \ l1_len -= 1;\n                    l2_len -= 1;\n                } else {\n \
    \                   l1_len -= 1;\n                }\n            } else {\n  \
    \              l1_len -= 1;\n            }\n        } else {\n            l2_len\
    \ -= 1;\n        }\n    }\n    result.resize(l1_len);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpq3q5iuia.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpq3q5iuia.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpq3q5iuia.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpq3q5iuia.rs:14:24\n\
    \     |\n14   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no method named `pop` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpq3q5iuia.rs:15:28\n   |\n15 |                 if\
    \ l1_iter.pop() == l2_iter.pop() {\n   |                            ^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `pop` found for struct `Cloned` in the current scope\n  --> /tmp/tmpq3q5iuia.rs:15:45\n\
    \   |\n15 |                 if l1_iter.pop() == l2_iter.pop() {\n   |        \
    \                                     ^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0061]: this function takes 2 arguments but 1 argument was\
    \ supplied\n    --> /tmp/tmpq3q5iuia.rs:"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        let mut l3_iter = l3.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut l4_iter = l4.iter().cloned().collect::<Vec<_>>();\n        if\
    \ l3_iter.len() == 0 && l4_iter.len() == 0 {\n            break;\n        }\n\
    \        let mut l3_iter = l3_iter.iter().cloned().collect::<Vec<_>>();\n    \
    \    let mut l4_iter = l4_iter.iter().cloned().collect::<Vec<_>>();\n        if\
    \ l3_iter.len() == 0 && l4_iter.len() == 0 {\n            break;\n        }\n\
    \        if l3_iter.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l4_iter.len() == 0 {\n            l3.pop();\n         \
    \   l4.pop();\n        }\n        if l3_iter.len() == 0 && l4_iter.len() == 0\
    \ {\n            break;\n        }\n        if l3_iter.len() == 0 {\n        \
    \    l3.pop();\n            l4.pop();\n        }\n        if l4_iter.len() ==\
    \ 0 {\n            l3.pop();\n            l4.pop();\n        }\n        if l3_iter.len()\
    \ == 0 && l4_iter.len() == 0 {\n            break;\n        }\n        if l3_iter.len()\
    \ == 0 {\n            l3.pop();\n            l4.pop();\n        }\n        if\
    \ l4_iter.len() == 0 {\n            l3.pop();\n            l4.pop();\n       \
    \ }\n        if l3_iter.len() == 0 && l4_iter.len() == 0 {\n            break;\n\
    \        }\n        if l3_iter.len() == 0 {\n            l3.pop();\n         \
    \   l4.pop();\n        }\n        if l4_iter.len() == 0 {\n            l3.pop();\n\
    \            l4.pop();\n        }\n        if l3_iter.len() == 0 && l4_iter.len()\
    \ == 0 {\n            break;\n        }\n        if l3_iter.len() == 0 {\n   \
    \         l3.pop();\n            l4.pop();\n        }\n        if l4_iter.len()\
    \ == 0 {\n            l3.pop();\n            l\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuzxb_6fq.rs:92:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n81 |         if l4_iter.len()\
    \ == 0 {\n   |                               - this delimiter might not be properly\
    \ closed...\n...\n84 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n92 | }\n   |   ^\n\nerror[E0425]: cannot find value `l` in this scope\n \
    \ --> /tmp/tmpuzxb_6fq.rs:83:13\n   |\n83 |             l\n   |             ^\
    \ help: a local variable with a similar name exists: `l1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuzxb_6fq.rs:11:5\n   |\n6  |   fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \          ---------- expected `Vec<isize>` because of return type\n...\n11 |\
    \ /     while l1.len() != 0 || l2.len() != 0 {\n12 | |         if l1.len() ==\
    \ 0 {\n13 | |             l3.pop();\n14 | |             l4.pop();\n...  |\n91\
    \ | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n\
    92 | | }\n   | |__^ expected struct `Vec`, found `()`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    result.sort();\n\
    \    let mut l3 = l2.clone();\n    l3.sort();\n    while l1.len() != 0 || l2.len()\
    \ != 0 {\n        if l1.len() == 0 {\n            result.push(l3.pop());\n   \
    \     } else if l2.len() == 0 {\n            result.push(l1.pop());\n        }\
    \ else {\n            if l1.pop() == l3.pop() {\n                result.push(l1.pop());\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptr50vvem.rs:13:25\n   |\n\
    13 |             result.push(l3.pop());\n   |                         ^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptr50vvem.rs:15:25\n   |\n15 |             result.push(l1.pop());\n\
    \   |                         ^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptr50vvem.rs:18:29\n   |\n18 |\
    \                 result.push(l1.pop());\n   |                             ^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut i = 0;\n            while i < l1.len()\
    \ && i < l2.len() && l1[i] == l2[i] {\n                i += 1;\n            }\n\
    \            result.push(l1[i]);\n            l1.pop();\n            l2.pop();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpkmqf5c9n.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    while\
    \ i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n            i +=\
    \ 1;\n        } else {\n            l1.swap_remove(i);\n            l2.swap_remove(i);\n\
    \        }\n    }\n    l1.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653]`,\n right: `[1, 5, 653]`', /tmp/tmp5f0kq_xi.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1[l1[0]]\
    \ == l2[l2[0]] {\n                    l3.pop();\n                    l4.pop();\n\
    \                } else {\n                    l3.pop();\n                   \
    \ l4.pop();\n                }\n            } else {\n                if l1[l1[0]]\
    \ > l2[l2[0]] {\n                    l3.pop();\n                    l4.pop();\n\
    \                } else {\n                    l3.pop();\n                   \
    \ l4.pop();\n                }\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbjwfjc23.rs:20:20\n\
    \   |\n20 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \    ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpbjwfjc23.rs:20:33\n   |\n20 |                 if l1[l1[0]] == l2[l2[0]]\
    \ {\n   |                                 ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbjwfjc23.rs:28:20\n   |\n28 |  \
    \               if l1[l1[0]] > l2[l2[0]] {\n   |                    ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbjwfjc23.rs:28:32\n\
    \   |\n28 |                 if l1[l1[0]] > l2[l2[0]] {\n   |                 \
    \               ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        let mut l1_next = l1_iter.next();\n\
    \        let mut l2_next = l2_iter.next();\n        if l1_next.unwrap() == l2_next.unwrap()\
    \ {\n            result.remove(l1_next.unwrap());\n            l1_iter.remove(l1_next.unwrap());\n\
    \            l2_iter.remove(l2_next.unwrap());\n        } else {\n           \
    \ if l1_next.unwrap() < l2_next.unwrap() {\n                l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                l1_next = l1_iter.next();\n            }\n            if l1_next.unwrap()\
    \ > l2_next.unwrap() {\n                l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                l2_next = l2_iter.next();\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `any` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp37qxhych.rs:10:19\n   |\n10 |     while l1_iter.any()\
    \ || l2_iter.any() {\n   |                   ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `any` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp37qxhych.rs:10:36\n   |\n10 |     while l1_iter.any() ||\
    \ l2_iter.any() {\n   |                                    ^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp37qxhych.rs:11:35\n   |\n11 |         let\
    \ mut l1_next = l1_iter.next();\n   |                                   ^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp37qxhych.rs:12:35\n\
    \   |\n12 |         let mut l2_next = l2_iter.next();\n   |                  \
    \                 ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `next` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp37qxhych.rs:20:35\n\
    \   |\n20 |                 l1_next = l1_iter.next();\n   |                  \
    \                 ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `next` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp37qxhych.rs:24:35\n\
    \   |\n24 |                 l2_next = l2_iter.next();\n   |                  \
    \                 ^^^^ method not found in `Vec<isize>`\n\nerror: aborting due\
    \ to 6 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.into_iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvkxhd123.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvkxhd123.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmpvkxhd123.rs:18:20\n   |\n18 |     l1.into_iter().cloned().collect()\n\
    \   |                    ^^^^^^ expected `isize`, found reference\n   |\n   =\
    \ note:   expected type `isize`\n           found reference `&_`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpvkxhd123.rs:18:29\n \
    \  |\n18 |       l1.into_iter().cloned().collect()\n   |                     \
    \          ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(*l2.pop());\n        }\n        if l2.len()\
    \ == 0 {\n            result.push(*l1.pop());\n        }\n        if l1.len()\
    \ == 0 && l2.len() == 0 {\n            break;\n        }\n        if l1.len()\
    \ == 1 {\n            if l2.len() == 1 {\n                result.push(*l1.pop());\n\
    \            } else {\n                l2.pop();\n            }\n        } else\
    \ if l2.len() == 1 {\n            l1.pop();\n        } else {\n            let\
    \ mut i = 0;\n            let mut j = 0;\n            while i < l1.len() && j\
    \ < l2.len() {\n                if l1[i] == l2[j] {\n                    i +=\
    \ 1;\n                    j += 1;\n                } else if l1[i] < l2[j] {\n\
    \                    i += 1;\n                } else {\n                    j\
    \ += 1;\n                }\n            }\n            if i == l1.len() {\n  \
    \              result.push(*l2.pop());\n            } else if j == l2.len() {\n\
    \                result.push(*l1.pop());\n            }\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpufwfs36v.rs:12:25\n\
    \   |\n12 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpufwfs36v.rs:15:25\n   |\n15 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpufwfs36v.rs:22:29\n   |\n22 |        \
    \         result.push(*l1.pop());\n   |                             ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpufwfs36v.rs:42:29\n\
    \   |\n42 |                 result.push(*l2.pop());\n   |                    \
    \         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmpufwfs36v.rs:44:29\n   |\n44 |                 result.push(*l1.pop());\n\
    \   |                             ^^^^^^^^^\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n\
    \    while l3.len() != 0 || l4.len() != 0 {\n        if l3.len() == 0 {\n    \
    \        l3.push(0);\n            l4.push(0);\n        }\n        if l4.len()\
    \ == 0 {\n            l4.push(0);\n            l3.push(0);\n        }\n      \
    \  if l3[0] == l2[0] {\n            l3.pop();\n            l4.pop();\n       \
    \ } else {\n            l3.pop();\n            l4.pop();\n        }\n    }\n \
    \   l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpabj27yql.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    while\
    \ i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n            i +=\
    \ 1;\n        } else {\n            l1.swap_remove(i);\n            l2.swap_remove(i);\n\
    \        }\n    }\n    l1.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653]`,\n right: `[1, 5, 653]`', /tmp/tmp5f0kq_xi.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpvruwvbej.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpvruwvbej.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvruwvbej.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l2.sort();\n    let mut l4 = l1.clone();\n    l4.sort();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else if l1[0]\
    \ < l2[0] {\n            l3.push(l1[0]);\n            l1.pop();\n        } else\
    \ {\n            l3.push(l2[0]);\n            l2.pop();\n        }\n    }\n  \
    \  l4\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpccphxkk4.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1.iter().any(|&x|\
    \ l2.iter().any(|&y| x == y)) {\n                    l3.push(l1.pop());\n    \
    \            } else {\n                    l3.push(l2.pop());\n              \
    \  }\n            } else {\n                let mut i = 0;\n                let\
    \ mut j = 0;\n                while i < l1.len() && j < l2.len() {\n         \
    \           if l1[i] < l2[j] {\n                        i += 1;\n            \
    \        } else {\n                        j += 1;\n                    }\n  \
    \              }\n                if i == l1.len() {\n                    l3.push(l2.pop());\n\
    \                } else if j == l2.len() {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    l3.push(l1[i]);\n             \
    \       l3.push(l2[j]);\n                }\n            }\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvwxgl0gp.rs:37:29\n   |\n\
    37 |                     l3.push(l1[i]);\n   |                             ^^^^^\n\
    \   |                             |\n   |                             expected\
    \ enum `Option`, found `isize`\n   |                             help: try using\
    \ a variant of the expected enum: `Some(l1[i])`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvwxgl0gp.rs:38:29\n   |\n38 |                     l3.push(l2[j]);\n\
    \   |                             ^^^^^\n   |                             |\n\
    \   |                             expected enum `Option`, found `isize`\n   |\
    \                             help: try using a variant of the expected enum:\
    \ `Some(l2[j])`\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvwxgl0gp.rs:43:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n43 |     l3\n   |     ^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1[l1[0]]\
    \ == l2[l2[0]] {\n                    l3.pop();\n                    l4.pop();\n\
    \                } else {\n                    l3.pop();\n                   \
    \ l4.pop();\n                    l3.push(l1[l1[0]]);\n                    l4.push(l2[l2[0]]);\n\
    \                }\n            } else {\n                if l1[l1[0]] < l2[l2[0]]\
    \ {\n                    l3.pop();\n                    l4.pop();\n          \
    \          l3.push(l1[l1[0]]);\n                } else {\n                   \
    \ l3.pop();\n                    l4.pop();\n                    l3.push(l2[l2[0]]);\n\
    \                }\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpo0p2wwe9.rs:20:20\n\
    \   |\n20 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \    ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpo0p2wwe9.rs:20:33\n   |\n20 |                 if l1[l1[0]] == l2[l2[0]]\
    \ {\n   |                                 ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpo0p2wwe9.rs:26:29\n   |\n26 |  \
    \                   l3.push(l1[l1[0]]);\n   |                             ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpo0p2wwe9.rs:27:29\n\
    \   |\n27 |                     l4.push(l2[l2[0]]);\n   |                    \
    \         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpo0p2wwe9.rs:30:20\n   |\n30 |                 if l1[l1[0]] < l2[l2[0]]\
    \ {\n   |                    ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l3_el\
    \ = l1_el;\n                l1_el = l1.pop();\n                l2_el = l2.pop();\n\
    \            }\n            l3.push(l3_el);\n        }\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `l3_el` in this scope\n  --> /tmp/tmpboa1gluf.rs:19:17\n\
    \   |\n19 |                 l3_el = l1_el;\n   |                 ^^^^^ help: a\
    \ local variable with a similar name exists: `l1_el`\n\nerror[E0425]: cannot find\
    \ value `l3_el` in this scope\n  --> /tmp/tmpboa1gluf.rs:23:21\n   |\n23 |   \
    \          l3.push(l3_el);\n   |                     ^^^^^ help: a local variable\
    \ with a similar name exists: `l1_el`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpboa1gluf.rs:26:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n26 |     l3\n   |     ^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n\
    \    while l3.len() != 0 || l4.len() != 0 {\n        if l3.len() == 0 {\n    \
    \        l3.push(0);\n            l4.push(0);\n        }\n        if l4.len()\
    \ == 0 {\n            l4.push(0);\n            l3.push(0);\n        }\n      \
    \  if l3[0] == l2[0] {\n            l3.pop();\n            l4.pop();\n       \
    \ } else {\n            l3.pop();\n            l4.pop();\n        }\n    }\n \
    \   l3.reverse();\n    l4.reverse();\n    l3.clone()\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpjijhbcfd.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_next\
    \ = l1_iter.next();\n    let mut l2_next = l2_iter.next();\n    while l1_next\
    \ && l2_next {\n        if l1_next.unwrap() == l2_next.unwrap() {\n          \
    \  result.push(l1_next.unwrap());\n            l1_next = l1_iter.next();\n   \
    \         l2_next = l2_iter.next();\n        } else if l1_next.unwrap() < l2_next.unwrap()\
    \ {\n            result.push(l1_next.unwrap());\n            l1_next = l1_iter.next();\n\
    \        } else {\n            result.push(l2_next.unwrap());\n            l2_next\
    \ = l2_iter.next();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgjm8t25w.rs:12:11\n   |\n\
    12 |     while l1_next && l2_next {\n   |           ^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgjm8t25w.rs:12:22\n\
    \   |\n12 |     while l1_next && l2_next {\n   |                      ^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgjm8t25w.rs:25:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n25 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpqb4ornlc.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut i = 0;\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any()\
    \ {\n            if l1_iter.peek() == l2_iter.peek() {\n                result.swap(i,\
    \ l1_iter.next());\n                i += 1;\n            } else {\n          \
    \      result.swap(i, l2_iter.next());\n                i += 1;\n            }\n\
    \        } else if l1_iter.any() {\n            result.swap(i, l1_iter.next());\n\
    \            i += 1;\n        } else if l2_iter.any() {\n            result.swap(i,\
    \ l2_iter.next());\n            i += 1;\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpmd_edkiq.rs:11:19\n     |\n11   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpmd_edkiq.rs:11:36\n\
    \     |\n11   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpmd_edkiq.rs:12:20\n\
    \     |\n12   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpmd_edkiq.rs:12:37\n     |\n12   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpmd_edkiq.rs:13:24\n   |\n13 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpmd_edkiq.rs:13:42\n\
    \   |\n13 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0308]: mismatched types\n  -->"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l1_el\
    \ = l1.pop();\n                l2_el = l2.pop();\n            }\n            result.push(l1_el);\n\
    \            result.push(l2_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn5gu092k.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(*l2.pop());\n            l2.pop();\n       \
    \ } else if l2.len() == 0 {\n            result.push(*l1.pop());\n           \
    \ l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(*l2.pop());\n                    l2.pop();\n\
    \                } else if l2.len() == 0 {\n                    result.push(*l1.pop());\n\
    \                    l1.pop();\n                } else {\n                   \
    \ if l1.len() == l2.len() {\n                        if l1.len() == 1 {\n    \
    \                        result.push(*l1.pop());\n                           \
    \ l1.pop();\n                        } else {\n                            result.push(*l1.pop());\n\
    \                            l1.pop();\n                        }\n          \
    \          } else {\n                        if l1.len() > l2.len() {\n      \
    \                      l1.pop();\n                        } else {\n         \
    \                   l2.pop();\n                        }\n                   \
    \ }\n                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpuy2m4qt2.rs:12:25\n\
    \   |\n12 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpuy2m4qt2.rs:15:25\n   |\n15 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpuy2m4qt2.rs:22:33\n   |\n22 |        \
    \             result.push(*l2.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpuy2m4qt2.rs:25:33\n\
    \   |\n25 |                     result.push(*l1.pop());\n   |                \
    \                 ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmpuy2m4qt2.rs:30:41\n   |\n30 | ...                   result.push(*l1.pop());\n\
    \   |                                   ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpuy2m4qt2.rs:33:41\n   |\n33 | ...    \
    \               result.push(*l1.pop());\n   |                                \
    \   ^^^^^^^^^\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_last = l1.last().unwrap();\n    let mut l2_last = l2.last().unwrap();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any()\
    \ {\n            if l1_iter.peek() == l2_iter.peek() {\n                l1_iter.next();\n\
    \                l2_iter.next();\n            } else {\n                l1_iter.next();\n\
    \                l2_iter.next();\n                l1_last = l1_iter.peek();\n\
    \                l2_last = l2_iter.peek();\n            }\n        } else if l1_iter.any()\
    \ {\n            l1_last = l1_iter.peek();\n            l1_iter.next();\n    \
    \    } else if l2_iter.any() {\n            l2_last = l2_iter.peek();\n      \
    \      l2_iter.next();\n        }\n        if l1_last == l2_last {\n         \
    \   result.push(l1_last);\n            l1_last = l1.last().unwrap();\n       \
    \     l2_last = l2.last().unwrap();\n        } else if l1_last < l2_last {\n \
    \           result.push(l1_last);\n            l1_last = l1.last().unwrap();\n\
    \        } else {\n            result.push(l2_last);\n            l2_last = l2.last().unwrap();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpgbtp84rx.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpgbtp84rx.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpgbtp84rx.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpgbtp84rx.rs:13:37\n     |\n13   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpgbtp84rx.rs:14:24\n   |\n14 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `peek` found for struct `Cloned` in the current scope\n  --> /tmp/tmpgbtp84rx.rs:14:42\n\
    \   |\n14 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `peek` fou"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwkce5gc4.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != l2.len() {\n        let mut i = 0;\n        let mut j =\
    \ 0;\n        while i < l1.len() && j < l2.len() {\n            if l1[i] < l2[j]\
    \ {\n                result.push(l1[i]);\n                i += 1;\n          \
    \  } else {\n                result.push(l2[j]);\n                j += 1;\n  \
    \          }\n        }\n        if i == l1.len() {\n            result.push(l2[j]);\n\
    \            j += 1;\n        }\n        if j == l2.len() {\n            result.push(l1[i]);\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmptyp57zjv.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n     \
    \       let mut l3_iter = l3.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1_elem = l1_iter.next();\n            let mut l2_elem = l2_iter.next();\n\
    \            while l1_elem.unwrap() == l2_elem.unwrap() {\n                l3_iter.push(l1_elem.unwrap());\n\
    \                l1_elem = l1_iter.next();\n                l2_elem = l2_iter.next();\n\
    \            }\n            l3.push(l3_iter.next().unwrap());\n        }\n   \
    \ }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpykngh4c1.rs:19:39\n   |\n19 |             let mut\
    \ l1_elem = l1_iter.next();\n   |                                       ^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpykngh4c1.rs:20:39\n\
    \   |\n20 |             let mut l2_elem = l2_iter.next();\n   |              \
    \                         ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmpykngh4c1.rs:23:35\n   |\n23 |                 l1_elem = l1_iter.next();\n\
    \   |                                   ^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `next` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpykngh4c1.rs:24:35\n   |\n24 |                 l2_elem =\
    \ l2_iter.next();\n   |                                   ^^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for struct `Vec<Option<isize>>`\
    \ in the current scope\n  --> /tmp/tmpykngh4c1.rs:26:29\n   |\n26 |          \
    \   l3.push(l3_iter.next().unwrap());\n   |                             ^^^^ method\
    \ not found in `Vec<Option<isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpykngh4c1.rs:29:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n29 |     l3\n   |     ^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() == l2_iter.any()\
    \ {\n            if l1_iter.any() {\n                let mut l1_iter = l1.iter().cloned();\n\
    \                while l1_iter.any() {\n                    let mut l2_iter =\
    \ l2.iter().cloned();\n                    while l2_iter.any() {\n           \
    \             if l1_iter.any() == l2_iter.any() {\n                          \
    \  if l1_iter.any() {\n                                l1_iter.next();\n     \
    \                           l2_iter.next();\n                                result.push(*l1_iter);\n\
    \                            }\n                        }\n                  \
    \      l2_iter.next();\n                    }\n                    l1_iter.next();\n\
    \                }\n            }\n            else {\n                let mut\
    \ l2_iter = l2.iter().cloned();\n                while l2_iter.any() {\n     \
    \               let mut l1_iter = l1.iter().cloned();\n                    while\
    \ l1_iter.any() {\n                        if l1_iter.any() == l2_iter.any() {\n\
    \                            if l1_iter.any() {\n                            \
    \    l1_iter.next();\n                                l2_iter.next();\n      \
    \                          result.push(*l1_iter);\n                          \
    \  }\n                        }\n                        l1_iter.next();\n   \
    \                 }\n                    l2_iter.next();\n                }\n\
    \            }\n        }\n        else {\n            let mut l1_iter = l1.iter().cloned();\n\
    \            while l1_iter.any() {\n                let mut l2_iter = l2.iter().cloned();\n\
    \                while l2_iter.any() {\n                    if l1_iter.any() ==\
    \ l2_iter.any() {\n                        if l1_iter.any() {\n              \
    \              l1_iter.next();\n                            l2_iter.next();\n\
    \                            result.push(*l1_iter);\n                        }\n\
    \                    }\n                    l2_iter.next();\n                }\n\
    \                l1_iter.next();\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpifmn5ysn.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpifmn5ysn.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpifmn5ysn.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() == l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpifmn5ysn.rs:13:37\n     |\n13   |         if l1_iter.any() ==\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmpifmn5ysn.rs:14:24\n     |\n14   |           \
    \  if l1_iter.any() {\n     |                        ^^^- supplied 0 arguments\n\
    \     |                        |\n     |                        expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpifmn5ysn.rs:16:31\n\
    \     |\n16   |                 while l1_iter.any() {\n     |                \
    \               ^^^- supplied 0 arguments\n     |                         "
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n\
    \    l5.sort();\n    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7\
    \ = l5.clone();\n    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n\
    \    let mut l9 = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n\
    \    l10.sort();\n    let mut l11 = l9.clone();\n    l11.sort();\n    let mut\
    \ l12 = l10.clone();\n    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n\
    \    let mut l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n\
    \    l15.sort();\n    let mut l16 = l14.clone();\n    l16.sort();\n    let mut\
    \ l17 = l15.clone();\n    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n\
    \    let mut l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n\
    \    l20.sort();\n    let mut l21 = l19.clone();\n    l21.sort();\n    let mut\
    \ l22 = l20.clone();\n    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n\
    \    let mut l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n\
    \    l25.sort();\n    let mut l26 = l24.clone();\n    l26.sort();\n    let mut\
    \ l27 = l25.clone();\n    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n\
    \    let mut l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n\
    \    l30.sort();\n    let mut l31 = l29.clone();\n    l31.sort();\n    let mut\
    \ l32 = l30.clone();\n    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n\
    \    let mut l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n\
    \    l35.sort();\n    let mut l36 = l34.clone();\n    l36.sort();\n    let mut\
    \ l37 = l35.clone();\n    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmpyau3ah7p.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    result.sort();\n\
    \    let mut l2 = l2.clone();\n    l2.sort();\n    while l1.len() != l2.len()\
    \ {\n        if l1.pop() == l2.pop() {\n            continue;\n        }\n   \
    \     break;\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpyd399lvl.rs:12:12\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n12 |         if l1.pop() == l2.pop() {\n   |            ^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    result.sort();\n\
    \    let mut j = 0;\n    for i in l2 {\n        while j < result.len() && result[j]\
    \ < i {\n            j += 1;\n        }\n        if j == result.len() {\n    \
    \        result.push(i);\n        } else {\n            result[j] = i;\n     \
    \   }\n        j += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 7, 1, 5, 9, 653, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpzi7uan_f.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   while l1_iter.any() || l2_iter.any() {\n        let mut l1_next = l1_iter.next();\n\
    \        let mut l2_next = l2_iter.next();\n        if l1_next.unwrap() == l2_next.unwrap()\
    \ {\n            result.remove(l1_next.unwrap());\n        } else {\n        \
    \    if l1_next.unwrap() < l2_next.unwrap() {\n                l1_iter = l1.iter().cloned();\n\
    \            } else {\n                l2_iter = l2.iter().cloned();\n       \
    \     }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp6uj272uu.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmp6uj272uu.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6uj272uu.rs:14:27\n   |\n14 |             result.remove(l1_next.unwrap());\n\
    \   |                           ^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |             result.remove(l1_next.unwrap().try_into().unwrap());\n\
    \   |                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        let mut i = l1.len();\n\
    \        let mut j = l2.len();\n        while i > 0 && j > 0 {\n            if\
    \ l1[i] < l2[j] {\n                result.remove(l1[i]);\n                i -=\
    \ 1;\n            } else {\n                result.remove(l2[j]);\n          \
    \      j -= 1;\n            }\n        }\n        if i == 0 {\n            break;\n\
    \        }\n        if j == 0 {\n            break;\n        }\n        result.push(l1[i]);\n\
    \        result.push(l2[j]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpscohfm5m.rs:14:31\n   |\n\
    14 |                 result.remove(l1[i]);\n   |                             \
    \  ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n14 |      \
    \           result.remove(l1[i].try_into().unwrap());\n   |                  \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpscohfm5m.rs:17:31\n   |\n17 |                 result.remove(l2[j]);\n\
    \   |                               ^^^^^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |                 result.remove(l2[j].try_into().unwrap());\n\
    \   |                               ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          result.push(l1_el);\n                l1_el = l1.pop();\n          \
    \      l2_el = l2.pop();\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkpgde7yu.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: -1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 1 {\n     \
    \           l3.pop();\n                l4.pop();\n            }\n            else\
    \ {\n                l3.pop();\n            }\n        }\n        if l2.len()\
    \ == 1 {\n            if l1.len() == 1 {\n                l3.pop();\n        \
    \        l4.pop();\n            }\n            else {\n                l3.pop();\n\
    \            }\n        }\n        if l1.len() == l2.len() {\n            l3.pop();\n\
    \            l4.pop();\n        }\n    }\n    l3.into_iter().collect()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747518
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any()\
    \ || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any() {\n          \
    \  if l1_iter.peek() == l2_iter.peek() {\n                l1_iter.next();\n  \
    \              l2_iter.next();\n            } else {\n                result.push(*l1_iter.next());\n\
    \                result.push(*l2_iter.next());\n            }\n        } else\
    \ if l1_iter.any() {\n            result.push(*l1_iter.next());\n        } else\
    \ {\n            result.push(*l2_iter.next());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpa14bdhgj.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpa14bdhgj.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpa14bdhgj.rs:11:20\n\
    \     |\n11   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpa14bdhgj.rs:11:37\n     |\n11   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpa14bdhgj.rs:12:24\n   |\n12 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpa14bdhgj.rs:12:42\n\
    \   |\n12 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0614]: type `Option<&isize>` "
  stdout: ''
  timestamp: 1659747511
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any()\
    \ {\n            if l1_iter.any() == l2_iter.any() {\n                if l1_iter.any()\
    \ == l1_iter.last() {\n                    l1_iter.pop();\n                  \
    \  l2_iter.pop();\n                } else {\n                    l1_iter.pop();\n\
    \                }\n            } else if l1_iter.any() == l2_iter.any() {\n \
    \               l2_iter.pop();\n            } else {\n                l1_iter.pop();\n\
    \            }\n        } else if l1_iter.any() {\n            l1_iter.pop();\n\
    \        } else {\n            l2_iter.pop();\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `any` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp3ebjdfvz.rs:10:19\n   |\n10 |     while l1_iter.any()\
    \ || l2_iter.any() {\n   |                   ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `any` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp3ebjdfvz.rs:10:36\n   |\n10 |     while l1_iter.any() ||\
    \ l2_iter.any() {\n   |                                    ^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp3ebjdfvz.rs:11:20\n   |\n11 |         if\
    \ l1_iter.any() && l2_iter.any() {\n   |                    ^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp3ebjdfvz.rs:11:37\n   |\n11 |         if\
    \ l1_iter.any() && l2_iter.any() {\n   |                                     ^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `any` found\
    \ for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp3ebjdfvz.rs:12:24\n\
    \   |\n12 |             if l1_iter.any() == l2_iter.any() {\n   |            \
    \            ^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named\
    \ `any` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp3ebjdfvz.rs:12:41\n\
    \   |\n12 |             if l1_iter.any() == l2_iter.any() {\n   |            \
    \                             ^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `any` found for struct `Vec<isize>` in the current scope\n \
    \ --> /tmp/tmp3ebjdfvz.rs:13:28\n   |\n13 |                 if l1_iter.any() ==\
    \ l1_iter.last() {\n   |                            ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `any` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp3ebjdfvz.rs:19:31\n   |\n19 |             } else if l1_iter.any()\
    \ == l2_iter.any() {\n   |                               ^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct `Vec<isize>` "
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        let mut found =\
    \ false;\n        for (i, &e) in l1.iter().enumerate() {\n            if e ==\
    \ l2[i] {\n                found = true;\n                l2.swap(i, 0);\n   \
    \             break;\n            }\n        }\n        if !found {\n        \
    \    result.push(*l1.pop());\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp4jvc6f1q.rs:19:25\n\
    \   |\n19 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.last() == l2.last() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6iqdyji5.rs:34:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n34 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n     \
    \       while l1_iter.len() > 0 && l2_iter.len() > 0 {\n                if l1_iter.peek()\
    \ == l2_iter.peek() {\n                    l1_iter.pop();\n                  \
    \  l2_iter.pop();\n                } else {\n                    break;\n    \
    \            }\n            }\n            result.push(l1_iter.peek());\n    \
    \        result.push(l2_iter.peek());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `peek` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp700an6vi.rs:19:28\n   |\n19 |                 if\
    \ l1_iter.peek() == l2_iter.peek() {\n   |                            ^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `peek` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp700an6vi.rs:19:46\n\
    \   |\n19 |                 if l1_iter.peek() == l2_iter.peek() {\n   |      \
    \                                        ^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `peek` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp700an6vi.rs:26:33\n   |\n26 |             result.push(l1_iter.peek());\n\
    \   |                                 ^^^^ method not found in `Vec<isize>`\n\n\
    error[E0599]: no method named `peek` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp700an6vi.rs:27:33\n   |\n27 |             result.push(l2_iter.peek());\n\
    \   |                                 ^^^^ method not found in `Vec<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp700an6vi.rs:30:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          let mut l1_el = l1[0];\n            let mut l2_el = l2[0];\n      \
    \      while l1_el == l2_el {\n                l1_el = l1[0];\n              \
    \  l2_el = l2[0];\n            }\n            l3.push(l1_el);\n            l1.pop();\n\
    \            l2.pop();\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmponqaa2ii.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_iter\
    \ = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any() || l2_iter.any()\
    \ {\n        if l1_iter.any() && l2_iter.any() {\n            if l1_iter.peek()\
    \ == l2_iter.peek() {\n                l1_iter.next();\n                l2_iter.next();\n\
    \            } else {\n                result.push(*l1_iter.next());\n       \
    \         result.push(*l2_iter.next());\n            }\n        } else if l1_iter.any()\
    \ {\n            result.push(*l1_iter.next());\n        } else if l2_iter.any()\
    \ {\n            result.push(*l2_iter.next());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp6_cjgl59.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmp6_cjgl59.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmp6_cjgl59.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp6_cjgl59.rs:13:37\n     |\n13   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp6_cjgl59.rs:14:24\n   |\n14 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp6_cjgl59.rs:14:42\n\
    \   |\n14 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0614]: type `Option<&isize>` "
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_iter\
    \ = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any() || l2_iter.any()\
    \ {\n        if l1_iter.any() && l2_iter.any() {\n            if l1_iter.peek()\
    \ == l2_iter.peek() {\n                l1_iter.next();\n                l2_iter.next();\n\
    \            } else {\n                l1_iter.next();\n                l2_iter.next();\n\
    \                result.push(*l1_iter.peek());\n            }\n        } else\
    \ if l1_iter.any() {\n            l1_iter.next();\n            result.push(*l1_iter.peek());\n\
    \        } else if l2_iter.any() {\n            l2_iter.next();\n            result.push(*l2_iter.peek());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp_4df1vhq.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmp_4df1vhq.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmp_4df1vhq.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp_4df1vhq.rs:13:37\n     |\n13   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp_4df1vhq.rs:14:24\n   |\n14 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp_4df1vhq.rs:14:42\n\
    \   |\n14 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0599]: no method named `peek`"
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        if l1.len() == 0\
    \ {\n            break;\n        }\n        if l2.len() == 0 {\n            break;\n\
    \        }\n        let mut i = 0;\n        let mut j = 0;\n        while i <\
    \ l1.len() && j < l2.len() {\n            if l1[i] == l2[j] {\n              \
    \  i += 1;\n                j += 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if i == l1.len() {\n            result.push(l2[j]);\n\
    \            l2.pop();\n        } else if j == l2.len() {\n            result.push(l1[i]);\n\
    \            l1.pop();\n        } else {\n            result.push(l1[i]);\n  \
    \          result.push(l2[j]);\n            l1.pop();\n            l2.pop();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpjo96rx3h.rs:31:13\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n31 |             l1.pop();\n   |             ^^ cannot borrow\
    \ as mutable\n\nerror[E0596]: cannot borrow `l1` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpjo96rx3h.rs:35:13\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |           -- help: consider changing this\
    \ to be mutable: `mut l1`\n...\n35 |             l1.pop();\n   |             ^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659747512
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0 && l1.front()\
    \ == l2.front() {\n                l1.pop();\n                l2.pop();\n    \
    \            i += 1;\n            }\n            if l1.len() == 0 {\n        \
    \        result.push(l2.pop());\n            } else if l2.len() == 0 {\n     \
    \           result.push(l1.pop());\n            } else {\n                result.push(l1.pop());\n\
    \                result.push(l2.pop());\n            }\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpz6c7vlh3.rs:19:56\n   |\n19 |             while\
    \ l1.len() != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |         \
    \                                               ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpz6c7vlh3.rs:19:70\n   |\n19 |             while l1.len()\
    \ != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |                  \
    \                                                    ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz6c7vlh3.rs:34:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n34 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_last = l1.last().unwrap();\n    let mut l2_last = l2.last().unwrap();\n\
    \    while l1_iter.next() != l2_iter.next() {\n        if *l1_iter == *l2_iter\
    \ {\n            result.push(*l1_iter);\n            l1_iter += 1;\n         \
    \   l2_iter += 1;\n        } else if *l1_iter > *l2_iter {\n            result.push(*l1_iter);\n\
    \            l1_iter += 1;\n        } else {\n            result.push(*l2_iter);\n\
    \            l2_iter += 1;\n        }\n    }\n    if l1_iter != l1_last {\n  \
    \      result.push(*l1_iter);\n    }\n    if l2_iter != l2_last {\n        result.push(*l2_iter);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmp92fxg7wk.rs:13:12\n   |\n13 |         if *l1_iter == *l2_iter {\n\
    \   |            ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>`\
    \ cannot be dereferenced\n  --> /tmp/tmp92fxg7wk.rs:13:24\n   |\n13 |        \
    \ if *l1_iter == *l2_iter {\n   |                        ^^^^^^^^\n\nerror[E0614]:\
    \ type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n  --> /tmp/tmp92fxg7wk.rs:14:25\n\
    \   |\n14 |             result.push(*l1_iter);\n   |                         ^^^^^^^^\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmp92fxg7wk.rs:15:13\n   |\n15 |             l1_iter +=\
    \ 1;\n   |             -------^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on type `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmp92fxg7wk.rs:16:13\n   |\n16 |             l2_iter +=\
    \ 1;\n   |             -------^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on type `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0614]: type\
    \ `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n  --> /tmp/tmp92fxg7wk.rs:17:19\n\
    \   |\n17 |         } else if *l1_iter > *l2_iter {\n   |                   ^^^^^^^^\n\
    \nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmp92fxg7wk.rs:17:30\n   |\n17 |         } else if *l1_iter > *l2_iter\
    \ {\n   |                              ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmp92fxg7wk.rs:18:25\n   |\n18 |\
    \             result.push(*l1_iter);\n   |                         ^^^^^^^^\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmp92fxg7wk.rs:19:13\n   |\n19 |             l1_iter +=\
    \ 1;\n   |             -------^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on"
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        }\n        let mut l3_iter =\
    \ l3.iter().cloned().collect::<Vec<_>>();\n        let mut l4_iter = l4.iter().cloned().collect::<Vec<_>>();\n\
    \        while l3_iter.len() != 0 || l4_iter.len() != 0 {\n            if l3_iter.len()\
    \ == 0 {\n                l3_iter.push(l4_iter.pop());\n            } else if\
    \ l4_iter.len() == 0 {\n                l4_iter.push(l3_iter.pop());\n       \
    \     }\n            if l3_iter.iter().any(|&x| l4_iter.iter().any(|&y| x == y))\
    \ {\n                l3_iter.push(l4_iter.pop());\n                l4_iter.push(l3_iter.pop());\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp84cja4wc.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp84cja4wc.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp84cja4wc.rs:21:30\n   |\n21 |  \
    \               l3_iter.push(l4_iter.pop());\n   |                           \
    \   ^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp84cja4wc.rs:23:30\n   |\n23 |                 l4_iter.push(l3_iter.pop());\n\
    \   |                              ^^^^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp84cja4wc.rs:26:30\n   |\n26 |\
    \                 l3_iter.push(l4_iter.pop());\n   |                         \
    \     ^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp84cja4wc.rs:27:30\n   |\n27 |                 l4_iter.push(l3_iter.pop());\n\
    \   |                              ^^^^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != l2.len() {\n        let mut i = 0;\n        while i < l1.len()\
    \ && l1.get(i) == l2.get(i) {\n            i += 1;\n        }\n        if i ==\
    \ l1.len() {\n            result.push(l2.get(0));\n            l2.remove(0);\n\
    \        }\n        else {\n            result.push(l1.get(i));\n            l1.remove(&i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplg4hxnlj.rs:16:25\n   |\n\
    16 |             result.push(l2.get(0));\n   |                         ^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplg4hxnlj.rs:20:25\n   |\n20 |             result.push(l1.get(i));\n\
    \   |                         ^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplg4hxnlj.rs:21:23\n   |\n21 |\
    \             l1.remove(&i);\n   |                       ^^ expected `usize`,\
    \ found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n21 -       \
    \      l1.remove(&i);\n21 +             l1.remove(i);\n   | \n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() ==\
    \ 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l1_el\
    \ = l1.pop();\n                l2_el = l2.pop();\n            }\n            result.push(l1_el);\n\
    \            result.push(l2_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu0qsy86w.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l4.len() == 0 {\n            l4.push(0);\n        }\n \
    \       if l3[0] == l4[0] {\n            l3.pop();\n            l4.pop();\n  \
    \      } else {\n            l3.pop();\n            l4.pop();\n        }\n   \
    \ }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp5xgdpxpb.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l2.sort();\n    while l1.len() != 0 || l2.len() != 0 {\n\
    \        if l1.len() == 0 {\n            l3.push(l2[0]);\n            l2.pop();\n\
    \        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n            l1.pop();\n\
    \        } else {\n            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n\
    \                l1.pop();\n            } else {\n                l3.push(l2[0]);\n\
    \                l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right:\
    \ `[1, 5, 653]`', /tmp/tmpo97j7fxh.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    while l3.len() != l4.len()\
    \ {\n        if l3[0] != l4[0] {\n            break;\n        }\n        l3.remove(0);\n\
    \        l4.remove(0);\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpp93b2t57.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    let mut i = 0;\n    while i < result.len() && i < l2.len()\
    \ {\n        if result[i] == l2[i] {\n            result.swap(i, i + 1);\n   \
    \         i += 1;\n        } else {\n            i += 1;\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpl_284th3.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n           \
    \     l1.pop();\n            } else {\n                l3.push(l2[0]);\n     \
    \           l2.pop();\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp4pw6w9ef.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwkce5gc4.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747510
- exit_code: -1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          let mut l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n       \
    \     let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n            while\
    \ l1_iter.len() > 0 && l2_iter.len() > 0 {\n                if l1_iter[0] == l2_iter[0]\
    \ {\n                    l3.push(l1_iter[0]);\n                    l1_iter.pop();\n\
    \                    l2_iter.pop();\n                } else {\n              \
    \      break;\n                }\n            }\n            if l1_iter.len()\
    \ > 0 {\n                l3.push(l1_iter[0]);\n                l1_iter.pop();\n\
    \            } else if l2_iter.len() > 0 {\n                l3.push(l2_iter[0]);\n\
    \                l2_iter.pop();\n            }\n        }\n    }\n    l3\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747518
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l3 = l2.clone();\n    while l3.len() > 0 {\n        let mut l4 = l3.clone();\n\
    \        while l4.len() > 0 {\n            if l4[0] < result[0] {\n          \
    \      result.swap(0, l4[0]);\n                l4.swap(0, 1);\n            }\n\
    \            if l4[0] > result[0] {\n                break;\n            }\n \
    \           l4.swap(0, 1);\n        }\n        l3.swap(0, 1);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9eaktvk1.rs:13:32\n   |\n\
    13 |                 result.swap(0, l4[0]);\n   |                            \
    \    ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n13 |      \
    \           result.swap(0, l4[0].try_into().unwrap());\n   |                 \
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            while l1.len() > 0 && l2.len() > 0 {\n                if l1.front()\
    \ == l2.front() {\n                    l1.pop();\n                    l2.pop();\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            result.push(l1.pop());\n            result.push(l2.pop());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpdwi154ie.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpdwi154ie.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdwi154ie.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747513
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l3 = l2.clone();\n    while l3.len() > 0 {\n        let mut l4 = l3.clone();\n\
    \        while l4.len() > 0 {\n            if l4[0] == l1[0] {\n             \
    \   l3.remove(0);\n                l4.remove(0);\n            } else {\n     \
    \           break;\n            }\n        }\n        if l3.len() > 0 {\n    \
    \        l3.remove(0);\n        }\n        if l4.len() > 0 {\n            l4.remove(0);\n\
    \        }\n        result.push(l3.pop());\n        result.push(l4.pop());\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsmckgr36.rs:25:21\n   |\n\
    25 |         result.push(l3.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsmckgr36.rs:26:21\n   |\n26 |         result.push(l4.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747513
