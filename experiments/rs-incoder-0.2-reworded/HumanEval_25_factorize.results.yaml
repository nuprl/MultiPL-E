language: rs
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n            i += 1;\n        }\n\
    \    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpv85umsxo.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut primes = vec![];\n    let mut primes_size = vec![];\n    let mut\
    \ primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut prime\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbxkck4eu.rs:62:18\n   |\n\
    62 |     let mut prime\n   |                  ^ help: add `;` here\n63 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxkck4eu.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_min_value\
    \ = \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpn2us537g.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_index\
    \ = Vec::new();\n    let mut prime_factors_count_index_max = Vec::new();\n   \
    \ let mut prime_factors_count_index_max_index = Vec::new();\n    let mut prime_factors_count_index_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_index = Vec::new();\n\
    \    let mut prime_factors_count_index_max_value_max = Vec::new();\n    let mut\
    \ prime_factors_count_index_max_value_max_index = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_index\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_index_max\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_index\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_index\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_index_max\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_index_max_max\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_max_index\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_max_value_index\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_max_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_max_value_index_max\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_max_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_index_max_value_max_value_max_value_max_value_index_max_max\
    \ = \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpcsdqn470.rs:40:1\n\
    \   |\n40 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut factorization = Vec::new();\n    let mut factorization_primes = Vec::new();\n\
    \    let mut factorization_prime_factors = Vec::new();\n    let mut factorization_prime_factors_count\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max = Vec::new();\n\
    \    let mut factorization_prime_factors_count_min = Vec::new();\n    let mut\
    \ factorization_prime_factors_count_max_prime = Vec::new();\n    let mut factorization_prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_min_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_min_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_min_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_min_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_min_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_prime_prime_prime_prime_prime\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgwwtlvk0.rs:36:80\n   |\n\
    36 |     let mut factorization_prime_factors_count_max_prime_prime_prime_prime_prime\n\
    \   |                                                                        \
    \        ^ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgwwtlvk0.rs:10:27\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = vec![true; n + 1];\n    let mut i = 2;\n    while i <= n\
    \ {\n        if primes[i] {\n            factors.push(i);\n            primes[i]\
    \ = false;\n        }\n        i += i;\n    }\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy7i44nsd.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n + 1];\n   |                           \
    \      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut primes = vec![true; (n + 1).try_into().unwrap()];\n   |                \
    \                 +     +++++++++++++++++++++\n\nerror[E0277]: the type `[bool]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpy7i44nsd.rs:15:12\n   |\n15 |  \
    \       if primes[i] {\n   |            ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpy7i44nsd.rs:17:13\n   |\n17 |            \
    \ primes[i] = false;\n   |             ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp20052cad.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors.push(factor);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfap3spo9.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_size_rem = Vec::new();\n    let mut primes_size_rem_size = Vec::new();\n\
    \    let mut primes_size_rem_size_rem = Vec::new();\n    let mut primes_size_rem_size_rem_size\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem = Vec::new();\n\
    \    let mut primes_size_rem_size_rem_size_rem_size = Vec::new();\n    let mut\
    \ primes_size_rem_size_rem_size_rem_size_rem = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size_rem_size\
    \ = Vec::new();\n    let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size_re\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd6nvaybm.rs:32:72\n   |\n\
    32 |     let mut primes_size_rem_size_rem_size_rem_size_rem_size_rem_size_re\n\
    \   |                                                                        ^\
    \ help: add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd6nvaybm.rs:10:27\n   |\n10 | fn factorize(n: isize) ->\
    \ Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_size_reverse = Vec::new();\n    let mut primes_size_reverse_sorted\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse = Vec::new();\n\
    \    let mut primes_size_reverse_sorted_reverse_size = Vec::new();\n    let mut\
    \ primes_size_reverse_sorted_reverse_size_reverse = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_reverse\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_reverse_size\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_reverse\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_reverse_size\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5fvms3bs.rs:33:106\n   |\n\
    33 |     let mut primes_size_reverse_sorted_reverse_size_reverse_size_sorted_reverse_size_reverse_size_sorted_\n\
    \   |                                                                        \
    \                                  ^ help: add `;` here\n34 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5fvms3bs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n != 1 {\n        if n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpyckib0h5.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpdi_8xluu.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_tm0gbkl.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp1018vabd.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpppz8wmdh.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppng22hm4.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphakr4k8m.rs:36:18\n   |\n\
    36 |     let mut prime\n   |                  ^ help: add `;` here\n37 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphakr4k8m.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut primes = vec![];\n    let mut prime_counter = 1;\n    let mut factor\
    \ = 1;\n    let mut i = 1;\n    while i * factor <= n {\n        if n % i == 0\
    \ {\n            factors.push(factor);\n            primes.push(i);\n        \
    \    factor = 1;\n            i += 1;\n        } else {\n            factor *=\
    \ i;\n        }\n    }\n    if factor > 1 {\n        factors.push(factor);\n \
    \       primes.push(1);\n    }\n    primes.sort_unstable();\n    primes.reverse();\n\
    \    for i in primes {\n        factors.push(factor);\n        factor = 1;\n \
    \   }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1]`,\n right: `[2]`', /tmp/tmpfg11d4vx.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_min = Vec::new();\n    let mut prime_factors_count_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min = Vec::new();\n\
    \    let mut prime_factors_count_max_min_max_min_max = Vec::new();\n    let mut\
    \ prime_factors_count_max_min_max_min_max_min = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn5u6tzv2.rs:10:27\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpppz8wmdh.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut i = 1;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n\
    \        } else {\n            primes.push(i);\n            i += 1;\n        }\n\
    \    }\n    if n > 1 {\n        factors.push(n as isize);\n    }\n    factors.into_iter().map(|x|\
    \ x * x).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppr51qa3o.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_max = Vec::new();\n\
    \    let mut prime_factors_count_min_value_min = Vec::new();\n    let mut prime_factors_count_min_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_index = Vec::new();\n\
    \    let mut prime_factors_count_min_value_min_index = Vec::new();\n    let mut\
    \ prime_factors_count_max_value_min_value = Vec::new();\n    let mut prime_factors_count_min_value_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_min = Vec::new();\n\
    \    let mut prime_factors_count_max_value_min_value_max = Vec::new();\n    let\
    \ mut prime_factors_count_min_value_min_value_min = Vec::new();\n    let mut prime_factors_count_min_value_min_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_min_value_min\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_value_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_value_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_min_value_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_value_min_index\
    \ = Vec::new();\n    let mut prime_factor\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmper12okra.rs:43:25\n   |\n\
    43 |     let mut prime_factor\n   |                         ^ help: add `;` here\n\
    44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmper12okra.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpqg56al2f.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n \
    \   let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpjir1rxv0.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpqg56al2f.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvjb84qzs.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjb84qzs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n            primes.push(i);\n\
    \            factors.push(1);\n            prime_factors.push(1);\n        }\n\
    \        while i <= n / i {\n            if n % i == 0 {\n                factors.push(i);\n\
    \                prime_factors.push(factors.len() - 1);\n            }\n     \
    \       i += 1;\n        }\n        i += 1;\n    }\n    factors.push(1);\n   \
    \ prime_factors.push(factors.len() - 1);\n    prime_factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps89llnch.rs:32:5\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n32 |     prime_factors\n\
    \   |     ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut factorization = factorization(n);\n    while factorization.len()\
    \ > 0 {\n        factors.push(factorization.pop());\n    }\n    factors\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpk6593_zp.rs:12:29\n   |\n12 |     let mut factorization = factorization(n);\n\
    \   |                             ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut factorization = factorization::Factorization::new();\n    let mut\
    \ prime_factorization = factorization::PrimeFactorization::new();\n    let mut\
    \ prime_factorization_prime_factorization = factorization::PrimeFactorization::new();\n\
    \    let mut prime_factorization_prime_factorization_prime_factorization = factorization::PrimeFactorization::new();\n\
    \    let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n    let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n    let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n    let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n    let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n    let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n    let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n    let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n    let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n    let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n    let mut prime_factorization_prime_factorization_prime_factorization_prime\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpml7cb41q.rs:28:78\n   |\n\
    28 |     let mut prime_factorization_prime_factorization_prime_factorization_prime\n\
    \   |                                                                        \
    \      ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `factorization`\n  -->\
    \ /tmp/tmpml7cb41q.rs:14:29\n   |\n14 |     let mut factorization = factorization::Factorization::new();\n\
    \   |                             ^^^^^^^^^^^^^ use of undeclared crate or module\
    \ `factorization`\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `factorization`\n  --> /tmp/tmpml7cb41q.rs:15:35\n   |\n15 |     let\
    \ mut prime_factorization = factorization::PrimeFactorization::new();\n   |  \
    \                                 ^^^^^^^^^^^^^ use of undeclared crate or module\
    \ `factorization`\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `factorization`\n  --> /tmp/tmpml7cb41q.rs:16:55\n   |\n16 |     let\
    \ mut prime_factorization_prime_factorization = factorization::PrimeFactorization::new();\n\
    \   |                                                       ^^^^^^^^^^^^^ use\
    \ of undeclared crate or module `factorization`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `factorization`\n  --> /tmp/tmpml7cb41q.rs:17:75\n\
    \   |\n17 |     let mut prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n   |                          \
    \                                                 ^^^^^^^^^^^^^ use of undeclared\
    \ crate or module `factorization`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `factorization`\n  --> /tmp/tmpml7cb41q.rs:18:95\n   |\n18 |\
    \     let mut prime_factorization_prime_factorization_prime_factorization_prime_factorization\
    \ = factorization::PrimeFactorization::new();\n   |                          \
    \                                                                     ^^^^^^^^^^^^^\
    \ use of undeclared crate or module `factorization`\n\nerror[E0433]: "
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpqg56al2f.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut primes = vec![];\n    let mut prime_factors = vec![];\n    let mut\
    \ prime_factors_count = vec![];\n    let mut prime_factors_count_max = vec![];\n\
    \    let mut prime_factors_count_min = vec![];\n    let mut prime_factors_count_max_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors = vec![];\n   \
    \ let mut prime_factors_count_max_prime_factors_count = vec![];\n    let mut prime_factors_count_min_prime_factors_count\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_count_max = vec![];\n\
    \    let mut prime_factors_count_min_prime_factors_count_max = vec![];\n    let\
    \ mut prime_factors_count_max_prime_factors_count_min = vec![];\n    let mut prime_factors_count_min_prime_factors_count_min\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_count_min_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_count_min_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_count_min_prime_factors_count\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_count_min_prime_factors_count\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_count_min_prime_factors_count_max\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_count_min_prime_factors_count_max\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_count_min_prime_factors_count_min\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_count_min_prime_factors_count_min\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_count_min_prime_factors_count_min_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_count_min_prime_factors_count_min_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_count_min_prime_factors_count_min_prime_factors_count\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_count_min_prime_factors_count_min_prime_factors_count\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_count_min_prime_factors_count_min_prime_factors_count_max\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_count_min_prime_factors_count_min_prime_factor\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp102ynuja.rs:38:97\n   |\n\
    38 |     let mut prime_factors_count_min_prime_factors_count_min_prime_factors_count_min_prime_factor\n\
    \   |                                                                        \
    \                         ^ help: add `;` here\n39 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp102ynuja.rs:10:27\n   |\n10 |\
    \ fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 0 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmphkjn6dl3.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut product = 1;\n    let mut i = 1;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            factors.push(i);\n            product *= i;\n    \
    \        i += 1;\n        }\n        i += 1;\n    }\n    factors.push(product);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1]`,\n right: `[2]`', /tmp/tmp8_7tu7em.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n \
    \   let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpjir1rxv0.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzrijad41.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvjb84qzs.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjb84qzs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvjb84qzs.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjb84qzs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpc089_6dr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n            i += 1;\n        }\n\
    \        else {\n            i += 1;\n        }\n    }\n    factors.push(n);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp1g39cyee.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut\
    \ prime_counter2 = 1;\n    let mut prime_counter3 = 1;\n    let mut prime_counter4\
    \ = 1;\n    let mut prime_counter5 = 1;\n    let mut prime_counter6 = 1;\n   \
    \ let mut prime_counter7 = 1;\n    let mut prime_counter8 = 1;\n    let mut prime_counter9\
    \ = 1;\n    let mut prime_counter10 = 1;\n    let mut prime_counter11 = 1;\n \
    \   let mut prime_counter12 = 1;\n    let mut prime_counter13 = 1;\n    let mut\
    \ prime_counter14 = 1;\n    let mut prime_counter15 = 1;\n    let mut prime_counter16\
    \ = 1;\n    let mut prime_counter17 = 1;\n    let mut prime_counter18 = 1;\n \
    \   let mut prime_counter19 = 1;\n    let mut prime_counter20 = 1;\n    let mut\
    \ prime_counter21 = 1;\n    let mut prime_counter22 = 1;\n    let mut prime_counter23\
    \ = 1;\n    let mut prime_counter24 = 1;\n    let mut prime_counter25 = 1;\n \
    \   let mut prime_counter26 = 1;\n    let mut prime_counter27 = 1;\n    let mut\
    \ prime_counter28 = 1;\n    let mut prime_counter29 = 1;\n    let mut prime_counter30\
    \ = 1;\n    let mut prime_counter31 = 1;\n    let mut prime_counter32 = 1;\n \
    \   let mut prime_counter33 = 1;\n    let mut prime_counter34 = 1;\n    let mut\
    \ prime_counter35 = 1;\n    let mut prime_counter36 = 1;\n    let mut prime_counter37\
    \ = 1;\n    let mut prime_counter38 = 1;\n    let mut prime_counter39 = 1;\n \
    \   let mut prime_counter40 = 1;\n    let mut prime_counter41 = 1;\n    let mut\
    \ prime_counter42 = 1;\n    let mut prime_counter43 = 1;\n    let mut prime_counter44\
    \ = 1;\n    let mut prime_counter45 = 1;\n    let mut prime_counter46 = 1;\n \
    \   let mut prime_counter47 = 1;\n    let mut prime_counter48 = 1;\n    let mut\
    \ prime_counter49 = 1;\n    let mut prime_counter50 = 1;\n    let mut prime_counter51\
    \ = 1;\n    let mut prime_counter52 = 1;\n    let mut prime_counter53 = 1;\n \
    \   let mut prime_counter54 = 1;\n    let mut prime_\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvb6s780l.rs:67:19\n   |\n\
    67 |     let mut prime_\n   |                   ^ help: add `;` here\n68 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvb6s780l.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = primes.len();\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprq6nb6mz.rs:10:27\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpc089_6dr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors.push(factor);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfap3spo9.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpd09x200x.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpc089_6dr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors.push(factor);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfap3spo9.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_sum = Vec::new();\n    let mut prime_factors_count_sum_max\
    \ = Vec::new();\n    let mut prime_factors_count_sum_min = Vec::new();\n    let\
    \ mut prime_factors_count_product = Vec::new();\n    let mut prime_factors_count_product_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_min = Vec::new();\n \
    \   let mut prime_factors_count_product_sum = Vec::new();\n    let mut prime_factors_count_product_sum_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product = Vec::new();\n    let mut prime_factors_count_product_product_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_product_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_sum = Vec::new();\n    let mut\
    \ prime_factors_count_product_product_sum_max = Vec::new();\n    let mut prime_factors_count_product_product_sum_min\
    \ = Vec::new();\n    let mut prime_factors_count_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_max = Vec::new();\n \
    \   let mut prime_factors_count_product_product_product_min = Vec::new();\n  \
    \  let mut prime_factors_count_product_product_product_sum = Vec::new();\n   \
    \ let mut prime_factors_count_product_product_product_sum_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_sum = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv375z0o6.rs:45:33\n   |\n\
    45 |     let mut prime_factors_count_\n   |                                 ^\
    \ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv375z0o6.rs:10:27\n   |\n10 | fn factorize(n: isize) ->\
    \ Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut i = 1;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            primes.push(i);\n\
    \            i += 1;\n        }\n        else {\n            i += 1;\n       \
    \ }\n    }\n    factors.push(n - 1);\n    primes.push(n - 1);\n    factors.sort_unstable();\n\
    \    primes.sort_unstable();\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1]`,\n right: `[2]`', /tmp/tmpohgyj_4y.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppng22hm4.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpd6m9o7m5.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpd09x200x.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 0 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp62gx__rn.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_index = Vec::new();\n   \
    \ let mut prime_factors_count_min = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_sum = Vec::new();\n    let mut\
    \ prime_factors_count_sum_index = Vec::new();\n    let mut prime_factors_count_product\
    \ = Vec::new();\n    let mut prime_factors_count_product_index = Vec::new();\n\
    \    let mut prime_factors_count_product2 = Vec::new();\n    let mut prime_factors_count_product2_index\
    \ = Vec::new();\n    let mut prime_factors_count_product3 = Vec::new();\n    let\
    \ mut prime_factors_count_product3_index = Vec::new();\n    let mut prime_factors_count_product4\
    \ = Vec::new();\n    let mut prime_factors_count_product4_index = Vec::new();\n\
    \    let mut prime_factors_count_product5 = Vec::new();\n    let mut prime_factors_count_product5_index\
    \ = Vec::new();\n    let mut prime_factors_count_product6 = Vec::new();\n    let\
    \ mut prime_factors_count_product6_index = Vec::new();\n    let mut prime_factors_count_product7\
    \ = Vec::new();\n    let mut prime_factors_count_product7_index = Vec::new();\n\
    \    let mut prime_factors_count_product8 = Vec::new();\n    let mut prime_factors_count_product8_index\
    \ = Vec::new();\n    let mut prime_factors_count_product9 = Vec::new();\n    let\
    \ mut prime_factors_count_product9_index = Vec::new();\n    let mut prime_factors_count_product10\
    \ = Vec::new();\n    let mut prime_factors_count_product10_index = Vec::new();\n\
    \    let mut prime_factors_count_product11 = Vec::new();\n    let mut prime_factors_count_product11_index\
    \ = Vec::new();\n    let mut prime_factors_count_product12 = Vec::new();\n   \
    \ let mut prime_factors_count_product12_index = Vec::new();\n    let mut prime_factors_count_product13\
    \ = Vec::new();\n    let mut prime_factors_count_product13_index = Vec::new();\n\
    \    let mut prime_factors_count_product14 = Vec\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdbeo_q2n.rs:47:48\n   |\n\
    47 |     let mut prime_factors_count_product14 = Vec\n   |                   \
    \                             ^ help: add `;` here\n48 | }\n   | - unexpected\
    \ token\n\nerror[E0423]: expected value, found struct `Vec`\n   --> /tmp/tmpdbeo_q2n.rs:47:45\n\
    \    |\n47  |       let mut prime_factors_count_product14 = Vec\n    |       \
    \                                        ^^^ help: use struct literal syntax instead:\
    \ `Vec { buf: val, len: val }`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbeo_q2n.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = vec![true; n];\n    let mut prime_factors = vec![0; n];\n\
    \    let mut i = 1;\n    while i < n {\n        if primes[i] {\n            prime_factors[i]\
    \ = 1;\n            i += 1;\n        } else {\n            let mut j = 2;\n  \
    \          while j < n {\n                if n % j == 0 {\n                  \
    \  prime_factors[j] += 1;\n                    break;\n                }\n   \
    \             j += 1;\n            }\n        }\n    }\n    for i in 1..n {\n\
    \        if prime_factors[i] == 0 {\n            factors.push(1);\n        } else\
    \ {\n            factors.push(prime_factors[i]);\n        }\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp33nmlryh.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp33nmlryh.rs:13:37\n\
    \   |\n13 |     let mut prime_factors = vec![0; n];\n   |                    \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    13 |     let mut prime_factors = vec![0; n.try_into().unwrap()];\n   |       \
    \                              ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type\
    \ `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmp33nmlryh.rs:16:12\n   |\n\
    16 |         if primes[i] {\n   |            ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp33nmlryh.rs:17:13\n   |\n17 |  \
    \           prime_factors[i] = 1;\n   |             ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp33nmlryh.rs:23:21\n\
    \   |\n23 |                     prime_factors[j] += 1;\n   |                 \
    \    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerr"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpc089_6dr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut product = 1;\n    let mut i = 1;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            factors.push(i);\n            product *= i;\n    \
    \        i += 1;\n        } else {\n            i += 1;\n        }\n    }\n  \
    \  factors.push(product);\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[2]`', /tmp/tmpvpuxgr8g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvjb84qzs.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjb84qzs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors.push(factor);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpwop1_xo0.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    if n > 1 {\n        factors.push(n);\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp19v4xldn.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_count = Vec::new();\n    let mut factorization_primes\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_prime_factors = Vec::new();\n    let mut factorization_prime_factors_count\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_prime = Vec::new();\n\
    \    let mut factorization_prime_factors_count_prime_prime = Vec::new();\n   \
    \ let mut factorization_prime_factors_count_prime_prime_prime = Vec::new();\n\
    \    let mut factorization_prime_factors_count_prime_prime_prime_prime = Vec::new();\n\
    \    let mut factorization_prime_factors_count_prime_prime_prime_prime_prime =\
    \ Vec::new();\n    let mut factorization_prime_factors_count_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpgi1doi60.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors.push(factor);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfap3spo9.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 0 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmphkjn6dl3.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_size_size = Vec::new();\n    let mut primes_size_primes = Vec::new();\n\
    \    let mut primes_size_primes_size = Vec::new();\n    let mut primes_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes = Vec::new();\n\
    \    let mut primes_size_primes_size_size_primes_size = Vec::new();\n    let mut\
    \ primes_size_primes_size_size_primes_size_size = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv7bp7otp.rs:33:104\n   |\n\
    33 |     let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size\n\
    \   |                                                                        \
    \                                ^ help: add `;` here\n34 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv7bp7otp.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_count = Vec::new();\n    let mut primes_count_size = Vec::new();\n\
    \    let mut primes_count_size = Vec::new();\n    let mut primes_count_size =\
    \ Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1i0fi6m1.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1i0fi6m1.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = vec![true; n];\n    let mut i = 2;\n    while i < n {\n\
    \        if primes[i] == true {\n            factors.push(i as isize);\n     \
    \       i += 1;\n        }\n        else {\n            i += 1;\n        }\n \
    \   }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_gmqaj8.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[bool]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpd_gmqaj8.rs:15:12\n   |\n15 |         if primes[i]\
    \ == true {\n   |            ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n            i += 1;\n        }\n\
    \        else {\n            i += 1;\n        }\n    }\n    factors.push(n);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp1g39cyee.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 0 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmphkjn6dl3.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n \
    \   let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpf5fsmmzk.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut product = n;\n    let mut i = 1;\n    while product % i == 0 {\n\
    \        factors.push(i);\n        product /= i;\n        i += 1;\n    }\n   \
    \ factors.push(product);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 1]`,\n right: `[2]`', /tmp/tmp4pwsdx3_.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvjb84qzs.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjb84qzs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpc089_6dr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = vec![true; n];\n    let mut prime_factors = vec![0; n];\n\
    \    let mut prime_factors_counter = 1;\n    let mut prime_factors_counter2 =\
    \ 1;\n    let mut prime_factors_counter3 = 1;\n    let mut prime_factors_counter4\
    \ = 0;\n    let mut prime_factors_counter5 = 0;\n    let mut prime_factors_counter6\
    \ = 0;\n    let mut prime_factors_counter7 = 0;\n    let mut prime_factors_counter8\
    \ = 0;\n    let mut prime_factors_counter9 = 0;\n    let mut prime_factors_counter10\
    \ = 0;\n    let mut prime_factors_counter11 = 0;\n    let mut prime_factors_counter12\
    \ = 0;\n    let mut prime_factors_counter13 = 0;\n    let mut prime_factors_counter14\
    \ = 0;\n    let mut prime_factors_counter15 = 0;\n    let mut prime_factors_counter16\
    \ = 0;\n    let mut prime_factors_counter17 = 0;\n    let mut prime_factors_counter18\
    \ = 0;\n    let mut prime_factors_counter19 = 0;\n    let mut prime_factors_counter20\
    \ = 0;\n    let mut prime_factors_counter21 = 0;\n    let mut prime_factors_counter22\
    \ = 0;\n    let mut prime_factors_counter23 = 0;\n    let mut prime_factors_counter24\
    \ = 0;\n    let mut prime_factors_counter25 = 0;\n    let mut prime_factors_counter26\
    \ = 0;\n    let mut prime_factors_counter27 = 0;\n    let mut prime_factors_counter28\
    \ = 0;\n    let mut prime_factors_counter29 = 0;\n    let mut prime_factors_counter30\
    \ = 0;\n    let mut prime_factors_counter31 = 0;\n    let mut prime_factors_counter32\
    \ = 0;\n    let mut prime_factors_counter33 = 0;\n    let mut prime_factors_counter34\
    \ = 0;\n    let mut prime_factors_counter35 = 0;\n    let mut prime_factors_counter36\
    \ = 0;\n    let mut prime_factors_counter37 = 0;\n    let mut prime_factors_counter38\
    \ = 0;\n    let mut prime_factors_counter39 = 0;\n    let mut prime_factors_counter40\
    \ = 0;\n    let mut prime_factors_counter41 = 0;\n    let mut prime_factors_counter42\
    \ = 0;\n    let mut prime_factors_counter43 = 0;\n    let mut prime_factors_counter44\
    \ = 0;\n    let mut prime_factors_counter45 = 0;\n    let mut prime_factors_counter46\
    \ = 0;\n    let mut prime_factors_counter47 = 0;\n    let mut prime_factors_counter48\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkr4la6db.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkr4la6db.rs:12:33\n \
    \  |\n12 |     let mut primes = vec![true; n];\n   |                         \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut primes = vec![true; n.try_into().unwrap()];\n   |                      \
    \           ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkr4la6db.rs:13:37\n\
    \   |\n13 |     let mut prime_factors = vec![0; n];\n   |                    \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    13 |     let mut prime_factors = vec![0; n.try_into().unwrap()];\n   |       \
    \                              ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkr4la6db.rs:10:27\n   |\n10 | fn factorize(n: isize) ->\
    \ Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut factorization = Vec::new();\n    let mut factorization_size = Vec::new();\n\
    \    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpfoeey71k.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut primes = vec![];\n    let mut prime_factors = vec![];\n    let mut\
    \ prime_factors_count = vec![];\n    let mut prime_factors_count_max = vec![];\n\
    \    let mut prime_factors_count_min = vec![];\n    let mut prime_factors_count_sum\
    \ = vec![];\n    let mut prime_factors_count_sum_max = vec![];\n    let mut prime_factors_count_sum_min\
    \ = vec![];\n    let mut prime_factors_count_product = vec![];\n    let mut prime_factors_count_product_max\
    \ = vec![];\n    let mut prime_factors_count_product_min = vec![];\n    let mut\
    \ prime_factors_count_product_sum = vec![];\n    let mut prime_factors_count_product_sum_max\
    \ = vec![];\n    let mut prime_factors_count_product_sum_min = vec![];\n    let\
    \ mut prime_factors_count_product_product = vec![];\n    let mut prime_factors_count_product_product_max\
    \ = vec![];\n    let mut prime_factors_count_product_product_min = vec![];\n \
    \   let mut prime_factors_count_product_product_sum = vec![];\n    let mut prime_factors_count_product_product_sum_max\
    \ = vec![];\n    let mut prime_factors_count_product_product_sum_min = vec![];\n\
    \    let mut prime_factors_count_product_product_product = vec![];\n    let mut\
    \ prime_factors_count_product_product_product_max = vec![];\n    let mut prime_factors_count_product_product_product_min\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_sum = vec![];\n\
    \    let mut prime_factors_count_product_product_product_sum_max = vec![];\n \
    \   let mut prime_factors_count_product_product_product_sum_min = vec![];\n  \
    \  let mut prime_factors_count_product_product_product_product = vec![];\n   \
    \ let mut prime_factors_count_product_product_product_product_max = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_min = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_sum = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_sum_max = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_sum_min = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_product = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_max = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_min = vec![];\n\
    \    let mut prime_factors_\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbw_dy2w0.rs:47:27\n   |\n\
    47 |     let mut prime_factors_\n   |                           ^ help: add `;`\
    \ here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbw_dy2w0.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n \
    \   let mut prime_counters = Vec::new();\n    let mut prime_counters_sorted =\
    \ Vec::new();\n    let mut prime_counters_sorted_reversed = Vec::new();\n    let\
    \ mut prime_counters_sorted_reversed_sorted = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = Vec::new();\n    let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reverse\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptk_avxvc.rs:32:154\n   |\n\
    32 |     let mut prime_counters_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reverse\n\
    \   |                                                                        \
    \                                                                            \
    \      ^ help: add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptk_avxvc.rs:10:27\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i as isize);\n            n /= i;\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    if n > 1 {\n        factors.push(n as isize);\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp16903i82.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut factorization = factorization(n);\n    let mut factorization_size\
    \ = factorization.len();\n    let mut factorization_index = 0;\n    let mut factorization_remainder\
    \ = factorization_size;\n    while factorization_remainder > 0 {\n        let\
    \ mut factorization_remainder_i = 0;\n        while factorization_remainder >\
    \ 0 && factorization_remainder_i < factorization_index {\n            factors.push(factorization[factorization_remainder_i]);\n\
    \            factorization_remainder--;\n            factorization_remainder_i\
    \ += 1;\n        }\n        factorization_index += 1;\n    }\n    factors\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpje13a18v.rs:20:38\n\
    \   |\n20 |             factorization_remainder--;\n   |                     \
    \                 ^ expected expression\n\nerror[E0425]: cannot find function\
    \ `factorization` in this scope\n  --> /tmp/tmpje13a18v.rs:12:29\n   |\n12 | \
    \    let mut factorization = factorization(n);\n   |                         \
    \    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 0 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factors.push(1);\n        factor *= factor;\n    }\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfafi48_k.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors.push(factor);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfap3spo9.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut product = n;\n    while product > 1 {\n        let mut factor = 1;\n\
    \        while product % factor == 0 {\n            factor += 1;\n        }\n\
    \        factors.push(factor);\n        product /= factor;\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[2]`', /tmp/tmpzgeun5bx.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_sum = Vec::new();\n    let mut prime_factors_count_sum_max\
    \ = Vec::new();\n    let mut prime_factors_count_sum_min = Vec::new();\n    let\
    \ mut prime_factors_count_product = Vec::new();\n    let mut prime_factors_count_product_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_min = Vec::new();\n \
    \   let mut prime_factors_count_product_sum = Vec::new();\n    let mut prime_factors_count_product_sum_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product = Vec::new();\n    let mut prime_factors_count_product_product_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_product_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_sum = Vec::new();\n    let mut\
    \ prime_factors_count_product_product_sum_max = Vec::new();\n    let mut prime_factors_count_product_product_sum_min\
    \ = Vec::new();\n    let mut prime_factors_count_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_max = Vec::new();\n \
    \   let mut prime_factors_count_product_product_product_min = Vec::new();\n  \
    \  let mut prime_factors_count_product_product_product_sum = Vec::new();\n   \
    \ let mut prime_factors_count_product_product_product_sum_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_sum = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv375z0o6.rs:45:33\n   |\n\
    45 |     let mut prime_factors_count_\n   |                                 ^\
    \ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv375z0o6.rs:10:27\n   |\n10 | fn factorize(n: isize) ->\
    \ Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n \
    \   let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpjir1rxv0.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut product = 1;\n    let mut i = 1;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            factors.push(i as isize);\n            product *=\
    \ i;\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    factors.push(product);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[2]`', /tmp/tmpqlgq_i08.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            i += 1;\n        }\n        else {\n     \
    \       i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmp53pts1eo.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_size2 = Vec::new();\n    let mut primes_size3 = Vec::new();\n\
    \    let mut primes_size4 = Vec::new();\n    let mut primes_size5 = Vec::new();\n\
    \    let mut primes_size6 = Vec::new();\n    let mut primes_size7 = Vec::new();\n\
    \    let mut primes_size8 = Vec::new();\n    let mut primes_size9 = Vec::new();\n\
    \    let mut primes_size10 = Vec::new();\n    let mut primes_size11 = Vec::new();\n\
    \    let mut primes_size12 = Vec::new();\n    let mut primes_size13 = Vec::new();\n\
    \    let mut primes_size14 = Vec::new();\n    let mut primes_size15 = Vec::new();\n\
    \    let mut primes_size16 = Vec::new();\n    let mut primes_size17 = Vec::new();\n\
    \    let mut primes_size18 = Vec::new();\n    let mut primes_size19 = Vec::new();\n\
    \    let mut primes_size20 = Vec::new();\n    let mut primes_size21 = Vec::new();\n\
    \    let mut primes_size22 = Vec::new();\n    let mut primes_size23 = Vec::new();\n\
    \    let mut primes_size24 = Vec::new();\n    let mut primes_size25 = Vec::new();\n\
    \    let mut primes_size26 = Vec::new();\n    let mut primes_size27 = Vec::new();\n\
    \    let mut primes_size28 = Vec::new();\n    let mut primes_size29 = Vec::new();\n\
    \    let mut primes_size30 = Vec::new();\n    let mut primes_size31 = Vec::new();\n\
    \    let mut primes_size32 = Vec::new();\n    let mut primes_size33 = Vec::new();\n\
    \    let mut primes_size34 = Vec::new();\n    let mut primes_size35 = Vec::new();\n\
    \    let mut primes_size36 = Vec::new();\n    let mut primes_size37 = Vec::new();\n\
    \    let mut primes_size38 = Vec::new();\n    let mut primes_size39 = Vec::new\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdh3qy8dl.rs:51:37\n   |\n\
    51 |     let mut primes_size39 = Vec::new\n   |                              \
    \       ^ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdh3qy8dl.rs:10:27\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n != 1 {\n        if n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpyckib0h5.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = vec![true; n];\n    let mut prime_factors = Vec::new();\n\
    \    let mut prime_factors_count = Vec::new();\n    let mut i = 2;\n    while\
    \ i < n {\n        if primes[i] == true {\n            prime_factors.push(i as\
    \ isize);\n            prime_factors_count.push(i);\n        }\n        i += 1;\n\
    \    }\n    prime_factors.sort_unstable();\n    prime_factors_count.sort_unstable();\n\
    \    for i in 0..prime_factors.len() {\n        let mut j = 0;\n        while\
    \ j < prime_factors_count.len() {\n            if prime_factors[j] == i {\n  \
    \              factors.push(prime_factors_count[j]);\n                j += 1;\n\
    \            }\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprnu4l2uk.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[bool]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmprnu4l2uk.rs:17:12\n   |\n17 |         if primes[i]\
    \ == true {\n   |            ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprnu4l2uk.rs:28:36\n\
    \   |\n28 |             if prime_factors[j] == i {\n   |                     \
    \               ^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    28 |             if prime_factors[j] == i.try_into().unwrap() {\n   |        \
    \                            ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzrijad41.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_value_prime_prime = Vec::new();\n    let\
    \ mut prime_factors_count_min_value_prime_prime = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime =\
    \ Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw8fy91qa.rs:37:79\n   |\n\
    37 |     let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_\n\
    \   |                                                                        \
    \       ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw8fy91qa.rs:10:27\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_ihys3j3.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzrijad41.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    factors.push(n);\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpu2gukcg0.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    factors.push(i);\n            primes.push(i);\n            prime_factors.push(i);\n\
    \        }\n        i += 1;\n    }\n    for i in factors.iter() {\n        let\
    \ mut j = 1;\n        while j * i <= n {\n            if n % i == 0 {\n      \
    \          factors.push(i);\n                primes.push(i);\n               \
    \ prime_factors.push(i);\n            }\n            j += 1;\n        }\n    }\n\
    \    for i in primes.iter() {\n        let mut j = 1;\n        while j * i <=\
    \ n {\n            if n % i == 0 {\n                factors.push(i);\n       \
    \         primes.push(i);\n                prime_factors.push(i);\n          \
    \  }\n            j += 1;\n        }\n    }\n    for i in prime_factors.iter()\
    \ {\n        let mut j = 1;\n        while j * i <= n {\n            if n % i\
    \ == 0 {\n                factors.push(i);\n                primes.push(i);\n\
    \                prime_factors.push(i);\n            }\n            j += 1;\n\
    \        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe7_8p91x.rs:27:30\n   |\n\
    27 |                 factors.push(i);\n   |                              ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    27 |                 factors.push(*i);\n   |                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpe7_8p91x.rs:28:29\n   |\n28 |  \
    \               primes.push(i);\n   |                             ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n28 |  \
    \               primes.push(*i);\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe7_8p91x.rs:29:36\n   |\n29 |              \
    \   prime_factors.push(i);\n   |                                    ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    29 |                 prime_factors.push(*i);\n   |                           \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe7_8p91x.rs:38:30\n\
    \   |\n38 |                 factors.push(i);\n   |                           \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n38 |                 factors.push(*i);\n   |                 \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe7_8p91x.rs:39:29\n\
    \   |\n39 |                 primes.push(i);\n   |                            \
    \ ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n39 |                 primes.push(*i);\n   |                           \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe7_8p91x.rs:40:36\n   |\n\
    40 |                 prime_factors.push(i);\n   |                            \
    \        ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n40 |                 prime_factors.push(*i);\n   |       \
    \                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe7_8p91x.rs:49:30\n\
    \   |\n49 |                 factors.push(i);\n   |                           \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider derefer"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvjb84qzs.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjb84qzs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_counter = Vec::new();\n    let mut prime_factors_counter2\
    \ = Vec::new();\n    let mut prime_factors_counter3 = Vec::new();\n    let mut\
    \ prime_factors_counter4 = Vec::new();\n    let mut prime_factors_counter5 = Vec::new();\n\
    \    let mut prime_factors_counter6 = Vec::new();\n    let mut prime_factors_counter7\
    \ = Vec::new();\n    let mut prime_factors_counter8 = Vec::new();\n    let mut\
    \ prime_factors_counter9 = Vec::new();\n    let mut prime_factors_counter10 =\
    \ Vec::new();\n    let mut prime_factors_counter11 = Vec::new();\n    let mut\
    \ prime_factors_counter12 = Vec::new();\n    let mut prime_factors_counter13 =\
    \ Vec::new();\n    let mut prime_factors_counter14 = Vec::new();\n    let mut\
    \ prime_factors_counter15 = Vec::new();\n    let mut prime_factors_counter16 =\
    \ Vec::new();\n    let mut prime_factors_counter17 = Vec::new();\n    let mut\
    \ prime_factors_counter18 = Vec::new();\n    let mut prime_factors_counter19 =\
    \ Vec::new();\n    let mut prime_factors_counter20 = Vec::new();\n    let mut\
    \ prime_factors_counter21 = Vec::new();\n    let mut prime_factors_counter22 =\
    \ Vec::new();\n    let mut prime_factors_counter23 = Vec::new();\n    let mut\
    \ prime_factors_counter24 = Vec::new();\n    let mut prime_factors_counter25 =\
    \ Vec::new();\n    let mut prime_factors_counter26 = Vec::new();\n    let mut\
    \ prime_factors_counter27 = Vec::new();\n    let mut prime_factors_counter28 =\
    \ Vec::new();\n    let mut prime_factors_counter29 = Vec::new();\n    let mut\
    \ prime_factors_counter30 = Vec::new();\n    let mut prime_factors_counter31 =\
    \ Vec::new();\n    let mut prime_factors_counter32 = Vec::new();\n    let mut\
    \ prime_factors_counter33 = Vec::new();\n    let mut prime_factors_counter34 =\
    \ Vec::new();\n    let mut prime_factors_counter35 = Vec::new();\n    let mut\
    \ \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpg8icom1o.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_value_prime_prime = Vec::new();\n    let\
    \ mut prime_factors_count_min_value_prime_prime = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime =\
    \ Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_prime_\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4mh4s0d7.rs:37:85\n   |\n\
    37 |     let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_prime_\n\
    \   |                                                                        \
    \             ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4mh4s0d7.rs:10:27\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n \
    \   let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpf5fsmmzk.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors.push(factor);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfap3spo9.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppng22hm4.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_value_prime_prime = Vec::new();\n    let\
    \ mut prime_factors_count_min_value_prime_prime = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime =\
    \ Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_prime_prime_prime_prime_prime_prime_prime\
    \ = \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp_w870f6l.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_count = Vec::new();\n  \
    \  let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max_index = Vec::new();\n    let mut primes_count_min_index\
    \ = Vec::new();\n    let mut primes_count_max_value = Vec::new();\n    let mut\
    \ primes_count_min_value = Vec::new();\n    let mut primes_count_max_value_max\
    \ = Vec::new();\n    let mut primes_count_min_value_max = Vec::new();\n    let\
    \ mut primes_count_max_value_min = Vec::new();\n    let mut primes_count_min_value_min\
    \ = Vec::new();\n    let mut primes_count_max_value_min_index = Vec::new();\n\
    \    let mut primes_count_min_value_min_index = Vec::new();\n    let mut primes_count_max_value_min_value\
    \ = Vec::new();\n    let mut primes_count_min_value_min_value = Vec::new();\n\
    \    let mut primes_count_max_value_min_value_max = Vec::new();\n    let mut primes_count_min_value_min_value_max\
    \ = Vec::new();\n    let mut primes_count_max_value_min_value_min = Vec::new();\n\
    \    let mut primes_count_min_value_min_value_min = Vec::new();\n    let mut primes_count_max_value_min_value_min_index\
    \ = Vec::new();\n    let mut primes_count_min_value_min_value_min_index = Vec::new();\n\
    \    let mut primes_count_max_value_min_value_min_value = Vec::new();\n    let\
    \ mut primes_count_min_value_min_value_min_value = Vec::new();\n    let mut primes_count_max_value_min_value_min_value_max\
    \ = Vec::new();\n    let mut primes_count_min_value_min_value_min_value_max =\
    \ Vec::new();\n    let mut primes_count_max_value_min_value_min_value_min = Vec::new();\n\
    \    let mut primes_count_min_value_min_value_min_value_min = Vec::new();\n  \
    \  let mut primes_count_max_value_min_value_min_value_min_index = Vec::new();\n\
    \    let mut primes_count_min_value_min_value_min_value_min_index = Vec::new();\n\
    \    let mut primes_count_max_value_min_value_min_value_min_value = Vec::new();\n\
    \    let mut primes_count_min_value_min_value_min_value_value = Vec::new();\n\
    \    let mut primes_count_max_value_min_value_\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps1s7u15p.rs:44:46\n   |\n\
    44 |     let mut primes_count_max_value_min_value_\n   |                     \
    \                         ^ help: add `;` here\n45 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps1s7u15p.rs:10:27\n   |\n10 |\
    \ fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = vec![true; n];\n    let mut i = 2;\n    while i < n {\n\
    \        if primes[i] == true {\n            factors.push(i as isize);\n     \
    \       i += 1;\n        }\n        while i < n && primes[i] == true {\n     \
    \       i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa2ud6x6q.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[bool]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpa2ud6x6q.rs:15:12\n   |\n15 |         if primes[i]\
    \ == true {\n   |            ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpa2ud6x6q.rs:19:24\n   |\n19 |         while\
    \ i < n && primes[i] == true {\n   |                        ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<bool>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = vec![true; n];\n    let mut prime_factors = vec![0; n];\n\
    \    let mut i = 1;\n    while i < n {\n        if primes[i] {\n            prime_factors[i]\
    \ = 1;\n            i += 1;\n        } else {\n            let mut j = 2;\n  \
    \          while j < i {\n                if primes[j] {\n                   \
    \ prime_factors[i] = prime_factors[i] * j;\n                    i += 1;\n    \
    \                break;\n                }\n                j += 1;\n        \
    \    }\n        }\n    }\n    for i in 0..n {\n        if prime_factors[i] ==\
    \ 1 {\n            factors.push(prime_factors[i]);\n        }\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq5vsnhtg.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq5vsnhtg.rs:13:37\n\
    \   |\n13 |     let mut prime_factors = vec![0; n];\n   |                    \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    13 |     let mut prime_factors = vec![0; n.try_into().unwrap()];\n   |       \
    \                              ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type\
    \ `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpq5vsnhtg.rs:16:12\n   |\n\
    16 |         if primes[i] {\n   |            ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpq5vsnhtg.rs:17:13\n   |\n17 |  \
    \           prime_factors[i] = 1;\n   |             ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpq5vsnhtg.rs:22:20\n   |\n\
    22 |                 if primes[j] {\n   |                    ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[{integer}]`\
    \ c"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    let mut i = 1;\n    while i <= n {\n        while\
    \ n % i == 0 {\n            factors.push(factor);\n            n /= i;\n     \
    \   }\n        factors.push(1);\n        factor += 1;\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppxd8el34.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpd09x200x.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut product = 1;\n    let mut i = 1;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            factors.push(i);\n            product *= i;\n    \
    \        i += 1;\n        } else {\n            i += 1;\n        }\n    }\n  \
    \  factors.push(product);\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[2]`', /tmp/tmpvpuxgr8g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors.push(factor);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfap3spo9.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut i = 2;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            primes.push(i);\n\
    \            i += 1;\n        }\n        else {\n            i += 1;\n       \
    \ }\n    }\n    factors.push(n - 1);\n    primes.push(n - 1);\n    factors.sort_unstable();\n\
    \    primes.sort_unstable();\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmp03azhhv0.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpw61xquum.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_sizes = Vec::new();\n    let mut primes_sizes_size = Vec::new();\n\
    \    let mut primes_sizes_sizes = Vec::new();\n    let mut primes_sizes_sizes_size\
    \ = Vec::new();\n    let mut primes_sizes_sizes_sizes = Vec::new();\n    let mut\
    \ primes_sizes_sizes_sizes_size = Vec::new();\n    let mut primes_sizes_sizes_sizes_sizes\
    \ = Vec::new();\n    let mut primes_sizes_sizes_sizes_sizes_size = Vec::new();\n\
    \    let mut primes_sizes_sizes_sizes_sizes_sizes = Vec::new();\n    let mut primes_sizes_sizes_sizes_sizes_sizes_size\
    \ = Vec::new();\n    let mut primes_sizes_sizes_sizes_sizes_sizes_sizes = Vec::new();\n\
    \    let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_size = Vec::new();\n \
    \   let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes = Vec::new();\n \
    \   let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_size = Vec::new();\n\
    \    let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes = Vec::new();\n\
    \    let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_size = Vec::new();\n\
    \    let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes = Vec::new();\n\
    \    let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_size\
    \ = Vec::new();\n    let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes\
    \ = Vec::new();\n    let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_size\
    \ = Vec::new();\n    let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_sizes\
    \ = Vec::new();\n    let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyonvbb8m.rs:35:62\n   |\n\
    35 |     let mut primes_sizes_sizes_sizes_sizes_sizes_sizes_sizes_\n   |     \
    \                                                         ^ help: add `;` here\n\
    36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyonvbb8m.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut\
    \ prime_factor = 1;\n    let mut factor = 1;\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_size = Vec::new();\n    let mut factorization_size_counter\
    \ = 1;\n    let mut factorization_size_counter2 = 0;\n    let mut factorization_size_counter3\
    \ = 0;\n    let mut factorization_size_counter4 = 0;\n    let mut factorization_size_counter5\
    \ = 0;\n    let mut factorization_size_counter6 = 0;\n    let mut factorization_size_counter7\
    \ = 0;\n    let mut factorization_size_counter8 = 0;\n    let mut factorization_size_counter9\
    \ = 0;\n    let mut factorization_size_counter10 = 0;\n    let mut factorization_size_counter11\
    \ = 0;\n    let mut factorization_size_counter12 = 0;\n    let mut factorization_size_counter13\
    \ = 0;\n    let mut factorization_size_counter14 = 0;\n    let mut factorization_size_counter15\
    \ = 0;\n    let mut factorization_size_counter16 = 0;\n    let mut factorization_size_counter17\
    \ = 0;\n    let mut factorization_size_counter18 = 0;\n    let mut factorization_size_counter19\
    \ = 0;\n    let mut factorization_size_counter20 = 0;\n    let mut factorization_size_counter21\
    \ = 0;\n    let mut factorization_size_counter22 = 0;\n    let mut factorization_size_counter23\
    \ = 0;\n    let mut factorization_size_counter24 = 0;\n    let mut factorization_size_counter25\
    \ = 0;\n    let mut factorization_size_counter26 = 0;\n    let mut factorization_size_counter27\
    \ = 0;\n    let mut factorization_size_counter28 = 0;\n    let mut factorization_size_counter29\
    \ = 0;\n    let mut factorization_size_counter30 = 0;\n    let mut factorization_size_counter31\
    \ = 0;\n    let mut factorization_size_counter32 = 0;\n    let mut factorization_size_counter33\
    \ = 0;\n    let mut factorization_size_counter34 = 0;\n    let mut factorization_size_counter35\
    \ = 0;\n    let mut factorization_size_counter36 = 0;\n    let mut factorization_size_counter37\
    \ = 0;\n    let mut factorization_size_counter38 = 0;\n    let mut factorization_size_counter39\
    \ = 0;\n    let mut factorization_size_counter40 = 0;\n    let mut factorization_size_counter41\
    \ = 0;\n    let mut factorization_size_counter42 = 0;\n    let mut factorization_size_counter43\
    \ = 0;\n    let mut factorization_size_counter44 = 0;\n    let mut factorization_size_counter45\
    \ = 0;\n    let mut factor\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3x91ku6s.rs:63:19\n   |\n\
    63 |     let mut factor\n   |                   ^ help: add `;` here\n64 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3x91ku6s.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_sum = Vec::new();\n    let mut prime_factors_count_sum_max\
    \ = Vec::new();\n    let mut prime_factors_count_sum_min = Vec::new();\n    let\
    \ mut prime_factors_count_product = Vec::new();\n    let mut prime_factors_count_product_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_min = Vec::new();\n \
    \   let mut prime_factors_count_product_sum = Vec::new();\n    let mut prime_factors_count_product_sum_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product = Vec::new();\n    let mut prime_factors_count_product_product_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_product_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_sum = Vec::new();\n    let mut\
    \ prime_factors_count_product_product_sum_max = Vec::new();\n    let mut prime_factors_count_product_product_sum_min\
    \ = Vec::new();\n    let mut prime_factors_count_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_max = Vec::new();\n \
    \   let mut prime_factors_count_product_product_product_min = Vec::new();\n  \
    \  let mut prime_factors_count_product_product_product_sum = Vec::new();\n   \
    \ let mut prime_factors_count_product_product_product_sum_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_sum = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv375z0o6.rs:45:33\n   |\n\
    45 |     let mut prime_factors_count_\n   |                                 ^\
    \ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv375z0o6.rs:10:27\n   |\n10 | fn factorize(n: isize) ->\
    \ Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut primes = vec![];\n    let mut prime_factors = vec![];\n    let mut\
    \ prime_factors_count = vec![];\n    let mut prime_factors_count_max = vec![];\n\
    \    let mut prime_factors_count_min = vec![];\n    let mut prime_factors_count_sum\
    \ = vec![];\n    let mut prime_factors_count_sum_max = vec![];\n    let mut prime_factors_count_sum_min\
    \ = vec![];\n    let mut prime_factors_count_product = vec![];\n    let mut prime_factors_count_product_max\
    \ = vec![];\n    let mut prime_factors_count_product_min = vec![];\n    let mut\
    \ prime_factors_count_product_sum = vec![];\n    let mut prime_factors_count_product_sum_max\
    \ = vec![];\n    let mut prime_factors_count_product_sum_min = vec![];\n    let\
    \ mut prime_factors_count_product_product = vec![];\n    let mut prime_factors_count_product_product_max\
    \ = vec![];\n    let mut prime_factors_count_product_product_min = vec![];\n \
    \   let mut prime_factors_count_product_product_sum = vec![];\n    let mut prime_factors_count_product_product_sum_max\
    \ = vec![];\n    let mut prime_factors_count_product_product_sum_min = vec![];\n\
    \    let mut prime_factors_count_product_product_product = vec![];\n    let mut\
    \ prime_factors_count_product_product_product_max = vec![];\n    let mut prime_factors_count_product_product_product_min\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_sum = vec![];\n\
    \    let mut prime_factors_count_product_product_product_sum_max = vec![];\n \
    \   let mut prime_factors_count_product_product_product_sum_min = vec![];\n  \
    \  let mut prime_factors_count_product_product_product_product = vec![];\n   \
    \ let mut prime_factors_count_product_product_product_product_max = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_min = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_sum = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_sum_max = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_sum_min = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_product = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_max = vec![];\n\
    \    let mut prime_factors_count_product_product_product_product_min = vec![];\n\
    \    let mut prime_factors_\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbw_dy2w0.rs:47:27\n   |\n\
    47 |     let mut prime_factors_\n   |                           ^ help: add `;`\
    \ here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbw_dy2w0.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors.push(factor);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfap3spo9.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_ihys3j3.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n \
    \   let mut prime_factors = Vec::new();\n    let mut prime_divisors = Vec::new();\n\
    \    let mut prime_divisors_counter = Vec::new();\n    let mut prime_divisors_counter2\
    \ = Vec::new();\n    let mut prime_divisors_counter3 = Vec::new();\n    let mut\
    \ prime_divisors_counter4 = Vec::new();\n    let mut prime_divisors_counter5 =\
    \ Vec::new();\n    let mut prime_divisors_counter6 = Vec::new();\n    let mut\
    \ prime_divisors_counter7 = Vec::new();\n    let mut prime_divisors_counter8 =\
    \ Vec::new();\n    let mut prime_divisors_counter9 = Vec::new();\n    let mut\
    \ prime_divisors_counter10 = Vec::new();\n    let mut prime_divisors_counter11\
    \ = Vec::new();\n    let mut prime_divisors_counter12 = Vec::new();\n    let mut\
    \ prime_divisors_counter13 = Vec::new();\n    let mut prime_divisors_counter14\
    \ = Vec::new();\n    let mut prime_divisors_counter15 = Vec::new();\n    let mut\
    \ prime_divisors_counter16 = Vec::new();\n    let mut prime_divisors_counter17\
    \ = Vec::new();\n    let mut prime_divisors_counter18 = Vec::new();\n    let mut\
    \ prime_divisors_counter19 = Vec::new();\n    let mut prime_divisors_counter20\
    \ = Vec::new();\n    let mut prime_divisors_counter21 = Vec::new();\n    let mut\
    \ prime_divisors_counter22 = Vec::new();\n    let mut prime_divisors_counter23\
    \ = Vec::new();\n    let mut prime_divisors_counter24 = Vec::new();\n    let mut\
    \ prime_divisors_counter25 = Vec::new();\n    let mut prime_divisors_counter26\
    \ = Vec::new();\n    let mut prime_divisors_counter27 = Vec::new();\n    let mut\
    \ prime_divisors_counter28 = Vec::new();\n    let mut prime_divisors_counter29\
    \ = Vec::new();\n    let mut prime_divisors_counter30 = Vec::new();\n    let mut\
    \ prime_divisors_counter31 = Vec::new();\n    let mut prime\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbwu6n7wz.rs:47:18\n   |\n\
    47 |     let mut prime\n   |                  ^ help: add `;` here\n48 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbwu6n7wz.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvjb84qzs.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjb84qzs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpc089_6dr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor += 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp0igmhz7n.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppng22hm4.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut factorization = Vec::new();\n    let mut factorization_size = Vec::new();\n\
    \    let mut factorization_primes = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_primes_size = Vec::new();\n    let\
    \ mut factorization_primes_size = Vec::new();\n    let mut factorization_primes_size\
    \ = Vec::new();\n    let mut factorization_\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa2er1gwk.rs:51:27\n   |\n\
    51 |     let mut factorization_\n   |                           ^ help: add `;`\
    \ here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpa2er1gwk.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpppz8wmdh.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    let mut prime_factor = 1;\n    let mut prime_factor_counter\
    \ = 1;\n    let mut prime_factor_counter_reverse = 1;\n    let mut prime_factor_counter_reverse_counter\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse = 1;\n    let\
    \ mut prime_factor_counter_reverse_counter_reverse_counter = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter\
    \ = 1;\n    let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg60csyll.rs:35:113\n   |\n\
    35 |     let mut prime_factor_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter_reverse_counter\n\
    \   |                                                                        \
    \                                         ^ help: add `;` here\n36 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg60csyll.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            i += 1;\n        }\n        else {\n     \
    \       i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpti35ar0h.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    let mut i = 1;\n    while i * factor <= n {\n  \
    \      if n % i == 0 {\n            factors.push(factor);\n            factor\
    \ *= i;\n        }\n        i += 1;\n    }\n    factors.push(factor);\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2]`,\n right: `[2]`', /tmp/tmpecn_xi5g.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n            i += 1;\n        }\n\
    \        else {\n            i += 1;\n        }\n    }\n    factors.push(n);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp1g39cyee.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 0 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmphkjn6dl3.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = vec![true; n];\n    let mut i = 1;\n    while i < n {\n\
    \        if primes[i] == true {\n            let mut j = 1;\n            while\
    \ j < i {\n                if n % i == 0 {\n                    factors.push(i);\n\
    \                    n /= i;\n                    break;\n                }\n\
    \                j += 1\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi2w3_wwl.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[bool]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpi2w3_wwl.rs:15:12\n   |\n15 |         if primes[i]\
    \ == true {\n   |            ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut\
    \ prime_counter2 = 1;\n    let mut prime_counter3 = 1;\n    let mut prime_counter4\
    \ = 1;\n    let mut prime_counter5 = 1;\n    let mut prime_counter6 = 1;\n   \
    \ let mut prime_counter7 = 1;\n    let mut prime_counter8 = 1;\n    let mut prime_counter9\
    \ = 1;\n    let mut prime_counter10 = 1;\n    let mut prime_counter11 = 1;\n \
    \   let mut prime_counter12 = 1;\n    let mut prime_counter13 = 1;\n    let mut\
    \ prime_counter14 = 1;\n    let mut prime_counter15 = 1;\n    let mut prime_counter16\
    \ = 1;\n    let mut prime_counter17 = 1;\n    let mut prime_counter18 = 1;\n \
    \   let mut prime_counter19 = 1;\n    let mut prime_counter20 = 1;\n    let mut\
    \ prime_counter21 = 1;\n    let mut prime_counter22 = 1;\n    let mut prime_counter23\
    \ = 1;\n    let mut prime_counter24 = 1;\n    let mut prime_counter25 = 1;\n \
    \   let mut prime_counter26 = 1;\n    let mut prime_counter27 = 1;\n    let mut\
    \ prime_counter28 = 1;\n    let mut prime_counter29 = 1;\n    let mut prime_counter30\
    \ = 1;\n    let mut prime_counter31 = 1;\n    let mut prime_counter32 = 1;\n \
    \   let mut prime_counter33 = 1;\n    let mut prime_counter34 = 1;\n    let mut\
    \ prime_counter35 = 1;\n    let mut prime_counter36 = 1;\n    let mut prime_counter37\
    \ = 1;\n    let mut prime_counter38 = 1;\n    let mut prime_counter39 = 1;\n \
    \   let mut prime_counter40 = 1;\n    let mut prime_counter41 = 1;\n    let mut\
    \ prime_counter42 = 1;\n    let mut prime_counter43 = 1;\n    let mut prime_counter44\
    \ = 1;\n    let mut prime_counter45 = 1;\n    let mut prime_counter46 = 1;\n \
    \   let mut prime_counter47 = 1;\n    let mut prime_counter48 = 1;\n    let mut\
    \ prime_counter49 = 1;\n    let mut prime_counter50 = 1;\n    let mut prime_counter51\
    \ = 1;\n    let mut prime_counter52 = 1;\n    let mut prime_counter53 = 1;\n \
    \   let mut prime_counter54 = 1;\n    let mut prime_\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvb6s780l.rs:67:19\n   |\n\
    67 |     let mut prime_\n   |                   ^ help: add `;` here\n68 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvb6s780l.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = vec![true; n];\n    let mut prime_factors = vec![0; n];\n\
    \    let mut i = 1;\n    while primes.len() != n {\n        if primes[i] {\n \
    \           prime_factors[i] = 1;\n            i += 1;\n        } else {\n   \
    \         for j in 2..i {\n                if n % j == 0 {\n                 \
    \   prime_factors[j] += 1;\n                    break;\n                }\n  \
    \          }\n        }\n    }\n    for i in 0..n {\n        if prime_factors[i]\
    \ == 0 {\n            factors.push(i);\n        }\n    }\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmgwe7zgh.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmgwe7zgh.rs:13:37\n\
    \   |\n13 |     let mut prime_factors = vec![0; n];\n   |                    \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    13 |     let mut prime_factors = vec![0; n.try_into().unwrap()];\n   |       \
    \                              ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmgwe7zgh.rs:15:27\n   |\n15 |     while primes.len() !=\
    \ n {\n   |                           ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n15 |     while primes.len() != n.try_into().unwrap() {\n\
    \   |                           ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmgwe7zgh.rs:21:24\n   |\n21 |                 if n % j\
    \ == 0 {\n   |                        ^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot mod `isize` by `usize`\n  --> /tmp/tmpmgwe7zgh.rs:21:22\n   |\n21 | \
    \                if n % j == 0 {\n   |                      ^ no implementation\
    \ for `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpmgwe7zgh.rs:29:12\n   |\n29 |         if prime_factors[i] == 0\
    \ {\n   |            ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborti"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 0 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmphkjn6dl3.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvjb84qzs.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjb84qzs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut factorization = Vec::new();\n    let mut factorization_size = Vec::new();\n\
    \    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::new();\n    let mut factorization_size = Vec::new();\n    let mut factorization_size\
    \ = Vec::\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpfoeey71k.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_ihys3j3.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_ihys3j3.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n \
    \   let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpf5fsmmzk.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = vec![true; n];\n    let mut i = 1;\n    while i < n {\n\
    \        if primes[i] == true {\n            factors.push(i);\n            while\
    \ i * i < n && primes[i * i] == true {\n                factors.push(i * i);\n\
    \                i += 1;\n            }\n        }\n        i += 1;\n    }\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuwn8yqi2.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[bool]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpuwn8yqi2.rs:15:12\n   |\n15 |         if primes[i]\
    \ == true {\n   |            ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpuwn8yqi2.rs:17:32\n   |\n17 |            \
    \ while i * i < n && primes[i * i] == true {\n   |                           \
    \     ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[bool]>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpw61xquum.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppng22hm4.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut\
    \ prime_counter2 = 1;\n    let mut prime_counter3 = 1;\n    let mut prime_counter4\
    \ = 1;\n    let mut prime_counter5 = 1;\n    let mut prime_counter6 = 1;\n   \
    \ let mut prime_counter7 = 1;\n    let mut prime_counter8 = 1;\n    let mut prime_counter9\
    \ = 1;\n    let mut prime_counter10 = 1;\n    let mut prime_counter11 = 1;\n \
    \   let mut prime_counter12 = 1;\n    let mut prime_counter13 = 1;\n    let mut\
    \ prime_counter14 = 1;\n    let mut prime_counter15 = 1;\n    let mut prime_counter16\
    \ = 1;\n    let mut prime_counter17 = 1;\n    let mut prime_counter18 = 1;\n \
    \   let mut prime_counter19 = 1;\n    let mut prime_counter20 = 1;\n    let mut\
    \ prime_counter21 = 1;\n    let mut prime_counter22 = 1;\n    let mut prime_counter23\
    \ = 1;\n    let mut prime_counter24 = 1;\n    let mut prime_counter25 = 1;\n \
    \   let mut prime_counter26 = 1;\n    let mut prime_counter27 = 1;\n    let mut\
    \ prime_counter28 = 1;\n    let mut prime_counter29 = 1;\n    let mut prime_counter30\
    \ = 1;\n    let mut prime_counter31 = 1;\n    let mut prime_counter32 = 1;\n \
    \   let mut prime_counter33 = 1;\n    let mut prime_counter34 = 1;\n    let mut\
    \ prime_counter35 = 1;\n    let mut prime_counter36 = 1;\n    let mut prime_counter37\
    \ = 1;\n    let mut prime_counter38 = 1;\n    let mut prime_counter39 = 1;\n \
    \   let mut prime_counter40 = 1;\n    let mut prime_counter41 = 1;\n    let mut\
    \ prime_counter42 = 1;\n    let mut prime_counter43 = 1;\n    let mut prime_counter44\
    \ = 1;\n    let mut prime_counter45 = 1;\n    let mut prime_counter46 = 1;\n \
    \   let mut prime_counter47 = 1;\n    let mut prime_counter48 = 1;\n    let mut\
    \ prime_counter49 = 1;\n    let mut prime_counter50 = 1;\n    let mut prime_counter51\
    \ = 1;\n    let mut prime_counter52 = 1;\n    let mut prime_counter53 = 1;\n \
    \   let mut prime_counter54 = 1;\n    let mut prime_\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvb6s780l.rs:67:19\n   |\n\
    67 |     let mut prime_\n   |                   ^ help: add `;` here\n68 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvb6s780l.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_count = Vec::new();\n    let mut factorization_prime\
    \ = Vec::new();\n    let mut factorization_prime_count = Vec::new();\n    let\
    \ mut factorization_prime_prime = Vec::new();\n    let mut factorization_prime_prime_count\
    \ = Vec::new();\n    let mut factorization_prime_prime_prime = Vec::new();\n \
    \   let mut factorization_prime_prime_prime_count = Vec::new();\n    let mut factorization_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_prime_prime_prime_count = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime = Vec::new();\n    let\
    \ mut factorization_prime_prime_prime_prime_prime_count = Vec::new();\n    let\
    \ mut factorization_prime_prime_prime_prime_prime_prime = Vec::new();\n    let\
    \ mut factorization_prime_prime_prime_prime_prime_count = Vec::new();\n    let\
    \ mut factorization_prime_prime_prime_prime_prime_prime = Vec::new();\n    let\
    \ mut factorization_prime_prime_prime_prime_prime_prime_count = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_count = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_count = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp3pxepoe.rs:38:62\n   |\n\
    38 |     let mut factorization_prime_prime_prime_prime_prime_prime\n   |     \
    \                                                         ^ help: add `;` here\n\
    39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp3pxepoe.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut i = 1;\n    while i <= n {\n  \
    \      if n % i == 0 {\n            factors.push(i);\n            primes.push(i);\n\
    \            i += 2;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    factors.push(n - 1);\n    primes.push(n - 1);\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1]`,\n right: `[2]`', /tmp/tmp6v6mdxdo.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748265
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvjb84qzs.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjb84qzs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_max = Vec::new();\n\
    \    let mut prime_factors_count_max_value_min_index = Vec::new();\n    let mut\
    \ prime_factors_count_max_value_max_index = Vec::new();\n    let mut prime_factors_count_max_value_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_index = Vec::new();\n\
    \    let mut prime_factors_count_max_value_min_value_max = Vec::new();\n    let\
    \ mut prime_factors_count_max_value_min_value_min_index = Vec::new();\n    let\
    \ mut prime_factors_count_max_value_min_value_max_index = Vec::new();\n    let\
    \ mut prime_factors_count_max_value_min_value_max_value = Vec::new();\n    let\
    \ mut prime_factors_count_max_value_min_value_max_value_index = Vec::new();\n\
    \    let mut prime_factors_count_max_value_min_value_max_value_value = Vec::new();\n\
    \    let mut prime_factors_count_max_value_min_value_max_value_min_index = Vec::new();\n\
    \    let mut prime_factors_count_max_value_min_value_max_value_min_index_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_max_value_min_index_value_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_max_value_min_index_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_max_value_min_index_value_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_max_value_min_index_value_max_value_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_max_value_min_index_value_max_value_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_max_value_min_index_value_max_value_value_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdkpg3tkv.rs:41:11\n   |\n\
    41 |     let mu\n   |           ^ help: add `;` here\n42 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdkpg3tkv.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppng22hm4.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpc089_6dr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    primes.push(i);\n            prime_factors.push(i);\n            factors.push(i);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in primes.iter_mut() {\n        *i /= prime_factors.iter().filter(|&x|\
    \ x == i).count();\n    }\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk16sgaqq.rs:26:15\n   |\n\
    26 |         *i /= prime_factors.iter().filter(|&x| x == i).count();\n   |   \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot divide-assign `isize` by `usize`\n  -->\
    \ /tmp/tmpk16sgaqq.rs:26:12\n   |\n26 |         *i /= prime_factors.iter().filter(|&x|\
    \ x == i).count();\n   |            ^^ no implementation for `isize /= usize`\n\
    \   |\n   = help: the trait `DivAssign<usize>` is not implemented for `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut product = 1;\n    let mut i = 1;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            factors.push(i);\n            product *= i;\n    \
    \        i += 1;\n        }\n        i += 1;\n    }\n    factors.push(product);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1]`,\n right: `[2]`', /tmp/tmp8_7tu7em.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut i = 1;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            primes.push(i);\n\
    \            i += 1;\n        }\n        else {\n            i += 1;\n       \
    \ }\n    }\n    for i in factors.iter_mut() {\n        *i /= primes.iter().filter(|&i|\
    \ i == *i).count();\n    }\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpy1btdwo_.rs:25:43\n\
    \   |\n25 |         *i /= primes.iter().filter(|&i| i == *i).count();\n   |  \
    \                                         ^^ no implementation for `&isize ==\
    \ isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy1btdwo_.rs:25:15\n\
    \   |\n25 |         *i /= primes.iter().filter(|&i| i == *i).count();\n   |  \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot divide-assign `isize` by `usize`\n  --> /tmp/tmpy1btdwo_.rs:25:12\n\
    \   |\n25 |         *i /= primes.iter().filter(|&i| i == *i).count();\n   |  \
    \          ^^ no implementation for `isize /= usize`\n   |\n   = help: the trait\
    \ `DivAssign<usize>` is not implemented for `isize`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n \
    \   let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size = Vec::new();\n    let mut primes_size = Vec::\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpf5fsmmzk.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut primes = vec![];\n    let mut prime_factors = vec![];\n    let mut\
    \ prime_factors_count = vec![];\n    let mut prime_factors_count_max = vec![];\n\
    \    let mut prime_factors_count_max_index = vec![];\n    let mut prime_factors_count_min\
    \ = vec![];\n    let mut prime_factors_count_min_index = vec![];\n    let mut\
    \ prime_factors_count_max_value = vec![];\n    let mut prime_factors_count_min_value\
    \ = vec![];\n    let mut prime_factors_count_max_value_max = vec![];\n    let\
    \ mut prime_factors_count_min_value_max = vec![];\n    let mut prime_factors_count_max_value_min\
    \ = vec![];\n    let mut prime_factors_count_min_value_min = vec![];\n    let\
    \ mut prime_factors_count_max_value_min_index = vec![];\n    let mut prime_factors_count_min_value_min_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_min_value = vec![];\n \
    \   let mut prime_factors_count_min_value_min_value = vec![];\n    let mut prime_factors_count_max_value_min_value_max\
    \ = vec![];\n    let mut prime_factors_count_min_value_min_value_max = vec![];\n\
    \    let mut prime_factors_count_max_value_min_value_min = vec![];\n    let mut\
    \ prime_factors_count_min_value_min_value_min = vec![];\n    let mut prime_factors_count_max_value_min_value_min_index\
    \ = vec![];\n    let mut prime_factors_count_min_value_min_value_min_index = vec![];\n\
    \    let mut prime_factors_count_max_value_min_value_min_value = vec![];\n   \
    \ let mut prime_factors_count_min_value_min_value_min_value = vec![];\n    let\
    \ mut prime_factors_count_max_value_min_value_min_value_max = vec![];\n    let\
    \ mut prime_factors_count_min_value_min_value_min_value_max = vec![];\n    let\
    \ mut prime_factors_count_max_value_min_value_min_value_min = vec![];\n    let\
    \ mut prime_factors_count_min_value_min_value_min_value_min = vec![];\n    let\
    \ mut prime_factors_count_max_value_min_value_min_value_min_index = vec![];\n\
    \    let mut prime_factors_count_min_value_min_value_min_value_min_index = vec![];\n\
    \    let mut prime_factors_count_max_value_min_value_min_value_min_value = vec![];\n\
    \    let mut prime_factors_count_min_value_min_value_min_value_value = vec![];\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp53k0s735.rs:45:11\n   |\n\
    45 |     let mu\n   |           ^ help: add `;` here\n46 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp53k0s735.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_min_value\
    \ = \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpn2us537g.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 0 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= factor;\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpdmlu2qlz.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n \
    \   let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpjir1rxv0.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n            i += 1;\n        }\n\
    \    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpv85umsxo.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let mut primes_size_rev = Vec::new();\n    let mut primes_size = Vec::new();\n\
    \    let \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpybvb8bo5.rs:55:1\n  \
    \ |\n55 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    factors.push(n);\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpw3z4l_zr.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut product = n;\n    while product > 1 {\n        let mut i = 0;\n \
    \       while product % i == 0 {\n            i += 1;\n        }\n        factors.push(i);\n\
    \        product /= i;\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpc8swon32.rs:15:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748265
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_ihys3j3.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_count = Vec::new();\n    let mut primes_count_size = Vec::new();\n\
    \    let mut primes_count_size = Vec::new();\n    let mut primes_count_size =\
    \ Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1i0fi6m1.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1i0fi6m1.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n            i += 1;\n        }\n\
    \    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpbpackb4j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 0 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor *= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp62gx__rn.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpey2s4t1j.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvjb84qzs.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjb84qzs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut product = n;\n    let mut i = 1;\n    while product % i == 0 {\n\
    \        factors.push(i);\n        product /= i;\n        i += 1;\n    }\n   \
    \ factors.push(product);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 1]`,\n right: `[2]`', /tmp/tmp8ev46azx.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748265
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n   \
    \ let mut primes_count = Vec::new();\n    let mut primes_count_size = Vec::new();\n\
    \    let mut primes_count_size = Vec::new();\n    let mut primes_count_size =\
    \ Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1i0fi6m1.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1i0fi6m1.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            factors.push(factor);\n            n /= factor;\n        }\n    \
    \    factor += 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp0igmhz7n.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut product = 1;\n    let mut i = 1;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            factors.push(i as isize);\n            product *=\
    \ i;\n            i += 1;\n        }\n    }\n    factors.push(product);\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[2]`', /tmp/tmpjemzwqob.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748265
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpd09x200x.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n \
    \   let mut prime_factors_counter = Vec::new();\n    let mut prime_factors_counter_reverse\
    \ = Vec::new();\n    let mut prime_factors_counter_reverse_2 = Vec::new();\n \
    \   let mut prime_factors_counter_reverse_3 = Vec::new();\n    let mut prime_factors_counter_reverse_4\
    \ = Vec::new();\n    let mut prime_factors_counter_reverse_5 = Vec::new();\n \
    \   let mut prime_factors_counter_reverse_6 = Vec::new();\n    let mut prime_factors_counter_reverse_7\
    \ = Vec::new();\n    let mut prime_factors_counter_reverse_8 = Vec::new();\n \
    \   let mut prime_factors_counter_reverse_9 = Vec::new();\n    let mut prime_factors_counter_reverse_10\
    \ = Vec::new();\n    let mut prime_factors_counter_reverse_11 = Vec::new();\n\
    \    let mut prime_factors_counter_reverse_12 = Vec::new();\n    let mut prime_factors_counter_reverse_13\
    \ = Vec::new();\n    let mut prime_factors_counter_reverse_14 = Vec::new();\n\
    \    let mut prime_factors_counter_reverse_15 = Vec::new();\n    let mut prime_factors_counter_reverse_16\
    \ = Vec::new();\n    let mut prime_factors_counter_reverse_17 = Vec::new();\n\
    \    let mut prime_factors_counter_reverse_18 = Vec::new();\n    let mut prime_factors_counter_reverse_19\
    \ = Vec::new();\n    let mut prime_factors_counter_reverse_20 = Vec::new();\n\
    \    let mut prime_factors_counter_reverse_21 = Vec::new();\n    let mut prime_factors_counter_reverse_22\
    \ = Vec::new();\n    let mut prime_factors_counter_reverse_23 = Vec::new();\n\
    \    let mut prime_factors_counter_reverse_24 = Vec::new();\n    let mut prime_factors_counter_reverse_25\
    \ = Vec::new();\n    let mut prime_factors_counter_reverse_26 = Vec::new();\n\
    \    let mut prime_factors_counter_reverse_27 = Vec::new();\n    let mut prime_factors_counter_reverse_28\
    \ = Vec::new();\n    let mut prime_factors_counter_reverse_29 = Vec::new();\n\
    \    let mut prime_factors_counter_reverse_30 = Vec::new();\n\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxleug2sz.rs:10:27\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut\
    \ prime_counter2 = 1;\n    let mut prime_counter3 = 1;\n    let mut prime_counter4\
    \ = 1;\n    let mut prime_counter5 = 1;\n    let mut prime_counter6 = 1;\n   \
    \ let mut prime_counter7 = 1;\n    let mut prime_counter8 = 1;\n    let mut prime_counter9\
    \ = 1;\n    let mut prime_counter10 = 1;\n    let mut prime_counter11 = 1;\n \
    \   let mut prime_counter12 = 1;\n    let mut prime_counter13 = 1;\n    let mut\
    \ prime_counter14 = 1;\n    let mut prime_counter15 = 1;\n    let mut prime_counter16\
    \ = 1;\n    let mut prime_counter17 = 1;\n    let mut prime_counter18 = 1;\n \
    \   let mut prime_counter19 = 1;\n    let mut prime_counter20 = 1;\n    let mut\
    \ prime_counter21 = 1;\n    let mut prime_counter22 = 1;\n    let mut prime_counter23\
    \ = 1;\n    let mut prime_counter24 = 1;\n    let mut prime_counter25 = 1;\n \
    \   let mut prime_counter26 = 1;\n    let mut prime_counter27 = 1;\n    let mut\
    \ prime_counter28 = 1;\n    let mut prime_counter29 = 1;\n    let mut prime_counter30\
    \ = 1;\n    let mut prime_counter31 = 1;\n    let mut prime_counter32 = 1;\n \
    \   let mut prime_counter33 = 1;\n    let mut prime_counter34 = 1;\n    let mut\
    \ prime_counter35 = 1;\n    let mut prime_counter36 = 1;\n    let mut prime_counter37\
    \ = 1;\n    let mut prime_counter38 = 1;\n    let mut prime_counter39 = 1;\n \
    \   let mut prime_counter40 = 1;\n    let mut prime_counter41 = 1;\n    let mut\
    \ prime_counter42 = 1;\n    let mut prime_counter43 = 1;\n    let mut prime_counter44\
    \ = 1;\n    let mut prime_counter45 = 1;\n    let mut prime_counter46 = 1;\n \
    \   let mut prime_counter47 = 1;\n    let mut prime_counter48 = 1;\n    let mut\
    \ prime_counter49 = 1;\n    let mut prime_counter50 = 1;\n    let mut prime_counter51\
    \ = 1;\n    let mut prime_counter52 = 1;\n    let mut prime_counter53 = 1;\n \
    \   let mut prime_counter54 = 1;\n    let mut prime_\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvb6s780l.rs:67:19\n   |\n\
    67 |     let mut prime_\n   |                   ^ help: add `;` here\n68 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvb6s780l.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut i = 1;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            primes.push(i);\n\
    \            while n % i == 0 {\n                n /= i;\n                factors.push(i);\n\
    \                primes.push(i);\n            }\n        }\n        i += 1;\n\
    \    }\n    factors.push(1);\n    primes.push(1);\n    factors.sort_unstable();\n\
    \    primes.sort_unstable();\n    factors.iter().cloned().collect()\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpx9or6bne.rs:19:17\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n19 |                 n /=\
    \ i;\n   |                 ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659748264
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut\
    \ prime_counter2 = 1;\n    let mut prime_counter3 = 1;\n    let mut prime_counter4\
    \ = 1;\n    let mut prime_counter5 = 1;\n    let mut prime_counter6 = 1;\n   \
    \ let mut prime_counter7 = 1;\n    let mut prime_counter8 = 1;\n    let mut prime_counter9\
    \ = 1;\n    let mut prime_counter10 = 1;\n    let mut prime_counter11 = 1;\n \
    \   let mut prime_counter12 = 1;\n    let mut prime_counter13 = 1;\n    let mut\
    \ prime_counter14 = 1;\n    let mut prime_counter15 = 1;\n    let mut prime_counter16\
    \ = 1;\n    let mut prime_counter17 = 1;\n    let mut prime_counter18 = 1;\n \
    \   let mut prime_counter19 = 1;\n    let mut prime_counter20 = 1;\n    let mut\
    \ prime_counter21 = 1;\n    let mut prime_counter22 = 1;\n    let mut prime_counter23\
    \ = 1;\n    let mut prime_counter24 = 1;\n    let mut prime_counter25 = 1;\n \
    \   let mut prime_counter26 = 1;\n    let mut prime_counter27 = 1;\n    let mut\
    \ prime_counter28 = 1;\n    let mut prime_counter29 = 1;\n    let mut prime_counter30\
    \ = 1;\n    let mut prime_counter31 = 1;\n    let mut prime_counter32 = 1;\n \
    \   let mut prime_counter33 = 1;\n    let mut prime_counter34 = 1;\n    let mut\
    \ prime_counter35 = 1;\n    let mut prime_counter36 = 1;\n    let mut prime_counter37\
    \ = 1;\n    let mut prime_counter38 = 1;\n    let mut prime_counter39 = 1;\n \
    \   let mut prime_counter40 = 1;\n    let mut prime_counter41 = 1;\n    let mut\
    \ prime_counter42 = 1;\n    let mut prime_counter43 = 1;\n    let mut prime_counter44\
    \ = 1;\n    let mut prime_counter45 = 1;\n    let mut prime_counter46 = 1;\n \
    \   let mut prime_counter47 = 1;\n    let mut prime_counter48 = 1;\n    let mut\
    \ prime_counter49 = 1;\n    let mut prime_counter50 = 1;\n    let mut prime_counter51\
    \ = 1;\n    let mut prime_counter52 = 1;\n    let mut prime_counter53 = 1;\n \
    \   let mut prime_counter54 = 1;\n    let mut prime_\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvb6s780l.rs:67:19\n   |\n\
    67 |     let mut prime_\n   |                   ^ help: add `;` here\n68 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvb6s780l.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748264
