language: rs
name: HumanEval_70_strange_sort_list
results:
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| *x == max).unwrap();\n    vec.push(min);\n\
    \    while min_idx != max_idx {\n        vec.push(lst.swap_remove(min_idx));\n\
    \        min_idx = lst.iter().position(|x| *x == min).unwrap();\n        max_idx\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiue7mdxj.rs:15:53\n   |\n\
    15 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiue7mdxj.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiue7mdxj.rs:19:18\n   |\n19 |         vec.push(lst.swap_remove(min_idx));\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n   |                  |\n   |\
    \                  expected `&isize`, found `isize`\n   |                  help:\
    \ consider borrowing here: `&lst.swap_remove(min_idx)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiue7mdxj.rs:20:49\n   |\n20 |         min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |         min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiue7mdxj.rs:21:49\n   |\n21 |         max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiue7mdxj.rs:23:5\n   |\n11 | fn strange_sort"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let\
    \ mut min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpx90w1rdj.rs:130:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    115 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n116 | \n117 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n130 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx90w1rdj.rs:11:42\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |    -----------------                     ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpakrdx50p.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp5vuq4b4t.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpz0vsx8us.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp642o2dzi.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmp642o2dzi.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp642o2dzi.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst[0];\n    let mut max = lst[0];\n\
    \    for el in lst.iter().rev() {\n        if el < min {\n            min = el;\n\
    \        }\n        if el > max {\n            max = el;\n        }\n    }\n \
    \   let mut result = vec![];\n    for el in lst.iter() {\n        if el == min\
    \ {\n            result.push(max);\n        } else {\n            result.push(el);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa66vdb00.rs:15:17\n   |\n\
    15 |         if el < min {\n   |                 ^^^\n   |                 |\n\
    \   |                 expected `&isize`, found `isize`\n   |                 help:\
    \ consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa66vdb00.rs:16:19\n\
    \   |\n12 |     let mut min = lst[0];\n   |                   ------ expected\
    \ due to this value\n...\n16 |             min = el;\n   |                   ^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |             min = *el;\n   |                   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa66vdb00.rs:18:17\n   |\n18 |         if el\
    \ > max {\n   |                 ^^^\n   |                 |\n   |            \
    \     expected `&isize`, found `isize`\n   |                 help: consider borrowing\
    \ here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa66vdb00.rs:19:19\n\
    \   |\n13 |     let mut max = lst[0];\n   |                   ------ expected\
    \ due to this value\n...\n19 |             max = el;\n   |                   ^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |             max = *el;\n   |                   +\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpa66vdb00.rs:24:15\n   |\n\
    24 |         if el == min {\n   |               ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa66vdb00.rs:27:25\n\
    \   |\n27 |             result.push(el);\n   |                         ^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    27 |             result.push(*el);\n   |                         +\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have det"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp1atdesvw.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpjl5t0wnl.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpbjsnhkop.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt78v1bsy.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt78v1bsy.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt78v1bsy.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| x == max).unwrap();\n    let mut min_idx =\
    \ min_idx as usize;\n    let mut max_idx = max_idx as usize;\n    let mut i =\
    \ 0;\n    while i < lst.len() {\n        if min_idx < max_idx {\n            result.push(lst[min_idx]);\n\
    \            min_idx += 1;\n        } else {\n            result.push(lst[max_idx]);\n\
    \            max_idx -= 1;\n        }\n        i += 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp_vwuxiw5.rs:35:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp8soqri_f.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| *x == max).unwrap();\n    while min_idx !=\
    \ max_idx {\n        let tmp = min;\n        min = max;\n        max = tmp;\n\
    \        min_idx = lst.iter().position(|x| *x == min).unwrap();\n        max_idx\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    }\n    lst.sort_unstable();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4icwjtrf.rs:15:53\n   |\n\
    15 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4icwjtrf.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4icwjtrf.rs:21:49\n   |\n21 |         min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4icwjtrf.rs:22:49\n   |\n22 |         max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |         max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                 +\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|&x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|&x| x == max).unwrap();\n\
    \    let mut new_lst = vec![];\n    while min_idx != max_idx {\n        new_lst.push(lst[min_idx]);\n\
    \        min_idx += 1;\n    }\n    new_lst.extend(lst.iter().skip(min_idx).take(max_idx\
    \ - min_idx));\n    new_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprw9err4v.rs:14:53\n   |\n\
    14 |     let mut min_idx = lst.iter().position(|&x| x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |     let\
    \ mut min_idx = lst.iter().position(|&x| x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprw9err4v.rs:15:53\n   |\n15 |     let mut max_idx = lst.iter().position(|&x|\
    \ x == max).unwrap();\n   |                                                  \
    \   ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n15 |     let mut max_idx = lst.iter().position(|&x| x == *max).unwrap();\n\
    \   |                                                     +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| x == max).unwrap();\n\
    \    while min_idx != max_idx {\n        res.push(min);\n        res.push(max);\n\
    \        min = lst.iter().nth(min_idx).unwrap();\n        max_idx = lst.iter().position(|x|\
    \ x == max).unwrap();\n    }\n    res.push(min);\n    res.push(max);\n    res\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6z78fsrr.rs:25:5\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n25 |     res\n   |     ^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n \
    \       if x < min_value {\n            min_value = x;\n        }\n        if\
    \ x > max_value {\n            max_value = x;\n        }\n    }\n    for x in\
    \ lst {\n        if x == min_value {\n            sorted_list.push(x);\n     \
    \   }\n        if x == max_value {\n            sorted_list.push(x);\n       \
    \ }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpdg897651.rs:23:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n23  |     for x in lst {\n \
    \   |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min =\
    \ lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n \
    \   let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx2\
    \ = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx2 = lst.iter().position(|x|\
    \ *x == max).unwrap();\n    let mut min_idx3 = lst.iter().position(|x| *x == min).unwrap();\n\
    \    let mut max_idx3 = lst.iter().position(|x| *x == max).unwrap();\n    let\
    \ mut min_idx4 = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx4\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx5 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx5 = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut min_idx6 = lst.iter().position(|x| *x == min).unwrap();\n    let\
    \ mut max_idx6 = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx7\
    \ = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx7 = lst.iter().position(|x|\
    \ *x == max).unwrap();\n    let mut min_idx8 = lst.iter().position(|x| *x == min).unwrap();\n\
    \    let mut max_idx8 = lst.iter().position(|x| *x == max).unwrap();\n    let\
    \ mut min_idx9 = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx9\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx10 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx10 = lst.iter().position(|x| *x ==\
    \ max).unwrap();\n    let mut min_idx11 = lst.iter().position(|x| *x == min).unwrap();\n\
    \    let mut max_idx11 = lst.iter().position(|x| *x == max).unwrap();\n    let\
    \ mut min_idx12 = lst.iter().position(|x| *x == min).\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpzd65uaep.rs:38:1\n   |\n38\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpzd65uaep.rs:37:60\n\
    \   |\n37 |     let mut min_idx12 = lst.iter().position(|x| *x == min).\n   |\
    \                                                            ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzd65uaep.rs:15:53\n\
    \   |\n15 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n\
    \   |                                                     ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |  \
    \   let mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |    \
    \                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzd65uaep.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzd65uaep.rs:17:54\n   |\n17 |     let mut min_idx2 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 \
    \     ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |     let mut min_idx2 = lst.iter().position(|x| *x ==\
    \ *min).unwrap();\n   |                                                      +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzd65uaep.rs:18:54\n   |\n18 |\
    \     let mut max_idx2 = lst.iter().position(|x| *x == max).unwrap();\n   |  \
    \                                                    ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |     let\
    \ mut max_idx2 = lst.iter().position(|x| *x == *max).unwrap();\n   |         \
    \                                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for value in\
    \ sorted_list.iter() {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in sorted_list.iter() {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n   --> /tmp/tmp5biyflsl.rs:114:17\n   \
    \ |\n114 |     let mut max_\n    |                 ^ help: add `;` here\n115 |\
    \ }\n    | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5biyflsl.rs:16:20\n\
    \   |\n16 |         if value < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5biyflsl.rs:17:25\n   |\n17 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5biyflsl.rs:19:20\n   |\n19 |         if value > max_value {\n\
    \   |                    ^^^^^^^^^\n   |                    |\n   |          \
    \          expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5biyflsl.rs:20:25\n\
    \   |\n20 |             max_value = value;\n   |                         ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |             max_value = *value;\n   |                         +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5biyflsl.rs:26:20\n   |\n26 |  \
    \       if value < min_value {\n   |                    ^^^^^^^^^\n   |      \
    \              |\n   |                    expected `&isize`, found `isize`\n \
    \  |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5biyflsl.rs:27:25\n   |\n27 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n27 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5biyflsl.rs:29:20\n   |\n29 |         if value > max_value {\n\
    \   |                    ^^^^^^"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.clone();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpbaqsjezy.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n \
    \       if x < min_value {\n            min_value = x;\n        }\n        if\
    \ x > max_value {\n            max_value = x;\n        }\n    }\n    for x in\
    \ lst {\n        if x == min_value {\n            sorted_list.push(x);\n     \
    \   }\n        if x == max_value {\n            sorted_list.push(x);\n       \
    \ }\n    }\n    for x in lst {\n        if x == min_value {\n            sorted_list.push(x);\n\
    \        }\n        if x == max_value {\n            sorted_list.push(x);\n  \
    \      }\n    }\n    for x in lst {\n        if x == min_value {\n           \
    \ sorted_list.push(x);\n        }\n        if x == max_value {\n            sorted_list.push(x);\n\
    \        }\n    }\n    for x in lst {\n        if x == min_value {\n         \
    \   sorted_list.push(x);\n        }\n        if x == max_value {\n           \
    \ sorted_list.push(x);\n        }\n    }\n    for x in lst {\n        if x ==\
    \ min_value {\n            sorted_list.push(x);\n        }\n        if x == max_value\
    \ {\n            sorted_list.push(x);\n        }\n    }\n    for x in lst {\n\
    \        if x == min_value {\n            sorted_list.push(x);\n        }\n  \
    \      if x == max_value {\n            sorted_list.push(x);\n        }\n    }\n\
    \    for x in lst {\n        if x == min_value {\n            sorted_list.push(x);\n\
    \        }\n        if x == max_value {\n            sorted_list.push(x);\n  \
    \      }\n    }\n    for x in lst {\n        if x == min_value {\n           \
    \ sorted_list.push(x);\n        }\n        if x == max_value {\n            sorted_list.push(x);\n\
    \        }\n    }\n    for x in lst {\n        if x == min_value {\n         \
    \   sorted_list.push(x);\n        }\n        if x == max_value {\n           \
    \ sorted_list.push(x);\n        }\n    }\n    for x in lst {\n        if x ==\
    \ min_value {\n            sorted_list.push(x);\n        }\n        if x == max_value\
    \ {\n            sorted_list.push(x);\n        }\n    }\n    for x in lst {\n\
    \        if x == min_value {\n            sorted_list.push(x);\n        }\n  \
    \      if x == max_value {\n            sorted_list.push(x);\n        }\n    }\n\
    \    for x in lst {\n        if x == min_value {\n            sorted_list.push(x);\n\
    \        }\n        if x == max_value {\n            sorted_list.push(x);\n  \
    \      }\n    }\n    for x in lst {\n        if x == min_value {\n           \
    \ sorted_list.push(x);\n        }\n        if x == max_\n}\n\nfn main() {\n  \
    \  let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3brgwoh3.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for x in lst {\n    |                  - this delimiter might not be\
    \ properly closed...\n...\n124 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   -->\
    \ /tmp/tmp3brgwoh3.rs:124:1\n    |\n123 |         if x == max_\n    |        \
    \ -- this `if` expression has a condition, but no block\n124 | }\n    | ^ expected\
    \ `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3brgwoh3.rs:11:42\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for el in lst {\n\
    \        if el < min_value {\n            min_value = el;\n        }\n       \
    \ if el > max_value {\n            max_value = el;\n        }\n    }\n    for\
    \ el in lst {\n        if el == min_value {\n            sorted_list.push(el);\n\
    \        }\n        if el == max_value {\n            sorted_list.push(el);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpwvixobxi.rs:23:15\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for el in lst {\n    | \
    \              ---\n    |               |\n    |               `lst` moved due\
    \ to this implicit call to `.into_iter()`\n    |               help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n23  |     for el in\
    \ lst {\n    |               ^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut mid = min + max / 2;\n    loop {\n        if lst.iter().any(|x| x\
    \ > mid) {\n            max = mid;\n            mid = min + max / 2;\n       \
    \ } else {\n            min = mid;\n            mid = min + max / 2;\n       \
    \ }\n        if lst.iter().any(|x| x < mid) {\n            min = mid;\n      \
    \      mid = min + max / 2;\n        } else {\n            break;\n        }\n\
    \    }\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp069505sh.rs:17:35\n   |\n\
    17 |         if lst.iter().any(|x| x > mid) {\n   |                          \
    \         ^^^\n   |                                   |\n   |                \
    \                   expected `&isize`, found `isize`\n   |                   \
    \                help: consider borrowing here: `&mid`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp069505sh.rs:18:19\n   |\n18 |             max = mid;\n\
    \   |                   ^^^\n   |                   |\n   |                  \
    \ expected `&isize`, found `isize`\n   |                   help: consider borrowing\
    \ here: `&mid`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp069505sh.rs:21:19\n\
    \   |\n21 |             min = mid;\n   |                   ^^^\n   |         \
    \          |\n   |                   expected `&isize`, found `isize`\n   |  \
    \                 help: consider borrowing here: `&mid`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp069505sh.rs:24:35\n   |\n24 |         if lst.iter().any(|x|\
    \ x < mid) {\n   |                                   ^^^\n   |               \
    \                    |\n   |                                   expected `&isize`,\
    \ found `isize`\n   |                                   help: consider borrowing\
    \ here: `&mid`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp069505sh.rs:25:19\n\
    \   |\n25 |             min = mid;\n   |                   ^^^\n   |         \
    \          |\n   |                   expected `&isize`, found `isize`\n   |  \
    \                 help: consider borrowing here: `&mid`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for el in lst.iter().rev() {\n\
    \        if el < min_value {\n            min_value = el;\n        }\n       \
    \ if el > max_value {\n            max_value = el;\n        }\n    }\n    for\
    \ el in lst.iter() {\n        if el < min_value {\n            result.push(el);\n\
    \        }\n        if el > max_value {\n            result.push(el);\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppzu19529.rs:16:17\n   |\n\
    16 |         if el < min_value {\n   |                 ^^^^^^^^^\n   |       \
    \          |\n   |                 expected `&isize`, found `isize`\n   |    \
    \             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppzu19529.rs:17:25\n   |\n17 |             min_value = el;\n\
    \   |                         ^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n17 |             min_value = *el;\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppzu19529.rs:19:17\n\
    \   |\n19 |         if el > max_value {\n   |                 ^^^^^^^^^\n   |\
    \                 |\n   |                 expected `&isize`, found `isize`\n \
    \  |                 help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppzu19529.rs:20:25\n   |\n20 |             max_value\
    \ = el;\n   |                         ^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n20 |             max_value\
    \ = *el;\n   |                         +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmppzu19529.rs:24:17\n   |\n24 |         if el < min_value {\n   |\
    \                 ^^^^^^^^^\n   |                 |\n   |                 expected\
    \ `&isize`, found `isize`\n   |                 help: consider borrowing here:\
    \ `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppzu19529.rs:27:17\n\
    \   |\n27 |         if el > max_value {\n   |                 ^^^^^^^^^\n   |\
    \                 |\n   |                 expected `&isize`, found `isize`\n \
    \  |                 help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppzu19529.rs:31:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n31 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min =\
    \ lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n \
    \   let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| *x == max).unwrap();\n    while min_idx !=\
    \ max_idx {\n        result.push(lst.swap_remove(min_idx));\n        min_idx =\
    \ lst.iter().position(|x| *x == min).unwrap();\n        max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw4xivl97.rs:15:53\n   |\n\
    15 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw4xivl97.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw4xivl97.rs:19:49\n   |\n19 |         min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |         min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw4xivl97.rs:20:49\n   |\n20 |         max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |         max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                 +\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut min = lst[0];\n\
    \    let mut max = lst[0];\n    for x in lst {\n        if x < min {\n       \
    \     min = x;\n        }\n        if x > max {\n            max = x;\n      \
    \  }\n    }\n    for x in lst {\n        if x == min {\n            res.push(min);\n\
    \        }\n        if x == max {\n            res.push(max);\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp1p1d45tl.rs:23:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n23  |     for x in lst {\n \
    \   |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst[0];\n    let mut max = lst[0];\n\
    \    for x in lst {\n        if x < min {\n            min = x;\n        }\n \
    \       if x > max {\n            max = x;\n        }\n    }\n    let mut result\
    \ = vec![];\n    while min <= max {\n        let mid = min + (max - min) / 2;\n\
    \        result.push(mid);\n        if mid == min {\n            min = min + 1;\n\
    \        } else {\n            max = mid - 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp8siqy9lo.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst[0];\n    let mut max = lst[0];\n\
    \    for x in lst {\n        if x < min {\n            min = x;\n        }\n \
    \       if x > max {\n            max = x;\n        }\n    }\n    let mut new_lst\
    \ = vec![];\n    for x in lst {\n        if x == min {\n            new_lst.push(x);\n\
    \        }\n        if x == max {\n            new_lst.push(x + 1);\n        }\n\
    \    }\n    new_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpm8yt1y9b.rs:23:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n14  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n23  |     for x in lst {\n \
    \   |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n \
    \       if x < min_value {\n            min_value = x;\n        }\n        if\
    \ x > max_value {\n            max_value = x;\n        }\n    }\n    for x in\
    \ lst {\n        if x == min_value {\n            sorted_list.push(x);\n     \
    \   }\n        if x == max_value {\n            sorted_list.push(x);\n       \
    \ }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpdg897651.rs:23:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n23  |     for x in lst {\n \
    \   |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut min_val\
    \ = lst.iter().min().unwrap();\n    let mut max_val = lst.iter().max().unwrap();\n\
    \    for val in lst {\n        if val < min_val {\n            min_val = val;\n\
    \        }\n        if val > max_val {\n            max_val = val;\n        }\n\
    \    }\n    let mut min_idx = lst.iter().position(|x| x == min_val).unwrap();\n\
    \    let mut max_idx = lst.iter().position(|x| x == max_val).unwrap();\n    let\
    \ mut min_idx2 = lst.iter().position(|x| x == min_val).unwrap();\n    while min_idx\
    \ != max_idx {\n        let mut tmp = min_idx;\n        min_idx = min_idx2;\n\
    \        min_idx2 = tmp;\n        let mut tmp = min_idx;\n        min_idx = lst.iter().position(|x|\
    \ x == min_val).unwrap();\n        min_idx2 = tmp;\n    }\n    for val in lst\
    \ {\n        if val < min_val {\n            res.push(min_val);\n            min_val\
    \ = val;\n        }\n        if val > max_val {\n            res.push(max_val);\n\
    \            max_val = val;\n        }\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvc5_c8al.rs:16:18\n   |\n\
    16 |         if val < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |  \
    \       if val < *min_val {\n   |                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvc5_c8al.rs:17:23\n   |\n17 |             min_val = val;\n\
    \   |                       ^^^\n   |                       |\n   |          \
    \             expected `&isize`, found `isize`\n   |                       help:\
    \ consider borrowing here: `&val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvc5_c8al.rs:19:18\n\
    \   |\n19 |         if val > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |         if val > *max_val {\n   |                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvc5_c8al.rs:20:23\n   |\n20 |             max_val = val;\n\
    \   |                       ^^^\n   |                       |\n   |          \
    \             expected `&isize`, found `isize`\n   |                       help:\
    \ consider borrowing here: `&val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvc5_c8al.rs:35:18\n\
    \   |\n35 |         if val < min_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |         if val < *min_val {\n   |                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvc5_c8al.rs:37:23\n   |\n37 |             min_val = val;\n\
    \   |                       ^^^\n   |                       |\n   |          \
    \             expected `&isize`, found `isize`\n   |                       help:\
    \ consider borrowing here: `&val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvc5_c8al.rs:39:18\n\
    \   |\n39 |         if val > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    39 |         if val > *max_val {\n   |                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvc5_c8al.rs:41:23\n   |\n41 |             max_val = val;\n\
    \   |  "
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for i in 1..lst.len() {\n  \
    \      if lst[i] < min_value {\n            min_value = lst[i];\n        }\n \
    \       if lst[i] > max_value {\n            max_value = lst[i];\n        }\n\
    \    }\n    let mut lst = lst.to_vec();\n    lst.sort();\n    for i in 0..lst.len()\
    \ {\n        if lst[i] < min_value {\n            lst[i] = min_value;\n      \
    \  }\n        if lst[i] > max_value {\n            lst[i] = max_value;\n     \
    \   }\n    }\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpyed1d_yv.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for i in 1..sorted_list.len()\
    \ {\n        if min_value > sorted_list[i] {\n            min_value = sorted_list[i];\n\
    \        }\n        if max_value < sorted_list[i] {\n            max_value = sorted_list[i];\n\
    \        }\n    }\n    for i in 0..sorted_list.len() {\n        if min_value >\
    \ sorted_list[i] {\n            sorted_list[i] = min_value;\n        }\n     \
    \   if max_value < sorted_list[i] {\n            sorted_list[i] = max_value;\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpp660v6hq.rs:36:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut min_val\
    \ = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n    for el in lst {\n\
    \        if el < min_val {\n            min_val = el;\n        }\n        if el\
    \ > max_val {\n            max_val = el;\n        }\n    }\n    let mut min_idx\
    \ = std::i32::MAX;\n    let mut max_idx = std::i32::MIN;\n    for el in lst {\n\
    \        if el < min_val {\n            min_idx = el;\n        }\n        if el\
    \ > max_val {\n            max_idx = el;\n        }\n    }\n    let mut min_idx\
    \ = max_idx;\n    let mut max_idx = min_idx;\n    for el in lst {\n        if\
    \ el < min_val {\n            min_idx = el;\n        }\n        if el > max_val\
    \ {\n            max_idx = el;\n        }\n    }\n    let mut min_idx = max_idx;\n\
    \    let mut max_idx = min_idx;\n    for el in lst {\n        if el < min_val\
    \ {\n            min_idx = el;\n        }\n        if el > max_val {\n       \
    \     max_idx = el;\n        }\n    }\n    let mut min_idx = max_idx;\n    let\
    \ mut max_idx = min_idx;\n    for el in lst {\n        if el < min_val {\n   \
    \         min_idx = el;\n        }\n        if el > max_val {\n            max_idx\
    \ = el;\n        }\n    }\n    let mut min_idx = max_idx;\n    let mut max_idx\
    \ = min_idx;\n    for el in lst {\n        if el < min_val {\n            min_idx\
    \ = el;\n        }\n        if el > max_val {\n            max_idx = el;\n   \
    \     }\n    }\n    let mut min_idx = max_idx;\n    let mut max_idx = min_idx;\n\
    \    for el in lst {\n        if el < min_val {\n            min_idx = el;\n \
    \       }\n        if el > max_val {\n            max_idx = el;\n        }\n \
    \   }\n    let mut min_idx = max_idx;\n    let mut max_idx = min_idx;\n    for\
    \ el in lst {\n        if el < min_val {\n            min_idx = el;\n        }\n\
    \        if el > max_val {\n            max_idx = el;\n        }\n    }\n    let\
    \ mut min_idx = max_idx;\n    let mut max_idx = min_idx;\n    for el in lst {\n\
    \        if el < min_val {\n            min_idx = el;\n        }\n        if el\
    \ > max_val {\n            max_idx = el;\n        }\n    }\n\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn33hyezs.rs:16:17\n   |\n\
    16 |         if el < min_val {\n   |                 ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if el < min_val.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn33hyezs.rs:17:23\n   |\n17 |             min_val = el;\n\
    \   |                       ^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn33hyezs.rs:19:17\n   |\n19 |         if el\
    \ > max_val {\n   |                 ^^^^^^^ expected `isize`, found `i32`\n  \
    \ |\nhelp: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n19 |         if el > max_val.try_into().unwrap() {\n   |\
    \                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn33hyezs.rs:20:23\n   |\n20 |             max_val = el;\n   | \
    \                      ^^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn33hyezs.rs:26:17\n   |\n26 |         if el < min_val {\n\
    \   |                 ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n26 |         if el < min_val.try_into().unwrap() {\n   |              \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn33hyezs.rs:27:23\n\
    \   |\n27 |             min_idx = el;\n   |                       ^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn33hyezs.rs:29:17\n\
    \   |\n29 |         if el > max_val {\n   |                 ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n29 |         if el > max_val.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn33hyezs.rs:30:23\n   |\n30 |             max_idx = el;\n\
    \   |                       ^^ exp"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(max_value);\n\
    \            sorted_list.push(value);\n        }\n    }\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp66om3qhn.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n23  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| x == max).unwrap();\n    while min_idx !=\
    \ max_idx {\n        lst[min_idx] = lst[max_idx];\n        lst[max_idx] = min;\n\
    \        min = lst[min_idx];\n        max = lst[max_idx];\n        min_idx = lst.iter().position(|x|\
    \ x == min).unwrap();\n        max_idx = lst.iter().position(|x| x == max).unwrap();\n\
    \    }\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8kcqjc_m.rs:19:24\n   |\n\
    19 |         lst[max_idx] = min;\n   |                        ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |  \
    \       lst[max_idx] = *min;\n   |                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8kcqjc_m.rs:20:15\n   |\n20 |         min = lst[min_idx];\n\
    \   |               ^^^^^^^^^^^^\n   |               |\n   |               expected\
    \ `&isize`, found `isize`\n   |               help: consider borrowing here: `&lst[min_idx]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8kcqjc_m.rs:21:15\n   |\n21 |\
    \         max = lst[max_idx];\n   |               ^^^^^^^^^^^^\n   |         \
    \      |\n   |               expected `&isize`, found `isize`\n   |          \
    \     help: consider borrowing here: `&lst[max_idx]`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n        if x\
    \ < min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut i = 1;\n    while\
    \ i < lst.len() {\n        if lst[i] < min_value {\n            result.push(min_value);\n\
    \            min_value = lst[i];\n        }\n        if lst[i] > max_value {\n\
    \            result.push(max_value);\n            max_value = lst[i];\n      \
    \  }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmp_ac1xm9l.rs:24:15\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n24  |     while i < lst.len()\
    \ {\n    |               ^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        } else if value > max_value {\n            sorted_list.push(value);\n\
    \        } else {\n            sorted_list.push(min_value);\n            sorted_list.push(max_value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp9_al4yp7.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n23  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n        if x\
    \ < min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    vec.push(min_value);\n\
    \    vec.push(max_value);\n    for x in lst {\n        if x == min_value {\n \
    \           vec.push(x);\n        }\n        if x == max_value {\n           \
    \ vec.push(x);\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpe2_b9abn.rs:25:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n25  |     for x in lst {\n \
    \   |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for el in lst {\n        if\
    \ el < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    vec.push(min_value);\n\
    \    vec.push(max_value);\n    for el in lst.iter().rev() {\n        if el < min_value\
    \ {\n            vec.push(el);\n        }\n        if el > max_value {\n     \
    \       vec.push(el);\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfyuxpgbg.rs:26:17\n   |\n\
    26 |         if el < min_value {\n   |                 ^^^^^^^^^\n   |       \
    \          |\n   |                 expected `&isize`, found `isize`\n   |    \
    \             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfyuxpgbg.rs:27:22\n   |\n27 |             vec.push(el);\n\
    \   |                      ^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n27 |             vec.push(*el);\n   |      \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfyuxpgbg.rs:29:17\n\
    \   |\n29 |         if el > max_value {\n   |                 ^^^^^^^^^\n   |\
    \                 |\n   |                 expected `&isize`, found `isize`\n \
    \  |                 help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfyuxpgbg.rs:30:22\n   |\n30 |             vec.push(el);\n\
    \   |                      ^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n30 |             vec.push(*el);\n   |      \
    \                +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if \n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxpav0c21.rs:130:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    115 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n116 |         if \n117 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n130 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpxpav0c21.rs:117:1\n    |\n117 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpav0c21.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| *x == max).unwrap();\n    while min_idx !=\
    \ max_idx {\n        let tmp = min;\n        min = max;\n        max = tmp;\n\
    \        min_idx = lst.iter().position(|x| *x == min).unwrap();\n        max_idx\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    }\n    lst.sort();\n   \
    \ lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3sn3m21k.rs:15:53\n   |\n\
    15 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3sn3m21k.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3sn3m21k.rs:21:49\n   |\n21 |         min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3sn3m21k.rs:22:49\n   |\n22 |         max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |         max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                 +\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min =\
    \ lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n \
    \   while min < max {\n        result.push(min);\n        min = lst.iter().filter(|&x|\
    \ x < min).min().unwrap();\n        max = lst.iter().filter(|&x| x > max).max().unwrap();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqr88bi3r.rs:20:5\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n20 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n       \
    \ if value < min_value {\n            min_value = value;\n        }\n        if\
    \ value > max_value {\n            max_value = value;\n        }\n    }\n    let\
    \ mut min_value = min_value;\n    let mut max_value = max_value;\n    for value\
    \ in lst {\n        if value < min_value {\n            min_value = value;\n \
    \       }\n        if value > max_value {\n            max_value = value;\n  \
    \      }\n    }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < \n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8drk4vrx.rs:130:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    115 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n116 |         if value < \n117 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n130 | }\n    |   ^\n\n\
    error: expected expression, found `}`\n   --> /tmp/tmp8drk4vrx.rs:117:1\n    |\n\
    117 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8drk4vrx.rs:11:42\n   |\n11 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----------------                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for value in\
    \ sorted_list.iter() {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in sorted_list.iter() {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n   --> /tmp/tmp5biyflsl.rs:114:17\n   \
    \ |\n114 |     let mut max_\n    |                 ^ help: add `;` here\n115 |\
    \ }\n    | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5biyflsl.rs:16:20\n\
    \   |\n16 |         if value < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5biyflsl.rs:17:25\n   |\n17 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5biyflsl.rs:19:20\n   |\n19 |         if value > max_value {\n\
    \   |                    ^^^^^^^^^\n   |                    |\n   |          \
    \          expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5biyflsl.rs:20:25\n\
    \   |\n20 |             max_value = value;\n   |                         ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |             max_value = *value;\n   |                         +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5biyflsl.rs:26:20\n   |\n26 |  \
    \       if value < min_value {\n   |                    ^^^^^^^^^\n   |      \
    \              |\n   |                    expected `&isize`, found `isize`\n \
    \  |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5biyflsl.rs:27:25\n   |\n27 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n27 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5biyflsl.rs:29:20\n   |\n29 |         if value > max_value {\n\
    \   |                    ^^^^^^"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for value in\
    \ sorted_list.iter().rev() {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    if min_value == max_value {\n        return sorted_list;\n\
    \    }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    if min_value == max_value {\n\
    \        return sorted_list;\n    }\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    for value in sorted_list.iter().rev() {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    if min_value == max_value {\n        return sorted_list;\n    }\n    let\
    \ mut min_value = min_value;\n    let mut max_value = max_value;\n    for value\
    \ in sorted_list.iter().rev().rev() {\n        if value < min_value {\n      \
    \      min_value = value;\n        }\n        if value > max_value {\n       \
    \     max_value = value;\n        }\n    }\n    if min_value == max_value {\n\
    \        return sorted_list;\n    }\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    for value in sorted_list.iter().rev().rev().rev()\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    if min_value == max_value {\n        return sorted_list;\n    }\n \
    \   let mut min_value = min_value;\n    let mut max_value = max_value;\n    for\
    \ value in sorted_list.iter().rev().rev().rev().rev() {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    if min_value == max_value\
    \ {\n        return sorted_list;\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter().rev().rev().rev().rev().rev()\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    if min_value == max_value {\n        return sorted_list;\n    }\n \
    \   let mut min_value = min_value;\n    let mut max_value = max_value;\n    for\
    \ value in sorted_list.iter().rev().rev().rev().rev\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp3t0fwj08.rs:107:1\n    |\n\
    107 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3t0fwj08.rs:16:20\n\
    \   |\n16 |         if value < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3t0fwj08.rs:17:25\n   |\n17 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3t0fwj08.rs:19:20\n   |\n19 |         if value > max_value {\n\
    \   |                    ^^^^^^^^^\n   |                    |\n   |          \
    \          expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3t0fwj08.rs:20:25\n\
    \   |\n20 |             max_value = value;\n   |                         ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |             max_value = *value;\n   |                         +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3t0fwj08.rs:29:20\n   |\n29 |  \
    \       if value < min_value {\n   |                    ^^^^^^^^^\n   |      \
    \              |\n   |                    expected `&isize`, found `isize`\n \
    \  |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3t0fwj08.rs:30:25\n   |\n30 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n30 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3t0fwj08.rs:32:20\n   |\n32 |         if value > max_value {\n\
    \   |                    ^^^^^^^^^\n   |                    |\n   |          \
    \          expected `&isize`"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < max_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > min_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp414els92.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n23  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror[E0382]: use of moved value: `lst`\n  --> /tmp/tmp414els92.rs:31:18\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- move occurs because `lst` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n23 |     for value in lst {\n   |     \
    \             ---\n   |                  |\n   |                  `lst` moved\
    \ due to this implicit call to `.into_iter()`\n   |                  help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n31 |     for value\
    \ in lst {\n   |                  ^^^ value used here after move\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n \
    \       if x < min_value {\n            min_value = x;\n        }\n        if\
    \ x > max_value {\n            max_value = x;\n        }\n    }\n    for x in\
    \ lst {\n        if x == min_value {\n            sorted_list.push(x);\n     \
    \   }\n        if x == max_value {\n            sorted_list.push(x);\n       \
    \ }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpdg897651.rs:23:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n23  |     for x in lst {\n \
    \   |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n \
    \       if x < min_value {\n            min_value = x;\n        }\n        if\
    \ x > max_value {\n            max_value = x;\n        }\n    }\n    let mut min_idx\
    \ = 1;\n    let mut max_idx = 1;\n    while min_idx < lst.len() {\n        if\
    \ lst[min_idx] < min_value {\n            min_idx = min_idx + 1;\n           \
    \ continue;\n        }\n        if lst[max_idx] > max_value {\n            max_idx\
    \ = max_idx + 1;\n            continue;\n        }\n        let tmp = min_value;\n\
    \        min_value = max_value;\n        max_value = tmp;\n        min_idx = max_idx;\n\
    \        max_idx = min_idx + 1;\n    }\n    sorted_list.push(min_value);\n   \
    \ sorted_list.push(max_value);\n    sorted_list.push(min_value);\n    sorted_list.push(max_value);\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmpmgrmk2w8.rs:25:21\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n25  |     while min_idx < lst.len()\
    \ {\n    |                     ^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0hfe469i.rs:147:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    129 |     for value in lst {\n    |                      - unclosed delimiter\n\
    ...\n133 |         if value > max_value {\n    |                             \
    \ - this delimiter might not be properly closed...\n134 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n147 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp0hfe469i.rs:129:5\n    |\n11  |   fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    |                                         \
    \   ---------- expected `Vec<isize>` because of return type\n...\n129 | /    \
    \ for value in lst {\n130 | |         if value < min_value {\n131 | |        \
    \     min_value = value;\n132 | |         }\n...   |\n146 | |     assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n147 | | }\n    | |__^ expected struct `Vec`, found `()`\n  \
    \  |\n    = note: expected struct `Vec<isize>`\n            found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for value in\
    \ sorted_list.iter().rev() {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    sorted_list.sort();\n    sorted_list.sort_by_key(|x|\
    \ {\n        if x == min_value {\n            0\n        } else if x == max_value\
    \ {\n            1\n        } else {\n            2\n        }\n    });\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjdji899j.rs:16:20\n   |\n\
    16 |         if value < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjdji899j.rs:17:25\n   |\n17 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjdji899j.rs:19:20\n   |\n19 |         if value > max_value {\n\
    \   |                    ^^^^^^^^^\n   |                    |\n   |          \
    \          expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjdji899j.rs:20:25\n\
    \   |\n20 |             max_value = value;\n   |                         ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |             max_value = *value;\n   |                         +\n\n\
    error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpjdji899j.rs:25:14\n\
    \   |\n25 |         if x == min_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpjdji899j.rs:27:21\n   |\n27 |         } else if x == max_value\
    \ {\n   |                     ^^ no implementation for `&isize == isize`\n   |\n\
    \   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if \n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxpav0c21.rs:130:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    115 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n116 |         if \n117 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n130 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpxpav0c21.rs:117:1\n    |\n117 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpav0c21.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n \
    \       if x < min_value {\n            min_value = x;\n        }\n        if\
    \ x > max_value {\n            max_value = x;\n        }\n    }\n    for x in\
    \ lst {\n        if x == min_value {\n            sorted_list.push(x);\n     \
    \   }\n        if x == max_value {\n            sorted_list.push(x);\n       \
    \ }\n    }\n    for x in lst {\n        if x == min_value {\n            sorted_list.push(x);\n\
    \        }\n        if x == max_value {\n            sorted_list.push(x);\n  \
    \      }\n    }\n    for x in lst {\n        if x == min_value {\n           \
    \ sorted_list.push(x);\n        }\n        if x == max_value {\n            sorted_list.push(x);\n\
    \        }\n    }\n    for x in lst {\n        if x == min_value {\n         \
    \   sorted_list.push(x);\n        }\n        if x == max_value {\n           \
    \ sorted_list.push(x);\n        }\n    }\n    for x in lst {\n        if x ==\
    \ min_value {\n            sorted_list.push(x);\n        }\n        if x == max_value\
    \ {\n            sorted_list.push(x);\n        }\n    }\n    for x in lst {\n\
    \        if x == min_value {\n            sorted_list.push(x);\n        }\n  \
    \      if x == max_value {\n            sorted_list.push(x);\n        }\n    }\n\
    \    for x in lst {\n        if x == min_value {\n            sorted_list.push(x);\n\
    \        }\n        if x == max_value {\n            sorted_list.push(x);\n  \
    \      }\n    }\n    for x in lst {\n        if x == min_value {\n           \
    \ sorted_list.push(x);\n        }\n        if x == max_value {\n            sorted_list.push(x);\n\
    \        }\n    }\n    for x in lst {\n        if x == min_value {\n         \
    \   sorted_list.push(x);\n        }\n        if x == max_value {\n           \
    \ sorted_list.push(x);\n        }\n    }\n    for x in lst {\n        if x ==\
    \ min_value {\n            sorted_list.push(x);\n        }\n        if x == max_value\
    \ {\n            sorted_list.push(x);\n        }\n    }\n    for x in lst {\n\
    \        if x == min_value {\n            sorted_list.push(x);\n        }\n  \
    \      if x == max_value {\n            sorted_list.push(x);\n        }\n    }\n\
    \    for x in lst {\n        if x == min_value {\n            sorted_list.push(x);\n\
    \        }\n        if x == max_value {\n            sorted_list.push(x);\n  \
    \      }\n    }\n    for x in lst {\n        if x == min_value {\n           \
    \ sorted_list.push(x);\n        }\n        if x == max_\n}\n\nfn main() {\n  \
    \  let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3brgwoh3.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for x in lst {\n    |                  - this delimiter might not be\
    \ properly closed...\n...\n124 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   -->\
    \ /tmp/tmp3brgwoh3.rs:124:1\n    |\n123 |         if x == max_\n    |        \
    \ -- this `if` expression has a condition, but no block\n124 | }\n    | ^ expected\
    \ `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3brgwoh3.rs:11:42\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let\
    \ mut min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpx90w1rdj.rs:130:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    115 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n116 | \n117 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n130 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx90w1rdj.rs:11:42\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |    -----------------                     ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n \
    \       if x < min_value {\n            min_value = x;\n        }\n        if\
    \ x > max_value {\n            max_value = x;\n        }\n    }\n    for x in\
    \ lst {\n        if x == min_value {\n            sorted_list.push(x);\n     \
    \   }\n        if x == max_value {\n            sorted_list.push(x);\n       \
    \ }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpdg897651.rs:23:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n23  |     for x in lst {\n \
    \   |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let\
    \ mut min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    sorted_list.push(min_value);\n    sorted_list.push(max_value);\n  \
    \  for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpw58em9di.rs:25:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n25  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n       \
    \ if value < min_value {\n            min_value = value;\n        }\n        if\
    \ value > max_value {\n            max_value = value;\n        }\n    }\n    for\
    \ value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          result.push(value);\n        }\n        if value > max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value < min_value {\n            result.push(value);\n        }\n   \
    \     if value > max_value {\n            result.push(value);\n        }\n   \
    \ }\n    for value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          result.push(value);\n        }\n        if value > max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value < min_value {\n            result.push(value);\n        }\n   \
    \     if value > max_value {\n            result.push(value);\n        }\n   \
    \ }\n    for value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          result.push(value);\n        }\n        if value > max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value < min_value {\n            result.push(value);\n        }\n   \
    \     if value > max_value {\n            result.push(value);\n        }\n   \
    \ }\n    for value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          result.push(value);\n        }\n        if value > max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value < min_value {\n            result.push(value);\n        }\n   \
    \     if value > max_value {\n            result.push(value);\n        }\n   \
    \ }\n    for value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          result.push(value);\n        }\n        if value > max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value < \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9gijw3un.rs:150:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    135 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n136 |         if value < \n137 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n150 | }\n    |   ^\n\n\
    error: expected expression, found `}`\n   --> /tmp/tmp9gijw3un.rs:137:1\n    |\n\
    137 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9gijw3un.rs:11:42\n   |\n11 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----------------                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| x == max).unwrap();\n\
    \    let mut new_lst = vec![];\n    while min_idx < max_idx {\n        new_lst.push(lst.swap_remove(min_idx).unwrap());\n\
    \        min_idx += 1;\n    }\n    new_lst.push(min);\n    new_lst.push(max);\n\
    \    new_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp7mayu2rb.rs:18:47\n   |\n18 |         new_lst.push(lst.swap_remove(min_idx).unwrap());\n\
    \   |                                               ^^^^^^ method not found in\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7mayu2rb.rs:23:5\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     new_lst\n   |     ^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| x == max).unwrap();\n    while min_idx !=\
    \ max_idx {\n        let tmp = min;\n        min = max.clone();\n        max =\
    \ tmp;\n        min_idx = lst.iter().position(|x| x == min).unwrap();\n      \
    \  max_idx = lst.iter().position(|x| x == max).unwrap();\n    }\n    lst.swap(min_idx,\
    \ max_idx);\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdrfoff6g.rs:19:15\n   |\n\
    19 |         min = max.clone();\n   |               ^^^^^^^^^^^\n   |        \
    \       |\n   |               expected `&isize`, found `isize`\n   |         \
    \      help: consider borrowing here: `&max`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| *x == max).unwrap();\n    while min_idx !=\
    \ max_idx {\n        result.push(min);\n        result.push(max);\n        min\
    \ = lst.iter().nth(min_idx).unwrap();\n        max = lst.iter().nth(max_idx).unwrap();\n\
    \        min_idx = lst.iter().position(|x| *x == min).unwrap();\n        max_idx\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfzh3m_6p.rs:15:53\n   |\n\
    15 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfzh3m_6p.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfzh3m_6p.rs:22:49\n   |\n22 |         min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |         min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfzh3m_6p.rs:23:49\n   |\n23 |         max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n23 |         max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfzh3m_6p.rs:25:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n25 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 5 pre"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for i in 1..sorted_list.len()\
    \ {\n        if min_value > sorted_list[i] {\n            min_value = sorted_list[i];\n\
    \        }\n        if max_value < sorted_list[i] {\n            max_value = sorted_list[i];\n\
    \        }\n    }\n    for i in 0..sorted_list.len() {\n        if min_value >\
    \ sorted_list[i] {\n            sorted_list[i] = min_value;\n        }\n     \
    \   if max_value < sorted_list[i] {\n            sorted_list[i] = max_value;\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpp660v6hq.rs:36:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for i in 1..sorted_list.len()\
    \ {\n        if sorted_list[i] < min_value {\n            min_value = sorted_list[i];\n\
    \        }\n        if sorted_list[i] > max_value {\n            max_value = sorted_list[i];\n\
    \        }\n    }\n    for i in 0..sorted_list.len() {\n        if sorted_list[i]\
    \ == min_value {\n            sorted_list[i] = max_value;\n        }\n       \
    \ if sorted_list[i] == max_value {\n            sorted_list[i] = min_value;\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 1]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpz3vzxohb.rs:36:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let\
    \ mut min_value = lst[0];\n    let mut max_value = lst[0];\n    for el in lst\
    \ {\n        if el < min_value {\n            min_value = el;\n        }\n   \
    \     if el > max_value {\n            max_value = el;\n        }\n    }\n   \
    \ for el in lst {\n        if el == min_value {\n            sorted_list.push(max_value);\n\
    \        }\n        if el == max_value {\n            sorted_list.push(min_value);\n\
    \        }\n        sorted_list.push(el);\n    }\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpz0aatruj.rs:23:15\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for el in lst {\n    | \
    \              ---\n    |               |\n    |               `lst` moved due\
    \ to this implicit call to `.into_iter()`\n    |               help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n23  |     for el in\
    \ lst {\n    |               ^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for value in\
    \ sorted_list.iter() {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    for value in sorted_list.iter() {\n        if value == min_value {\n    \
    \        min_pos = 0;\n        }\n        if value == max_value {\n          \
    \  max_pos = 0;\n        }\n        if value < min_value {\n            sorted_list.swap(min_pos,\
    \ max_pos);\n            min_pos = min_pos + 1;\n        }\n        if value >\
    \ max_value {\n            sorted_list.swap(min_pos, max_pos);\n            max_pos\
    \ = max_pos + 1;\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa7jlhkb4.rs:16:20\n   |\n\
    16 |         if value < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa7jlhkb4.rs:17:25\n   |\n17 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa7jlhkb4.rs:19:20\n   |\n19 |         if value > max_value {\n\
    \   |                    ^^^^^^^^^\n   |                    |\n   |          \
    \          expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa7jlhkb4.rs:20:25\n\
    \   |\n20 |             max_value = value;\n   |                         ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |             max_value = *value;\n   |                         +\n\n\
    error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpa7jlhkb4.rs:26:18\n\
    \   |\n26 |         if value == min_value {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpa7jlhkb4.rs:29:18\n   |\n29 |         if value == max_value {\n\
    \   |                  ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa7jlhkb4.rs:32:20\n   |\n32 |         if value\
    \ < min_value {\n   |                    ^^^^^^^^^\n   |                    |\n\
    \   |                    expected `&isize`, found `isize`\n   |              \
    \      help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa7jlhkb4.rs:36:20"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < max_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > min_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp414els92.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n23  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror[E0382]: use of moved value: `lst`\n  --> /tmp/tmp414els92.rs:31:18\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- move occurs because `lst` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n23 |     for value in lst {\n   |     \
    \             ---\n   |                  |\n   |                  `lst` moved\
    \ due to this implicit call to `.into_iter()`\n   |                  help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n31 |     for value\
    \ in lst {\n   |                  ^^^ value used here after move\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|&x| x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|&x| x == max).unwrap();\n    while min_idx !=\
    \ max_idx {\n        let tmp = min;\n        min = max;\n        max = tmp;\n\
    \        min_idx = lst.iter().position(|&x| x == min).unwrap();\n        max_idx\
    \ = lst.iter().position(|&x| x == max).unwrap();\n    }\n    lst.iter().cloned().rev()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpayza73ui.rs:15:53\n   |\n\
    15 |     let mut min_idx = lst.iter().position(|&x| x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |     let\
    \ mut min_idx = lst.iter().position(|&x| x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpayza73ui.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|&x|\
    \ x == max).unwrap();\n   |                                                  \
    \   ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|&x| x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpayza73ui.rs:21:49\n   |\n21 |         min_idx = lst.iter().position(|&x|\
    \ x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         min_idx = lst.iter().position(|&x| x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpayza73ui.rs:22:49\n   |\n22 |         max_idx = lst.iter().position(|&x|\
    \ x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |         max_idx = lst.iter().position(|&x| x == *max).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpayza73ui.rs:24:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n24 |     lst.iter().cloned().rev()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `Rev`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found str"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min =\
    \ lst[0];\n    let mut max = lst[0];\n    for el in lst {\n        if el < min\
    \ {\n            min = el;\n        }\n        if el > max {\n            max\
    \ = el;\n        }\n    }\n    for el in lst {\n        if el == min {\n     \
    \       result.push(el);\n        }\n        if el == max {\n            result.push(el);\n\
    \        }\n    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n   --> /tmp/tmp2abahgnm.rs:119:5\n    |\n\
    11  |   fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |         \
    \                                   ---------- expected `Vec<isize>` because of\
    \ return type\n...\n119 | /     for el in lst {\n120 | |         if el == min\
    \ {\n121 | |             result.push(el);\n122 | |         }\n...   |\n125 | |\
    \         }\n126 | |     }\n    | |_____^ expected struct `Vec`, found `()`\n\
    \    |\n    = note: expected struct `Vec<isize>`\n            found unit type\
    \ `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for el in lst {\n\
    \        if el < min_value {\n            min_value = el;\n        }\n       \
    \ if el > max_value {\n            max_value = el;\n        }\n    }\n    for\
    \ el in lst {\n        if el == min_value {\n            sorted_list.push(el);\n\
    \        }\n        if el == max_value {\n            sorted_list.push(el);\n\
    \        }\n        if el > min_value {\n            sorted_list.push(el);\n \
    \       }\n        if el < max_value {\n            sorted_list.push(el);\n  \
    \      }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpw9oc7pms.rs:23:15\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for el in lst {\n    | \
    \              ---\n    |               |\n    |               `lst` moved due\
    \ to this implicit call to `.into_iter()`\n    |               help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n23  |     for el in\
    \ lst {\n    |               ^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst[0];\n    let mut max = lst[0];\n\
    \    for x in lst {\n        if x < min {\n            min = x;\n        }\n \
    \       if x > max {\n            max = x;\n        }\n    }\n    let mut new_list\
    \ = vec![];\n    for x in lst {\n        if x == min {\n            new_list.push(max);\n\
    \        } else {\n            new_list.push(min);\n        }\n    }\n    new_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpxotjkaqx.rs:23:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n14  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n23  |     for x in lst {\n \
    \   |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for value in\
    \ sorted_list.iter() {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in sorted_list.iter() {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n   --> /tmp/tmp5biyflsl.rs:114:17\n   \
    \ |\n114 |     let mut max_\n    |                 ^ help: add `;` here\n115 |\
    \ }\n    | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5biyflsl.rs:16:20\n\
    \   |\n16 |         if value < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5biyflsl.rs:17:25\n   |\n17 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5biyflsl.rs:19:20\n   |\n19 |         if value > max_value {\n\
    \   |                    ^^^^^^^^^\n   |                    |\n   |          \
    \          expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5biyflsl.rs:20:25\n\
    \   |\n20 |             max_value = value;\n   |                         ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |             max_value = *value;\n   |                         +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5biyflsl.rs:26:20\n   |\n26 |  \
    \       if value < min_value {\n   |                    ^^^^^^^^^\n   |      \
    \              |\n   |                    expected `&isize`, found `isize`\n \
    \  |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5biyflsl.rs:27:25\n   |\n27 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n27 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5biyflsl.rs:29:20\n   |\n29 |         if value > max_value {\n\
    \   |                    ^^^^^^"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n       \
    \ if value < min_value {\n            min_value = value;\n        }\n        if\
    \ value > max_value {\n            max_value = value;\n        }\n    }\n    for\
    \ value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          result.push(value);\n        }\n        if value > max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value < min_value {\n            result.push(value);\n        }\n   \
    \     if value > max_value {\n            result.push(value);\n        }\n   \
    \ }\n    for value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          result.push(value);\n        }\n        if value > max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value < min_value {\n            result.push(value);\n        }\n   \
    \     if value > max_value {\n            result.push(value);\n        }\n   \
    \ }\n    for value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          result.push(value);\n        }\n        if value > max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value < min_value {\n            result.push(value);\n        }\n   \
    \     if value > max_value {\n            result.push(value);\n        }\n   \
    \ }\n    for value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          result.push(value);\n        }\n        if value > max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value < min_value {\n            result.push(value);\n        }\n   \
    \     if value > max_value {\n            result.push(value);\n        }\n   \
    \ }\n    for value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          result.push(value);\n        }\n        if value > max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value < \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9gijw3un.rs:150:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    135 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n136 |         if value < \n137 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n150 | }\n    |   ^\n\n\
    error: expected expression, found `}`\n   --> /tmp/tmp9gijw3un.rs:137:1\n    |\n\
    137 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9gijw3un.rs:11:42\n   |\n11 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----------------                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if \n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxpav0c21.rs:130:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    115 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n116 |         if \n117 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n130 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpxpav0c21.rs:117:1\n    |\n117 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpav0c21.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for el in lst {\n\
    \        if el < min_value {\n            min_value = el;\n        }\n       \
    \ if el > max_value {\n            max_value = el;\n        }\n    }\n    sorted_list.push(min_value);\n\
    \    sorted_list.push(max_value);\n    for el in lst {\n        if el < min_value\
    \ {\n            sorted_list.push(el);\n        }\n        if el > max_value {\n\
    \            sorted_list.push(el);\n        }\n    }\n    sorted_list.push(min_value);\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpqthom88i.rs:25:15\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for el in lst {\n    | \
    \              ---\n    |               |\n    |               `lst` moved due\
    \ to this implicit call to `.into_iter()`\n    |               help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n25  |     for el in\
    \ lst {\n    |               ^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|&x| x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|&x| x == max).unwrap();\n    while min_idx !=\
    \ max_idx {\n        let tmp = min;\n        min = max.clone();\n        max =\
    \ tmp;\n        min_idx = lst.iter().position(|&x| x == min).unwrap();\n     \
    \   max_idx = lst.iter().position(|&x| x == max).unwrap();\n    }\n    lst.sort_unstable();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2gpvvj3t.rs:15:53\n   |\n\
    15 |     let mut min_idx = lst.iter().position(|&x| x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |     let\
    \ mut min_idx = lst.iter().position(|&x| x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2gpvvj3t.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|&x|\
    \ x == max).unwrap();\n   |                                                  \
    \   ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|&x| x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2gpvvj3t.rs:19:15\n   |\n19 |         min = max.clone();\n\
    \   |               ^^^^^^^^^^^\n   |               |\n   |               expected\
    \ `&isize`, found `isize`\n   |               help: consider borrowing here: `&max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2gpvvj3t.rs:21:49\n   |\n21 |\
    \         min_idx = lst.iter().position(|&x| x == min).unwrap();\n   |       \
    \                                          ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |         min_idx = lst.iter().position(|&x|\
    \ x == *min).unwrap();\n   |                                                 +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2gpvvj3t.rs:22:49\n   |\n22 |\
    \         max_idx = lst.iter().position(|&x| x == max).unwrap();\n   |       \
    \                                          ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |         max_idx = lst.iter().position(|&x|\
    \ x == *max).unwrap();\n   |                                                 +\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for v in lst.iter().rev() {\n\
    \        if v < min_value {\n            min_value = v;\n        }\n        if\
    \ v > max_value {\n            max_value = v;\n        }\n    }\n    for v in\
    \ lst.iter() {\n        if v < min_value {\n            vec.push(min_value);\n\
    \            min_value = v;\n        }\n        if v > max_value {\n         \
    \   vec.push(max_value);\n            max_value = v;\n        }\n    }\n    vec.push(min_value);\n\
    \    vec.push(max_value);\n    vec\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5qfyxhe7.rs:16:16\n   |\n\
    16 |         if v < min_value {\n   |                ^^^^^^^^^\n   |         \
    \       |\n   |                expected `&isize`, found `isize`\n   |        \
    \        help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5qfyxhe7.rs:17:25\n   |\n17 |             min_value = v;\n\
    \   |                         ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n17 |             min_value = *v;\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5qfyxhe7.rs:19:16\n\
    \   |\n19 |         if v > max_value {\n   |                ^^^^^^^^^\n   |  \
    \              |\n   |                expected `&isize`, found `isize`\n   | \
    \               help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5qfyxhe7.rs:20:25\n   |\n20 |             max_value = v;\n\
    \   |                         ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n20 |             max_value = *v;\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5qfyxhe7.rs:24:16\n\
    \   |\n24 |         if v < min_value {\n   |                ^^^^^^^^^\n   |  \
    \              |\n   |                expected `&isize`, found `isize`\n   | \
    \               help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5qfyxhe7.rs:26:25\n   |\n26 |             min_value = v;\n\
    \   |                         ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n26 |             min_value = *v;\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5qfyxhe7.rs:28:16\n\
    \   |\n28 |         if v > max_value {\n   |                ^^^^^^^^^\n   |  \
    \              |\n   |                expected `&isize`, found `isize`\n   | \
    \               help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5qfyxhe7.rs:30:25\n   |\n30 |             max_value = v;\n\
    \   |                         ^ "
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0hfe469i.rs:147:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    129 |     for value in lst {\n    |                      - unclosed delimiter\n\
    ...\n133 |         if value > max_value {\n    |                             \
    \ - this delimiter might not be properly closed...\n134 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n147 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp0hfe469i.rs:129:5\n    |\n11  |   fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    |                                         \
    \   ---------- expected `Vec<isize>` because of return type\n...\n129 | /    \
    \ for value in lst {\n130 | |         if value < min_value {\n131 | |        \
    \     min_value = value;\n132 | |         }\n...   |\n146 | |     assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n147 | | }\n    | |__^ expected struct `Vec`, found `()`\n  \
    \  |\n    = note: expected struct `Vec<isize>`\n            found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n        if x\
    \ < min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    for x in lst {\n      \
    \  if x == min_value {\n            result.push(max_value);\n            result.push(x);\n\
    \        } else {\n            result.push(x);\n            result.push(min_value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpbxt84c0w.rs:23:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n23  |     for x in lst {\n \
    \   |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(max_value);\n\
    \            sorted_list.push(value);\n        }\n    }\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp66om3qhn.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n23  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if \n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxpav0c21.rs:130:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    115 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n116 |         if \n117 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n130 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpxpav0c21.rs:117:1\n    |\n117 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpav0c21.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for el in lst {\n\
    \        if el < min_value {\n            min_value = el;\n        }\n       \
    \ if el > max_value {\n            max_value = el;\n        }\n    }\n    let\
    \ mut min_pos = 0;\n    let mut max_pos = 0;\n    for el in lst {\n        if\
    \ el == min_value {\n            sorted_list.push(min_pos);\n            min_pos\
    \ = min_pos + 1;\n        }\n        if el == max_value {\n            sorted_list.push(max_pos);\n\
    \            max_pos = max_pos + 1;\n        }\n    }\n    sorted_list.push(min_pos);\n\
    \    sorted_list.push(max_pos);\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp6xiqamgd.rs:25:15\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for el in lst {\n    | \
    \              ---\n    |               |\n    |               `lst` moved due\
    \ to this implicit call to `.into_iter()`\n    |               help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n25  |     for el in\
    \ lst {\n    |               ^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| *x == max).unwrap();\n    let mut i = 0;\n\
    \    while i < min_idx {\n        swap(&mut lst, i, min_idx);\n        min_idx\
    \ += 1;\n        i += 1;\n    }\n    while i < max_idx {\n        swap(&mut lst,\
    \ i, max_idx);\n        max_idx += 1;\n        i += 1;\n    }\n    lst\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpuzbco3_1.rs:19:9\n\
    \   |\n19 |         swap(&mut lst, i, min_idx);\n   |         ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find function `swap` in this scope\n  --> /tmp/tmpuzbco3_1.rs:24:9\n   |\n24\
    \ |         swap(&mut lst, i, max_idx);\n   |         ^^^^ not found in this scope\n\
    \   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::swap;\n\
    \   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpuzbco3_1.rs:15:53\n   |\n15 |     let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |     let mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuzbco3_1.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if \n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxpav0c21.rs:130:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    115 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n116 |         if \n117 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n130 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpxpav0c21.rs:117:1\n    |\n117 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpav0c21.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if \n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxpav0c21.rs:130:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    115 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n116 |         if \n117 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n130 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpxpav0c21.rs:117:1\n    |\n117 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpav0c21.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list.iter().min().unwrap();\n    let mut max_value = sorted_list.iter().max().unwrap();\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    while min_pos < max_pos\
    \ {\n        let mut pos = min_pos;\n        while pos < max_pos && sorted_list[pos]\
    \ < min_value {\n            pos += 1;\n        }\n        let mut new_pos = pos;\n\
    \        while new_pos < max_pos && sorted_list[new_pos] == max_value {\n    \
    \        new_pos += 1;\n        }\n        if new_pos == max_pos {\n         \
    \   break;\n        }\n        sorted_list.swap(pos, new_pos);\n        min_pos\
    \ = new_pos + 1;\n        max_pos = new_pos;\n    }\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2lmf7vxh.rs:19:51\n   |\n\
    19 |         while pos < max_pos && sorted_list[pos] < min_value {\n   |     \
    \                                              ^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |        \
    \ while pos < max_pos && sorted_list[pos] < *min_value {\n   |               \
    \                                    +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2lmf7vxh.rs:23:60\n   |\n23 |         while new_pos < max_pos && sorted_list[new_pos]\
    \ == max_value {\n   |                                                       \
    \     ^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |         while new_pos < max_pos && sorted_list[new_pos]\
    \ == *max_value {\n   |                                                      \
    \      +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for el in lst {\n        if\
    \ el < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    for el in lst {\n    \
    \    if el == min_value {\n            result.push(max_value);\n        }\n  \
    \      if el == max_value {\n            result.push(min_value);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp9uxia29o.rs:23:15\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for el in lst {\n    | \
    \              ---\n    |               |\n    |               `lst` moved due\
    \ to this implicit call to `.into_iter()`\n    |               help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n23  |     for el in\
    \ lst {\n    |               ^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let\
    \ mut min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        } else {\n            if value == max_value {\n                sorted_list.push(value);\n\
    \            } else {\n                sorted_list.push(value);\n            \
    \    sorted_list.push(max_value);\n                sorted_list.push(min_value);\n\
    \            }\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp5pggpv9m.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n23  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < max_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > min_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp414els92.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n23  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror[E0382]: use of moved value: `lst`\n  --> /tmp/tmp414els92.rs:31:18\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- move occurs because `lst` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n23 |     for value in lst {\n   |     \
    \             ---\n   |                  |\n   |                  `lst` moved\
    \ due to this implicit call to `.into_iter()`\n   |                  help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n31 |     for value\
    \ in lst {\n   |                  ^^^ value used here after move\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for el in lst {\n        if\
    \ el < min_value {\n            vec.push(min_value);\n            min_value =\
    \ el;\n        } else if el > max_value {\n            vec.push(max_value);\n\
    \            max_value = el;\n        } else {\n            vec.push(el);\n  \
    \      }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpaz4rgyaj.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748646
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst[0];\n    let mut max = lst[0];\n\
    \    for &i in lst {\n        if i < min {\n            min = i;\n        }\n\
    \        if i > max {\n            max = i;\n        }\n    }\n    let mut lst\
    \ = Vec::new();\n    for &i in lst {\n        if i == min {\n            lst.push(i);\n\
    \        }\n        if i == max {\n            lst.push(i);\n        }\n    }\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptqy4hgox.rs:14:9\n   |\n\
    14 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptqy4hgox.rs:25:22\n   |\n25 |             lst.push(i);\n\
    \   |                      ^\n   |                      |\n   |              \
    \        cyclic type of infinite size\n   |                      help: consider\
    \ borrowing here: `&i`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqy4hgox.rs:28:22\n\
    \   |\n28 |             lst.push(i);\n   |                      ^\n   |      \
    \                |\n   |                      cyclic type of infinite size\n \
    \  |                      help: consider borrowing here: `&i`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptqy4hgox.rs:31:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n31 |     lst\n   |     ^^^\
    \ expected `isize`, found reference\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&_>`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let\
    \ mut min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpyf7bch5k.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n23  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n        if x\
    \ < min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    for x in lst {\n      \
    \  if x == min_value {\n            result.push(max_value);\n            result.push(x);\n\
    \        } else {\n            result.push(x);\n            result.push(min_value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpbxt84c0w.rs:23:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n23  |     for x in lst {\n \
    \   |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for value in\
    \ sorted_list.iter().rev() {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = sorted_list.iter().rev().position(|x| *x == min_value);\n\
    \    let mut max_pos = sorted_list.iter().rev().position(|x| *x == max_value);\n\
    \    while min_pos < max_pos {\n        sorted_list[min_pos] = sorted_list[min_pos\
    \ + 1];\n        min_pos += 1;\n    }\n    sorted_list[min_pos] = min_value;\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy9u9ky2u.rs:16:20\n   |\n\
    16 |         if value < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy9u9ky2u.rs:17:25\n   |\n17 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy9u9ky2u.rs:19:20\n   |\n19 |         if value > max_value {\n\
    \   |                    ^^^^^^^^^\n   |                    |\n   |          \
    \          expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy9u9ky2u.rs:20:25\n\
    \   |\n20 |             max_value = value;\n   |                         ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |             max_value = *value;\n   |                         +\n\n\
    error[E0277]: the type `[isize]` cannot be indexed by `Option<usize>`\n  --> /tmp/tmpy9u9ky2u.rs:28:9\n\
    \   |\n28 |         sorted_list[min_pos] = sorted_list[min_pos + 1];\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `Option<usize>`\n\
    \   = note: required because of the requirements on the impl of `Index<Option<usize>>`\
    \ for `Vec<isize>`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpy9u9ky2u.rs:28:52\n   |\n28 |         sorted_list[min_pos] = sorted_list[min_pos\
    \ + 1];\n   |                                            ------- ^ - {integer}\n\
    \   |                                            |\n   |                     \
    \                       Option<usize>\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Option<usize>`\n  --> /tmp/"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut min_val\
    \ = lst[0];\n    let mut max_val = lst[0];\n    for el in lst.iter() {\n     \
    \   if el < min_val {\n            min_val = el;\n        }\n        if el > max_val\
    \ {\n            max_val = el;\n        }\n    }\n    vec.push(min_val);\n   \
    \ vec.push(max_val);\n    for el in lst.iter().rev() {\n        if el < min_val\
    \ {\n            vec.push(el);\n        }\n        if el > max_val {\n       \
    \     vec.push(el);\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx4mtlbtm.rs:16:17\n   |\n\
    16 |         if el < min_val {\n   |                 ^^^^^^^\n   |           \
    \      |\n   |                 expected `&isize`, found `isize`\n   |        \
    \         help: consider borrowing here: `&min_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx4mtlbtm.rs:17:23\n   |\n17 |             min_val = el;\n\
    \   |                       ^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             min_val = *el;\n   |      \
    \                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx4mtlbtm.rs:19:17\n\
    \   |\n19 |         if el > max_val {\n   |                 ^^^^^^^\n   |    \
    \             |\n   |                 expected `&isize`, found `isize`\n   | \
    \                help: consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx4mtlbtm.rs:20:23\n   |\n20 |             max_val = el;\n\
    \   |                       ^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |             max_val = *el;\n   |      \
    \                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx4mtlbtm.rs:26:17\n\
    \   |\n26 |         if el < min_val {\n   |                 ^^^^^^^\n   |    \
    \             |\n   |                 expected `&isize`, found `isize`\n   | \
    \                help: consider borrowing here: `&min_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx4mtlbtm.rs:27:22\n   |\n27 |             vec.push(el);\n\
    \   |                      ^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n27 |             vec.push(*el);\n   |      \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx4mtlbtm.rs:29:17\n\
    \   |\n29 |         if el > max_val {\n   |                 ^^^^^^^\n   |    \
    \             |\n   |                 expected `&isize`, found `isize`\n   | \
    \                help: consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx4mtlbtm.rs:30:22\n   |\n30 |             vec.push(el);\n\
    \   |                      ^^ expected `isize`, found "
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| x == max).unwrap();\n    while min_idx !=\
    \ max_idx {\n        res.push(min);\n        res.push(max);\n        min = lst.iter().nth(min_idx).unwrap();\n\
    \        max_idx = lst.iter().position(|x| x == max).unwrap();\n    }\n    res.push(min);\n\
    \    res.push(max);\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi74qpxe9.rs:25:5\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n25 |     res\n   |     ^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    let mut min_idx = 1;\n    let mut max_idx = 1;\n    while min_idx <\
    \ lst.len() {\n        if lst[min_idx] > max_value {\n            min_idx += 1;\n\
    \            continue;\n        }\n        if lst[min_idx] < min_value {\n   \
    \         max_idx += 1;\n            continue;\n        }\n        let mut tmp\
    \ = min_idx;\n        min_idx = max_idx;\n        max_idx = tmp;\n    }\n    for\
    \ idx in 0..min_idx {\n        sorted_list.push(min_value);\n    }\n    for idx\
    \ in min_idx..max_idx {\n        sorted_list.push(max_value);\n    }\n    for\
    \ idx in max_idx..lst.len() {\n        sorted_list.push(lst[idx]);\n    }\n  \
    \  sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused variable: `idx`\n  --> /tmp/tmpw24knf92.rs:38:9\n   |\n\
    38 |     for idx in 0..min_idx {\n   |         ^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_idx`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: unused variable: `idx`\n  --> /tmp/tmpw24knf92.rs:41:9\n\
    \   |\n41 |     for idx in min_idx..max_idx {\n   |         ^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_idx`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpw24knf92.rs:34:13\n   |\n34 |        \
    \ let mut tmp = min_idx;\n   |             ----^^^\n   |             |\n   | \
    \            help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmpw24knf92.rs:25:21\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n25  |   \
    \  while min_idx < lst.len() {\n    |                     ^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\n\nerror: aborting due to previous error; 3 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if \n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxpav0c21.rs:130:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    115 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n116 |         if \n117 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n130 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpxpav0c21.rs:117:1\n    |\n117 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpav0c21.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut min_val\
    \ = lst[0];\n    let mut max_val = lst[0];\n    for val in lst {\n        if val\
    \ < min_val {\n            min_val = val;\n        }\n        if val > max_val\
    \ {\n            max_val = val;\n        }\n    }\n    for val in lst {\n    \
    \    if val == min_val {\n            res.push(min_val);\n        }\n        if\
    \ val == max_val {\n            res.push(max_val);\n        }\n        res.push(val);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpe3lqbcim.rs:23:16\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for val in lst {\n    |\
    \                ---\n    |                |\n    |                `lst` moved\
    \ due to this implicit call to `.into_iter()`\n    |                help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n23  |     for val\
    \ in lst {\n    |                ^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for el in lst {\n        if\
    \ el < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_idx = 1;\n\
    \    let mut max_idx = 1;\n    while min_idx < lst.len() && max_idx < lst.len()\
    \ {\n        if lst[min_idx] < min_value {\n            min_idx++;\n         \
    \   continue;\n        }\n        if lst[max_idx] > max_value {\n            max_idx++;\n\
    \            continue;\n        }\n        let tmp = lst[min_idx];\n        lst[min_idx]\
    \ = lst[max_idx];\n        lst[max_idx] = tmp;\n        min_idx++;\n        max_idx++;\n\
    \    }\n    result.extend(lst.iter().cloned());\n    result\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp53phapbt.rs:27:21\n\
    \   |\n27 |             min_idx++;\n   |                     ^ expected expression\n\
    \nerror: expected expression, found `+`\n  --> /tmp/tmp53phapbt.rs:31:21\n   |\n\
    31 |             max_idx++;\n   |                     ^ expected expression\n\n\
    error: expected expression, found `+`\n  --> /tmp/tmp53phapbt.rs:37:17\n   |\n\
    37 |         min_idx++;\n   |                 ^ expected expression\n\nerror:\
    \ aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| x == max).unwrap();\n    let mut min_idx2\
    \ = lst.iter().position(|x| x == min).unwrap();\n    let mut max_idx2 = lst.iter().position(|x|\
    \ x == max).unwrap();\n    let mut min_idx3 = lst.iter().position(|x| x == min).unwrap();\n\
    \    let mut max_idx3 = lst.iter().position(|x| x == max).unwrap();\n    let mut\
    \ min_idx4 = lst.iter().position(|x| x == min).unwrap();\n    let mut max_idx4\
    \ = lst.iter().position(|x| x == max).unwrap();\n    let mut min_idx5 = lst.iter().position(|x|\
    \ x == min).unwrap();\n    let mut max_idx5 = lst.iter().position(|x| x == max).unwrap();\n\
    \    let mut min_idx6 = lst.iter().position(|x| x == min).unwrap();\n    let mut\
    \ max_idx6 = lst.iter().position(|x| x == max).unwrap();\n    let mut min_idx7\
    \ = lst.iter().position(|x| x == min).unwrap();\n    let mut max_idx7 = lst.iter().position(|x|\
    \ x == max).unwrap();\n    let mut min_idx8 = lst.iter().position(|x| x == min).unwrap();\n\
    \    let mut max_idx8 = lst.iter().position(|x| x == max).unwrap();\n    let mut\
    \ min_idx9 = lst.iter().position(|x| x == min).unwrap();\n    let mut max_idx9\
    \ = lst.iter().position(|x| x == max).unwrap();\n    let mut min_idx10 = lst.iter().position(|x|\
    \ x == min).unwrap();\n    let mut max_idx10 = lst.iter().position(|x| x == max).unwrap();\n\
    \    let mut min_idx11 = lst.iter().position(|x| x == min).unwrap();\n    let\
    \ mut max_idx11 = lst.iter().position(|x| x == max).unwrap();\n    let mut min_idx12\
    \ = lst.iter().position(|x| x == min).unwrap();\n    let mut max_idx12 = lst.iter().position(|x|\
    \ x == max).unwrap();\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg7g9z8xw.rs:11:42\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    sorted_list.push(min_value);\n    sorted_list.push(max_value);\n   \
    \ for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpdvk4hol0.rs:25:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n25  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n        if x\
    \ < min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_idx = 1;\n\
    \    let mut max_idx = 1;\n    while min_idx < lst.len() {\n        if lst[min_idx]\
    \ < min_value {\n            min_value = lst[min_idx];\n            min_idx +=\
    \ 1;\n        }\n        if lst[max_idx] > max_value {\n            max_value\
    \ = lst[max_idx];\n            max_idx += 1;\n        }\n    }\n    let mut min_idx\
    \ = 1;\n    let mut max_idx = 1;\n    while min_idx < lst.len() {\n        if\
    \ lst[min_idx] < min_value {\n            min_value = lst[min_idx];\n        \
    \    min_idx += 1;\n        }\n        if lst[max_idx] > max_value {\n       \
    \     max_value = lst[max_idx];\n            max_idx += 1;\n        }\n    }\n\
    \    while min_idx < lst.len() {\n        if lst[min_idx] > max_value {\n    \
    \        result.push(min_value);\n            min_value -= 1;\n            min_idx\
    \ += 1;\n        }\n        if lst[max_idx] < min_value {\n            result.push(max_value);\n\
    \            max_value += 1;\n            max_idx += 1;\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmpa6snya4i.rs:25:21\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            ---\n    |              |\n    |              `lst` moved due to\
    \ this implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst`\n...\n25  |     while min_idx < lst.len()\
    \ {\n    |                     ^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx2\
    \ = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx2 = lst.iter().position(|x|\
    \ *x == max).unwrap();\n    let mut min_idx3 = lst.iter().position(|x| *x == min).unwrap();\n\
    \    let mut max_idx3 = lst.iter().position(|x| *x == max).unwrap();\n    while\
    \ min_idx != max_idx {\n        if min_idx2 == max_idx2 {\n            lst[min_idx2]\
    \ = min;\n            lst[max_idx2] = max;\n            min_idx2 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n            max_idx2 = lst.iter().position(|x| *x == max).unwrap();\n\
    \            min_idx3 = lst.iter().position(|x| *x == min).unwrap();\n       \
    \     max_idx3 = lst.iter().position(|x| *x == max).unwrap();\n        } else\
    \ {\n            lst[min_idx2] = min;\n            lst[max_idx2] = max;\n    \
    \        min_idx2 = lst.iter().position(|x| *x == min).unwrap();\n           \
    \ max_idx2 = lst.iter().position(|x| *x == max).unwrap();\n            min_idx3\
    \ = lst.iter().position(|x| *x == min).unwrap();\n            max_idx3 = lst.iter().position(|x|\
    \ *x == max).unwrap();\n        }\n        min = lst[min_idx];\n        max =\
    \ lst[max_idx];\n        min_idx = lst.iter().position(|x| *x == min).unwrap();\n\
    \        max_idx = lst.iter().position(|x| *x == max).unwrap();\n    }\n    lst\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2kfct4t1.rs:15:53\n   |\n\
    15 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2kfct4t1.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2kfct4t1.rs:17:54\n   |\n17 |     let mut min_idx2 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 \
    \     ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |     let mut min_idx2 = lst.iter().position(|x| *x ==\
    \ *min).unwrap();\n   |                                                      +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2kfct4t1.rs:18:54\n   |\n18 |\
    \     let mut max_idx2 = lst.iter().position(|x| *x == max).unwrap();\n   |  \
    \                                                    ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |     let\
    \ mut max_idx2 = lst.iter().position(|x| *x == *max).unwrap();\n   |         \
    \                                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2kfct4t1.rs:19:54\n   |\n19 |     let mut min_idx3 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 \
    \     ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n19 |     let mut min_idx3 = lst.iter().position(|x| *x ==\
    \ *min).unwrap();\n   |        "
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt291ujex.rs:137:3\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpt291ujex.rs:124:1\n    |\n123 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt291ujex.rs:11:42\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min_idx = lst.iter().position(|&x| x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|&x| x == max).unwrap();\n    while min_idx !=\
    \ max_idx {\n        let tmp = min;\n        min = max.clone();\n        max =\
    \ tmp;\n        min_idx = lst.iter().position(|&x| x == min).unwrap();\n     \
    \   max_idx = lst.iter().position(|&x| x == max).unwrap();\n    }\n    lst.sort_unstable();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2gpvvj3t.rs:15:53\n   |\n\
    15 |     let mut min_idx = lst.iter().position(|&x| x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |     let\
    \ mut min_idx = lst.iter().position(|&x| x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2gpvvj3t.rs:16:53\n   |\n16 |     let mut max_idx = lst.iter().position(|&x|\
    \ x == max).unwrap();\n   |                                                  \
    \   ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n16 |     let mut max_idx = lst.iter().position(|&x| x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2gpvvj3t.rs:19:15\n   |\n19 |         min = max.clone();\n\
    \   |               ^^^^^^^^^^^\n   |               |\n   |               expected\
    \ `&isize`, found `isize`\n   |               help: consider borrowing here: `&max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2gpvvj3t.rs:21:49\n   |\n21 |\
    \         min_idx = lst.iter().position(|&x| x == min).unwrap();\n   |       \
    \                                          ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |         min_idx = lst.iter().position(|&x|\
    \ x == *min).unwrap();\n   |                                                 +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2gpvvj3t.rs:22:49\n   |\n22 |\
    \         max_idx = lst.iter().position(|&x| x == max).unwrap();\n   |       \
    \                                          ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |         max_idx = lst.iter().position(|&x|\
    \ x == *max).unwrap();\n   |                                                 +\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: -1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst[0];\n    let mut max = lst[0];\n\
    \    for el in lst {\n        if el < min {\n            min = el;\n        }\n\
    \        if el > max {\n            max = el;\n        }\n    }\n    let mut result\
    \ = vec![];\n    while min < max {\n        let mut el = min;\n        while el\
    \ < max {\n            result.push(el);\n            el += 1;\n        }\n   \
    \     el = min;\n        while el > min {\n            result.push(el);\n    \
    \        el -= 1;\n        }\n        min = el;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748651
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkvn2bbga.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n       \
    \ if value < min_value {\n            min_value = value;\n        }\n        if\
    \ value > max_value {\n            max_value = value;\n        }\n    }\n    for\
    \ value in lst {\n        if value < min_value {\n            result.push(value);\n\
    \        }\n        if value > max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < max_value {\n  \
    \          result.push(value);\n        }\n    }\n    for value in lst {\n   \
    \     if value > max_value {\n            result.push(value);\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpgzni5jca.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  ---\n    |                  |\n    |                  `lst`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst`\n...\n23  |   \
    \  for value in lst {\n    |                  ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n\nerror[E0382]: use of moved value: `lst`\n  --> /tmp/tmpgzni5jca.rs:31:18\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- move occurs because `lst` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n23 |     for value in lst {\n   |     \
    \             ---\n   |                  |\n   |                  `lst` moved\
    \ due to this implicit call to `.into_iter()`\n   |                  help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n31 |     for value\
    \ in lst {\n   |                  ^^^ value used here after move\n\nerror[E0382]:\
    \ use of moved value: `lst`\n  --> /tmp/tmpgzni5jca.rs:36:18\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    31 |     for value in lst {\n   |                  ---\n   |                 \
    \ |\n   |                  `lst` moved due to this implicit call to `.into_iter()`\n\
    \   |                  help: consider borrowing to avoid moving into the for loop:\
    \ `&lst`\n...\n36 |     for value in lst {\n   |                  ^^^ value used\
    \ here after move\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for el in lst {\n\
    \        if el < min_value {\n            min_value = el;\n        }\n       \
    \ if el > max_value {\n            max_value = el;\n        }\n    }\n    for\
    \ el in lst {\n        if el == min_value {\n            sorted_list.push(el);\n\
    \        }\n        if el == max_value {\n            sorted_list.push(el);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpwvixobxi.rs:23:15\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for el in lst {\n    | \
    \              ---\n    |               |\n    |               `lst` moved due\
    \ to this implicit call to `.into_iter()`\n    |               help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n23  |     for el in\
    \ lst {\n    |               ^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748645
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgaj0njit.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min\
    \ = lst[0];\n    let mut max = lst[0];\n    for x in lst {\n        if x < min\
    \ {\n            min = x;\n        }\n        if x > max {\n            max =\
    \ x;\n        }\n    }\n    let mut lst = vec![];\n    let mut i = min;\n    while\
    \ i <= max {\n        lst.push(i);\n        i += 1;\n    }\n    lst.push(max);\n\
    \    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpzh42mtws.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748646
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list[0];\n    let mut max_value = sorted_list[0];\n    for value in\
    \ sorted_list.iter() {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut new_list = vec![];\n    for value in sorted_list.iter()\
    \ {\n        if value < min_value {\n            new_list.push(value);\n     \
    \   }\n        if value > max_value {\n            new_list.push(value);\n   \
    \     }\n    }\n    for value in sorted_list.iter() {\n        if value < min_value\
    \ {\n            new_list.push(value);\n        }\n    }\n    for value in sorted_list.iter()\
    \ {\n        if value > max_value {\n            new_list.push(value);\n     \
    \   }\n    }\n    new_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcdvvcb15.rs:16:20\n   |\n\
    16 |         if value < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcdvvcb15.rs:17:25\n   |\n17 |             min_value\
    \ = value;\n   |                         ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |             min_value\
    \ = *value;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcdvvcb15.rs:19:20\n   |\n19 |         if value > max_value {\n\
    \   |                    ^^^^^^^^^\n   |                    |\n   |          \
    \          expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcdvvcb15.rs:20:25\n\
    \   |\n20 |             max_value = value;\n   |                         ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |             max_value = *value;\n   |                         +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcdvvcb15.rs:25:20\n   |\n25 |  \
    \       if value < min_value {\n   |                    ^^^^^^^^^\n   |      \
    \              |\n   |                    expected `&isize`, found `isize`\n \
    \  |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcdvvcb15.rs:28:20\n   |\n28 |         if value\
    \ > max_value {\n   |                    ^^^^^^^^^\n   |                    |\n\
    \   |                    expected `&isize`, found `isize`\n   |              \
    \      help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcdvvcb15.rs:33:20\n   |\n33 |         if value < min_value\
    \ {\n   |                    ^^^^^^^^^\n   |                    |\n   |      \
    \              expected `&isize`, found `isize`\n   |                    help:\
    \ consider borrowing here: `&min_value`\n\nerror[E0308]: mi"
  stdout: ''
  timestamp: 1659748646
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst {\n        if value == min_value {\n            sorted_list.push(value);\n\
    \        }\n        if value == max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp83poisdh.rs:23:18\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
