language: rs
name: HumanEval_33_sort_third
results:
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_unstable();\n\
    \    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmphfc25z1f.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    l.iter().cloned().skip(l.len()\
    \ / 3).collect()\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmps7igv4c3.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    let mut l2 = l.clone();\n    let mut i = 0;\n\
    \    while i < l.len() {\n        if i % 3 == 0 {\n            l2.swap(i, i +\
    \ 1);\n        }\n        i += 1;\n    }\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 7 but the
    index is 7'', /tmp/tmpsbtecre9.rs:14:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9kvx841n.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|&x|\
    \ x % 3);\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmptn11gm85.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n   \
    \ l3.sort();\n    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjb7hxewx.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmppg3dgnyx.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpetu0de9s.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    l2.iter().enumerate().filter(|(_,\
    \ i)| i % 3 == 0).map(|(_, i)| l2[i / 3]).collect()\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmphrhrkbdm.rs:11:45\n\
    \   |\n11 |     l2.iter().enumerate().filter(|(_, i)| i % 3 == 0).map(|(_, i)|\
    \ l2[i / 3]).collect()\n   |                                           - ^ - {integer}\n\
    \   |                                           |\n   |                      \
    \                     &&isize\n   |\nhelp: `%` can be used on `isize`, you can\
    \ dereference `i`\n   |\n11 |     l2.iter().enumerate().filter(|(_, i)| *i % 3\
    \ == 0).map(|(_, i)| l2[i / 3]).collect()\n   |                              \
    \             +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmphrhrkbdm.rs:11:68\n   |\n11 |     l2.iter().enumerate().filter(|(_,\
    \ i)| i % 3 == 0).map(|(_, i)| l2[i / 3]).collect()\n   |                    \
    \                                                ^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut l2 = l;\n    let mut l3 = l;\n    let mut l4 =\
    \ l;\n    let mut l5 = l;\n    let mut l6 = l;\n    let mut l7 = l;\n    let mut\
    \ l8 = l;\n    let mut l9 = l;\n    let mut l10 = l;\n    let mut l11 = l;\n \
    \   let mut l12 = l;\n    let mut l13 = l;\n    let mut l14 = l;\n    let mut\
    \ l15 = l;\n    let mut l16 = l;\n    let mut l17 = l;\n    let mut l18 = l;\n\
    \    let mut l19 = l;\n    let mut l20 = l;\n    let mut l21 = l;\n    let mut\
    \ l22 = l;\n    let mut l23 = l;\n    let mut l24 = l;\n    let mut l25 = l;\n\
    \    let mut l26 = l;\n    let mut l27 = l;\n    let mut l28 = l;\n    let mut\
    \ l29 = l;\n    let mut l30 = l;\n    let mut l31 = l;\n    let mut l32 = l;\n\
    \    let mut l33 = l;\n    let mut l34 = l;\n    let mut l35 = l;\n    let mut\
    \ l36 = l;\n    let mut l37 = l;\n    let mut l38 = l;\n    let mut l39 = l;\n\
    \    let mut l40 = l;\n    let mut l41 = l;\n    let mut l42 = l;\n    let mut\
    \ l43 = l;\n    let mut l44 = l;\n    let mut l45 = l;\n    let mut l46 = l;\n\
    \    let mut l47 = l;\n    let mut l48 = l;\n    let mut l49 = l;\n    let mut\
    \ l50 = l;\n    let mut l51 = l;\n    let mut l52 = l;\n    let mut l53 = l;\n\
    \    let mut l54 = l;\n    let mut l55 = l;\n    let mut l56 = l;\n    let mut\
    \ l57 = l;\n    let mut l58 = l;\n    let mut l59 = l;\n    let mut l60 = l;\n\
    \    let mut l61 = l;\n    let mut l62 = l;\n    let mut l63 = l;\n    let mut\
    \ l64 = l;\n    let mut l65 = l;\n    let mut l66 = \n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpfkhywyo8.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    l.sort_unstable_by_key(|&x| x %\
    \ 3);\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9, 4, 2, 5, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpsjp3mssp.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    let mut l2 = l.clone();\n\
    \    l2.iter_mut().filter(|&x| x % 3 == 0).for_each(|&x| {\n        l2[x as usize]\
    \ = l[x as usize];\n    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmpssi3quqr.rs:12:33\n\
    \   |\n12 |     l2.iter_mut().filter(|&x| x % 3 == 0).for_each(|&x| {\n   |  \
    \                             - ^ - {integer}\n   |                          \
    \     |\n   |                               &mut isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n12 |     l2.iter_mut().filter(|&x|\
    \ *x % 3 == 0).for_each(|&x| {\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpssi3quqr.rs:12:53\n   |\n12 |     l2.iter_mut().filter(|&x|\
    \ x % 3 == 0).for_each(|&x| {\n   |                                          \
    \           ^--\n   |                                                     ||\n\
    \   |                                                     |expected due to this\n\
    \   |                                                     types differ in mutability\n\
    \   |                                                     help: did you mean `x`:\
    \ `&&mut isize`\n   |\n   = note: expected mutable reference `&mut isize`\n  \
    \                    found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    let mut l2 = l.to_vec();\n\
    \    l2.iter_mut().enumerate().for_each(|(i, v)| {\n        if i % 3 == 0 {\n\
    \            *v = (*v + 1) as isize;\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 4, 6, 6, 8, 10]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp58p5yrhl.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|&x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7_dedwpt.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    let mut l2 = l.to_vec();\n\
    \    l2.sort_unstable();\n    let mut l3 = l.to_vec();\n    l3.sort_unstable();\n\
    \    let mut l4 = l.to_vec();\n    l4.sort_unstable();\n    let mut l5 = l.to_vec();\n\
    \    l5.sort_unstable();\n    let mut l6 = l.to_vec();\n    l6.sort_unstable();\n\
    \    let mut l7 = l.to_vec();\n    l7.sort_unstable();\n    let mut l8 = l.to_vec();\n\
    \    l8.sort_unstable();\n    let mut l9 = l.to_vec();\n    l9.sort_unstable();\n\
    \    let mut l10 = l.to_vec();\n    l10.sort_unstable();\n    let mut l11 = l.to_vec();\n\
    \    l11.sort_unstable();\n    let mut l12 = l.to_vec();\n    l12.sort_unstable();\n\
    \    let mut l13 = l.to_vec();\n    l13.sort_unstable();\n    let mut l14 = l.to_vec();\n\
    \    l14.sort_unstable();\n    let mut l15 = l.to_vec();\n    l15.sort_unstable();\n\
    \    let mut l16 = l.to_vec();\n    l16.sort_unstable();\n    let mut l17 = l.to_vec();\n\
    \    l17.sort_unstable();\n    let mut l18 = l.to_vec();\n    l18.sort_unstable();\n\
    \    let mut l19 = l.to_vec();\n    l19.sort_unstable();\n    let mut l20 = l.to_vec();\n\
    \    l20.sort_unstable();\n    let mut l21 = l.to_vec();\n    l21.sort_unstable();\n\
    \    let mut l22 = l.to_vec();\n    l22.sort_unstable();\n    let mut l23 = l.to_vec();\n\
    \    l23.sort_unstable();\n    let mut l24 = l.to_vec();\n    l24.sort_unstable();\n\
    \    let mut l25 = l.to_vec();\n    l25.sort_unstable();\n    let mut l26 = l.to_vec();\n\
    \    l26.sort_unstable();\n    let mut l27 = l.to_vec();\n    l27.sort_unstable();\n\
    \    let mut l28 = l.to_vec();\n    l28.sort_unstable();\n    let mut l29 = l.to_vec();\n\
    \    l29.sort_unstable();\n    let mut l\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzylzlvio.rs:67:14\n   |\n\
    67 |     let mut l\n   |              ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpzylzlvio.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n   \
    \ l3.iter_mut().for_each(|&i| {\n        if i % 3 == 0 {\n            *i = *i\
    \ / 3;\n        }\n    });\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv0p47o3q.rs:12:29\n   |\n\
    12 |     l3.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpe4126q1o.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l.clone();\n    l3.sort_unstable();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqppo1ggv.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    l.iter().filter(|&i| i\
    \ % 3 == 0).cloned().collect()\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp6vgnzb7d.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            *i = *i / 3;\n        }\n    });\n \
    \   l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplfe1bhwm.rs:12:29\n   |\n\
    12 |     l2.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = l;\n    l3.sort();\n    let\
    \ mut l4 = l;\n    l4.sort();\n    let mut l5 = l;\n    l5.sort();\n    let mut\
    \ l6 = l;\n    l6.sort();\n    let mut l7 = l;\n    l7.sort();\n    let mut l8\
    \ = l;\n    l8.sort();\n    let mut l9 = l;\n    l9.sort();\n    let mut l10 =\
    \ l;\n    l10.sort();\n    let mut l11 = l;\n    l11.sort();\n    let mut l12\
    \ = l;\n    l12.sort();\n    let mut l13 = l;\n    l13.sort();\n    let mut l14\
    \ = l;\n    l14.sort();\n    let mut l15 = l;\n    l15.sort();\n    let mut l16\
    \ = l;\n    l16.sort();\n    let mut l17 = l;\n    l17.sort();\n    let mut l18\
    \ = l;\n    l18.sort();\n    let mut l19 = l;\n    l19.sort();\n    let mut l20\
    \ = l;\n    l20.sort();\n    let mut l21 = l;\n    l21.sort();\n    let mut l22\
    \ = l;\n    l22.sort();\n    let mut l23 = l;\n    l23.sort();\n    let mut l24\
    \ = l;\n    l24.sort();\n    let mut l25 = l;\n    l25.sort();\n    let mut l26\
    \ = l;\n    l26.sort();\n    let mut l27 = l;\n    l27.sort();\n    let mut l28\
    \ = l;\n    l28.sort();\n    let mut l29 = l;\n    l29.sort();\n    let mut l30\
    \ = l;\n    l30.sort();\n    let mut l31 = l;\n    l31.sort();\n    let mut l32\
    \ = l;\n    l32.sort();\n    let mut l33 = l;\n    l33.sort();\n    let mut l34\
    \ = l;\n    l34.sort();\n    let mut l35 = l;\n    l35.sort();\n    let mut l36\
    \ = l;\n    l36.sort();\n    let mut l37 = l;\n    l37.sort();\n    let mut l38\
    \ = l;\n    l38.sort();\n    let mut l39 = l;\n    l39.sort();\n    let mut l40\
    \ = l;\n    l40.sort();\n    let mut l41 = l;\n    l41.sort();\n    let mu\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpad_0ttpb.rs:89:11\n   |\n\
    89 |     let mu\n   |           ^ help: add `;` here\n90 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpad_0ttpb.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut i = 0;\n    while i < l2.len() {\n        if i\
    \ % 3 == 0 {\n            l2.swap(i, l2.len() - 1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `l2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpohs2vd9y.rs:13:24\n   |\n13 |             l2.swap(i,\
    \ l2.len() - 1);\n   |             -- ----    ^^ immutable borrow occurs here\n\
    \   |             |  |\n   |             |  mutable borrow later used by call\n\
    \   |             mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut i = 0;\n    while i < l2.len() {\n        if i\
    \ % 3 == 0 {\n            l2[i] = l2[i];\n        } else {\n            l2[i]\
    \ = l2[i + 1];\n        }\n        i += 1;\n    }\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, 4, 4, 9, 2, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqwbp927z.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort();\n    l2\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp__m8fun5.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l;\n    l3.sort();\n    let mut l2 = vec![];\n    for i in 0..l3.len()\
    \ {\n        if i % 3 == 0 {\n            l2.push(l3[i]);\n        } else {\n\
    \            l2.push(l3[i] - 1);\n        }\n    }\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 3, 5, 5, 7, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpm1as4j4c.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l2\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp8b9_ewum.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|&x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7_dedwpt.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|&i|\
    \ {\n        if i % 3 == 0 {\n            i\n        } else {\n            i.checked_mul(3).ok()\n\
    \        }\n    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpu5jafvus.rs:14:30\n   |\n14 |             i.checked_mul(3).ok()\n\
    \   |                              ^^ help: there is an associated function with\
    \ a similar name: `or`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            *i = *i / 3;\n        }\n    });\n \
    \   l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplfe1bhwm.rs:12:29\n   |\n\
    12 |     l2.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_by_key(|x| {\n        if x % 3 == 0 {\n        \
    \    x.checked_add(1).ok_or(\"sort_third: x not divisible by 3\")\n        } else\
    \ {\n            x.checked_add(2).ok_or(\"sort_third: x not divisible by 3\")\n\
    \        }\n    });\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpg77y3alz.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    l.iter_mut().filter(|&x| x % 3\
    \ == 0).cloned().collect()\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmp8lznubh_.rs:11:32\n\
    \   |\n11 |     l.iter_mut().filter(|&x| x % 3 == 0).cloned().collect()\n   |\
    \                              - ^ - {integer}\n   |                         \
    \     |\n   |                              &mut isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n11 |     l.iter_mut().filter(|&x|\
    \ *x % 3 == 0).cloned().collect()\n   |                              +\n\nerror[E0271]:\
    \ type mismatch resolving `<Filter<std::slice::IterMut<'_, isize>, [closure@/tmp/tmp8lznubh_.rs:11:25:\
    \ 11:40]> as Iterator>::Item == &_`\n  --> /tmp/tmp8lznubh_.rs:11:42\n   |\n11\
    \ |     l.iter_mut().filter(|&x| x % 3 == 0).cloned().collect()\n   |        \
    \                                  ^^^^^^ types differ in mutability\n   |\n \
    \  = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Filter<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmp8lznubh_.rs:11:25: 11:40]>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp8lznubh_.rs:11:51\n   |\n11 |        l.iter_mut().filter(|&x|\
    \ x % 3 == 0).cloned().collect()\n   |                                       \
    \               ^^^^^^^ method cannot be called on `Cloned<Filter<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmp8lznubh_.rs:11:25: 11:40]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<std::slice::IterMut<'_, isize>, [closure@/tmp/tmp8lznubh_.rs:11:25:\
    \ 11:40]> as Iterator>::Item = &_`\n           which is required by `Cloned<Filter<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmp8lznubh_.rs:11:25: 11:40]>>: Iterator`\n          \
    \ `Cloned<Filter<std::slice::IterMut<'_, isize>, [closure@/tmp/tmp8lznubh_.rs:11:25:\
    \ 11:40]>>: Iterator`\n           which is required by `&mut Cloned<Filter<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmp8lznubh_.rs:11:25: 11:40]>>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanat"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|&i| {\n        if i % 3 == 0 {\n\
    \            l.swap(i, i - 1);\n        }\n        i\n    });\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3tr8x7jz.rs:12:20\n   |\n\
    12 |             l.swap(i, i - 1);\n   |                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n12 |             l.swap(i.try_into().unwrap(),\
    \ i - 1);\n   |                    ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3tr8x7jz.rs:12:23\n   |\n12 |             l.swap(i, i -\
    \ 1);\n   |                       ^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n12 |             l.swap(i, (i - 1).try_into().unwrap());\n\
    \   |                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n        l2[i] = l2[i] / 3;\n    });\n    l2\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmprs6urfbv.rs:12:33\n\
    \   |\n12 |     l2.iter_mut().filter(|&i| i % 3 == 0).for_each(|&i| {\n   |  \
    \                             - ^ - {integer}\n   |                          \
    \     |\n   |                               &mut isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `i`\n   |\n12 |     l2.iter_mut().filter(|&i|\
    \ *i % 3 == 0).for_each(|&i| {\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprs6urfbv.rs:12:53\n   |\n12 |     l2.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n   |                                          \
    \           ^--\n   |                                                     ||\n\
    \   |                                                     |expected due to this\n\
    \   |                                                     types differ in mutability\n\
    \   |                                                     help: did you mean `i`:\
    \ `&&mut isize`\n   |\n   = note: expected mutable reference `&mut isize`\n  \
    \                    found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut l2 = l;\n    let mut l3 = l;\n    let mut l4 =\
    \ l;\n    let mut l5 = l;\n    let mut l6 = l;\n    let mut l7 = l;\n    let mut\
    \ l8 = l;\n    let mut l9 = l;\n    let mut l10 = l;\n    let mut l11 = l;\n \
    \   let mut l12 = l;\n    let mut l13 = l;\n    let mut l14 = l;\n    let mut\
    \ l15 = l;\n    let mut l16 = l;\n    let mut l17 = l;\n    let mut l18 = l;\n\
    \    let mut l19 = l;\n    let mut l20 = l;\n    let mut l21 = l;\n    let mut\
    \ l22 = l;\n    let mut l23 = l;\n    let mut l24 = l;\n    let mut l25 = l;\n\
    \    let mut l26 = l;\n    let mut l27 = l;\n    let mut l28 = l;\n    let mut\
    \ l29 = l;\n    let mut l30 = l;\n    let mut l31 = l;\n    let mut l32 = l;\n\
    \    let mut l33 = l;\n    let mut l34 = l;\n    let mut l35 = l;\n    let mut\
    \ l36 = l;\n    let mut l37 = l;\n    let mut l38 = l;\n    let mut l39 = l;\n\
    \    let mut l40 = l;\n    let mut l41 = l;\n    let mut l42 = l;\n    let mut\
    \ l43 = l;\n    let mut l44 = l;\n    let mut l45 = l;\n    let mut l46 = l;\n\
    \    let mut l47 = l;\n    let mut l48 = l;\n    let mut l49 = l;\n    let mut\
    \ l50 = l;\n    let mut l51 = l;\n    let mut l52 = l;\n    let mut l53 = l;\n\
    \    let mut l54 = l;\n    let mut l55 = l;\n    let mut l56 = l;\n    let mut\
    \ l57 = l;\n    let mut l58 = l;\n    let mut l59 = l;\n    let mut l60 = l;\n\
    \    let mut l61 = l;\n    let mut l62 = l;\n    let mut l63 = l;\n    let mut\
    \ l64 = l;\n    let mut l65 = l;\n    let mut l66 = \n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpfkhywyo8.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut i = 0;\n    while i < l2.len() {\n        if i\
    \ % 3 == 0 {\n            l2.swap(i, l2.len() - 1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `l2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpohs2vd9y.rs:13:24\n   |\n13 |             l2.swap(i,\
    \ l2.len() - 1);\n   |             -- ----    ^^ immutable borrow occurs here\n\
    \   |             |  |\n   |             |  mutable borrow later used by call\n\
    \   |             mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = vec![];\n    for i in 0..l2.len()\
    \ {\n        if i % 3 == 0 {\n            l3.push(l2[i]);\n        } else {\n\
    \            l3.push(l2[i]);\n            l3.push(l2[i]);\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 3, 4, 4, 5, 6, 6, 8, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpml750rw1.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l.iter().cloned().collect::<Vec<_>>();\n    l3.sort_by_key(|x|\
    \ x % 3);\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpyr8djkp_.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpe4126q1o.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut i = 0;\n    while i < l2.len() {\n        if i\
    \ % 3 == 0 {\n            l2.swap(i, l2.len() - 1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `l2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpohs2vd9y.rs:13:24\n   |\n13 |             l2.swap(i,\
    \ l2.len() - 1);\n   |             -- ----    ^^ immutable borrow occurs here\n\
    \   |             |  |\n   |             |  mutable borrow later used by call\n\
    \   |             mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp02oclvgy.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = l;\n    l3.sort();\n    let\
    \ mut l4 = l;\n    l4.sort();\n    let mut l5 = l;\n    l5.sort();\n    let mut\
    \ l6 = l;\n    l6.sort();\n    let mut l7 = l;\n    l7.sort();\n    let mut l8\
    \ = l;\n    l8.sort();\n    let mut l9 = l;\n    l9.sort();\n    let mut l10 =\
    \ l;\n    l10.sort();\n    let mut l11 = l;\n    l11.sort();\n    let mut l12\
    \ = l;\n    l12.sort();\n    let mut l13 = l;\n    l13.sort();\n    let mut l14\
    \ = l;\n    l14.sort();\n    let mut l15 = l;\n    l15.sort();\n    let mut l16\
    \ = l;\n    l16.sort();\n    let mut l17 = l;\n    l17.sort();\n    let mut l18\
    \ = l;\n    l18.sort();\n    let mut l19 = l;\n    l19.sort();\n    let mut l20\
    \ = l;\n    l20.sort();\n    let mut l21 = l;\n    l21.sort();\n    let mut l22\
    \ = l;\n    l22.sort();\n    let mut l23 = l;\n    l23.sort();\n    let mut l24\
    \ = l;\n    l24.sort();\n    let mut l25 = l;\n    l25.sort();\n    let mut l26\
    \ = l;\n    l26.sort();\n    let mut l27 = l;\n    l27.sort();\n    let mut l28\
    \ = l;\n    l28.sort();\n    let mut l29 = l;\n    l29.sort();\n    let mut l30\
    \ = l;\n    l30.sort();\n    let mut l31 = l;\n    l31.sort();\n    let mut l32\
    \ = l;\n    l32.sort();\n    let mut l33 = l;\n    l33.sort();\n    let mut l34\
    \ = l;\n    l34.sort();\n    let mut l35 = l;\n    l35.sort();\n    let mut l36\
    \ = l;\n    l36.sort();\n    let mut l37 = l;\n    l37.sort();\n    let mut l38\
    \ = l;\n    l38.sort();\n    let mut l39 = l;\n    l39.sort();\n    let mut l40\
    \ = l;\n    l40.sort();\n    let mut l41 = l;\n    l41.sort();\n    let mu\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpad_0ttpb.rs:89:11\n   |\n\
    89 |     let mu\n   |           ^ help: add `;` here\n90 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpad_0ttpb.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    l.iter().filter(|&x| x % 3 == 0).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpwg8z3lkh.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut l3 = l;\n    let mut l4 = l;\n    let mut l5 =\
    \ l;\n    let mut l6 = l;\n    let mut l7 = l;\n    let mut l8 = l;\n    let mut\
    \ l9 = l;\n    let mut l10 = l;\n    let mut l11 = l;\n    let mut l12 = l;\n\
    \    let mut l13 = l;\n    let mut l14 = l;\n    let mut l15 = l;\n    let mut\
    \ l16 = l;\n    let mut l17 = l;\n    let mut l18 = l;\n    let mut l19 = l;\n\
    \    let mut l20 = l;\n    let mut l21 = l;\n    let mut l22 = l;\n    let mut\
    \ l23 = l;\n    let mut l24 = l;\n    let mut l25 = l;\n    let mut l26 = l;\n\
    \    let mut l27 = l;\n    let mut l28 = l;\n    let mut l29 = l;\n    let mut\
    \ l30 = l;\n    let mut l31 = l;\n    let mut l32 = l;\n    let mut l33 = l;\n\
    \    let mut l34 = l;\n    let mut l35 = l;\n    let mut l36 = l;\n    let mut\
    \ l37 = l;\n    let mut l38 = l;\n    let mut l39 = l;\n    let mut l40 = l;\n\
    \    let mut l41 = l;\n    let mut l42 = l;\n    let mut l43 = l;\n    let mut\
    \ l44 = l;\n    let mut l45 = l;\n    let mut l46 = l;\n    let mut l47 = l;\n\
    \    let mut l48 = l;\n    let mut l49 = l;\n    let mut l50 = l;\n    let mut\
    \ l51 = l;\n    let mut l52 = l;\n    let mut l53 = l;\n    let mut l54 = l;\n\
    \    let mut l55 = l;\n    let mut l56 = l;\n    let mut l57 = l;\n    let mut\
    \ l58 = l;\n    let mut l59 = l;\n    let mut l60 = l;\n    let mut l61 = l;\n\
    \    let mut l62 = l;\n    let mut l63 = l;\n    let mut l64 = l;\n    let mut\
    \ l65 = l;\n    let mut l66 = l;\n    let mut l\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsmkhveep.rs:74:14\n   |\n\
    74 |     let mut l\n   |              ^ help: add `;` here\n75 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsmkhveep.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            x.to_owned()\n        } else {\n            x.to_owned() + 3\n  \
    \      }\n    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 6, 4, 5, 9, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmplcdp6ema.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|&x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l2\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpgbqzya7m.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = vec![];\n    for i in 0..l2.len()\
    \ {\n        if i % 3 == 0 {\n            l3.push(l2[i]);\n        } else {\n\
    \            l3.push(l2[i]);\n            l3.push(l2[i]);\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 3, 4, 4, 5, 6, 6, 8, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpml750rw1.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|&i| i / 3);\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 5, 3, 4, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpznpqca9s.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l.clone();\n    l3.sort_unstable();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqppo1ggv.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    let mut l2 = l.clone();\n    let mut i = 0;\n\
    \    while i < l.len() {\n        if i % 3 == 0 {\n            l2.swap(i, i +\
    \ 1);\n        }\n        i += 1;\n    }\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 7 but the
    index is 7'', /tmp/tmpsbtecre9.rs:14:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    l.iter().filter(|&i| i % 3 == 0).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp44wn7sqs.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            *i = *i / 3;\n        }\n    });\n \
    \   l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplfe1bhwm.rs:12:29\n   |\n\
    12 |     l2.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            x.to_owned()\n        } else {\n            x.to_owned()\n      \
    \  }\n    });\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpi6lfdcmq.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    l.iter().cloned().skip(l.len()\
    \ / 3).collect()\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmps7igv4c3.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|&x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpmh8svq58.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|&x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7_dedwpt.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpcw_58c7y.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    l.iter().filter(|&x| x\
    \ % 3 == 0).cloned().collect()\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqcv733u9.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    l2.iter().cloned().skip(1).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n  --> /tmp/tmpbgdi3hmh.rs:11:32\n   |\n11 |     l2.iter().cloned().skip(1).cloned().collect()\n\
    \   |                                ^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note: expected reference `&isize`\n              found reference `&&_`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Skip<Cloned<std::slice::Iter<'_, isize>>>>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpbgdi3hmh.rs:11:41\n   |\n11 |\
    \        l2.iter().cloned().skip(1).cloned().collect()\n   |                 \
    \                           ^^^^^^^ method cannot be called on `Cloned<Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Skip<Cloned<std::slice::Iter<'_, isize>>>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>>: Iterator`\n           `Cloned<Skip<Cloned<std::slice::Iter<'_, isize>>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = l;\n    l3.sort();\n    let\
    \ mut l4 = l;\n    l4.sort();\n    let mut l5 = l;\n    l5.sort();\n    let mut\
    \ l6 = l;\n    l6.sort();\n    let mut l7 = l;\n    l7.sort();\n    let mut l8\
    \ = l;\n    l8.sort();\n    let mut l9 = l;\n    l9.sort();\n    let mut l10 =\
    \ l;\n    l10.sort();\n    let mut l11 = l;\n    l11.sort();\n    let mut l12\
    \ = l;\n    l12.sort();\n    let mut l13 = l;\n    l13.sort();\n    let mut l14\
    \ = l;\n    l14.sort();\n    let mut l15 = l;\n    l15.sort();\n    let mut l16\
    \ = l;\n    l16.sort();\n    let mut l17 = l;\n    l17.sort();\n    let mut l18\
    \ = l;\n    l18.sort();\n    let mut l19 = l;\n    l19.sort();\n    let mut l20\
    \ = l;\n    l20.sort();\n    let mut l21 = l;\n    l21.sort();\n    let mut l22\
    \ = l;\n    l22.sort();\n    let mut l23 = l;\n    l23.sort();\n    let mut l24\
    \ = l;\n    l24.sort();\n    let mut l25 = l;\n    l25.sort();\n    let mut l26\
    \ = l;\n    l26.sort();\n    let mut l27 = l;\n    l27.sort();\n    let mut l28\
    \ = l;\n    l28.sort();\n    let mut l29 = l;\n    l29.sort();\n    let mut l30\
    \ = l;\n    l30.sort();\n    let mut l31 = l;\n    l31.sort();\n    let mut l32\
    \ = l;\n    l32.sort();\n    let mut l33 = l;\n    l33.sort();\n    let mut l34\
    \ = l;\n    l34.sort();\n    let mut l35 = l;\n    l35.sort();\n    let mut l36\
    \ = l;\n    l36.sort();\n    let mut l37 = l;\n    l37.sort();\n    let mut l38\
    \ = l;\n    l38.sort();\n    let mut l39 = l;\n    l39.sort();\n    let mut l40\
    \ = l;\n    l40.sort();\n    let mut l41 = l;\n    l41.sort();\n    let mu\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpad_0ttpb.rs:89:11\n   |\n\
    89 |     let mu\n   |           ^ help: add `;` here\n90 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpad_0ttpb.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    let mut l2 = l.clone();\n\
    \    l2.iter_mut().filter(|&x| x % 3 == 0).for_each(|&x| {\n        l2[x as usize\
    \ - 1] = (x as usize) % 3;\n    });\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmp4_az727w.rs:12:33\n\
    \   |\n12 |     l2.iter_mut().filter(|&x| x % 3 == 0).for_each(|&x| {\n   |  \
    \                             - ^ - {integer}\n   |                          \
    \     |\n   |                               &mut isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n12 |     l2.iter_mut().filter(|&x|\
    \ *x % 3 == 0).for_each(|&x| {\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4_az727w.rs:12:53\n   |\n12 |     l2.iter_mut().filter(|&x|\
    \ x % 3 == 0).for_each(|&x| {\n   |                                          \
    \           ^--\n   |                                                     ||\n\
    \   |                                                     |expected due to this\n\
    \   |                                                     types differ in mutability\n\
    \   |                                                     help: did you mean `x`:\
    \ `&&mut isize`\n   |\n   = note: expected mutable reference `&mut isize`\n  \
    \                    found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4_az727w.rs:13:30\n   |\n13 |         l2[x as usize - 1] = (x as\
    \ usize) % 3;\n   |                              ^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = l;\n    l3.sort();\n    let\
    \ mut l4 = l;\n    l4.sort();\n    let mut l5 = l;\n    l5.sort();\n    let mut\
    \ l6 = l;\n    l6.sort();\n    let mut l7 = l;\n    l7.sort();\n    let mut l8\
    \ = l;\n    l8.sort();\n    let mut l9 = l;\n    l9.sort();\n    let mut l10 =\
    \ l;\n    l10.sort();\n    let mut l11 = l;\n    l11.sort();\n    let mut l12\
    \ = l;\n    l12.sort();\n    let mut l13 = l;\n    l13.sort();\n    let mut l14\
    \ = l;\n    l14.sort();\n    let mut l15 = l;\n    l15.sort();\n    let mut l16\
    \ = l;\n    l16.sort();\n    let mut l17 = l;\n    l17.sort();\n    let mut l18\
    \ = l;\n    l18.sort();\n    let mut l19 = l;\n    l19.sort();\n    let mut l20\
    \ = l;\n    l20.sort();\n    let mut l21 = l;\n    l21.sort();\n    let mut l22\
    \ = l;\n    l22.sort();\n    let mut l23 = l;\n    l23.sort();\n    let mut l24\
    \ = l;\n    l24.sort();\n    let mut l25 = l;\n    l25.sort();\n    let mut l26\
    \ = l;\n    l26.sort();\n    let mut l27 = l;\n    l27.sort();\n    let mut l28\
    \ = l;\n    l28.sort();\n    let mut l29 = l;\n    l29.sort();\n    let mut l30\
    \ = l;\n    l30.sort();\n    let mut l31 = l;\n    l31.sort();\n    let mut l32\
    \ = l;\n    l32.sort();\n    let mut l33 = l;\n    l33.sort();\n    let mut l34\
    \ = l;\n    l34.sort();\n    let mut l35 = l;\n    l35.sort();\n    let mut l36\
    \ = l;\n    l36.sort();\n    let mut l37 = l;\n    l37.sort();\n    let mut l38\
    \ = l;\n    l38.sort();\n    let mut l39 = l;\n    l39.sort();\n    let mut l40\
    \ = l;\n    l40.sort();\n    let mut l41 = l;\n    l41.sort();\n    let mu\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpad_0ttpb.rs:89:11\n   |\n\
    89 |     let mu\n   |           ^ help: add `;` here\n90 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpad_0ttpb.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            x.to_owned()\n        } else {\n            x.to_owned() + 3\n  \
    \      }\n    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 6, 4, 5, 9, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp3uadd38t.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpw9jurkfk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort_by_key(|&x| {\n        if x % 3 == 0 {\n     \
    \       0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\n\
    fn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpohftyxl9.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = Vec::new();\n    for i in\
    \ 0..l2.len() {\n        if i % 3 == 0 {\n            l3.push(l2[i]);\n      \
    \  } else {\n            l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw9a5b6wa.rs:16:21\n   |\n\
    16 |             l3.push(i);\n   |                     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n16 |             l3.push(i.try_into().unwrap());\n\
    \   |                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9kvx841n.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|&x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7_dedwpt.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    l2.iter().enumerate().filter(|(i, _)|\
    \ i % 3 == 0).map(|(i, _)| {\n        l2[i] = l2[i] / 3;\n        l2[i] = l2[i]\
    \ % 3;\n        l2[i]\n    }).collect()\n}\n\nfn main() {\n    let candidate =\
    \ sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6,\
    \ 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `l2` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpg4g4wplg.rs:11:59\n   |\n11 |     l2.iter().enumerate().filter(|(i,\
    \ _)| i % 3 == 0).map(|(i, _)| {\n   |     --                                \
    \                --- ^^^^^^^^ mutable borrow occurs here\n   |     |         \
    \                                        |\n   |     immutable borrow occurs here\
    \                      immutable borrow later used by call\n12 |         l2[i]\
    \ = l2[i] / 3;\n   |         -- second borrow occurs due to use of `l2` in closure\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n        l2[i] = l2[i] / 3;\n    });\n    l2\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmprs6urfbv.rs:12:33\n\
    \   |\n12 |     l2.iter_mut().filter(|&i| i % 3 == 0).for_each(|&i| {\n   |  \
    \                             - ^ - {integer}\n   |                          \
    \     |\n   |                               &mut isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `i`\n   |\n12 |     l2.iter_mut().filter(|&i|\
    \ *i % 3 == 0).for_each(|&i| {\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprs6urfbv.rs:12:53\n   |\n12 |     l2.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n   |                                          \
    \           ^--\n   |                                                     ||\n\
    \   |                                                     |expected due to this\n\
    \   |                                                     types differ in mutability\n\
    \   |                                                     help: did you mean `i`:\
    \ `&&mut isize`\n   |\n   = note: expected mutable reference `&mut isize`\n  \
    \                    found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9kvx841n.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpetu0de9s.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut i = 0;\n    while i < l2.len() {\n        if i\
    \ % 3 == 0 {\n            l2.swap(i, l2.len() - 1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `l2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpohs2vd9y.rs:13:24\n   |\n13 |             l2.swap(i,\
    \ l2.len() - 1);\n   |             -- ----    ^^ immutable borrow occurs here\n\
    \   |             |  |\n   |             |  mutable borrow later used by call\n\
    \   |             mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    l2.iter().enumerate().filter(|(_,\
    \ i)| i % 3 == 0).map(|(_, i)| l2.swap(i)).collect()\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp7d9of05t.rs:11:45\n\
    \   |\n11 |     l2.iter().enumerate().filter(|(_, i)| i % 3 == 0).map(|(_, i)|\
    \ l2.swap(i)).collect()\n   |                                           - ^ -\
    \ {integer}\n   |                                           |\n   |          \
    \                                 &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n11 |     l2.iter().enumerate().filter(|(_, i)|\
    \ *i % 3 == 0).map(|(_, i)| l2.swap(i)).collect()\n   |                      \
    \                     +\n\nerror[E0061]: this function takes 2 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmp7d9of05t.rs:11:71\n    |\n11  |     l2.iter().enumerate().filter(|(_,\
    \ i)| i % 3 == 0).map(|(_, i)| l2.swap(i)).collect()\n    |                  \
    \                                                     ^^^^ - supplied 1 argument\n\
    \    |                                                                       |\n\
    \    |                                                                       expected\
    \ 2 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `()`\n  --> /tmp/tmp7d9of05t.rs:11:80\n   |\n11 |     l2.iter().enumerate().filter(|(_,\
    \ i)| i % 3 == 0).map(|(_, i)| l2.swap(i)).collect()\n   |                   \
    \                                                             ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=()>`\n   |\n\
    \   = help: the trait `FromIterator<()>` is not implemented for `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            *i = *i / 3;\n        }\n    });\n \
    \   l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplfe1bhwm.rs:12:29\n   |\n\
    12 |     l2.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut l2 = l;\n    let mut l3 = l;\n    let mut l4 =\
    \ l;\n    let mut l5 = l;\n    let mut l6 = l;\n    let mut l7 = l;\n    let mut\
    \ l8 = l;\n    let mut l9 = l;\n    let mut l10 = l;\n    let mut l11 = l;\n \
    \   let mut l12 = l;\n    let mut l13 = l;\n    let mut l14 = l;\n    let mut\
    \ l15 = l;\n    let mut l16 = l;\n    let mut l17 = l;\n    let mut l18 = l;\n\
    \    let mut l19 = l;\n    let mut l20 = l;\n    let mut l21 = l;\n    let mut\
    \ l22 = l;\n    let mut l23 = l;\n    let mut l24 = l;\n    let mut l25 = l;\n\
    \    let mut l26 = l;\n    let mut l27 = l;\n    let mut l28 = l;\n    let mut\
    \ l29 = l;\n    let mut l30 = l;\n    let mut l31 = l;\n    let mut l32 = l;\n\
    \    let mut l33 = l;\n    let mut l34 = l;\n    let mut l35 = l;\n    let mut\
    \ l36 = l;\n    let mut l37 = l;\n    let mut l38 = l;\n    let mut l39 = l;\n\
    \    let mut l40 = l;\n    let mut l41 = l;\n    let mut l42 = l;\n    let mut\
    \ l43 = l;\n    let mut l44 = l;\n    let mut l45 = l;\n    let mut l46 = l;\n\
    \    let mut l47 = l;\n    let mut l48 = l;\n    let mut l49 = l;\n    let mut\
    \ l50 = l;\n    let mut l51 = l;\n    let mut l52 = l;\n    let mut l53 = l;\n\
    \    let mut l54 = l;\n    let mut l55 = l;\n    let mut l56 = l;\n    let mut\
    \ l57 = l;\n    let mut l58 = l;\n    let mut l59 = l;\n    let mut l60 = l;\n\
    \    let mut l61 = l;\n    let mut l62 = l;\n    let mut l63 = l;\n    let mut\
    \ l64 = l;\n    let mut l65 = l;\n    let mut l66 = \n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpfkhywyo8.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.iter_mut().for_each(|&mut\
    \ i| {\n        if i % 3 == 0 {\n            *i = *i / 3;\n        }\n    });\n\
    \    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpuyipn26c.rs:14:13\n\
    \   |\n14 |             *i = *i / 3;\n   |             ^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpuyipn26c.rs:14:18\n   |\n14 |\
    \             *i = *i / 3;\n   |                  ^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_by_key(|x| {\n\
    \        match x % 3 {\n            0 => x,\n            1 => x + 1,\n       \
    \     2 => x + 2,\n            _ => x,\n        }\n    });\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpvwt1dp3r.rs:13:18\n\
    \   |\n11 | /         match x % 3 {\n12 | |             0 => x,\n   | |      \
    \            - this is found to be of type `&isize`\n13 | |             1 => x\
    \ + 1,\n   | |                  ^^^^^ expected `&isize`, found `isize`\n14 | |\
    \             2 => x + 2,\n15 | |             _ => x,\n16 | |         }\n   |\
    \ |_________- `match` arms have incompatible types\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpe4126q1o.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpyq7ike75.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.sort_unstable();\n\
    \    let mut l3 = l;\n    l3.sort_unstable();\n    let mut l4 = l;\n    l4.sort_unstable();\n\
    \    let mut l5 = l;\n    l5.sort_unstable();\n    let mut l6 = l;\n    l6.sort_unstable();\n\
    \    let mut l7 = l;\n    l7.sort_unstable();\n    let mut l8 = l;\n    l8.sort_unstable();\n\
    \    let mut l9 = l;\n    l9.sort_unstable();\n    let mut l10 = l;\n    l10.sort_unstable();\n\
    \    let mut l11 = l;\n    l11.sort_unstable();\n    let mut l12 = l;\n    l12.sort_unstable();\n\
    \    let mut l13 = l;\n    l13.sort_unstable();\n    let mut l14 = l;\n    l14.sort_unstable();\n\
    \    let mut l15 = l;\n    l15.sort_unstable();\n    let mut l16 = l;\n    l16.sort_unstable();\n\
    \    let mut l17 = l;\n    l17.sort_unstable();\n    let mut l18 = l;\n    l18.sort_unstable();\n\
    \    let mut l19 = l;\n    l19.sort_unstable();\n    let mut l20 = l;\n    l20.sort_unstable();\n\
    \    let mut l21 = l;\n    l21.sort_unstable();\n    let mut l22 = l;\n    l22.sort_unstable();\n\
    \    let mut l23 = l;\n    l23.sort_unstable();\n    let mut l24 = l;\n    l24.sort_unstable();\n\
    \    let mut l25 = l;\n    l25.sort_unstable();\n    let mut l26 = l;\n    l26.sort_unstable();\n\
    \    let mut l27 = l;\n    l27.sort_unstable();\n    let mut l28 = l;\n    l28.sort_unstable();\n\
    \    let mut l29 = l;\n    l29.sort_unstable();\n    let mut l30 = l;\n    l30.sort_unstable();\n\
    \    let mut l31 = l;\n    l31.sort_unstable();\n    let mut l32 = l;\n    l32.sort_unstable();\n\
    \    let mut l33 = l;\n    l33.sort_unstable();\n    let mut l34 = l;\n    l34.sort_unstable();\n\
    \    let mut l35 = l;\n    l35.sort_unstable();\n    let \n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4dwlcoj4.rs:80:1\n  \
    \ |\n80 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp92x6oiai.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    let mut l2 = l.clone();\n\
    \    l2.iter_mut().for_each(|&i| {\n        if i % 3 == 0 {\n            *i =\
    \ *i / 3;\n        }\n    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjyool33d.rs:12:29\n   |\n\
    12 |     l2.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|&i| i / 3);\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 5, 3, 4, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpznpqca9s.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n   \
    \ l3.iter_mut().enumerate().for_each(|(i, &v)| {\n        if i % 3 == 0 {\n  \
    \          *v = (*v + 1) as isize;\n        }\n    });\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1wj5p5c7.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l.clone();\n    l3.sort_unstable();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqppo1ggv.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n        l2[i] = l2[i] / 3;\n    });\n    l2\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmprs6urfbv.rs:12:33\n\
    \   |\n12 |     l2.iter_mut().filter(|&i| i % 3 == 0).for_each(|&i| {\n   |  \
    \                             - ^ - {integer}\n   |                          \
    \     |\n   |                               &mut isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `i`\n   |\n12 |     l2.iter_mut().filter(|&i|\
    \ *i % 3 == 0).for_each(|&i| {\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprs6urfbv.rs:12:53\n   |\n12 |     l2.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n   |                                          \
    \           ^--\n   |                                                     ||\n\
    \   |                                                     |expected due to this\n\
    \   |                                                     types differ in mutability\n\
    \   |                                                     help: did you mean `i`:\
    \ `&&mut isize`\n   |\n   = note: expected mutable reference `&mut isize`\n  \
    \                    found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9kvx841n.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.sort_unstable();\n\
    \    let mut l3 = l;\n    l3.sort_unstable();\n    let mut l4 = l;\n    l4.sort_unstable();\n\
    \    let mut l5 = l;\n    l5.sort_unstable();\n    let mut l6 = l;\n    l6.sort_unstable();\n\
    \    let mut l7 = l;\n    l7.sort_unstable();\n    let mut l8 = l;\n    l8.sort_unstable();\n\
    \    let mut l9 = l;\n    l9.sort_unstable();\n    let mut l10 = l;\n    l10.sort_unstable();\n\
    \    let mut l11 = l;\n    l11.sort_unstable();\n    let mut l12 = l;\n    l12.sort_unstable();\n\
    \    let mut l13 = l;\n    l13.sort_unstable();\n    let mut l14 = l;\n    l14.sort_unstable();\n\
    \    let mut l15 = l;\n    l15.sort_unstable();\n    let mut l16 = l;\n    l16.sort_unstable();\n\
    \    let mut l17 = l;\n    l17.sort_unstable();\n    let mut l18 = l;\n    l18.sort_unstable();\n\
    \    let mut l19 = l;\n    l19.sort_unstable();\n    let mut l20 = l;\n    l20.sort_unstable();\n\
    \    let mut l21 = l;\n    l21.sort_unstable();\n    let mut l22 = l;\n    l22.sort_unstable();\n\
    \    let mut l23 = l;\n    l23.sort_unstable();\n    let mut l24 = l;\n    l24.sort_unstable();\n\
    \    let mut l25 = l;\n    l25.sort_unstable();\n    let mut l26 = l;\n    l26.sort_unstable();\n\
    \    let mut l27 = l;\n    l27.sort_unstable();\n    let mut l28 = l;\n    l28.sort_unstable();\n\
    \    let mut l29 = l;\n    l29.sort_unstable();\n    let mut l30 = l;\n    l30.sort_unstable();\n\
    \    let mut l31 = l;\n    l31.sort_unstable();\n    let mut l32 = l;\n    l32.sort_unstable();\n\
    \    let mut l33 = l;\n    l33.sort_unstable();\n    let mut l34 = l;\n    l34.sort_unstable();\n\
    \    let mut l35 = l;\n    l35.sort_unstable();\n    let \n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4dwlcoj4.rs:80:1\n  \
    \ |\n80 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    let mut l2 = l.clone();\n    let mut l3 = l.clone();\n\
    \    let mut l4 = l.clone();\n    let mut l5 = l.clone();\n    let mut l6 = l.clone();\n\
    \    let mut l7 = l.clone();\n    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n\
    \    let mut l10 = l.clone();\n    let mut l11 = l.clone();\n    let mut l12 =\
    \ l.clone();\n    let mut l13 = l.clone();\n    let mut l14 = l.clone();\n   \
    \ let mut l15 = l.clone();\n    let mut l16 = l.clone();\n    let mut l17 = l.clone();\n\
    \    let mut l18 = l.clone();\n    let mut l19 = l.clone();\n    let mut l20 =\
    \ l.clone();\n    let mut l21 = l.clone();\n    let mut l22 = l.clone();\n   \
    \ let mut l23 = l.clone();\n    let mut l24 = l.clone();\n    let mut l25 = l.clone();\n\
    \    let mut l26 = l.clone();\n    let mut l27 = l.clone();\n    let mut l28 =\
    \ l.clone();\n    let mut l29 = l.clone();\n    let mut l30 = l.clone();\n   \
    \ let mut l31 = l.clone();\n    let mut l32 = l.clone();\n    let mut l33 = l.clone();\n\
    \    let mut l34 = l.clone();\n    let mut l35 = l.clone();\n    let mut l36 =\
    \ l.clone();\n    let mut l37 = l.clone();\n    let mut l38 = l.clone();\n   \
    \ let mut l39 = l.clone();\n    let mut l40 = l.clone();\n    let mut l41 = l.clone();\n\
    \    let mut l42 = l.clone();\n    let mut l43 = l.clone();\n    let mut l44 =\
    \ l.clone();\n    let mut l45 = l.clone();\n    let mut l46 = l.clone();\n   \
    \ let mut l47 = l.clone();\n    let mut l48 = l.clone();\n    let mut l49 = l.clone();\n\
    \    let mut l50 = l.clone();\n    let mut l51 = l.clone();\n    let mut l52 =\
    \ l.clone();\n    let mut l53 = l.clone();\n    let mut l54 = l.clone();\n   \
    \ let mut l55 = l.clone();\n    let mut l56 = l.clone();\n    let mut l57 = l.clone();\n\
    \    let mut l58 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1i3y2f4c.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1i3y2f4c.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|&x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7_dedwpt.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort();\n    l2.dedup();\n    l2\n}\n\nfn\
    \ main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpi0vkxgm1.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l.clone();\n    l3.sort_unstable();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqppo1ggv.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    let mut l2 = l.to_vec();\n\
    \    l2.iter_mut().enumerate().for_each(|(i, &v)| {\n        if i % 3 == 0 {\n\
    \            *i = *i / 3;\n        }\n    });\n    l2.sort_unstable();\n    l2\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdqvt3r17.rs:12:45\n   |\n\
    12 |     l2.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpdqvt3r17.rs:14:13\n\
    \   |\n14 |             *i = *i / 3;\n   |             ^^\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmpdqvt3r17.rs:14:18\n   |\n14 |\
    \             *i = *i / 3;\n   |                  ^^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    l.iter().filter(|&x| x\
    \ % 3 == 0).cloned().collect()\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqcv733u9.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|&x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7_dedwpt.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n   \
    \ l3.iter_mut().enumerate().for_each(|(i, v)| {\n        if i % 3 == 0 {\n   \
    \         l3[i] = v;\n        }\n    });\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf8j31zcx.rs:14:21\n   |\n\
    14 |             l3[i] = v;\n   |                     ^ expected `isize`, found\
    \ `&mut isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |    \
    \         l3[i] = *v;\n   |                     +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    let mut l2 = l.clone();\n\
    \    l2.sort_unstable();\n    let mut l3 = l.clone();\n    l3.sort_unstable();\n\
    \    let mut l4 = l.clone();\n    l4.sort_unstable();\n    let mut l5 = l.clone();\n\
    \    l5.sort_unstable();\n    let mut l6 = l.clone();\n    l6.sort_unstable();\n\
    \    let mut l7 = l.clone();\n    l7.sort_unstable();\n    let mut l8 = l.clone();\n\
    \    l8.sort_unstable();\n    let mut l9 = l.clone();\n    l9.sort_unstable();\n\
    \    let mut l10 = l.clone();\n    l10.sort_unstable();\n    let mut l11 = l.clone();\n\
    \    l11.sort_unstable();\n    let mut l12 = l.clone();\n    l12.sort_unstable();\n\
    \    let mut l13 = l.clone();\n    l13.sort_unstable();\n    let mut l14 = l.clone();\n\
    \    l14.sort_unstable();\n    let mut l15 = l.clone();\n    l15.sort_unstable();\n\
    \    let mut l16 = l.clone();\n    l16.sort_unstable();\n    let mut l17 = l.clone();\n\
    \    l17.sort_unstable();\n    let mut l18 = l.clone();\n    l18.sort_unstable();\n\
    \    let mut l19 = l.clone();\n    l19.sort_unstable();\n    let mut l20 = l.clone();\n\
    \    l20.sort_unstable();\n    let mut l21 = l.clone();\n    l21.sort_unstable();\n\
    \    let mut l22 = l.clone();\n    l22.sort_unstable();\n    let mut l23 = l.clone();\n\
    \    l23.sort_unstable();\n    let mut l24 = l.clone();\n    l24.sort_unstable();\n\
    \    let mut l25 = l.clone();\n    l25.sort_unstable();\n    let mut l26 = l.clone();\n\
    \    l26.sort_unstable();\n    let mut l27 = l.clone();\n    l27.sort_unstable();\n\
    \    let mut l28 = l.clone();\n    l28.sort_unstable();\n    let mut l29 = l.clone();\n\
    \    l29.sort_unstable();\n    let mut l30 = l.clone();\n    l30.sort_unstable();\n\
    \    let mut l31 = l.clone();\n    l31.sort_unstable();\n    let mut l32 = l.clone();\n\
    \    l32.sort_unstable();\n    let mut l33 = l.clone();\n    l33.sort_\n}\n\n\
    fn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `sort_` on type `Vec<isize>`\n  --> /tmp/tmp_v4osgda.rs:74:9\n\
    \   |\n74 |     l33.sort_\n   |         ^^^^^ unknown field\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0609`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut l2 = l;\n    let mut l3 = l;\n    let mut l4 =\
    \ l;\n    let mut l5 = l;\n    let mut l6 = l;\n    let mut l7 = l;\n    let mut\
    \ l8 = l;\n    let mut l9 = l;\n    let mut l10 = l;\n    let mut l11 = l;\n \
    \   let mut l12 = l;\n    let mut l13 = l;\n    let mut l14 = l;\n    let mut\
    \ l15 = l;\n    let mut l16 = l;\n    let mut l17 = l;\n    let mut l18 = l;\n\
    \    let mut l19 = l;\n    let mut l20 = l;\n    let mut l21 = l;\n    let mut\
    \ l22 = l;\n    let mut l23 = l;\n    let mut l24 = l;\n    let mut l25 = l;\n\
    \    let mut l26 = l;\n    let mut l27 = l;\n    let mut l28 = l;\n    let mut\
    \ l29 = l;\n    let mut l30 = l;\n    let mut l31 = l;\n    let mut l32 = l;\n\
    \    let mut l33 = l;\n    let mut l34 = l;\n    let mut l35 = l;\n    let mut\
    \ l36 = l;\n    let mut l37 = l;\n    let mut l38 = l;\n    let mut l39 = l;\n\
    \    let mut l40 = l;\n    let mut l41 = l;\n    let mut l42 = l;\n    let mut\
    \ l43 = l;\n    let mut l44 = l;\n    let mut l45 = l;\n    let mut l46 = l;\n\
    \    let mut l47 = l;\n    let mut l48 = l;\n    let mut l49 = l;\n    let mut\
    \ l50 = l;\n    let mut l51 = l;\n    let mut l52 = l;\n    let mut l53 = l;\n\
    \    let mut l54 = l;\n    let mut l55 = l;\n    let mut l56 = l;\n    let mut\
    \ l57 = l;\n    let mut l58 = l;\n    let mut l59 = l;\n    let mut l60 = l;\n\
    \    let mut l61 = l;\n    let mut l62 = l;\n    let mut l63 = l;\n    let mut\
    \ l64 = l;\n    let mut l65 = l;\n    let mut l66 = \n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpfkhywyo8.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpetu0de9s.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort_by_key(|&x| {\n        if x % 3 == 0 {\n     \
    \       0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\n\
    fn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpohftyxl9.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    l.iter().cloned().skip(l.len()\
    \ / 3).collect()\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpe9m7wdzc.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpyq7ike75.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.sort_unstable();\n\
    \    let mut l3 = l;\n    l3.sort_unstable();\n    let mut l4 = l;\n    l4.sort_unstable();\n\
    \    let mut l5 = l;\n    l5.sort_unstable();\n    let mut l6 = l;\n    l6.sort_unstable();\n\
    \    let mut l7 = l;\n    l7.sort_unstable();\n    let mut l8 = l;\n    l8.sort_unstable();\n\
    \    let mut l9 = l;\n    l9.sort_unstable();\n    let mut l10 = l;\n    l10.sort_unstable();\n\
    \    let mut l11 = l;\n    l11.sort_unstable();\n    let mut l12 = l;\n    l12.sort_unstable();\n\
    \    let mut l13 = l;\n    l13.sort_unstable();\n    let mut l14 = l;\n    l14.sort_unstable();\n\
    \    let mut l15 = l;\n    l15.sort_unstable();\n    let mut l16 = l;\n    l16.sort_unstable();\n\
    \    let mut l17 = l;\n    l17.sort_unstable();\n    let mut l18 = l;\n    l18.sort_unstable();\n\
    \    let mut l19 = l;\n    l19.sort_unstable();\n    let mut l20 = l;\n    l20.sort_unstable();\n\
    \    let mut l21 = l;\n    l21.sort_unstable();\n    let mut l22 = l;\n    l22.sort_unstable();\n\
    \    let mut l23 = l;\n    l23.sort_unstable();\n    let mut l24 = l;\n    l24.sort_unstable();\n\
    \    let mut l25 = l;\n    l25.sort_unstable();\n    let mut l26 = l;\n    l26.sort_unstable();\n\
    \    let mut l27 = l;\n    l27.sort_unstable();\n    let mut l28 = l;\n    l28.sort_unstable();\n\
    \    let mut l29 = l;\n    l29.sort_unstable();\n    let mut l30 = l;\n    l30.sort_unstable();\n\
    \    let mut l31 = l;\n    l31.sort_unstable();\n    let mut l32 = l;\n    l32.sort_unstable();\n\
    \    let mut l33 = l;\n    l33.sort_unstable();\n    let mut l34 = l;\n    l34.sort_unstable();\n\
    \    let mut l35 = l;\n    l35.sort_unstable();\n    let \n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4dwlcoj4.rs:80:1\n  \
    \ |\n80 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = l;\n    l3.sort();\n    let\
    \ mut l4 = l;\n    l4.sort();\n    let mut l5 = l;\n    l5.sort();\n    let mut\
    \ l6 = l;\n    l6.sort();\n    let mut l7 = l;\n    l7.sort();\n    let mut l8\
    \ = l;\n    l8.sort();\n    let mut l9 = l;\n    l9.sort();\n    let mut l10 =\
    \ l;\n    l10.sort();\n    let mut l11 = l;\n    l11.sort();\n    let mut l12\
    \ = l;\n    l12.sort();\n    let mut l13 = l;\n    l13.sort();\n    let mut l14\
    \ = l;\n    l14.sort();\n    let mut l15 = l;\n    l15.sort();\n    let mut l16\
    \ = l;\n    l16.sort();\n    let mut l17 = l;\n    l17.sort();\n    let mut l18\
    \ = l;\n    l18.sort();\n    let mut l19 = l;\n    l19.sort();\n    let mut l20\
    \ = l;\n    l20.sort();\n    let mut l21 = l;\n    l21.sort();\n    let mut l22\
    \ = l;\n    l22.sort();\n    let mut l23 = l;\n    l23.sort();\n    let mut l24\
    \ = l;\n    l24.sort();\n    let mut l25 = l;\n    l25.sort();\n    let mut l26\
    \ = l;\n    l26.sort();\n    let mut l27 = l;\n    l27.sort();\n    let mut l28\
    \ = l;\n    l28.sort();\n    let mut l29 = l;\n    l29.sort();\n    let mut l30\
    \ = l;\n    l30.sort();\n    let mut l31 = l;\n    l31.sort();\n    let mut l32\
    \ = l;\n    l32.sort();\n    let mut l33 = l;\n    l33.sort();\n    let mut l34\
    \ = l;\n    l34.sort();\n    let mut l35 = l;\n    l35.sort();\n    let mut l36\
    \ = l;\n    l36.sort();\n    let mut l37 = l;\n    l37.sort();\n    let mut l38\
    \ = l;\n    l38.sort();\n    let mut l39 = l;\n    l39.sort();\n    let mut l40\
    \ = l;\n    l40.sort();\n    let mut l41 = l;\n    l41.sort();\n    let mu\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpad_0ttpb.rs:89:11\n   |\n\
    89 |     let mu\n   |           ^ help: add `;` here\n90 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpad_0ttpb.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = vec![];\n    for i in 0..l2.len()\
    \ {\n        if i % 3 == 0 {\n            l3.push(l2[i]);\n        } else {\n\
    \            l3.push(l2[i]);\n            l3.push(l2[i]);\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 3, 4, 4, 5, 6, 6, 8, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpml750rw1.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l.clone();\n    l3.sort();\n    let mut l3prime = l3.clone();\n\
    \    l3prime.sort();\n    let mut l3primeprime = l3prime.clone();\n    l3primeprime.sort();\n\
    \    let mut l3primeprimeprime = l3primeprime.clone();\n    l3primeprimeprime.sort();\n\
    \    let mut l3primeprimeprimeprime = l3primeprimeprime.clone();\n    l3primeprimeprimeprime.sort();\n\
    \    let mut l3primeprimeprimeprimeprime = l3primeprimeprimeprime.clone();\n \
    \   l3primeprimeprimeprimeprime.sort();\n    let mut l3primeprimeprimeprimeprimeprime\
    \ = l3primeprimeprimeprimeprime.clone();\n    l3primeprimeprimeprimeprimeprime.sort();\n\
    \    let mut l3primeprimeprimeprimeprimeprime = l3primeprimeprimeprimeprimeprime.clone();\n\
    \    l3primeprimeprimeprimeprimeprimeprime.sort();\n    let mut l3primeprimeprimeprimeprimeprime\
    \ = l3primeprimeprimeprimeprimeprimeprime.clone();\n    l3primeprimeprimeprimeprimeprimeprime.sort();\n\
    \    let mut l3primeprimeprimeprimeprimeprimeprime = l3primeprimeprimeprimeprimeprimeprimeprime.clone();\n\
    \    l3primeprimeprimeprimeprimeprimeprimeprime.sort();\n    let mut l3primeprimeprimeprimeprimeprimeprime\
    \ = l3primeprimeprimeprimeprimeprimeprimeprimeprime.clone();\n    l3primeprimeprimeprimeprimeprimeprimeprimeprime.sort();\n\
    \    let mut l3primeprimeprimeprimeprimeprimeprimeprime = l3primeprimeprimeprimeprimeprimeprimeprimeprime.clone();\n\
    \    l3primeprimeprimeprimeprimeprimeprimeprimeprime.sort();\n    let mut l3primeprimeprimeprimeprimeprimeprimeprime\
    \ = l3primeprimeprimeprimeprimeprimeprimeprimeprime.clone();\n    l3primeprimeprimeprimeprimeprimeprimeprimeprime.sort();\n\
    \    let mut l3primeprimeprimeprimeprimeprimeprimeprime = l3primeprimeprimeprimeprimeprimeprimeprimeprime.clone();\n\
    \    l3primeprimeprimeprimeprimeprimeprimeprimeprime.sort();\n    let mut l3primeprimeprimeprimeprimeprimeprimeprime\
    \ = l3primeprimeprimeprimeprimeprimeprimeprimeprimeprime.clone();\n    l3primeprimeprimeprimeprimeprimeprimeprimeprimeprime.sort();\n\
    \    let mut l3primeprimeprimeprimeprimeprimeprime\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8xw1cxr2.rs:39:50\n   |\n\
    39 |     let mut l3primeprimeprimeprimeprimeprimeprime\n   |                 \
    \                                 ^ help: add `;` here\n40 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `l3primeprimeprimeprimeprimeprimeprime`\
    \ in this scope\n  --> /tmp/tmp8xw1cxr2.rs:24:5\n   |\n24 |     l3primeprimeprimeprimeprimeprimeprime.sort();\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `l3primeprimeprimeprimeprimeprime`\n\nerror[E0425]: cannot\
    \ find value `l3primeprimeprimeprimeprimeprimeprime` in this scope\n  --> /tmp/tmp8xw1cxr2.rs:25:48\n\
    \   |\n25 |     let mut l3primeprimeprimeprimeprimeprime = l3primeprimeprimeprimeprimeprimeprime.clone();\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `l3primeprimeprimeprimeprimeprime`\n\
    \nerror[E0425]: cannot find value `l3primeprimeprimeprimeprimeprimeprime` in this\
    \ scope\n  --> /tmp/tmp8xw1cxr2.rs:26:5\n   |\n26 |     l3primeprimeprimeprimeprimeprimeprime.sort();\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `l3primeprimeprimeprimeprimeprime`\n\nerror[E0425]: cannot\
    \ find value `l3primeprimeprimeprimeprimeprimeprimeprime` in this scope\n  -->\
    \ /tmp/tmp8xw1cxr2.rs:27:53\n   |\n27 |     let mut l3primeprimeprimeprimeprimeprimeprime\
    \ = l3primeprimeprimeprimeprimeprimeprimeprime.clone();\n   |                \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `l3primeprimeprimeprimeprimeprime`\n\
    \nerror[E0425]: cannot find value `l3primeprimeprimeprimeprimeprimeprimeprime`\
    \ in this scope\n  --> /tmp/tmp8xw1cxr2.rs:28:5\n   |\n28 |     l3primeprimeprimeprimeprimeprimeprimeprime.sort();\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `l3primeprimeprimeprimeprimeprimeprime`\n\nerror[E0425]:\
    \ cannot find value `l3primepr"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    l.iter().cloned().skip(l.len()\
    \ / 3).collect()\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpe9m7wdzc.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    l.iter().filter_map(|&i|\
    \ {\n        if i % 3 == 0 {\n            Some(i)\n        } else {\n        \
    \    None\n        }\n    }).cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmplznn3lor.rs:11:25:\
    \ 17:6] as FnOnce<(&isize,)>>::Output == Option<&_>`\n  --> /tmp/tmplznn3lor.rs:17:8\n\
    \   |\n17 |     }).cloned().collect()\n   |        ^^^^^^ expected `isize`, found\
    \ reference\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ enum `Option<&_>`\n   = note: required because of the requirements on the impl\
    \ of `Iterator` for `FilterMap<std::slice::Iter<'_, isize>, [closure@/tmp/tmplznn3lor.rs:11:25:\
    \ 17:6]>`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<FilterMap<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmplznn3lor.rs:11:25: 17:6]>>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmplznn3lor.rs:17:17\n   |\n17 |        }).cloned().collect()\n\
    \   |                    ^^^^^^^ method cannot be called on `Cloned<FilterMap<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmplznn3lor.rs:11:25: 17:6]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<FilterMap<std::slice::Iter<'_, isize>, [closure@/tmp/tmplznn3lor.rs:11:25:\
    \ 17:6]> as Iterator>::Item = &_`\n           which is required by `Cloned<FilterMap<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmplznn3lor.rs:11:25: 17:6]>>: Iterator`\n           `Cloned<FilterMap<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmplznn3lor.rs:11:25: 17:6]>>: Iterator`\n           which\
    \ is required by `&mut Cloned<FilterMap<std::slice::Iter<'_, isize>, [closure@/tmp/tmplznn3lor.rs:11:25:\
    \ 17:6]>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n   \
    \ l3.sort();\n    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjb7hxewx.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    l.iter().cloned().skip(l.len()\
    \ / 3).collect()\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmps7igv4c3.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpcw_58c7y.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n   \
    \ l3.iter_mut().filter(|&i| i % 3 == 0).cloned().for_each(|&i| {\n        l3[i]\
    \ = l3[i / 3];\n    });\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmp1soix2_i.rs:12:33\n\
    \   |\n12 |     l3.iter_mut().filter(|&i| i % 3 == 0).cloned().for_each(|&i| {\n\
    \   |                               - ^ - {integer}\n   |                    \
    \           |\n   |                               &mut isize\n   |\nhelp: `%`\
    \ can be used on `isize`, you can dereference `i`\n   |\n12 |     l3.iter_mut().filter(|&i|\
    \ *i % 3 == 0).cloned().for_each(|&i| {\n   |                               +\n\
    \nerror[E0271]: type mismatch resolving `<Filter<std::slice::IterMut<'_, isize>,\
    \ [closure@/tmp/tmp1soix2_i.rs:12:26: 12:41]> as Iterator>::Item == &_`\n  -->\
    \ /tmp/tmp1soix2_i.rs:12:43\n   |\n12 |     l3.iter_mut().filter(|&i| i % 3 ==\
    \ 0).cloned().for_each(|&i| {\n   |                                          \
    \ ^^^^^^ types differ in mutability\n   |\n   = note: expected mutable reference\
    \ `&mut isize`\n                      found reference `&_`\n\nerror[E0599]: the\
    \ method `for_each` exists for struct `Cloned<Filter<std::slice::IterMut<'_, isize>,\
    \ [closure@/tmp/tmp1soix2_i.rs:12:26: 12:41]>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp1soix2_i.rs:12:52\n   |\n12 |        l3.iter_mut().filter(|&i|\
    \ i % 3 == 0).cloned().for_each(|&i| {\n   |                                 \
    \                      ^^^^^^^^ method cannot be called on `Cloned<Filter<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmp1soix2_i.rs:12:26: 12:41]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<std::slice::IterMut<'_, isize>, [closure@/tmp/tmp1soix2_i.rs:12:26:\
    \ 12:41]> as Iterator>::Item = &_`\n           which is required by `Cloned<Filter<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmp1soix2_i.rs:12:26: 12:41]>>: Iterator`\n          \
    \ `Cloned<Filter<std::slice::IterMut<'_, isize>, [closure@/tmp/tmp1soix2_i.rs:12:26:\
    \ 12:41]>>: Iterator`\n           which is required by `&mut Cloned<Filter<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmp1soix2_i.rs:12:26: 12:41]>>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    let mut l2 = l.clone();\n\
    \    l2.iter_mut().filter(|&i| i % 3 == 0).for_each(|&i| {\n        l2[i] = l2[i]\
    \ / 3;\n    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n \
    \   assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmp7k11fo1l.rs:12:33\n\
    \   |\n12 |     l2.iter_mut().filter(|&i| i % 3 == 0).for_each(|&i| {\n   |  \
    \                             - ^ - {integer}\n   |                          \
    \     |\n   |                               &mut isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `i`\n   |\n12 |     l2.iter_mut().filter(|&i|\
    \ *i % 3 == 0).for_each(|&i| {\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7k11fo1l.rs:12:53\n   |\n12 |     l2.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n   |                                          \
    \           ^--\n   |                                                     ||\n\
    \   |                                                     |expected due to this\n\
    \   |                                                     types differ in mutability\n\
    \   |                                                     help: did you mean `i`:\
    \ `&&mut isize`\n   |\n   = note: expected mutable reference `&mut isize`\n  \
    \                    found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut l3 = l;\n    let mut l4 = l;\n    let mut l5 =\
    \ l;\n    let mut l6 = l;\n    let mut l7 = l;\n    let mut l8 = l;\n    let mut\
    \ l9 = l;\n    let mut l10 = l;\n    let mut l11 = l;\n    let mut l12 = l;\n\
    \    let mut l13 = l;\n    let mut l14 = l;\n    let mut l15 = l;\n    let mut\
    \ l16 = l;\n    let mut l17 = l;\n    let mut l18 = l;\n    let mut l19 = l;\n\
    \    let mut l20 = l;\n    let mut l21 = l;\n    let mut l22 = l;\n    let mut\
    \ l23 = l;\n    let mut l24 = l;\n    let mut l25 = l;\n    let mut l26 = l;\n\
    \    let mut l27 = l;\n    let mut l28 = l;\n    let mut l29 = l;\n    let mut\
    \ l30 = l;\n    let mut l31 = l;\n    let mut l32 = l;\n    let mut l33 = l;\n\
    \    let mut l34 = l;\n    let mut l35 = l;\n    let mut l36 = l;\n    let mut\
    \ l37 = l;\n    let mut l38 = l;\n    let mut l39 = l;\n    let mut l40 = l;\n\
    \    let mut l41 = l;\n    let mut l42 = l;\n    let mut l43 = l;\n    let mut\
    \ l44 = l;\n    let mut l45 = l;\n    let mut l46 = l;\n    let mut l47 = l;\n\
    \    let mut l48 = l;\n    let mut l49 = l;\n    let mut l50 = l;\n    let mut\
    \ l51 = l;\n    let mut l52 = l;\n    let mut l53 = l;\n    let mut l54 = l;\n\
    \    let mut l55 = l;\n    let mut l56 = l;\n    let mut l57 = l;\n    let mut\
    \ l58 = l;\n    let mut l59 = l;\n    let mut l60 = l;\n    let mut l61 = l;\n\
    \    let mut l62 = l;\n    let mut l63 = l;\n    let mut l64 = l;\n    let mut\
    \ l65 = l;\n    let mut l66 = l;\n    let mut l\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsmkhveep.rs:74:14\n   |\n\
    74 |     let mut l\n   |              ^ help: add `;` here\n75 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsmkhveep.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            *i = *i / 3;\n        }\n    });\n\
    \    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi17eso1m.rs:12:45\n   |\n\
    12 |     l2.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpi17eso1m.rs:14:13\n\
    \   |\n14 |             *i = *i / 3;\n   |             ^^\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmpi17eso1m.rs:14:18\n   |\n14 |\
    \             *i = *i / 3;\n   |                  ^^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n   \
    \ l3.iter_mut().for_each(|&i| {\n        if i % 3 == 0 {\n            l3[i] =\
    \ i;\n        }\n    });\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7vzy1gpc.rs:12:29\n   |\n\
    12 |     l3.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9kvx841n.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n   \
    \ l3.iter_mut().enumerate().for_each(|(i, &v)| {\n        if i % 3 == 0 {\n  \
    \          *v = (*v + 1) as isize;\n        }\n    });\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1wj5p5c7.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n   \
    \ l3.sort();\n    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjb7hxewx.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = l;\n    l3.sort();\n    let\
    \ mut l4 = l;\n    l4.sort();\n    let mut l5 = l;\n    l5.sort();\n    let mut\
    \ l6 = l;\n    l6.sort();\n    let mut l7 = l;\n    l7.sort();\n    let mut l8\
    \ = l;\n    l8.sort();\n    let mut l9 = l;\n    l9.sort();\n    let mut l10 =\
    \ l;\n    l10.sort();\n    let mut l11 = l;\n    l11.sort();\n    let mut l12\
    \ = l;\n    l12.sort();\n    let mut l13 = l;\n    l13.sort();\n    let mut l14\
    \ = l;\n    l14.sort();\n    let mut l15 = l;\n    l15.sort();\n    let mut l16\
    \ = l;\n    l16.sort();\n    let mut l17 = l;\n    l17.sort();\n    let mut l18\
    \ = l;\n    l18.sort();\n    let mut l19 = l;\n    l19.sort();\n    let mut l20\
    \ = l;\n    l20.sort();\n    let mut l21 = l;\n    l21.sort();\n    let mut l22\
    \ = l;\n    l22.sort();\n    let mut l23 = l;\n    l23.sort();\n    let mut l24\
    \ = l;\n    l24.sort();\n    let mut l25 = l;\n    l25.sort();\n    let mut l26\
    \ = l;\n    l26.sort();\n    let mut l27 = l;\n    l27.sort();\n    let mut l28\
    \ = l;\n    l28.sort();\n    let mut l29 = l;\n    l29.sort();\n    let mut l30\
    \ = l;\n    l30.sort();\n    let mut l31 = l;\n    l31.sort();\n    let mut l32\
    \ = l;\n    l32.sort();\n    let mut l33 = l;\n    l33.sort();\n    let mut l34\
    \ = l;\n    l34.sort();\n    let mut l35 = l;\n    l35.sort();\n    let mut l36\
    \ = l;\n    l36.sort();\n    let mut l37 = l;\n    l37.sort();\n    let mut l38\
    \ = l;\n    l38.sort();\n    let mut l39 = l;\n    l39.sort();\n    let mut l40\
    \ = l;\n    l40.sort();\n    let mut l41 = l;\n    l41.sort();\n    let mu\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpad_0ttpb.rs:89:11\n   |\n\
    89 |     let mu\n   |           ^ help: add `;` here\n90 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpad_0ttpb.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_by_key(|&i| i / 3);\n    l\n}\n\nfn main() {\n \
    \   let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 5, 3, 4, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpdlsoyms9.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747463
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut l3 = l;\n    let mut l4 = l;\n    let mut l5 =\
    \ l;\n    let mut l6 = l;\n    let mut l7 = l;\n    let mut l8 = l;\n    let mut\
    \ l9 = l;\n    let mut l10 = l;\n    let mut l11 = l;\n    let mut l12 = l;\n\
    \    let mut l13 = l;\n    let mut l14 = l;\n    let mut l15 = l;\n    let mut\
    \ l16 = l;\n    let mut l17 = l;\n    let mut l18 = l;\n    let mut l19 = l;\n\
    \    let mut l20 = l;\n    let mut l21 = l;\n    let mut l22 = l;\n    let mut\
    \ l23 = l;\n    let mut l24 = l;\n    let mut l25 = l;\n    let mut l26 = l;\n\
    \    let mut l27 = l;\n    let mut l28 = l;\n    let mut l29 = l;\n    let mut\
    \ l30 = l;\n    let mut l31 = l;\n    let mut l32 = l;\n    let mut l33 = l;\n\
    \    let mut l34 = l;\n    let mut l35 = l;\n    let mut l36 = l;\n    let mut\
    \ l37 = l;\n    let mut l38 = l;\n    let mut l39 = l;\n    let mut l40 = l;\n\
    \    let mut l41 = l;\n    let mut l42 = l;\n    let mut l43 = l;\n    let mut\
    \ l44 = l;\n    let mut l45 = l;\n    let mut l46 = l;\n    let mut l47 = l;\n\
    \    let mut l48 = l;\n    let mut l49 = l;\n    let mut l50 = l;\n    let mut\
    \ l51 = l;\n    let mut l52 = l;\n    let mut l53 = l;\n    let mut l54 = l;\n\
    \    let mut l55 = l;\n    let mut l56 = l;\n    let mut l57 = l;\n    let mut\
    \ l58 = l;\n    let mut l59 = l;\n    let mut l60 = l;\n    let mut l61 = l;\n\
    \    let mut l62 = l;\n    let mut l63 = l;\n    let mut l64 = l;\n    let mut\
    \ l65 = l;\n    let mut l66 = l;\n    let mut l\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsmkhveep.rs:74:14\n   |\n\
    74 |     let mut l\n   |              ^ help: add `;` here\n75 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsmkhveep.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_unstable();\n    l.iter().filter(|&x| x\
    \ % 3 == 0).cloned().collect()\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqcv733u9.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut i = 0;\n    while i < l2.len() {\n        if i\
    \ % 3 == 0 {\n            l2.swap(i, l2.len() - 1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `l2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpohs2vd9y.rs:13:24\n   |\n13 |             l2.swap(i,\
    \ l2.len() - 1);\n   |             -- ----    ^^ immutable borrow occurs here\n\
    \   |             |  |\n   |             |  mutable borrow later used by call\n\
    \   |             mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l.clone();\n    l3.sort_unstable();\n    let mut l2 = l.clone();\n\
    \    l2.sort_unstable();\n    let mut l1 = l.clone();\n    l1.sort_unstable();\n\
    \    let mut l0 = l.clone();\n    l0.sort_unstable();\n    let mut l1 = l.clone();\n\
    \    l1.sort_unstable();\n    let mut l2 = l.clone();\n    l2.sort_unstable();\n\
    \    let mut l3 = l.clone();\n    l3.sort_unstable();\n    let mut l4 = l.clone();\n\
    \    l4.sort_unstable();\n    let mut l5 = l.clone();\n    l5.sort_unstable();\n\
    \    let mut l6 = l.clone();\n    l6.sort_unstable();\n    let mut l7 = l.clone();\n\
    \    l7.sort_unstable();\n    let mut l8 = l.clone();\n    l8.sort_unstable();\n\
    \    let mut l9 = l.clone();\n    l9.sort_unstable();\n    let mut l10 = l.clone();\n\
    \    l10.sort_unstable();\n    let mut l11 = l.clone();\n    l11.sort_unstable();\n\
    \    let mut l12 = l.clone();\n    l12.sort_unstable();\n    let mut l13 = l.clone();\n\
    \    l13.sort_unstable();\n    let mut l14 = l.clone();\n    l14.sort_unstable();\n\
    \    let mut l15 = l.clone();\n    l15.sort_unstable();\n    let mut l16 = l.clone();\n\
    \    l16.sort_unstable();\n    let mut l17 = l.clone();\n    l17.sort_unstable();\n\
    \    let mut l18 = l.clone();\n    l18.sort_unstable();\n    let mut l19 = l.clone();\n\
    \    l19.sort_unstable();\n    let mut l20 = l.clone();\n    l20.sort_unstable();\n\
    \    let mut l21 = l.clone();\n    l21.sort_unstable();\n    let mut l22 = l.clone();\n\
    \    l22.sort_unstable();\n    let mut l23 = l.clone();\n    l23.sort_unstable();\n\
    \    let mut l24 = l.clone();\n    l24.sort_unstable();\n    let mut l25 = l.clone();\n\
    \    l25.sort_unstable();\n    let mut l26 = l.clone();\n    l26.sort_unstable();\n\
    \    let mut l27 = l.clone();\n    l27.sort_unstable();\n    let mut l28 = l.clone();\n\
    \    l28.sort_unstable();\n    let mut l29 = l.clone();\n    l29.sort_unstable();\n\
    \    let \n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmppafn_oed.rs:76:1\n  \
    \ |\n76 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.iter_mut().filter(|&x|\
    \ x % 3 == 0).cloned().for_each(|&x| {\n        l2.swap_remove(x);\n    });\n\
    \    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmpvdm5xgnc.rs:12:33\n\
    \   |\n12 |     l2.iter_mut().filter(|&x| x % 3 == 0).cloned().for_each(|&x| {\n\
    \   |                               - ^ - {integer}\n   |                    \
    \           |\n   |                               &mut isize\n   |\nhelp: `%`\
    \ can be used on `isize`, you can dereference `x`\n   |\n12 |     l2.iter_mut().filter(|&x|\
    \ *x % 3 == 0).cloned().for_each(|&x| {\n   |                               +\n\
    \nerror[E0271]: type mismatch resolving `<Filter<std::slice::IterMut<'_, isize>,\
    \ [closure@/tmp/tmpvdm5xgnc.rs:12:26: 12:41]> as Iterator>::Item == &_`\n  -->\
    \ /tmp/tmpvdm5xgnc.rs:12:43\n   |\n12 |     l2.iter_mut().filter(|&x| x % 3 ==\
    \ 0).cloned().for_each(|&x| {\n   |                                          \
    \ ^^^^^^ types differ in mutability\n   |\n   = note: expected mutable reference\
    \ `&mut isize`\n                      found reference `&_`\n\nerror[E0599]: the\
    \ method `for_each` exists for struct `Cloned<Filter<std::slice::IterMut<'_, isize>,\
    \ [closure@/tmp/tmpvdm5xgnc.rs:12:26: 12:41]>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpvdm5xgnc.rs:12:52\n   |\n12 |        l2.iter_mut().filter(|&x|\
    \ x % 3 == 0).cloned().for_each(|&x| {\n   |                                 \
    \                      ^^^^^^^^ method cannot be called on `Cloned<Filter<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmpvdm5xgnc.rs:12:26: 12:41]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<std::slice::IterMut<'_, isize>, [closure@/tmp/tmpvdm5xgnc.rs:12:26:\
    \ 12:41]> as Iterator>::Item = &_`\n           which is required by `Cloned<Filter<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmpvdm5xgnc.rs:12:26: 12:41]>>: Iterator`\n          \
    \ `Cloned<Filter<std::slice::IterMut<'_, isize>, [closure@/tmp/tmpvdm5xgnc.rs:12:26:\
    \ 12:41]>>: Iterator`\n           which is required by `&mut Cloned<Filter<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmpvdm5xgnc.rs:12:26: 12:41]>>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            x.to_owned()\n        } else {\n            x.to_owned().cmp(&l.iter().skip(x).take(1).collect::<Vec<_>>().unwrap().0)\n\
    \        }\n    });\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpshjzz93i.rs:14:45\n   |\n\
    14 |             x.to_owned().cmp(&l.iter().skip(x).take(1).collect::<Vec<_>>().unwrap().0)\n\
    \   |                                             ^ expected `usize`, found `&isize`\n\
    \nerror[E0599]: no method named `unwrap` found for struct `Vec<&isize>` in the\
    \ current scope\n  --> /tmp/tmpshjzz93i.rs:14:76\n   |\n14 |             x.to_owned().cmp(&l.iter().skip(x).take(1).collect::<Vec<_>>().unwrap().0)\n\
    \   |                                                                        \
    \    ^^^^^^ method not found in `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l2\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp8b9_ewum.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpetu0de9s.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut i = 0;\n    while i < l2.len() {\n        if i\
    \ % 3 == 0 {\n            l2.swap(i, l2.len() - 1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `l2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpohs2vd9y.rs:13:24\n   |\n13 |             l2.swap(i,\
    \ l2.len() - 1);\n   |             -- ----    ^^ immutable borrow occurs here\n\
    \   |             |  |\n   |             |  mutable borrow later used by call\n\
    \   |             mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = l;\n    l3.sort();\n    let\
    \ mut l4 = l;\n    l4.sort();\n    let mut l5 = l;\n    l5.sort();\n    let mut\
    \ l6 = l;\n    l6.sort();\n    let mut l7 = l;\n    l7.sort();\n    let mut l8\
    \ = l;\n    l8.sort();\n    let mut l9 = l;\n    l9.sort();\n    let mut l10 =\
    \ l;\n    l10.sort();\n    let mut l11 = l;\n    l11.sort();\n    let mut l12\
    \ = l;\n    l12.sort();\n    let mut l13 = l;\n    l13.sort();\n    let mut l14\
    \ = l;\n    l14.sort();\n    let mut l15 = l;\n    l15.sort();\n    let mut l16\
    \ = l;\n    l16.sort();\n    let mut l17 = l;\n    l17.sort();\n    let mut l18\
    \ = l;\n    l18.sort();\n    let mut l19 = l;\n    l19.sort();\n    let mut l20\
    \ = l;\n    l20.sort();\n    let mut l21 = l;\n    l21.sort();\n    let mut l22\
    \ = l;\n    l22.sort();\n    let mut l23 = l;\n    l23.sort();\n    let mut l24\
    \ = l;\n    l24.sort();\n    let mut l25 = l;\n    l25.sort();\n    let mut l26\
    \ = l;\n    l26.sort();\n    let mut l27 = l;\n    l27.sort();\n    let mut l28\
    \ = l;\n    l28.sort();\n    let mut l29 = l;\n    l29.sort();\n    let mut l30\
    \ = l;\n    l30.sort();\n    let mut l31 = l;\n    l31.sort();\n    let mut l32\
    \ = l;\n    l32.sort();\n    let mut l33 = l;\n    l33.sort();\n    let mut l34\
    \ = l;\n    l34.sort();\n    let mut l35 = l;\n    l35.sort();\n    let mut l36\
    \ = l;\n    l36.sort();\n    let mut l37 = l;\n    l37.sort();\n    let mut l38\
    \ = l;\n    l38.sort();\n    let mut l39 = l;\n    l39.sort();\n    let mut l40\
    \ = l;\n    l40.sort();\n    let mut l41 = l;\n    l41.sort();\n    let mu\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpad_0ttpb.rs:89:11\n   |\n\
    89 |     let mu\n   |           ^ help: add `;` here\n90 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpad_0ttpb.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    let mut i = 0;\n    while i < l2.len() {\n        if i\
    \ % 3 == 0 {\n            l2.swap(i, l2.len() - 1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `l2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpohs2vd9y.rs:13:24\n   |\n13 |             l2.swap(i,\
    \ l2.len() - 1);\n   |             -- ----    ^^ immutable borrow occurs here\n\
    \   |             |  |\n   |             |  mutable borrow later used by call\n\
    \   |             mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpetu0de9s.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = vec![];\n    for i in 0..l.len()\
    \ {\n        if i % 3 == 0 {\n            l3.push(l2[i]);\n        } else {\n\
    \            l3.push(l[i]);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n  --> /tmp/tmpwu3wxwkr.rs:12:17\n\
    \   |\n8  | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n   |               -\
    \ move occurs because `l` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n9  |     let mut l2 = l;\n   |                  - value moved\
    \ here\n...\n12 |     for i in 0..l.len() {\n   |                 ^ value borrowed\
    \ here after move\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpw9jurkfk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    let mut l2 = l;\n    l2.sort_unstable();\n\
    \    let mut l3 = l;\n    l3.sort_unstable();\n    let mut l4 = l;\n    l4.sort_unstable();\n\
    \    let mut l5 = l;\n    l5.sort_unstable();\n    let mut l6 = l;\n    l6.sort_unstable();\n\
    \    let mut l7 = l;\n    l7.sort_unstable();\n    let mut l8 = l;\n    l8.sort_unstable();\n\
    \    let mut l9 = l;\n    l9.sort_unstable();\n    let mut l10 = l;\n    l10.sort_unstable();\n\
    \    let mut l11 = l;\n    l11.sort_unstable();\n    let mut l12 = l;\n    l12.sort_unstable();\n\
    \    let mut l13 = l;\n    l13.sort_unstable();\n    let mut l14 = l;\n    l14.sort_unstable();\n\
    \    let mut l15 = l;\n    l15.sort_unstable();\n    let mut l16 = l;\n    l16.sort_unstable();\n\
    \    let mut l17 = l;\n    l17.sort_unstable();\n    let mut l18 = l;\n    l18.sort_unstable();\n\
    \    let mut l19 = l;\n    l19.sort_unstable();\n    let mut l20 = l;\n    l20.sort_unstable();\n\
    \    let mut l21 = l;\n    l21.sort_unstable();\n    let mut l22 = l;\n    l22.sort_unstable();\n\
    \    let mut l23 = l;\n    l23.sort_unstable();\n    let mut l24 = l;\n    l24.sort_unstable();\n\
    \    let mut l25 = l;\n    l25.sort_unstable();\n    let mut l26 = l;\n    l26.sort_unstable();\n\
    \    let mut l27 = l;\n    l27.sort_unstable();\n    let mut l28 = l;\n    l28.sort_unstable();\n\
    \    let mut l29 = l;\n    l29.sort_unstable();\n    let mut l30 = l;\n    l30.sort_unstable();\n\
    \    let mut l31 = l;\n    l31.sort_unstable();\n    let mut l32 = l;\n    l32.sort_unstable();\n\
    \    let mut l33 = l;\n    l33.sort_unstable();\n    let mut l34 = l;\n    l34.sort_unstable();\n\
    \    let mut l35 = l;\n    l35.sort_unstable();\n    let \n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4dwlcoj4.rs:80:1\n  \
    \ |\n80 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    l.iter().filter(|&x| x % 3 == 0).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpwg8z3lkh.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| {\n        if x % 3 == 0 {\n\
    \            0\n        } else {\n            1\n        }\n    });\n    l\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpetu0de9s.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l.clone();\n    l3.sort();\n    let mut l2 = l.clone();\n    l2.sort();\n\
    \    let mut l1 = l.clone();\n    l1.sort();\n    let mut l0 = l.clone();\n  \
    \  l0.sort();\n    let mut l1 = l.clone();\n    l1.sort();\n    let mut l2 = l.clone();\n\
    \    l2.sort();\n    let mut l3 = l.clone();\n    l3.sort();\n    let mut l4 =\
    \ l.clone();\n    l4.sort();\n    let mut l5 = l.clone();\n    l5.sort();\n  \
    \  let mut l6 = l.clone();\n    l6.sort();\n    let mut l7 = l.clone();\n    l7.sort();\n\
    \    let mut l8 = l.clone();\n    l8.sort();\n    let mut l9 = l.clone();\n  \
    \  l9.sort();\n    let mut l10 = l.clone();\n    l10.sort();\n    let mut l11\
    \ = l.clone();\n    l11.sort();\n    let mut l12 = l.clone();\n    l12.sort();\n\
    \    let mut l13 = l.clone();\n    l13.sort();\n    let mut l14 = l.clone();\n\
    \    l14.sort();\n    let mut l15 = l.clone();\n    l15.sort();\n    let mut l16\
    \ = l.clone();\n    l16.sort();\n    let mut l17 = l.clone();\n    l17.sort();\n\
    \    let mut l18 = l.clone();\n    l18.sort();\n    let mut l19 = l.clone();\n\
    \    l19.sort();\n    let mut l20 = l.clone();\n    l20.sort();\n    let mut l21\
    \ = l.clone();\n    l21.sort();\n    let mut l22 = l.clone();\n    l22.sort();\n\
    \    let mut l23 = l.clone();\n    l23.sort();\n    let mut l24 = l.clone();\n\
    \    l24.sort();\n    let mut l25 = l.clone();\n    l25.sort();\n    let mut l26\
    \ = l.clone();\n    l26.sort();\n    let mut l27 = l.clone();\n    l27.sort();\n\
    \    let mut l28 = l.clone();\n    l28.sort();\n    let mut l29 = l.clone();\n\
    \    l29.sort();\n    let mut l30 = l.clone();\n    l30.sort();\n    let mut l31\
    \ = l.clone();\n    l31.sort();\n    let mut l32 = l.clone();\n    l32.sort();\n\
    \    let mut l33 = l.clone();\n    l33.sort();\n    let mut l34 = l.clone();\n\
    \    l34.\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpxu1whpbl.rs:85:1\n   |\n85\
    \ | }\n   | ^\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9kvx841n.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9kvx841n.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l.clone();\n    l3.sort_unstable();\n    l3.dedup();\n    l3\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmppvgmr010.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747463
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l.to_vec();\n    l.sort_by_key(|x| x % 3);\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp626qvx8d.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l;\n    l2.sort();\n    let mut l3 = l;\n    l3.sort();\n    for\
    \ i in 0..l.len() / 3 {\n        if l3[i] != i {\n            l3[i] = l3[i];\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5fcxf1dk.rs:14:21\n   |\n\
    14 |         if l3[i] != i {\n   |                     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n14 |         if l3[i] != i.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9kvx841n.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpyq7ike75.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    l.sort_unstable();\n    l.sort_unstable_by_key(|x| x %\
    \ 3);\n    l\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9, 4, 2, 5, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpba772go5.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747463
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l2 = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n\
    \    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfsizjhgk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747462
- exit_code: 101
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l3 = l.clone();\n    l3.sort();\n    let mut l2 = vec![];\n    for\
    \ i in 0..l3.len() {\n        if i % 3 == 0 {\n            l2.push(l3[i]);\n \
    \       } else {\n            l2.push(l3[i / 3]);\n        }\n    }\n    l2\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 2, 5, 3, 3, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpnyqwiddp.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747463
- exit_code: 1
  program: "/// This function takes a vector l and returns a vector l' such that\n\
    /// l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1,\
    \ 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n///\
    \ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n  \
    \  let mut l = l;\n    let mut l2 = l;\n    let mut l3 = l;\n    let mut l4 =\
    \ l;\n    let mut l5 = l;\n    let mut l6 = l;\n    let mut l7 = l;\n    let mut\
    \ l8 = l;\n    let mut l9 = l;\n    let mut l10 = l;\n    let mut l11 = l;\n \
    \   let mut l12 = l;\n    let mut l13 = l;\n    let mut l14 = l;\n    let mut\
    \ l15 = l;\n    let mut l16 = l;\n    let mut l17 = l;\n    let mut l18 = l;\n\
    \    let mut l19 = l;\n    let mut l20 = l;\n    let mut l21 = l;\n    let mut\
    \ l22 = l;\n    let mut l23 = l;\n    let mut l24 = l;\n    let mut l25 = l;\n\
    \    let mut l26 = l;\n    let mut l27 = l;\n    let mut l28 = l;\n    let mut\
    \ l29 = l;\n    let mut l30 = l;\n    let mut l31 = l;\n    let mut l32 = l;\n\
    \    let mut l33 = l;\n    let mut l34 = l;\n    let mut l35 = l;\n    let mut\
    \ l36 = l;\n    let mut l37 = l;\n    let mut l38 = l;\n    let mut l39 = l;\n\
    \    let mut l40 = l;\n    let mut l41 = l;\n    let mut l42 = l;\n    let mut\
    \ l43 = l;\n    let mut l44 = l;\n    let mut l45 = l;\n    let mut l46 = l;\n\
    \    let mut l47 = l;\n    let mut l48 = l;\n    let mut l49 = l;\n    let mut\
    \ l50 = l;\n    let mut l51 = l;\n    let mut l52 = l;\n    let mut l53 = l;\n\
    \    let mut l54 = l;\n    let mut l55 = l;\n    let mut l56 = l;\n    let mut\
    \ l57 = l;\n    let mut l58 = l;\n    let mut l59 = l;\n    let mut l60 = l;\n\
    \    let mut l61 = l;\n    let mut l62 = l;\n    let mut l63 = l;\n    let mut\
    \ l64 = l;\n    let mut l65 = l;\n    let mut l66 = \n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpfkhywyo8.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
