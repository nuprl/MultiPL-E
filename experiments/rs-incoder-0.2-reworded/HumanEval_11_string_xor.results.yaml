language: rs
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from_utf8(\n        a.as_bytes().iter().chain(b.as_bytes().iter()).map(|x|\
    \ x ^ 0xff).collect(),\n    )\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmk9pxj_4.rs:6:5\n  |\n5 |\
    \   fn string_xor(a: String, b: String) -> String {\n  |                     \
    \                     ------ expected `String` because of return type\n6 | / \
    \    String::from_utf8(\n7 | |         a.as_bytes().iter().chain(b.as_bytes().iter()).map(|x|\
    \ x ^ 0xff).collect(),\n8 | |     )\n  | |_____^ expected struct `String`, found\
    \ enum `Result`\n  |\n  = note: expected struct `String`\n               found\
    \ enum `Result<String, FromUtf8Error>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpzrcup1xg.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpzrcup1xg.rs:6:20\n  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                    ^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpfv9j_4hi.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzduwiiob.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpzduwiiob.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in a.chars().chain(b.chars())\
    \ {\n        res.push((c ^ b[a.chars().index(c)]) as char);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzi30z45d.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().chain(b.chars()) {\n  |         ^^    --------------------------\
    \ this expression has type `char`\n  |         |\n  |         expected `char`,\
    \ found reference\n  |\n  = note:   expected type `char`\n          found reference\
    \ `&_`\n\nerror[E0599]: no method named `index` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmpzi30z45d.rs:8:35\n  |\n8 |         res.push((c ^\
    \ b[a.chars().index(c)]) as char);\n  |                                   ^^^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        *res += if *c != *c { *c };\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpegc7db1o.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `(char, char)`\n  |         |\n  |         expected\
    \ tuple, found reference\n  |\n  = note:  expected tuple `(char, char)`\n    \
    \      found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).filter(|&b| b == '1').collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmprcmdfbeb.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).filter(|&b|\
    \ b == '1').collect::<String>()\n  |       ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmprcmdfbeb.rs:6:22\n  |\n6 |     a.iter().chain(b.iter()).filter(|&b|\
    \ b == '1').collect::<String>()\n  |                      ^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        if *c != *c {\n            res.push_str(&format!(\"{}\", *c));\n\
    \        } else {\n            res.push_str(&format!(\"{}\", *c ^ *c));\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4akzk_ve.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `(char, char)`\n  |         |\n  |         expected\
    \ tuple, found reference\n  |\n  = note:  expected tuple `(char, char)`\n    \
    \      found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(\n        a.chars().zip(b.chars()).fold(String::new(),\
    \ |mut acc, (char1, char2)| {\n            acc.push_str(char1.to_string() + char2.to_string());\n\
    \            acc\n        }),\n    )\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0u3citk4.rs:8:46\n  |\n8 |\
    \             acc.push_str(char1.to_string() + char2.to_string());\n  |      \
    \                                        ^^^^^^^^^^^^^^^^^\n  |              \
    \                                |\n  |                                      \
    \        expected `&str`, found struct `String`\n  |                         \
    \                     help: consider borrowing here: `&char2.to_string()`\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp0u3citk4.rs:8:26\n  |\n8 |      \
    \       acc.push_str(char1.to_string() + char2.to_string());\n  |            \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |                    \
    \      |\n  |                          expected `&str`, found struct `String`\n\
    \  |                          help: consider borrowing here: `&(char1.to_string()\
    \ + char2.to_string())`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp3gwx0fh6.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpsqy5wbfa.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp6499ycql.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |       ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp6499ycql.rs:6:20\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |                    ^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(binary_xor_str(a, b))\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_xor_str` in this scope\n -->\
    \ /tmp/tmps66irm39.rs:6:18\n  |\n6 |     String::from(binary_xor_str(a, b))\n\
    \  |                  ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpiinlxipk.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpfv9j_4hi.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].iter().map(|x| if x == b[i] { x } else { 0 }).collect());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmpyi6bpw65.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect());\n  |                            \
    \  ^^^^ method not found in `str`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmpyi6bpw65.rs:8:53\n  |\n8 |         res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect());\n  |                            \
    \                         ^^^^ `String` cannot be indexed by `usize`\n  |\n  =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpbg5piv85.rs:8:23\n\
    \  |\n8 |         res.push_str(&a[i] ^ b[i]);\n  |                       ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmpbg5piv85.rs:8:30\n  |\n8 |         res.push_str(&a[i]\
    \ ^ b[i]);\n  |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzduwiiob.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpzduwiiob.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:7:15\n\
    \    |\n7   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:8:15\n    |\n8   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpfv9j_4hi.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        *result .= if *c != *c { *c };\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `=`\n --> /tmp/tmpvwl3k_7a.rs:8:18\n  |\n8 | \
    \        *result .= if *c != *c { *c };\n  |                  ^\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpvwl3k_7a.rs:7:9\n  |\n7 |     for &c in a.chars().zip(b.chars())\
    \ {\n  |         ^^    ------------------------ this expression has type `(char,\
    \ char)`\n  |         |\n  |         expected tuple, found reference\n  |\n  =\
    \ note:  expected tuple `(char, char)`\n          found reference `&_`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n -->\
    \ /tmp/tmpvwl3k_7a.rs:8:9\n  |\n8 |         *result .= if *c != *c { *c };\n \
    \ |         ^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help:\
    \ the trait `Sized` is not implemented for `str`\n  = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&char ^ char`\n --> /tmp/tmp_kgce26q.rs:8:49\n\
    \  |\n8 |         res.push_str(&a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap());\n\
    \  |                      -------------------------- ^ -------------------------\
    \ char\n  |                      |\n  |                      &char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptm81cv2j.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(format!(\"{:b}\", bincode::xor(a.to_string(),\
    \ b.to_string())))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `bincode`\n\
    \ --> /tmp/tmp272bh5k_.rs:6:34\n  |\n6 |     String::from(format!(\"{:b}\", bincode::xor(a.to_string(),\
    \ b.to_string())))\n  |                                  ^^^^^^^ use of undeclared\
    \ crate or module `bincode`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string())\n        .map(|x|\
    \ x.to_string())\n        .unwrap_or(String::from(\"0\"))\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmporswg6b4.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string())\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmppdvydvmv.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_string()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmps4qr9u69.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:7:15\n\
    \    |\n7   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:8:15\n    |\n8   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpsqy5wbfa.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmphms3hk8l.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpiinlxipk.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_string()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmps4qr9u69.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpzrcup1xg.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpzrcup1xg.rs:6:20\n  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                    ^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpiinlxipk.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(format!(\"{:b}\", a.to_u32() ^ b.to_u32()))\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_u32` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp5dv4sv_w.rs:6:36\n  |\n6 |     String::from(format!(\"\
    {:b}\", a.to_u32() ^ b.to_u32()))\n  |                                    ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `to_u32` found\
    \ for struct `String` in the current scope\n --> /tmp/tmp5dv4sv_w.rs:6:49\n  |\n\
    6 |     String::from(format!(\"{:b}\", a.to_u32() ^ b.to_u32()))\n  |        \
    \                                         ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpfv9j_4hi.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:7:15\n\
    \    |\n7   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:8:15\n    |\n8   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].iter().map(|x| if x == b'1' { b'0' } else {\
    \ b'1' }).collect::<String>());\n    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].iter().map(|x|\
    \ if x == b'1' { b'0' } else { b'1' }).collect::<String>());\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmp69byrpfa.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().map(|x|\
    \ if x == b'1' { b'0' } else { b'1' }).collect::<String>());\n  |            \
    \                  ^^^^ method not found in `str`\n\nerror[E0599]: no method named\
    \ `iter` found for type `str` in the current scope\n  --> /tmp/tmp69byrpfa.rs:11:30\n\
    \   |\n11 |         res.push_str(&b[i..].iter().map(|x| if x == b'1' { b'0' }\
    \ else { b'1' }).collect::<String>());\n   |                              ^^^^\
    \ method not found in `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpzrcup1xg.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpzrcup1xg.rs:6:20\n  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                    ^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).filter(|&b| b == '1').collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmprcmdfbeb.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).filter(|&b|\
    \ b == '1').collect::<String>()\n  |       ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmprcmdfbeb.rs:6:22\n  |\n6 |     a.iter().chain(b.iter()).filter(|&b|\
    \ b == '1').collect::<String>()\n  |                      ^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:7:15\n\
    \    |\n7   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:8:15\n    |\n8   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a |\
    \ &b {\n        if *c != '0' {\n            res.push_str(&*c + '0');\n       \
    \ } else {\n            res.push_str(&*c + '1');\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmpfwl6zj_v.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).map(|c| c ^ 0xff).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp_ko5vhgf.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).map(|c|\
    \ c ^ 0xff).collect()\n  |       ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n -->\
    \ /tmp/tmp_ko5vhgf.rs:6:22\n  |\n6 |     a.iter().chain(b.iter()).map(|c| c ^\
    \ 0xff).collect()\n  |                      ^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpzrcup1xg.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpzrcup1xg.rs:6:20\n  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                    ^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpfv9j_4hi.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a &\
    \ &b {\n        if *c != 0 {\n            res.push_str(&*c as char);\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpl9wi5qn_.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmp2he7fpwg.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        match c {\n            '0' => result.push('0'),\n          \
    \  '1' => result.push('1'),\n            _ => panic!(\"String contains invalid\
    \ character: {}\", c),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpo1f3iepx.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &b in &b {\n\
    \        if *b != 0 {\n            res.push_str(&a[*b as usize]);\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmphcne5_4x.rs:7:15\n\
    \    |\n7   |     for &b in &b {\n    |               ^^ `&String` is not an iterator\n\
    \    |\n    = help: the trait `Iterator` is not implemented for `&String`\n  \
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:7:15\n\
    \    |\n7   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:8:15\n    |\n8   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmp2he7fpwg.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        if *a != *b {\n            result.push(*a\
    \ ^ *b);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpiug7k9y8.rs:8:12\n\
    \  |\n8 |         if *a != *b {\n  |            ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n --> /tmp/tmpiug7k9y8.rs:8:18\n  |\n8 |         if *a\
    \ != *b {\n  |                  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \ --> /tmp/tmpiug7k9y8.rs:9:25\n  |\n9 |             result.push(*a ^ *b);\n \
    \ |                         ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \ --> /tmp/tmpiug7k9y8.rs:9:30\n  |\n9 |             result.push(*a ^ *b);\n \
    \ |                              ^^\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp3gwx0fh6.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpzrcup1xg.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpzrcup1xg.rs:6:20\n  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                    ^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].iter().map(|x| if x == b[i] { x } else { 0 }).collect::<String>());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmprn7okoc1.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect::<String>());\n  |                  \
    \            ^^^^ method not found in `str`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n --> /tmp/tmprn7okoc1.rs:8:53\n  |\n8 |      \
    \   res.push_str(&a[i..].iter().map(|x| if x == b[i] { x } else { 0 }).collect::<String>());\n\
    \  |                                                     ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n --> /tmp/tmphf6uukv_.rs:8:23\n\
    \  |\n8 |         res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n \
    \ |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ no implementation for `usize ^ char`\n --> /tmp/tmphf6uukv_.rs:8:35\n  |\n8\
    \ |         res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n  |    \
    \                               ^ no implementation for `usize ^ char`\n  |\n\
    \  = help: the trait `BitXor<char>` is not implemented for `usize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptm81cv2j.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string())\n        .expect(\"\
    String XOR failed\")\n        .to_string()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpsmgkdey4.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string())\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:7:15\n\
    \    |\n7   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmptrmcgj8k.rs:8:15\n    |\n8   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpb_4oql0d.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmp2he7fpwg.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a |\
    \ &b {\n        if *c != 0 {\n            res.push_str(&*c as char);\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmp7wpit1vc.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpfv9j_4hi.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).map(|x| x.to_ascii_lowercase()).fold(String::new(),\
    \ |x, y| {\n        x.chars().zip(y.chars()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \    })\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmprbd4o30b.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).map(|x|\
    \ x.to_ascii_lowercase()).fold(String::new(), |x, y| {\n  |       ^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `iter` found for struct\
    \ `String` in the current scope\n --> /tmp/tmprbd4o30b.rs:6:22\n  |\n6 |     a.iter().chain(b.iter()).map(|x|\
    \ x.to_ascii_lowercase()).fold(String::new(), |x, y| {\n  |                  \
    \    ^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a {\
    \ res += &c ^ &b[c.to_digit(10).unwrap()]; }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpviw3zta0.rs:7:15\n\
    \    |\n7   |     for &c in &a { res += &c ^ &b[c.to_digit(10).unwrap()]; }\n\
    \    |               ^^ `&String` is not an iterator\n    |\n    = help: the trait\
    \ `Iterator` is not implemented for `&String`\n    = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmppdvydvmv.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &b in &b\
    \ {\n        if *b == '1' {\n            result.push(*a);\n        }\n       \
    \ *a = '0';\n        *a = '1';\n        *a = '0';\n        *a = '1';\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpe_qzoajn.rs:7:15\n\
    \    |\n7   |     for &b in &b {\n    |               ^^ `&String` is not an iterator\n\
    \    |\n    = help: the trait `Iterator` is not implemented for `&String`\n  \
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpe_qzoajn.rs:9:25\n  |\n9 |             result.push(*a);\n  |   \
    \                      ^^ expected `char`, found `str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe_qzoajn.rs:11:14\n   |\n11 |         *a = '0';\n   | \
    \             ^^^ expected `str`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe_qzoajn.rs:12:14\n   |\n12 |         *a = '1';\n   |         \
    \     ^^^ expected `str`, found `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpe_qzoajn.rs:13:14\n   |\n13 |         *a = '0';\n   |              ^^^\
    \ expected `str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe_qzoajn.rs:14:14\n\
    \   |\n14 |         *a = '1';\n   |              ^^^ expected `str`, found `char`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpe_qzoajn.rs:11:9\n   |\n11 |         *a = '0';\n   |   \
    \      ^^ doesn't have a size known at compile-time\n   |\n   = help: the trait\
    \ `Sized` is not implemented for `str`\n   = note: the left-hand-side of an assignment\
    \ must have a statically known size\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(format!(\"{:b}\", bincode::xor(&a,\
    \ &b)))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `bincode`\n\
    \ --> /tmp/tmp74hb2ctm.rs:6:34\n  |\n6 |     String::from(format!(\"{:b}\", bincode::xor(&a,\
    \ &b)))\n  |                                  ^^^^^^^ use of undeclared crate\
    \ or module `bincode`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp6499ycql.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |       ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp6499ycql.rs:6:20\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |                    ^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_string()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmps4qr9u69.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &b in b.chars().cloned()\
    \ {\n        if a.chars().any(|c| c == b) {\n            result.push(b);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n --> /tmp/tmps6ls_919.rs:7:25\n  |\n7 |     for &b in b.chars().cloned()\
    \ {\n  |                         ^^^^^^ expected `char`, found reference\n  |\n\
    \  = note:   expected type `char`\n          found reference `&_`\n\nerror[E0271]:\
    \ type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n   --> /tmp/tmps6ls_919.rs:7:15\n\
    \    |\n7   |     for &b in b.chars().cloned() {\n    |               ^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `char`\n    |\n    = note: expected reference `&_`\n\
    \                    found type `char`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\
    note: required by `into_iter`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmps6ls_919.rs:7:15\n   |\n7  |     for\
    \ &b in b.chars().cloned() {\n   |               ^^^^^^^^^^^^^^^^^^ expected reference,\
    \ found `char`\n   |\n   = note: expected reference `&_`\n                   found\
    \ type `char`\n   = note: required because of the requirements on the impl of\
    \ `Iterator` for `Cloned<Chars<'_>>`\nnote: required by `std::iter::Iterator::next`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &b in &b\
    \ {\n        if *b != 0 {\n            result.push(*a);\n        }\n        *a\
    \ = (*a) ^ *b;\n        a++;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmplhj5a03q.rs:12:11\n\
    \   |\n12 |         a++;\n   |           ^ expected expression\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmplhj5a03q.rs:7:15\n    |\n7   |\
    \     for &b in &b {\n    |               ^^ `&String` is not an iterator\n  \
    \  |\n    = help: the trait `Iterator` is not implemented for `&String`\n    =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `&String`\nnote: required by `into_iter`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmplhj5a03q.rs:9:25\n  |\n9 |             result.push(*a);\n  |   \
    \                      ^^ expected `char`, found `str`\n\nerror[E0277]: the size\
    \ for values of type `str` cannot be known at compilation time\n  --> /tmp/tmplhj5a03q.rs:11:9\n\
    \   |\n11 |         *a = (*a) ^ *b;\n   |         ^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: the left-hand-side of an assignment must have a statically known size\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(format!(\"{:b}\", bin::Xor(a.to_string(),\
    \ b.to_string())))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `bin`\n\
    \ --> /tmp/tmprwo9_igl.rs:6:34\n  |\n6 |     String::from(format!(\"{:b}\", bin::Xor(a.to_string(),\
    \ b.to_string())))\n  |                                  ^^^ use of undeclared\
    \ crate or module `bin`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpiinlxipk.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpzrcup1xg.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpzrcup1xg.rs:6:20\n  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                    ^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp3gwx0fh6.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpb_4oql0d.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptm81cv2j.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string())\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpojjocoec.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string())\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp1vxaa4eu.rs:6:19\n  |\n6 |     a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |                   ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp1vxaa4eu.rs:6:44\n  |\n6 |     a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |                                            ^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpzrcup1xg.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpzrcup1xg.rs:6:20\n  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                    ^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp3gwx0fh6.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpsqy5wbfa.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a {\
    \ res.push(c); }\n    for &c in &b { res.push(c); }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpnhir2rxo.rs:7:15\n\
    \    |\n7   |     for &c in &a { res.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpnhir2rxo.rs:8:15\n    |\n8   |\
    \     for &c in &b { res.push(c); }\n    |               ^^ `&String` is not an\
    \ iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&String`\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        *result += if *c != *c { *c };\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpa6h0tc32.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `(char, char)`\n  |         |\n  |         expected\
    \ tuple, found reference\n  |\n  = note:  expected tuple `(char, char)`\n    \
    \      found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmppdvydvmv.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a.chars()\n            .skip(i)\n            .take(b.len())\n\
    \            .map(|b| b as char)\n            .collect::<String>());\n    }\n\
    \    res.push_str(&b.chars().collect::<String>());\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"111000110001000000000101010\"`,\n right: `\"010010\"`', /tmp/tmp285qn_gr.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a &\
    \ &b {\n        if *c != 0 {\n            res.push_str(&*c as char);\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpl9wi5qn_.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).filter(|x| x != 0).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpnyy71qqh.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).filter(|x|\
    \ x != 0).collect::<String>()\n  |       ^^^^ method not found in `String`\n\n\
    error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpnyy71qqh.rs:6:22\n  |\n6 |     a.iter().chain(b.iter()).filter(|x|\
    \ x != 0).collect::<String>()\n  |                      ^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].chars().map(|c| c ^ b[i..]).collect::<String>());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ str`\n --> /tmp/tmp3rhpksd0.rs:8:48\n\
    \  |\n8 |         res.push_str(&a[i..].chars().map(|c| c ^ b[i..]).collect::<String>());\n\
    \  |                                              - ^ ------ str\n  |        \
    \                                      |\n  |                                \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmpi47vtwv1.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpx9qh5r21.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmpx9qh5r21.rs:8:28\n  |\n8 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string())\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpojjocoec.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string())\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmpi47vtwv1.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmphms3hk8l.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(format!(\"{:b}\", bincode::xor_encode(a.as_bytes(),\
    \ b.as_bytes())))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `bincode`\n\
    \ --> /tmp/tmp46ee6a8a.rs:6:34\n  |\n6 |     String::from(format!(\"{:b}\", bincode::xor_encode(a.as_bytes(),\
    \ b.as_bytes())))\n  |                                  ^^^^^^^ use of undeclared\
    \ crate or module `bincode`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(binary_xor_impl(a, b).to_string())\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_xor_impl` in this scope\n -->\
    \ /tmp/tmp6ztiv5tf.rs:6:18\n  |\n6 |     String::from(binary_xor_impl(a, b).to_string())\n\
    \  |                  ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n --> /tmp/tmphf6uukv_.rs:8:23\n\
    \  |\n8 |         res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n \
    \ |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ no implementation for `usize ^ char`\n --> /tmp/tmphf6uukv_.rs:8:35\n  |\n8\
    \ |         res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n  |    \
    \                               ^ no implementation for `usize ^ char`\n  |\n\
    \  = help: the trait `BitXor<char>` is not implemented for `usize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpfv9j_4hi.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmpi47vtwv1.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        *res += if *c != *c { *c };\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpegc7db1o.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `(char, char)`\n  |         |\n  |         expected\
    \ tuple, found reference\n  |\n  = note:  expected tuple `(char, char)`\n    \
    \      found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a &\
    \ &b {\n        if *c != 0 {\n            res.push_str(&*c as char);\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpl9wi5qn_.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().iter().chain(b.to_string().iter()).map(|x|\
    \ x ^ 1).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpczxnwl4q.rs:6:19\n  |\n6 |     a.to_string().iter().chain(b.to_string().iter()).map(|x|\
    \ x ^ 1).collect()\n  |                   ^^^^ method not found in `String`\n\n\
    error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpczxnwl4q.rs:6:46\n  |\n6 |     a.to_string().iter().chain(b.to_string().iter()).map(|x|\
    \ x ^ 1).collect()\n  |                                              ^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpsqy5wbfa.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp1vxaa4eu.rs:6:19\n  |\n6 |     a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |                   ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp1vxaa4eu.rs:6:44\n  |\n6 |     a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |                                            ^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a &\
    \ &b {\n        if *c != 0 {\n            res.push_str(&*c as char);\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpl9wi5qn_.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpsqy5wbfa.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string())\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpojjocoec.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string())\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a {\
    \ res.push(c); }\n    for &c in &b { res.push(c); }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpnhir2rxo.rs:7:15\n\
    \    |\n7   |     for &c in &a { res.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpnhir2rxo.rs:8:15\n    |\n8   |\
    \     for &c in &b { res.push(c); }\n    |               ^^ `&String` is not an\
    \ iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&String`\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpsqy5wbfa.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in a.chars().zip(b.chars()).filter(|&(a,\
    \ b)| a == b).map(|&(a, b)| {\n        res.push_str(&format!(\"{}\", a ^ b));\n\
    \    });\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `;`\n --> /tmp/tmp94cjv9u7.rs:9:7\n  |\n9 |\
    \     });\n  |       ^\n  |       |\n  |       expected `{`\n  |       help: try\
    \ placing this code inside a block: `{ ; }`\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(\n        a.chars().filter(|c| b.get(c)\
    \ != Some(1))\n            .chain(b.get(c).unwrap().chars().filter(|c| a.get(c)\
    \ != Some(1)))\n            .collect::<String>()\n            .join(),\n    )\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n --> /tmp/tmptaigfcc2.rs:8:26\n\
    \  |\n8 |             .chain(b.get(c).unwrap().chars().filter(|c| a.get(c) !=\
    \ Some(1)))\n  |                          ^ help: a local variable with a similar\
    \ name exists: `a`\n\nerror[E0277]: the type `str` cannot be indexed by `&char`\n\
    \ --> /tmp/tmptaigfcc2.rs:7:36\n  |\n7 |         a.chars().filter(|c| b.get(c)\
    \ != Some(1))\n  |                                    ^ string indices are ranges\
    \ of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for\
    \ `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmptaigfcc2.rs:7:47\n \
    \ |\n7 |         a.chars().filter(|c| b.get(c) != Some(1))\n  |              \
    \                                 ^\n  |                                     \
    \          |\n  |                                               expected reference,\
    \ found integer\n  |                                               help: consider\
    \ borrowing here: `&1`\n  |\n  = note: expected reference `&_`\n             \
    \     found type `{integer}`\n\nerror[E0308]: mismatched types\n --> /tmp/tmptaigfcc2.rs:8:74\n\
    \  |\n8 |             .chain(b.get(c).unwrap().chars().filter(|c| a.get(c) !=\
    \ Some(1)))\n  |                                                             \
    \             ^\n  |                                                         \
    \                 |\n  |                                                     \
    \                     expected reference, found integer\n  |                 \
    \                                                         help: consider borrowing\
    \ here: `&1`\n  |\n  = note: expected reference `&_`\n                  found\
    \ type `{integer}`\n\nerror[E0599]: no method named `join` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmptaigfcc2.rs:10:14\n   |\n10 |          \
    \   .join(),\n   |              ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string())\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpojjocoec.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string())\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp7gr4l6z1.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpx9qh5r21.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmpx9qh5r21.rs:8:28\n  |\n8 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp3gwx0fh6.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).filter(|&b| b == '1').collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmprcmdfbeb.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).filter(|&b|\
    \ b == '1').collect::<String>()\n  |       ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmprcmdfbeb.rs:6:22\n  |\n6 |     a.iter().chain(b.iter()).filter(|&b|\
    \ b == '1').collect::<String>()\n  |                      ^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp7_tdpxt7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptm81cv2j.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpx9qh5r21.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmpx9qh5r21.rs:8:28\n  |\n8 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpsqy5wbfa.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpsqy5wbfa.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp3gwx0fh6.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmp3gwx0fh6.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpx9qh5r21.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmpx9qh5r21.rs:8:28\n  |\n8 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746969
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmp2he7fpwg.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbd73n1kd.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746968
