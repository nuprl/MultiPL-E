language: rs
name: HumanEval_98_count_upper
results:
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E').count()\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5_gjdvni.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E').count()\n   |            \
    \                                    ^^^\n   |                               \
    \                 |\n   |                                                expected\
    \ `&char`, found `char`\n   |                                                help:\
    \ consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5_gjdvni.rs:10:60\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E').count()\n   |            \
    \                                                ^^^\n   |                   \
    \                                         |\n   |                            \
    \                                expected `&char`, found `char`\n   |        \
    \                                                    help: consider borrowing\
    \ here: `&'Z'`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp5_gjdvni.rs:10:83\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E').count()\n   |            \
    \                                                                       ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp5_gjdvni.rs:10:95\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E').count()\n   |                                                    \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp5_gjdvni.rs:10:107\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= "
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_even()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpd4y091he.rs:10:79\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_even()).count()\n   |           \
    \                                                                    ^^^^^^^ method\
    \ not found in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd4y091he.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_even()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_even()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgvyhwuic.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').count(|(_, c)| c >= 'A' && c <= 'Z')\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnanq0xg7.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').count(|(_,\
    \ c)| c >= 'A' && c <= 'Z')\n   |                                            \
    \    ^^^\n   |                                                |\n   |        \
    \                                        expected `&char`, found `char`\n   |\
    \                                                help: consider borrowing here:\
    \ `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnanq0xg7.rs:10:60\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').count(|(_,\
    \ c)| c >= 'A' && c <= 'Z')\n   |                                            \
    \                ^^^\n   |                                                   \
    \         |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpnanq0xg7.rs:10:65\n\
    \    |\n10  |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').count(|(_,\
    \ c)| c >= 'A' && c <= 'Z')\n    |                                           \
    \                      ^^^^^ ----------------------------- supplied 1 argument\n\
    \    |                                                                 |\n   \
    \ |                                                                 expected 0\
    \ arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnanq0xg7.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c\
    \ <= 'Z').count(|(_, c)| c >= 'A' && c <= 'Z')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' && c != 'I' && c != 'o' && c != 'O' && c != 'u' && c !=\
    \ 'U').count()\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqci2dy2b.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E' && c != 'i' ...\n   |     \
    \                                           ^^^\n   |                        \
    \                        |\n   |                                             \
    \   expected `&char`, found `char`\n   |                                     \
    \           help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqci2dy2b.rs:10:60\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' ...\n   |                                             \
    \               ^^^\n   |                                                    \
    \        |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpqci2dy2b.rs:10:83\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' ...\n   |                                             \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqci2dy2b.rs:10:95\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E' && c != 'i' ...\n   |     \
    \                                                                            \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpqci2dy2b.rs:10:107\n   |\n10 | ...'Z').filter(|(_,\
    \ c)| c != 'a"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiov7ca99.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8znwxpp0.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' && c != 'I' && c != 'o' && c != 'O' && c != 'u' && c !=\
    \ 'U').count() as isize\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqo60io7u.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E' && c != 'i' ...\n   |     \
    \                                           ^^^\n   |                        \
    \                        |\n   |                                             \
    \   expected `&char`, found `char`\n   |                                     \
    \           help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqo60io7u.rs:10:60\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' ...\n   |                                             \
    \               ^^^\n   |                                                    \
    \        |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpqo60io7u.rs:10:83\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' ...\n   |                                             \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqo60io7u.rs:10:95\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E' && c != 'i' ...\n   |     \
    \                                                                            \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpqo60io7u.rs:10:107\n   |\n10 | ...'Z').filter(|(_,\
    \ c)| c != 'a"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiov7ca99.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfo7oquyl.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').count() as isize\n   |   \
    \                            ^^^\n   |                               |\n   | \
    \                              expected `&char`, found `char`\n   |          \
    \                     help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfo7oquyl.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as isize\n   |                               \
    \            ^^^\n   |                                           |\n   |     \
    \                                      expected `&char`, found `char`\n   |  \
    \                                         help: consider borrowing here: `&'Z'`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' && c != 'I' && c != 'o' && c != 'O' && c != 'u' && c !=\
    \ 'U').count() as isize\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqo60io7u.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E' && c != 'i' ...\n   |     \
    \                                           ^^^\n   |                        \
    \                        |\n   |                                             \
    \   expected `&char`, found `char`\n   |                                     \
    \           help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqo60io7u.rs:10:60\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' ...\n   |                                             \
    \               ^^^\n   |                                                    \
    \        |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpqo60io7u.rs:10:83\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' ...\n   |                                             \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqo60io7u.rs:10:95\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E' && c != 'i' ...\n   |     \
    \                                                                            \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpqo60io7u.rs:10:107\n   |\n10 | ...'Z').filter(|(_,\
    \ c)| c != 'a"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiov7ca99.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiov7ca99.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiov7ca99.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' && c != 'I' && c != 'o' && c != 'O' && c != 'u' && c !=\
    \ 'U').count() as isize\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqo60io7u.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E' && c != 'i' ...\n   |     \
    \                                           ^^^\n   |                        \
    \                        |\n   |                                             \
    \   expected `&char`, found `char`\n   |                                     \
    \           help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqo60io7u.rs:10:60\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' ...\n   |                                             \
    \               ^^^\n   |                                                    \
    \        |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpqo60io7u.rs:10:83\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E' && c != 'i' ...\n   |                                             \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqo60io7u.rs:10:95\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E' && c != 'i' ...\n   |     \
    \                                                                            \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpqo60io7u.rs:10:107\n   |\n10 | ...'Z').filter(|(_,\
    \ c)| c != 'a"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiov7ca99.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() % 2 == 0\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp019u1310.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').count() % 2 == 0\n   |   \
    \                            ^^^\n   |                               |\n   | \
    \                              expected `&char`, found `char`\n   |          \
    \                     help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp019u1310.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() % 2 == 0\n   |                               \
    \            ^^^\n   |                                           |\n   |     \
    \                                      expected `&char`, found `char`\n   |  \
    \                                         help: consider borrowing here: `&'Z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp019u1310.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').count() % 2 == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgvyhwuic.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| {\n        c.is_ascii_letter() || c.is_ascii_digit()\n\
    \    }).count(|(_, c)| {\n        c.is_ascii_letter() || c.is_ascii_digit()\n\
    \    })\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp27vhqz95.rs:11:11\n   |\n11 |         c.is_ascii_letter()\
    \ || c.is_ascii_digit()\n   |           ^^^^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp27vhqz95.rs:12:8\n    |\n12  |       }).count(|(_, c)| {\n   \
    \ |  ________^^^^^_-\n    | |        |\n    | |        expected 0 arguments\n\
    13  | |         c.is_ascii_letter() || c.is_ascii_digit()\n14  | |     })\n  \
    \  | |_____- supplied 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp27vhqz95.rs:10:5\n   |\n9  | \
    \  fn count_upper(s: String) -> isize {\n   |                                -----\
    \ expected `isize` because of return type\n10 | /     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| {\n11 | |         c.is_ascii_letter()\
    \ || c.is_ascii_digit()\n12 | |     }).count(|(_, c)| {\n13 | |         c.is_ascii_letter()\
    \ || c.is_ascii_digit()\n14 | |     })\n   | |______^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n10 ~     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| {\n11 +         c.is_ascii_letter() ||\
    \ c.is_ascii_digit()\n12 +     }).count(|(_, c)| {\n13 +         c.is_ascii_letter()\
    \ || c.is_ascii_digit()\n14 +     }).try_into().unwrap()\n   |\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8znwxpp0.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `1`', /tmp/tmp0hag_nvk.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747090
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8znwxpp0.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiov7ca99.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() % 2 == 0\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp019u1310.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').count() % 2 == 0\n   |   \
    \                            ^^^\n   |                               |\n   | \
    \                              expected `&char`, found `char`\n   |          \
    \                     help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp019u1310.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() % 2 == 0\n   |                               \
    \            ^^^\n   |                                           |\n   |     \
    \                                      expected `&char`, found `char`\n   |  \
    \                                         help: consider borrowing here: `&'Z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp019u1310.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').count() % 2 == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A').count()\n}\n\
    \nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgxshhnsp.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A').count()\n   |                                    \
    \            ^^^\n   |                                                |\n   |\
    \                                                expected `&char`, found `char`\n\
    \   |                                                help: consider borrowing\
    \ here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxshhnsp.rs:10:60\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A').count()\n   |                                    \
    \                        ^^^\n   |                                           \
    \                 |\n   |                                                    \
    \        expected `&char`, found `char`\n   |                                \
    \                            help: consider borrowing here: `&'Z'`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpgxshhnsp.rs:10:83\n   |\n10\
    \ |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A').count()\n   |                                    \
    \                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgxshhnsp.rs:10:95\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A').count()\n   |                                    \
    \                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxshhnsp.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' &"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8znwxpp0.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8znwxpp0.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_letter()).count()\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp_ox91cfh.rs:10:79\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_letter()).count()\n   |   \
    \                                                                            ^^^^^^^^^^^^^^^\
    \ method not found in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ox91cfh.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_letter()).count()\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzpnzdo28.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').count()\n\
    \   |                                                ^^^\n   |               \
    \                                 |\n   |                                    \
    \            expected `&char`, found `char`\n   |                            \
    \                    help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzpnzdo28.rs:10:60\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').count()\n   |                                    \
    \                        ^^^\n   |                                           \
    \                 |\n   |                                                    \
    \        expected `&char`, found `char`\n   |                                \
    \                            help: consider borrowing here: `&'Z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzpnzdo28.rs:10:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n10 |     s.chars().enumerate().filter(|(_, c)| c >=\
    \ 'A' && c <= 'Z').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').count().try_into().unwrap()\n   |\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiov7ca99.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgerwmqo0.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).count().try_into().unwrap()\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c % 2 == 0).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpq9u1avqo.rs:10:79\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c.is_uppercase()).filter(|(_,\
    \ c)| c % 2 == 0).count()\n   |                                              \
    \                               - ^ - {integer}\n   |                        \
    \                                                     |\n   |                \
    \                                                             &char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq9u1avqo.rs:10:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n10 |     s.chars().enumerate().filter(|(_, c)| c.is_uppercase()).filter(|(_,\
    \ c)| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c % 2 == 0).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiov7ca99.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'e' && c != 'i' &&\
    \ c != 'o' && c != 'u').count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn7e2sjm2.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')...\n   |     \
    \                                           ^^^\n   |                        \
    \                        |\n   |                                             \
    \   expected `&char`, found `char`\n   |                                     \
    \           help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn7e2sjm2.rs:10:60\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'e' && c != 'i' &&\
    \ c != 'o' && c != 'u')...\n   |                                             \
    \               ^^^\n   |                                                    \
    \        |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpn7e2sjm2.rs:10:83\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'e' && c != 'i' &&\
    \ c != 'o' && c != 'u')...\n   |                                             \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn7e2sjm2.rs:10:95\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')...\n   |     \
    \                                                                            \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn7e2sjm2.rs:10:107\n   |\n10 | ...'Z').filter(|(_,\
    \ c)| c != 'a"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfo7oquyl.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').count() as isize\n   |   \
    \                            ^^^\n   |                               |\n   | \
    \                              expected `&char`, found `char`\n   |          \
    \                     help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfo7oquyl.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as isize\n   |                               \
    \            ^^^\n   |                                           |\n   |     \
    \                                      expected `&char`, found `char`\n   |  \
    \                                         help: consider borrowing here: `&'Z'`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiov7ca99.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp4euyq4u1.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4euyq4u1.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4xi_ve7a.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xi_ve7a.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `1`', /tmp/tmp0hag_nvk.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747090
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiren62.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugimd_us.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpugimd_us.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpugimd_us.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747089
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').count(|(_, c)| c >= 'a' && c <= 'z')\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpggj9v_85.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').count(|(_,\
    \ c)| c >= 'a' && c <= 'z')\n   |                                            \
    \    ^^^\n   |                                                |\n   |        \
    \                                        expected `&char`, found `char`\n   |\
    \                                                help: consider borrowing here:\
    \ `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpggj9v_85.rs:10:60\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').count(|(_,\
    \ c)| c >= 'a' && c <= 'z')\n   |                                            \
    \                ^^^\n   |                                                   \
    \         |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpggj9v_85.rs:10:65\n\
    \    |\n10  |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').count(|(_,\
    \ c)| c >= 'a' && c <= 'z')\n    |                                           \
    \                      ^^^^^ ----------------------------- supplied 1 argument\n\
    \    |                                                                 |\n   \
    \ |                                                                 expected 0\
    \ arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpggj9v_85.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c\
    \ <= 'Z').count(|(_, c)| c >= 'a' && c <= 'z')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n"
  stdout: ''
  timestamp: 1659747089
