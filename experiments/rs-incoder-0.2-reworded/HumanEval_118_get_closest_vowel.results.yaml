language: rs
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf_qks2oz.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf_qks2oz.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptqrq69cj.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqrq69cj.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj928mecv.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj928mecv.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels_iter.skip(1);\n    let mut\
    \ vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaxbo5mb0.rs:55:11\n   |\n\
    55 |     let mu\n   |           ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxbo5mb0.rs:15:39\n \
    \  |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jo_cctw.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_lowercase()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_uppercase()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp7rbuwab4.rs:36:1\n   |\n36 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp7rbuwab4.rs:35:68\n   |\n15 | fn get_closest_vowel(word: String) ->\
    \ String {\n   |                                              - closing delimiter\
    \ possibly meant for this\n...\n35 |     let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter\n   |                                                   \
    \                 ^ unclosed delimiter\n36 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0271]: type mismatch resolving `<SkipWhile<Chars<'_>, [closure@/tmp/tmp7rbuwab4.rs:18:69:\
    \ 18:97]> as IntoIterator>::Item == &&str`\n   --> /tmp/tmp7rbuwab4.rs:18:39\n\
    \    |\n18  |     let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_lowercase()));\n    |                                       ^^^^^\
    \ expected `&&str`, found `char`\n    |\nnote: required by a bound in `std::iter::Iterator::chain`\n\
    \nerror[E0599]: the method `chain` exists for struct `std::iter::Chain<std::slice::Iter<'_,\
    \ &str>, SkipWhile<Chars<'_>, [closure@/tmp/tmp7rbuwab4.rs:18:69: 18:97]>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmp7rbuwab4.rs:19:39\n   |\n\
    19 |       let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_uppercase()));\n   |                                         ^^^^^\
    \ method cannot be called on `std::iter::Chain<std::slice::Iter<'_, &str>, SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp7rbuwab4.rs:18:69: 18:97]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp7rbuwab4.rs:18:69: 18:97]> as Iterator>::Item = &&str`\n  \
    \         which is required by `std::iter::Chain<std::slice::Iter<'_, &str>, SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp7rbuwab4.rs:18:69: 18:97]>>: Iterator`\n           `std::iter::Chain<std::slice::Iter<'_,\
    \ &str>, SkipWhile<Chars<'_>, [closu"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len = word.len();\n    let mut vowels_idx2\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len2 = word.len();\n    let mut vowels_idx3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len3 = word.len();\n    let mut vowels_idx4\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len4 = word.len();\n    let mut vowels_idx5\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len5 = word.len();\n    let mut vowels_idx6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len6 = word.len();\n    let mut vowels_idx7\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len7 = word.len();\n    let mut vowels_idx8\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len8 = word.len();\n    let mut vowels_idx9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len9 = word.len();\n    let mut vowels_idx10\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len10 = word.len();\n    let mut\
    \ vowels_idx11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len11 = word.len();\n\
    \    let mut vowels_idx12 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len12 = word.len();\n\
    \    let mut vowels_idx13 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len13 = word.len();\n\
    \    let mut vowels_idx14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len14 = word.len();\n\
    \    let mut vowels_idx15 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len15 = word.len();\n\
    \    let mut vowels_idx16 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len16 = word.len();\n\
    \    let mut vowels_idx17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len17 = word.len();\n\
    \    let mut vowels_idx18 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len18 = word.len();\n\
    \    let mut vowels_idx19 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len19 = word.len();\n\
    \    let mut vowels_idx20\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfbjswfi7.rs:55:25\n   |\n\
    55 |     let mut vowels_idx20\n   |                         ^ help: add `;` here\n\
    56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfbjswfi7.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj2nrle7l.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj2nrle7l.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4fnkhsgt.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4fnkhsgt.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index_end = vec![0];\n    let mut vowels_index_start\
    \ = vec![0];\n    let mut vowels_index_start_end = vec![0];\n    let mut vowels_index_start_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end = vec![0];\n    let mut\
    \ vowels_index_start_end_end_end_end = vec![0];\n    let mut vowels_index_start_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end = vec![0];\n\
    \    let mut vowels_index_start_end_end_end_end_end_end_end = vec![0];\n    let\
    \ mut vowels_index_start_end_end_end_end_end_end_end_end = vec![0];\n    let mut\
    \ vowels_index_start_end_end_end_end_end_end_end_end_end = vec![0];\n    let mut\
    \ vowels_index_start_end_end_end_end_end_end_end_end_end_end = vec![0];\n    let\
    \ mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end = vec![0];\n\
    \    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcenj1n95.rs:41:80\n   |\n\
    41 |     let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_\n\
    \   |                                                                        \
    \        ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcenj1n95.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmmiyhfuv.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmmiyhfuv.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx1z_dk17.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1z_dk17.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid_iter = vowels_mid.iter();\n    let mut vowels_mid_end\
    \ = vowels_mid_iter.next();\n    let mut vowels_mid_start = vowels_mid_iter.next();\n\
    \    let mut vowels_mid_mid_iter = vowels_mid_mid.iter();\n    let mut vowels_mid_mid_end\
    \ = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_start\
    \ = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzdqd5s6s.rs:48:54\n   |\n\
    48 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_\n   |             \
    \                                         ^ help: add `;` here\n49 | }\n   | -\
    \ unexpected token\n\nerror[E0425]: cannot find value `vowels_mid_mid` in this\
    \ scope\n  --> /tmp/tmpzdqd5s6s.rs:24:35\n   |\n24 |     let mut vowels_mid_mid_iter\
    \ = vowels_mid_mid.iter();\n   |                                   ^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels_mid_end`\n\nerror[E0425]:\
    \ cannot find value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmpzdqd5s6s.rs:27:39\n\
    \   |\n27 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmpzdqd5s6s.rs:30:39\n\
    \   |\n30 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmpzdqd5s6s.rs:33:39\n\
    \   |\n33 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmpzdqd5s6s.rs:36:39\n\
    \   |\n36 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmpzdqd5s6s.rs:39:39\n\
    \   |\n39 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `v"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|v| vowels_set.insert(v));\n \
    \   let mut vowels_count = vowels.len();\n    let mut vowels_index = 0;\n    let\
    \ mut vowels_index2 = 0;\n    let mut vowels_index3 = 0;\n    let mut vowels_index4\
    \ = 0;\n    let mut vowels_index5 = 0;\n    let mut vowels_index6 = 0;\n    let\
    \ mut vowels_index7 = 0;\n    let mut vowels_index8 = 0;\n    let mut vowels_index9\
    \ = 0;\n    let mut vowels_index10 = 0;\n    let mut vowels_index11 = 0;\n   \
    \ let mut vowels_index12 = 0;\n    let mut vowels_index13 = 0;\n    let mut vowels_index14\
    \ = 0;\n    let mut vowels_index15 = 0;\n    let mut vowels_index16 = 0;\n   \
    \ let mut vowels_index17 = 0;\n    let mut vowels_index18 = 0;\n    let mut vowels_index19\
    \ = 0;\n    let mut vowels_index20 = 0;\n    let mut vowels_index21 = 0;\n   \
    \ let mut vowels_index22 = 0;\n    let mut vowels_index23 = 0;\n    let mut vowels_index24\
    \ = 0;\n    let mut vowels_index25 = 0;\n    let mut vowels_index26 = 0;\n   \
    \ let mut vowels_index27 = 0;\n    let mut vowels_index28 = 0;\n    let mut vowels_index29\
    \ = 0;\n    let mut vowels_index30 = 0;\n    let mut vowels_index31 = 0;\n   \
    \ let mut vowels_index32 = 0;\n    let mut vowels_index33 = 0;\n    let mut vowels_index34\
    \ = 0;\n    let mut vowels_index35 = 0;\n    let mut vowels_index36 = 0;\n   \
    \ let mut vowels_index37 = 0;\n    let mut vowels_index38 = 0;\n    let mut vowels_index39\
    \ = 0;\n    let mut vowels_index40 = 0;\n    let mut vowels_index41 = 0;\n   \
    \ let mut vowels_index42 = 0;\n    let mut vowels_index43 = 0;\n    let mut vowels_index44\
    \ = 0;\n    let mut vowels_index45 = 0;\n    let mut vowels_index46 = 0;\n   \
    \ let mut vowels_index47 = 0;\n    let mut vowels_index48 = 0;\n    let mut vowels_index49\
    \ = 0;\n    let mut vowels_index50 = 0;\n    let mut vowels_index51 = 0;\n\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp0ilk_vkg.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0ilk_vkg.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).count();\n \
    \   let mut vowels_idx_end = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).count();\n\
    \    vowels_idx_end += 1;\n    \n    if vowels_idx > vowels_idx_end {\n      \
    \  vowels_idx = 0;\n    }\n    \n    let mut vowels_idx = vowels_idx;\n    let\
    \ mut vowels_idx_end = vowels_idx_end;\n    \n    while vowels_idx < vowels_idx_end\
    \ {\n        if word.chars().nth(vowels_idx).unwrap().is_uppercase() {\n     \
    \       break;\n        }\n        vowels_idx += 1;\n    }\n    \n    let mut\
    \ vowels_idx = vowels_idx;\n    let mut vowels_idx_end = vowels_idx_end;\n   \
    \ \n    while vowels_idx < vowels_idx_end {\n        if word.chars().nth(vowels_idx).unwrap().is_lowercase()\
    \ {\n            break;\n        }\n        vowels_idx += 1;\n    }\n    \n  \
    \  if vowels_idx == 0 {\n        return String::from(\"\");\n    }\n    \n   \
    \ let mut vowels_idx = vowels_idx;\n    let mut vowels_idx_end = vowels_idx_end;\n\
    \    \n    while vowels_idx < vowels_idx_end {\n        if word.chars().nth(vowels_idx).unwrap().is_uppercase()\
    \ {\n            break;\n        }\n        vowels_idx += 1;\n    }\n    \n  \
    \  let mut vowels_idx = vowels_idx;\n    let mut vowels_idx_end = vowels_idx_end;\n\
    \    \n    while vowels_idx < vowels_idx_end {\n        if word.chars().nth(vowels_idx).unwrap().is_lowercase()\
    \ {\n            break;\n        }\n        vowels_idx += 1;\n    }\n    \n  \
    \  if vowels_idx == 0 {\n        return String::from(\"\");\n    }\n    \n   \
    \ let mut vowels_idx = vowels_idx;\n    let mut vowels_idx_end = vowels_idx_end;\n\
    \    \n    while vowels_idx < vowels_idx_end {\n        if word.chars().nth(vowels_idx).unwrap().is_uppercase()\
    \ {\n            break;\n        }\n        vowels_idx += 1;\n    }\n    \n  \
    \  let mut vowels_idx = vowels_idx;\n    let mut vowels_idx_end = vowels_idx_end;\n\
    \    \n    while vowels_idx < vowels_idx_end {\n        if word.chars().nth\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9r1s67go.rs:105:3\n\
    \    |\n15  | fn get_closest_vowel(word: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n86  |     while\
    \ vowels_idx < vowels_idx_end {\n    |                                       -\
    \ this delimiter might not be properly closed...\n87  |         if word.chars().nth\n\
    88  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    105 | }\n    |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp9r1s67go.rs:88:1\n\
    \   |\n87 |         if word.chars().nth\n   |         -- this `if` expression\
    \ has a condition, but no block\n88 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9r1s67go.rs:17:84\n   |\n17 |     let mut vowels_idx\
    \ = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).count();\n \
    \  |                                                                         \
    \           ^ expected `&&str`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9r1s67go.rs:18:88\n   |\n18 |     let mut vowels_idx_end = word.chars().enumerate().filter(|&(_,\
    \ c)| vowels.contains(c)).count();\n   |                                     \
    \                                                   ^ expected `&&str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9r1s67go.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_index = word.chars().enumerate().filter(|&(_, c)| vowels_set.contains(c)).next();\n\
    \    let mut vowels_index = vowels_index.unwrap();\n    let mut vowels_index =\
    \ vowels_index.0;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index\
    \ = vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowel\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb7zeawin.rs:58:33\n   |\n\
    58 |     let mut vowels_index = vowel\n   |                                 ^\
    \ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpb7zeawin.rs:17:26\n\
    \   |\n17 |     let mut vowels_set = HashSet::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `vowel` in this scope\n  --> /tmp/tmpb7zeawin.rs:58:28\n   |\n58 |   \
    \  let mut vowels_index = vowel\n   |                            ^^^^^ help: a\
    \ local variable with a similar name exists: `vowels`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb7zeawin.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_len = word.len();\n    let mut vowels_idx = word.len() - 1;\n   \
    \ let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len() -\
    \ 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpkejp4bqk.rs:62:1\n   |\n62\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpkejp4bqk.rs:61:31\n\
    \   |\n61 |     let mut vowels_idx = word.\n   |                             \
    \  ^ help: add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkejp4bqk.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count\
    \ = vec![0];\n    let \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmptafgi201.rs:63:1\n  \
    \ |\n63 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpkwnll7v_.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4x9c1taz.rs:46:35\n   |\n\
    46 |     let mut vowels_index = vowels_\n   |                                \
    \   ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `vowels_` in this scope\n  --> /tmp/tmp4x9c1taz.rs:46:28\n   |\n\
    46 |     let mut vowels_index = vowels_\n   |                            ^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels`\n\nerror[E0282]:\
    \ type annotations needed\n  --> /tmp/tmp4x9c1taz.rs:19:28\n   |\n18 |     let\
    \ mut vowels_index = vowels_index.iter().cloned().collect();\n   |         ----------------\
    \ consider giving `vowels_index` a type\n19 |     let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \   |                            ^^^^^^^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4x9c1taz.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplmi0a3js.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpirfoume3.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid_next = vowels_iter.next();\n    let mut vowels_mid_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next = vowels_iter.next();\n\
    \    let mut vowels_mid_next_next_next_next = vowels_iter.next();\n    let mut\
    \ vowels_mid_next_next_next_next_next = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmf4ey3wi.rs:42:44\n   |\n\
    42 |     let mut vowels_mid_next_next_next_next_\n   |                       \
    \                     ^ help: add `;` here\n43 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpmf4ey3wi.rs:15:39\n   |\n15 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |    -----------------     \
    \             ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplmi0a3js.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid_iter = vowels_mid.iter();\n    let mut vowels_mid_end\
    \ = vowels_mid_iter.next();\n    let mut vowels_mid_start = vowels_mid_iter.next();\n\
    \    let mut vowels_mid_mid = vowels_mid_iter.next();\n    let mut vowels_mid_mid_iter\
    \ = vowels_mid_mid.iter();\n    let mut vowels_mid_mid_end = vowels_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid\
    \ = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_start = vowels_mid_mid_mid_iter.next();\n    let mut\
    \ vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid_start = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_mid_iter = vowels_mid_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_mid_iter.next();\n    let mut\
    \ vowels_mid_mid_mid_mid_start = vowels_mid_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid_start = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_mid_iter = vowels_mid_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp65r0pmyg.rs:46:61\n   |\n\
    46 |     let mut vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_\n   |      \
    \                                                       ^ help: add `;` here\n\
    47 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `vowels_mid_mid_mid_`\
    \ in this scope\n  --> /tmp/tmp65r0pmyg.rs:46:42\n   |\n46 |     let mut vowels_mid_mid_mid_mid_end\
    \ = vowels_mid_mid_mid_\n   |                                          ^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels_mid_mid_mid`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp65r0pmyg.rs:15:39\n   |\n15 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |    -----------------     \
    \             ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n        vowels_set.insert(vowel);\n\
    \    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(&c.to_ascii_lowercase()) {\n            vowels_set.insert(c.to_ascii_lowercase());\n\
    \        }\n    });\n    vowels_set.iter().next().unwrap()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5ggc8ved.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp5ggc8ved.rs:21:26\n\
    \   |\n21 |     let mut vowels_set = HashSet::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len = word.len();\n    let mut vowels_idx_len\
    \ = vowels_len / 2;\n    let mut vowels_idx_left = vowels_len - vowels_idx_len;\n\
    \    let mut vowels_idx_right = vowels_len - vowels_idx_len - 1;\n    let mut\
    \ vowels_idx_left_idx = vowels_idx_left;\n    let mut vowels_idx_right_idx = vowels_idx_right;\n\
    \    let mut vowels_idx_left_len = vowels_idx_left;\n    let mut vowels_idx_right_len\
    \ = vowels_idx_right;\n    let mut vowels_idx_left_left_idx = vowels_idx_left_idx;\n\
    \    let mut vowels_idx_left_right_idx = vowels_idx_right_idx;\n    let mut vowels_idx_right_left_idx\
    \ = vowels_idx_right_idx;\n    let mut vowels_idx_right_right_idx = vowels_idx_right_idx;\n\
    \    let mut vowels_idx_left_left_len = vowels_idx_left_len;\n    let mut vowels_idx_left_right_len\
    \ = vowels_idx_right_len;\n    let mut vowels_idx_right_left_len = vowels_idx_right_len;\n\
    \    let mut vowels_idx_right_right_len = vowels_idx_right_len;\n    let mut vowels_idx_left_left_left_idx\
    \ = vowels_idx_left_left_idx;\n    let mut vowels_idx_left_left_right_idx = vowels_idx_left_right_idx;\n\
    \    let mut vowels_idx_left_right_left_idx = vowels_idx_right_left_idx;\n   \
    \ let mut vowels_idx_left_right_right_idx = vowels_idx_right_right_idx;\n    let\
    \ mut vowels_idx_right_left_left_idx = vowels_idx_right_left_idx;\n    let mut\
    \ vowels_idx_right_left_right_idx = vowels_idx_right_right_idx;\n    let mut vowels_idx_right_right_left_idx\
    \ = vowels_idx_right_right_idx;\n    let mut vowels_idx_right_right_right_idx\
    \ = vowels_idx_right_right_idx;\n    let mut vowels_idx_left_left_left_len = vowels_idx_left_left_len;\n\
    \    let mut vowels_idx_left_left_right_len = vowels_idx_left_right_len;\n   \
    \ let mut vowels_idx_left_right_left_len = vowels_idx_right_left_len;\n    let\
    \ mut vowels_idx_left_right_right_len = vowels_idx_right_right_len;\n    let mut\
    \ vowels_idx_right_left_left_len = vowels_idx_right_left_len;\n    let mut vowels_idx_right_left_right_len\
    \ = vowels_idx_right_right_len;\n    let mut vowels_\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf9xban1h.rs:48:20\n   |\n\
    48 |     let mut vowels_\n   |                    ^ help: add `;` here\n49 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf9xban1h.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index2\
    \ = vec![0];\n    let mut vowels_count_index3 = vec![0];\n    let mut vowels_count_index4\
    \ = vec![0];\n    let mut vowels_count_index5 = vec![0];\n    let mut vowels_count_index6\
    \ = vec![0];\n    let mut vowels_count_index7 = vec![0];\n    let mut vowels_count_index8\
    \ = vec![0];\n    let mut vowels_count_index9 = vec![0];\n    let mut vowels_count_index10\
    \ = vec![0];\n    let mut vowels_count_index11 = vec![0];\n    let mut vowels_count_index12\
    \ = vec![0];\n    let mut vowels_count_index13 = vec![0];\n    let mut vowels_count_index14\
    \ = vec![0];\n    let mut vowels_count_index15 = vec![0];\n    let mut vowels_count_index16\
    \ = vec![0];\n    let mut vowels_count_index17 = vec![0];\n    let mut vowels_count_index18\
    \ = vec![0];\n    let mut vowels_count_index19 = vec![0];\n    let mut vowels_count_index20\
    \ = vec![0];\n    let mut vowels_count_index21 = vec![0];\n    let mut vowels_count_index22\
    \ = vec![0];\n    let mut vowels_count_index23 = vec![0];\n    let mut vowels_count_index24\
    \ = vec![0];\n    let mut vowels_count_index25 = vec![0];\n    let mut vowels_count_index26\
    \ = vec![0];\n    let mut vowels_count_index27 = vec![0];\n    let mut vowels_count_index28\
    \ = vec![0];\n    let mut vowels_count_index29 = vec![0];\n    let mut vowels_count_index30\
    \ = vec![0];\n    let mut vowels_count_index31 = vec![0];\n    let mut vowels_count_index32\
    \ = vec![0];\n    let mut vowels_count_index33 = vec![0];\n    let mut vowels_count_index34\
    \ = vec![0];\n    let mut vowels_count_index35 = vec![0];\n    let mut vowels_count_index36\
    \ = vec![0];\n    let mut vowels_count_index37 = vec![0];\n    let mut vowels_count_index38\
    \ = vec![0];\n    let mut \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3_qsud6d.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpirfoume3.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|v| vowels_set.insert(v));\n \
    \   let mut vowels_count = vowels.len();\n    let mut vowel_found = false;\n \
    \   let mut vowel_pos = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos\
    \ = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let\
    \ mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let mut vowel_found\
    \ = false;\n    let mut vowel_pos = 0;\n    let mut vowel_found = false;\n   \
    \ let mut vowel_pos = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos\
    \ = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let\
    \ mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let mut vowel_found\
    \ = false;\n    let mut vowel_pos = 0;\n    let mut vowel_found = false;\n   \
    \ let mut vowel_pos = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos\
    \ = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let\
    \ mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let mut vowel_found\
    \ = false;\n    let mut vowel_pos = 0;\n    let mut vowel_found = false;\n   \
    \ let mut vowel_pos = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos\
    \ = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let\
    \ mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let mut vowel_found\
    \ = false;\n    let mut vowel_pos = 0;\n    let mut vowel_found = false;\n   \
    \ let mut vowel_pos = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos\
    \ = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let\
    \ mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let mut vowel_found\
    \ = false;\n    let mut vowel_pos = 0;\n    let mut vowel_found = false;\n   \
    \ let mut vowel_pos = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos\
    \ = 0;\n    let mut vowel_found = false;\n    let mut vowel_pos = 0;\n    let\
    \ mut vowel_found\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6nuiuebi.rs:76:24\n   |\n\
    76 |     let mut vowel_found\n   |                        ^ help: add `;` here\n\
    77 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmp6nuiuebi.rs:17:26\n   |\n17 |     let mut vowels_set\
    \ = HashSet::new();\n   |                          ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6nuiuebi.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).map(|(_, c)|\
    \ c).collect::<Vec<_>>();\n    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n\
    \    vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n    vowels_idx.reverse();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n    vowels_idx.reverse();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n    vowels_idx.reverse();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n    vowels_idx.reverse();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n    vowels_idx.reverse();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n    vowels_idx.reverse();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n    vowels_idx.reverse();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n    vowels_idx.reverse();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n    vowels_idx.reverse();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdv8ioya9.rs:17:84\n   |\n\
    17 |     let mut vowels_idx = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n   |                                          \
    \                                          ^ expected `&&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdv8ioya9.rs:19:39\n   |\n19 |  \
    \   vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n   |                 \
    \                      ^^^^^^^^^^^^^ expected `char`, found `usize`\n   |\n  \
    \ = note: expected reference `&char`\n              found reference `&usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdv8ioya9.rs:22:39\n   |\n22 |\
    \     vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n   |               \
    \                        ^^^^^^^^^^^^^ expected `char`, found `usize`\n   |\n\
    \   = note: expected reference `&char`\n              found reference `&usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdv8ioya9.rs:25:39\n   |\n25 |\
    \     vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n   |               \
    \                        ^^^^^^^^^^^^^ expected `char`, found `usize`\n   |\n\
    \   = note: expected reference `&char`\n              found reference `&usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdv8ioya9.rs:28:39\n   |\n28 |\
    \     vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n   |               \
    \                        ^^^^^^^^^^^^^ expected `char`, found `usize`\n   |\n\
    \   = note: expected reference `&char`\n              found reference `&usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdv8ioya9.rs:31:39\n   |\n31 |\
    \     vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n   |               \
    \                        ^^^^^^^^^^^^^ expected `char`, found `usize`\n   |\n\
    \   = note: expected reference `&char`\n              found reference `&usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdv8ioya9.rs:34:39\n   |\n34 |\
    \     vowels_idx.sort_by_key(|&x| x.cmp(&vowels.len()));\n   |               \
    \                        ^^^^^^^^^^^^^ expected `char`, found `usize`\n   |\n\
    \   = note: ex"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut vowels_count_end\
    \ = vec![0];\n    let mut vowels_count_start = vec![0];\n    let mut vowels_count_start_index\
    \ = vec![0];\n    let mut vowels_count_end_index = vec![0];\n    let mut vowels_count_start_end\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpggc5gs4d.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels_iter.skip(1);\n    let mut\
    \ vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaxbo5mb0.rs:55:11\n   |\n\
    55 |     let mu\n   |           ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxbo5mb0.rs:15:39\n \
    \  |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found2\
    \ = HashSet::new();\n    let mut vowels_found3 = HashSet::new();\n    let mut\
    \ vowels_found4 = HashSet::new();\n    let mut vowels_found5 = HashSet::new();\n\
    \    let mut vowels_found6 = HashSet::new();\n    let mut vowels_found7 = HashSet::new();\n\
    \    let mut vowels_found8 = HashSet::new();\n    let mut vowels_found9 = HashSet::new();\n\
    \    let mut vowels_found10 = HashSet::new();\n    let mut vowels_found11 = HashSet::new();\n\
    \    let mut vowels_found12 = HashSet::new();\n    let mut vowels_found13 = HashSet::new();\n\
    \    let mut vowels_found14 = HashSet::new();\n    let mut vowels_found15 = HashSet::new();\n\
    \    let mut vowels_found16 = HashSet::new();\n    let mut vowels_found17 = HashSet::new();\n\
    \    let mut vowels_found18 = HashSet::new();\n    let mut vowels_found19 = HashSet::new();\n\
    \    let mut vowels_found20 = HashSet::new();\n    let mut vowels_found21 = HashSet::new();\n\
    \    let mut vowels_found22 = HashSet::new();\n    let mut vowels_found23 = HashSet::new();\n\
    \    let mut vowels_found24 = HashSet::new();\n    let mut vowels_found25 = HashSet::new();\n\
    \    let mut vowels_found26 = HashSet::new();\n    let mut vowels_found27 = HashSet::new();\n\
    \    let mut vowels_found28 = HashSet::new();\n    let mut vowels_found29 = HashSet::new();\n\
    \    let mut vowels_found30 = HashSet::new();\n    let mut vowels_found31 = HashSet::new();\n\
    \    let mut vowels_found32 = HashSet::new();\n    let mut vowels_found33 = HashSet::new();\n\
    \    let mut vowels_found34 = HashSet::new();\n    let \n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpvttxjwbe.rs:56:1\n  \
    \ |\n56 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpvttxjwbe.rs:17:26\n   |\n17 |     let\
    \ mut vowels_set = HashSet::new();\n   |                          ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpvttxjwbe.rs:21:28\n   |\n21 |  \
    \   let mut vowels_found = HashSet::new();\n   |                            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvttxjwbe.rs:22:29\n   |\n22\
    \ |     let mut vowels_found2 = HashSet::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvttxjwbe.rs:23:29\n   |\n23\
    \ |     let mut vowels_found3 = HashSet::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvttxjwbe.rs:24:29\n   |\n24\
    \ |     let mut vowels_found4 = HashSet::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvttxjwbe.rs:25:29\n   |\n25\
    \ |     let mut vowels_found5 = HashSet::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvttxjwbe.rs:26:29\n   |\n26\
    \ |     let m"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_start.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_start.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpkwnll7v_.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).map(|(_, c)|\
    \ c).collect::<Vec<_>>();\n    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx\
    \ = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx =\
    \ vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx\
    \ = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx =\
    \ vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx\
    \ = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx =\
    \ vowels_idx.iter().cloned().collect\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0tkuz39v.rs:38:60\n   |\n\
    38 |     let mut vowels_idx = vowels_idx.iter().cloned().collect\n   |       \
    \                                                     ^ help: add `;` here\n39\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0tkuz39v.rs:17:84\n\
    \   |\n17 |     let mut vowels_idx = word.chars().enumerate().filter(|&(_, c)|\
    \ vowels.contains(c)).map(|(_, c)| c).collect::<Vec<_>>();\n   |             \
    \                                                                       ^ expected\
    \ `&&str`, found `char`\n\nerror[E0615]: attempted to take value of method `collect`\
    \ on type `Cloned<std::slice::Iter<'_, char>>`\n  --> /tmp/tmp0tkuz39v.rs:38:53\n\
    \   |\n38 |     let mut vowels_idx = vowels_idx.iter().cloned().collect\n   |\
    \                                                     ^^^^^^^ method, not a field\n\
    \   |\nhelp: use parentheses to call the method\n   |\n38 |     let mut vowels_idx\
    \ = vowels_idx.iter().cloned().collect()\n   |                               \
    \                             ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0tkuz39v.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0615.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index_len = vec![0];\n    let mut vowels_index_len_count\
    \ = vec![0];\n    let mut vowels_index_len_count2 = vec![0];\n    let mut vowels_index_len_count3\
    \ = vec![0];\n    let mut vowels_index_len_count4 = vec![0];\n    let mut vowels_index_len_count5\
    \ = vec![0];\n    let mut vowels_index_len_count6 = vec![0];\n    let mut vowels_index_len_count7\
    \ = vec![0];\n    let mut vowels_index_len_count8 = vec![0];\n    let mut vowels_index_len_count9\
    \ = vec![0];\n    let mut vowels_index_len_count10 = vec![0];\n    let mut vowels_index_len_count11\
    \ = vec![0];\n    let mut vowels_index_len_count12 = vec![0];\n    let mut vowels_index_len_count13\
    \ = vec![0];\n    let mut vowels_index_len_count14 = vec![0];\n    let mut vowels_index_len_count15\
    \ = vec![0];\n    let mut vowels_index_len_count16 = vec![0];\n    let mut vowels_index_len_count17\
    \ = vec![0];\n    let mut vowels_index_len_count18 = vec![0];\n    let mut vowels_index_len_count19\
    \ = vec![0];\n    let mut vowels_index_len_count20 = vec![0];\n    let mut vowels_index_len_count21\
    \ = vec![0];\n    let mut vowels_index_len_count22 = vec![0];\n    let mut vowels_index_len_count23\
    \ = vec![0];\n    let mut vowels_index_len_count24 = vec![0];\n    let mut vowels_index_len_count25\
    \ = vec![0];\n    let mut vowels_index_len_count26 = vec![0];\n    let mut vowels_index_len_count27\
    \ = vec![0];\n    let mut vowels_index_len_count28 = vec![0];\n    let mut vowels_index_len_count29\
    \ = vec![0];\n    let mut vowels_index_len_count30 = vec![0];\n    let mut vowels_index_len_count31\
    \ = vec![0];\n    let mut vowels_index_len_count32 = vec![0];\n    let mut vowels_index_len_count33\
    \ = vec![0];\n    let mut vowels_index_len_count34 = vec![0];\n    let mut vowels_index_len_count35\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprc2y652_.rs:53:37\n   |\n\
    53 |     let mut vowels_index_len_count35\n   |                              \
    \       ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprc2y652_.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4x9c1taz.rs:46:35\n   |\n\
    46 |     let mut vowels_index = vowels_\n   |                                \
    \   ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `vowels_` in this scope\n  --> /tmp/tmp4x9c1taz.rs:46:28\n   |\n\
    46 |     let mut vowels_index = vowels_\n   |                            ^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels`\n\nerror[E0282]:\
    \ type annotations needed\n  --> /tmp/tmp4x9c1taz.rs:19:28\n   |\n18 |     let\
    \ mut vowels_index = vowels_index.iter().cloned().collect();\n   |         ----------------\
    \ consider giving `vowels_index` a type\n19 |     let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \   |                            ^^^^^^^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4x9c1taz.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_mid = vowels.iter().rev();\n\
    \    let mut vowels_mid2 = vowels.iter().rev();\n    let mut vowels_mid3 = vowels.iter().rev();\n\
    \    let mut vowels_mid4 = vowels.iter().rev();\n    let mut vowels_mid5 = vowels.iter().rev();\n\
    \    let mut vowels_mid6 = vowels.iter().rev();\n    let mut vowels_mid7 = vowels.iter().rev();\n\
    \    let mut vowels_mid8 = vowels.iter().rev();\n    let mut vowels_mid9 = vowels.iter().rev();\n\
    \    let mut vowels_mid10 = vowels.iter().rev();\n    let mut vowels_mid11 = vowels.iter().rev();\n\
    \    let mut vowels_mid12 = vowels.iter().rev();\n    let mut vowels_mid13 = vowels.iter().rev();\n\
    \    let mut vowels_mid14 = vowels.iter().rev();\n    let mut vowels_mid15 = vowels.iter().rev();\n\
    \    let mut vowels_mid16 = vowels.iter().rev();\n    let mut vowels_mid17 = vowels.iter().rev();\n\
    \    let mut vowels_mid18 = vowels.iter().rev();\n    let mut vowels_mid19 = vowels.iter().rev();\n\
    \    let mut vowels_mid20 = vowels.iter().rev();\n    let mut vowels_mid21 = vowels.iter().rev();\n\
    \    let mut vowels_mid22 = vowels.iter().rev();\n    let mut vowels_mid23 = vowels.iter().rev();\n\
    \    let mut vowels_mid24 = vowels.iter().rev();\n    let mut vowels_mid25 = vowels.iter().rev();\n\
    \    let mut vowels_mid26 = vowels.iter().rev();\n    let mut vowels_mid27 = vowels.iter().rev();\n\
    \    let mut vowels_mid28 = vowels.iter().rev();\n    let mut vowels_mid29 = vowels.iter().rev();\n\
    \    let mut vowels_mid30 = vowels.iter().rev();\n    let mut vowels_mid31 = vowels.iter().rev();\n\
    \    let mut vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1gaubyu1.rs:51:18\n   |\n\
    51 |     let mut vowel\n   |                  ^ help: add `;` here\n52 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1gaubyu1.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jo_cctw.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index2\
    \ = vec![0];\n    let mut vowels_count_index3 = vec![0];\n    let mut vowels_count_index4\
    \ = vec![0];\n    let mut vowels_count_index5 = vec![0];\n    let mut vowels_count_index6\
    \ = vec![0];\n    let mut vowels_count_index7 = vec![0];\n    let mut vowels_count_index8\
    \ = vec![0];\n    let mut vowels_count_index9 = vec![0];\n    let mut vowels_count_index10\
    \ = vec![0];\n    let mut vowels_count_index11 = vec![0];\n    let mut vowels_count_index12\
    \ = vec![0];\n    let mut vowels_count_index13 = vec![0];\n    let mut vowels_count_index14\
    \ = vec![0];\n    let mut vowels_count_index15 = vec![0];\n    let mut vowels_count_index16\
    \ = vec![0];\n    let mut vowels_count_index17 = vec![0];\n    let mut vowels_count_index18\
    \ = vec![0];\n    let mut vowels_count_index19 = vec![0];\n    let mut vowels_count_index20\
    \ = vec![0];\n    let mut vowels_count_index21 = vec![0];\n    let mut vowels_count_index22\
    \ = vec![0];\n    let mut vowels_count_index23 = vec![0];\n    let mut vowels_count_index24\
    \ = vec![0];\n    let mut vowels_count_index25 = vec![0];\n    let mut vowels_count_index26\
    \ = vec![0];\n    let mut vowels_count_index27 = vec![0];\n    let mut vowels_count_index28\
    \ = vec![0];\n    let mut vowels_count_index29 = vec![0];\n    let mut vowels_count_index30\
    \ = vec![0];\n    let mut vowels_count_index31 = vec![0];\n    let mut vowels_count_index32\
    \ = vec![0];\n    let mut vowels_count_index33 = vec![0];\n    let mut vowels_count_index34\
    \ = vec![0];\n    let mut vowels_count_index35 = vec![0];\n    let mut vowels_count_index36\
    \ = vec![0];\n    let mut vowels_count_index37 = vec![0];\n    let mut vowels_count_index38\
    \ = vec![0];\n    let mut \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3_qsud6d.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index_end = vec![0];\n    let mut vowels_index_start\
    \ = vec![0];\n    let mut vowels_index_start_end = vec![0];\n    let mut vowels_index_start_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end = vec![0];\n    let mut\
    \ vowels_index_start_end_end_end_end = vec![0];\n    let mut vowels_index_start_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end = vec![0];\n\
    \    let mut vowels_index_start_end_end_end_end_end_end_end = vec![0];\n    let\
    \ mut vowels_index_start_end_end_end_end_end_end_end_end = vec![0];\n    let mut\
    \ vowels_index_start_end_end_end_end_end_end_end_end_end = vec![0];\n    let mut\
    \ vowels_index_start_end_end_end_end_end_end_end_end_end_end = vec![0];\n    let\
    \ mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end = vec![0];\n\
    \    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcenj1n95.rs:41:80\n   |\n\
    41 |     let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_\n\
    \   |                                                                        \
    \        ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcenj1n95.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwrxv4b5l.rs:59:33\n   |\n\
    59 |     let mut vowels_set = HashSet\n   |                                 ^\
    \ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpwrxv4b5l.rs:17:26\n\
    \   |\n17 |     let mut vowels_set = HashSet::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpwrxv4b5l.rs:21:26\n   |\n21\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpwrxv4b5l.rs:22:26\n   |\n22\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpwrxv4b5l.rs:23:26\n   |\n23\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpwrxv4b5l.rs:24:26\n   |\n24\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpwrxv4b5l.rs:25:26\n   |\n25\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared t"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count_index\
    \ = vec![0];\n    let mut vowels_index_count_index_count = vec![0];\n    let mut\
    \ vowels_index_count_index_count_index = vec![0];\n    let mut vowels_index_count_index_count_index_count\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index = vec![0];\n\
    \    let mut vowels_index_count_index_count_index_count_index_count = vec![0];\n\
    \    let mut vowels_index_count_index_count_index_count_index_count_index = vec![0];\n\
    \    let mut vowels_index_count_index_count_index_count_index_count_index_count\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![0];\n    let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpy0g64b0j.rs:41:122\n   |\n\
    41 |     let mut vowels_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_\n\
    \   |                                                                        \
    \                                                  ^ help: add `;` here\n42 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy0g64b0j.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index2\
    \ = vec![0];\n    let mut vowels_count_index3 = vec![0];\n    let mut vowels_count_index4\
    \ = vec![0];\n    let mut vowels_count_index5 = vec![0];\n    let mut vowels_count_index6\
    \ = vec![0];\n    let mut vowels_count_index7 = vec![0];\n    let mut vowels_count_index8\
    \ = vec![0];\n    let mut vowels_count_index9 = vec![0];\n    let mut vowels_count_index10\
    \ = vec![0];\n    let mut vowels_count_index11 = vec![0];\n    let mut vowels_count_index12\
    \ = vec![0];\n    let mut vowels_count_index13 = vec![0];\n    let mut vowels_count_index14\
    \ = vec![0];\n    let mut vowels_count_index15 = vec![0];\n    let mut vowels_count_index16\
    \ = vec![0];\n    let mut vowels_count_index17 = vec![0];\n    let mut vowels_count_index18\
    \ = vec![0];\n    let mut vowels_count_index19 = vec![0];\n    let mut vowels_count_index20\
    \ = vec![0];\n    let mut vowels_count_index21 = vec![0];\n    let mut vowels_count_index22\
    \ = vec![0];\n    let mut vowels_count_index23 = vec![0];\n    let mut vowels_count_index24\
    \ = vec![0];\n    let mut vowels_count_index25 = vec![0];\n    let mut vowels_count_index26\
    \ = vec![0];\n    let mut vowels_count_index27 = vec![0];\n    let mut vowels_count_index28\
    \ = vec![0];\n    let mut vowels_count_index29 = vec![0];\n    let mut vowels_count_index30\
    \ = vec![0];\n    let mut vowels_count_index31 = vec![0];\n    let mut vowels_count_index32\
    \ = vec![0];\n    let mut vowels_count_index33 = vec![0];\n    let mut vowels_count_index34\
    \ = vec![0];\n    let mut vowels_count_index35 = vec![0];\n    let mut vowels_count_index36\
    \ = vec![0];\n    let mut vowels_count_index37 = vec![0];\n    let mut vowels_count_index38\
    \ = vec![0];\n    let mut \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3_qsud6d.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels_iter.skip_while(|&x| !word.contains(&x));\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_letter());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_upper());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_lower());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_digit());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_symbol());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_whitespace());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_newline());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_hex());\n \
    \   let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_control());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_print());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_punct());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_graph());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_print());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_graph());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_print());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_graph());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_print());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_graph());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_print());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_graph());\n\
    \    let mut vowels_iter = vowels_iter.skip_while(|&x| !x.is_ascii_\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpeej1t8bj.rs:40:1\n   |\n40 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpeej1t8bj.rs:39:49\n   |\n15 | fn get_closest_vowel(word: String) ->\
    \ String {\n   |                                              - closing delimiter\
    \ possibly meant for this\n...\n39 |     let mut vowels_iter = vowels_iter.skip_while(|&x|\
    \ !x.is_ascii_\n   |                                                 ^ unclosed\
    \ delimiter\n40 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `str`\n  --> /tmp/tmpeej1t8bj.rs:18:70\n   |\n\
    18 |     let mut vowels_iter = vowels_iter.skip_while(|&x| !word.contains(&x));\n\
    \   |                                                                      ^^\
    \ expected an `Fn<(char,)>` closure, found `str`\n   |\n   = help: the trait `Fn<(char,)>`\
    \ is not implemented for `str`\n   = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&str`\n   = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&&&str`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for reference `&&str` in the current\
    \ scope\n  --> /tmp/tmpeej1t8bj.rs:19:58\n   |\n19 |     let mut vowels_iter =\
    \ vowels_iter.skip_while(|&x| !x.is_ascii_letter());\n   |                   \
    \                                       ^^^^^^^^^^^^^^^ method not found in `&&str`\n\
    \nerror[E0599]: no method named `is_ascii_upper` found for reference `&&str` in\
    \ the current scope\n  --> /tmp/tmpeej1t8bj.rs:20:58\n   |\n20 |     let mut vowels_iter\
    \ = vowels_iter.skip_while(|&x| !x.is_ascii_upper());\n   |                  \
    \                                        ^^^^^^^^^^^^^^ method not found in `&&str`\n\
    \nerror[E0599]: no method named `is_ascii_lower` found for reference `&&str` in\
    \ the current scope\n  --> /tmp/tmpeej1t8bj.rs:21:58\n   |\n21 |     let mut vowels_iter\
    \ = vowels_iter.skip_while(|&x| !x.is_ascii_lower());\n   |                  \
    \                     "
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_middle = vowels_iter.next();\n\
    \    let mut vowels_next = vowels_iter.next();\n    let mut vowels_prev = vowels_iter.next();\n\
    \    let mut vowels_first = vowels_iter.next();\n    let mut vowels_last = vowels_iter.next();\n\
    \    let mut vowels_first_next = vowels_iter.next();\n    let mut vowels_last_next\
    \ = vowels_iter.next();\n    let mut vowels_first_prev = vowels_iter.next();\n\
    \    let mut vowels_last_prev = vowels_iter.next();\n    let mut vowels_first_first_next\
    \ = vowels_iter.next();\n    let mut vowels_last_first_next = vowels_iter.next();\n\
    \    let mut vowels_first_last_next = vowels_iter.next();\n    let mut vowels_first_last_prev\
    \ = vowels_iter.next();\n    let mut vowels_last_last_prev = vowels_iter.next();\n\
    \    let mut vowels_first_first_prev = vowels_iter.next();\n    let mut vowels_last_first_prev\
    \ = vowels_iter.next();\n    let mut vowels_first_last_last_prev = vowels_iter.next();\n\
    \    let mut vowels_last_last_prev = vowels_iter.next();\n    let mut vowels_first_first_last_prev\
    \ = vowels_iter.next();\n    let mut vowels_last_first_last_prev = vowels_iter.next();\n\
    \    let mut vowels_first_last_last_last_prev = vowels_iter.next();\n    let mut\
    \ vowels_last_last_last_prev = vowels_iter.next();\n    let mut vowels_first_first_last_last_prev\
    \ = vowels_iter.next();\n    let mut vowels_last_first_last_last_prev = vowels_iter.next();\n\
    \    let mut vowels_first_last_last_last_last_prev = vowels_iter.next();\n   \
    \ let mut vowels_last_last_last_last_prev = vowels_iter.next();\n    let mut vowels_first_first_last_last_last_prev\
    \ = vowels_iter.next();\n    let mut vowels_last_first_last_last_last_prev = vowels_iter.next();\n\
    \    let mut vowels_first_last_last_last_last_last_prev = vowels_iter.next();\n\
    \    let mut vowels_last_last_last_last_last_prev = vowels_iter.next();\n    let\
    \ mut vowels_first_first_last_last_last_last_prev = vowels_iter.next();\n    let\
    \ mut vowels_last_first_last_last_last_last_prev = vowels_iter.next();\n    let\
    \ mut vowels_first_last_last_last_last_last_last_prev = vowels_iter.next();\n\
    \    let mut vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1h3rmc1v.rs:53:18\n   |\n\
    53 |     let mut vowel\n   |                  ^ help: add `;` here\n54 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1h3rmc1v.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len = vowels.len();\n    let mut\
    \ vowels_idx_len = vowels_idx.len();\n    let mut vowels_idx_start = vowels_idx[0];\n\
    \    let mut vowels_idx_end = vowels_idx[vowels_idx_len - 1];\n    let mut vowels_idx_cur\
    \ = vowels_idx[0];\n    let mut vowels_idx_next = vowels_idx[0];\n    let mut\
    \ vowels_idx_prev = vowels_idx[0];\n    let mut vowels_idx_last_next = vowels_idx[0];\n\
    \    let mut vowels_idx_last_prev = vowels_idx[0];\n    let mut vowels_idx_last_cur\
    \ = vowels_idx[0];\n    let mut vowels_idx_last_last_next = vowels_idx[0];\n \
    \   let mut vowels_idx_last_last_prev = vowels_idx[0];\n    let mut vowels_idx_last_last_cur\
    \ = vowels_idx[0];\n    let mut vowels_idx_last_last_last_next = vowels_idx[0];\n\
    \    let mut vowels_idx_last_last_last_prev = vowels_idx[0];\n    let mut vowels_idx_last_last_last_cur\
    \ = vowels_idx[0];\n    let mut vowels_idx_last_last_last_last_next = vowels_idx[0];\n\
    \    let mut vowels_idx_last_last_last_last_prev = vowels_idx[0];\n    let mut\
    \ vowels_idx_last_last_last_last_cur = vowels_idx[0];\n    let mut vowels_idx_last_last_last_last_last_next\
    \ = vowels_idx[0];\n    let mut vowels_idx_last_last_last_last_last_prev = vowels_idx[0];\n\
    \    let mut vowels_idx_last_last_last_last_last_cur = vowels_idx[0];\n    let\
    \ mut vowels_idx_last_last_last_last_last_last_next = vowels_idx[0];\n    let\
    \ mut vowels_idx_last_last_last_last_last_last_prev = vowels_idx[0];\n    let\
    \ mut vowels_idx_last_last_last_last_last_last_cur = vowels_idx[0];\n    let mut\
    \ vowels_idx_last_last_last_last_last_last_last_next = vowels_idx[0];\n    let\
    \ mut vowels_idx_last_last_last_last_last_last_last_prev = vowels_idx[0];\n  \
    \  let mut vowels_idx_last_last_last_last_last_last_last_cur = vowels_idx[0];\n\
    \    let mut vowels_idx_last_last_last_last_last_last_last_last_next = vowels_idx[0];\n\
    \    let mut vowels_idx_last_last_last_last_last_last_last_last_prev = vowels_idx[0];\n\
    \    let mut vowels_idx_last_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd29quyek.rs:48:29\n   |\n\
    48 |     let mut vowels_idx_last_\n   |                             ^ help: add\
    \ `;` here\n49 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd29quyek.rs:15:39\n   |\n15 | fn get_closest_vowel(word: String)\
    \ -> String {\n   |    -----------------                  ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|v| vowels_set.insert(v));\n \
    \   let mut vowels_iter = word.chars().skip_while(|&c| vowels_set.contains(c));\n\
    \    let mut vowels_iter2 = vowels_iter.clone();\n    let mut vowels_iter3 = vowels_iter.clone();\n\
    \    let mut vowels_iter4 = vowels_iter.clone();\n    let mut vowels_iter5 = vowels_iter.clone();\n\
    \    let mut vowels_iter6 = vowels_iter.clone();\n    let mut vowels_iter7 = vowels_iter.clone();\n\
    \    let mut vowels_iter8 = vowels_iter.clone();\n    let mut vowels_iter9 = vowels_iter.clone();\n\
    \    let mut vowels_iter10 = vowels_iter.clone();\n    let mut vowels_iter11 =\
    \ vowels_iter.clone();\n    let mut vowels_iter12 = vowels_iter.clone();\n   \
    \ let mut vowels_iter13 = vowels_iter.clone();\n    let mut vowels_iter14 = vowels_iter.clone();\n\
    \    let mut vowels_iter15 = vowels_iter.clone();\n    let mut vowels_iter16 =\
    \ vowels_iter.clone();\n    let mut vowels_iter17 = vowels_iter.clone();\n   \
    \ let mut vowels_iter18 = vowels_iter.clone();\n    let mut vowels_iter19 = vowels_iter.clone();\n\
    \    let mut vowels_iter20 = vowels_iter.clone();\n    let mut vowels_iter21 =\
    \ vowels_iter.clone();\n    let mut vowels_iter22 = vowels_iter.clone();\n   \
    \ let mut vowels_iter23 = vowels_iter.clone();\n    let mut vowels_iter24 = vowels_iter.clone();\n\
    \    let mut vowels_iter25 = vowels_iter.clone();\n    let mut vowels_iter26 =\
    \ vowels_iter.clone();\n    let mut vowels_iter27 = vowels_iter.clone();\n   \
    \ let mut vowels_iter28 = vowels_iter.clone();\n    let mut vowels_iter29 = vowels_iter.clone();\n\
    \    let mut vowels_iter30 = vowels_iter.clone();\n    let mut vowels_iter31 =\
    \ vowels_iter.clone();\n    let mut vowels_iter32 = vowels_iter.clone();\n   \
    \ let mut vowels_iter33 = vowels_iter.clone();\n    let mut vowels_iter34 = vowels_iter.clone();\n\
    \    let mut vowels_iter35 = vowels_iter.clone();\n    let mut vowels_iter36 =\
    \ vowels_iter.clone();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpz6e9_u3z.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz6e9_u3z.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4x9c1taz.rs:46:35\n   |\n\
    46 |     let mut vowels_index = vowels_\n   |                                \
    \   ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `vowels_` in this scope\n  --> /tmp/tmp4x9c1taz.rs:46:28\n   |\n\
    46 |     let mut vowels_index = vowels_\n   |                            ^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels`\n\nerror[E0282]:\
    \ type annotations needed\n  --> /tmp/tmp4x9c1taz.rs:19:28\n   |\n18 |     let\
    \ mut vowels_index = vowels_index.iter().cloned().collect();\n   |         ----------------\
    \ consider giving `vowels_index` a type\n19 |     let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \   |                            ^^^^^^^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4x9c1taz.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp3vdr26mq.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplmi0a3js.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut consonants_set = HashSet::new();\n\
    \    for consonant in consonants.iter() {\n        consonants_set.insert(consonant);\n\
    \    }\n    let mut vowels_count = word.chars().filter(|c| vowels_set.contains(c)).count();\n\
    \    let mut consonants_count = word.chars().filter(|c| consonants_set.contains(c)).count();\n\
    \    let mut vowel_pos = word.chars().filter(|c| vowels_set.contains(c)).count();\n\
    \    let mut consonant_pos = word.chars().filter(|c| consonants_set.contains(c)).count();\n\
    \    let mut vowel_pos = word.chars().filter(|c| vowels_set.contains(c)).count();\n\
    \    let mut consonant_pos = word.chars().filter(|c| consonants_set.contains(c)).count();\n\
    \    let mut vowel_pos = word.chars().filter(|c| vowels_set.contains(c)).count();\n\
    \    let mut consonant_pos = word.chars().filter(|c| consonants_set.contains(c)).count();\n\
    \    while vowel_pos > 0 || consonant_pos > 0 {\n        if vowel_pos > 0 {\n\
    \            if vowel_pos == vowels_count {\n                vowels_count += 1;\n\
    \                vowel_pos -= 1;\n            } else {\n                vowels_count\
    \ += 1;\n                vowel_pos -= 1;\n            }\n        }\n        if\
    \ consonant_pos > 0 {\n            if consonant_pos == consonants_count {\n  \
    \              consonants_count += 1;\n                consonant_pos -= 1;\n \
    \           } else {\n                consonants_count += 1;\n               \
    \ consonant_pos -= 1;\n            }\n        }\n    }\n    if vowel_pos == 0\
    \ {\n        String::from(\"\")\n    } else if consonant_pos == 0 {\n        String::from(\"\
    \")\n    } else {\n        let mut vowel_pos = word.chars().filter(|c| vowels_set.contains(c)).count();\n\
    \        let mut consonant_pos = word.chars().filter(\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprdk3fc7g.rs:78:3\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n58 |     } else {\n\
    \   |            - this delimiter might not be properly closed...\n...\n61 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n78 | }\n\
    \   |   ^\n\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found\
    \ `}`\n  --> /tmp/tmprdk3fc7g.rs:61:1\n   |\n61 | }\n   | ^ expected one of `.`,\
    \ `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmprdk3fc7g.rs:60:52\n   |\n15 | fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                              - closing delimiter\
    \ possibly meant for this\n...\n60 |         let mut consonant_pos = word.chars().filter(\n\
    \   |                                                    ^ unclosed delimiter\n\
    61 | }\n   | ^ mismatched closing delimiter\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmprdk3fc7g.rs:17:26\n   |\n17\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmprdk3fc7g.rs:22:30\n   |\n22\
    \ |     let mut consonants_set = HashSet::new();\n   |                       \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprdk3fc7g.rs:55:9\n   |\n54 | /     if vowel_pos == 0 {\n55 | |\
    \         String::from(\"\")\n   | |         ^^^^^^^^^^^^^^^^ expected `()`, found\
    \ struct `String`\n56 | |     } else if consonant_pos == 0 {\n57 | |         String::from(\"\
    \")\n...  |\n60 | |         let mut consonant_pos = word.chars().filter(\n61 |\
    \ | }\n   | |_- expected this to be `()`\n   |\nhelp: consider using a semicolon\
    \ here\n   |\n55 |         String::from(\"\");\n   |  "
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4x9c1taz.rs:46:35\n   |\n\
    46 |     let mut vowels_index = vowels_\n   |                                \
    \   ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `vowels_` in this scope\n  --> /tmp/tmp4x9c1taz.rs:46:28\n   |\n\
    46 |     let mut vowels_index = vowels_\n   |                            ^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels`\n\nerror[E0282]:\
    \ type annotations needed\n  --> /tmp/tmp4x9c1taz.rs:19:28\n   |\n18 |     let\
    \ mut vowels_index = vowels_index.iter().cloned().collect();\n   |         ----------------\
    \ consider giving `vowels_index` a type\n19 |     let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \   |                            ^^^^^^^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4x9c1taz.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).map(|(_, c)|\
    \ c).collect::<Vec<_>>();\n    vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx\
    \ = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx =\
    \ vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx\
    \ = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx =\
    \ vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx\
    \ = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx =\
    \ vowels_idx.iter().cloned().collect::<\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `>`, a const expression, lifetime, or type, found\
    \ `}`\n  --> /tmp/tmp_2uxajwn.rs:39:1\n   |\n38 |     let mut vowels_idx = vowels_idx.iter().cloned().collect::<\n\
    \   |                                                               - expected\
    \ one of `>`, a const expression, lifetime, or type\n39 | }\n   | ^ unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_2uxajwn.rs:17:84\n \
    \  |\n17 |     let mut vowels_idx = word.chars().enumerate().filter(|&(_, c)|\
    \ vowels.contains(c)).map(|(_, c)| c).collect::<Vec<_>>();\n   |             \
    \                                                                       ^ expected\
    \ `&&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_index = word.chars().enumerate().filter(|&(_, c)| vowels_set.contains(c)).collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    vowels_index.sort();\n    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyzpe2lby.rs:42:33\n   |\n\
    42 |     let mut vowels_index = vowel\n   |                                 ^\
    \ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpyzpe2lby.rs:17:26\n\
    \   |\n17 |     let mut vowels_set = HashSet::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `vowel` in this scope\n  --> /tmp/tmpyzpe2lby.rs:42:28\n   |\n42 |   \
    \  let mut vowels_index = vowel\n   |                            ^^^^^ help: a\
    \ local variable with a similar name exists: `vowels`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyzpe2lby.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp3vdr26mq.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|v| vowels_set.insert(v));\n \
    \   let mut vowels_index = word.chars().enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_, c)| vowels_set.contains(c));\n\
    \    let mut vowels_index = vowels_index.enumerate().filter(|&(_\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `:` or `|`, found `)`\n  --> /tmp/tmp301n5b9n.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected one of `:` or `|`\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmp301n5b9n.rs:37:62\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                              - closing\
    \ delimiter possibly meant for this\n...\n37 |     let mut vowels_index = vowels_index.enumerate().filter(|&(_\n\
    \   |                                                              ^ unclosed\
    \ delimiter\n38 | }\n   | ^ mismatched closing delimiter\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp301n5b9n.rs:17:26\n\
    \   |\n17 |     let mut vowels_set = HashSet::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels {\n        vowels_set.insert(vowel.to_string());\n\
    \    }\n    let mut vowels_set2 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set2.insert(vowel.to_string());\n    }\n    let mut vowels_set3\
    \ = HashSet::new();\n    for vowel in vowels {\n        vowels_set3.insert(vowel.to_string());\n\
    \    }\n    let mut vowels_set4 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set4.insert(vowel.to_string());\n    }\n    let mut vowels_set5\
    \ = HashSet::new();\n    for vowel in vowels {\n        vowels_set5.insert(vowel.to_string());\n\
    \    }\n    let mut vowels_set6 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set6.insert(vowel.to_string());\n    }\n    let mut vowels_set7\
    \ = HashSet::new();\n    for vowel in vowels {\n        vowels_set7.insert(vowel.to_string());\n\
    \    }\n    let mut vowels_set8 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set8.insert(vowel.to_string());\n    }\n    let mut vowels_set9\
    \ = HashSet::new();\n    for vowel in vowels {\n        vowels_set9.insert(vowel.to_string());\n\
    \    }\n    let mut vowels_set10 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set10.insert(vowel.to_string());\n    }\n    let mut vowels_set11\
    \ = HashSet::new();\n    for vowel in vowels {\n        vowels_set11.insert(vowel.to_string());\n\
    \    }\n    let mut vowels_set12 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set12.insert(vowel.to_string());\n    }\n    let mut vowels_set13\
    \ = HashSet::new();\n    for vowel in vowels {\n        vowels_set13.insert(vowel.to_string());\n\
    \    }\n    let mut vowels_set14 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set14.insert(vowel.to_string());\n    }\n    let mut vowels_set15\
    \ = HashSet::new();\n    for vowel in vowels {\n        vowels_set15.insert(vowel.to_string());\n\
    \    }\n    let mut vowels_set16 = HashSet::new();\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpabx3qor_.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpabx3qor_.rs:21:27\n\
    \   |\n21 |     let mut vowels_set2 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpabx3qor_.rs:25:27\n\
    \   |\n25 |     let mut vowels_set3 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpabx3qor_.rs:29:27\n\
    \   |\n29 |     let mut vowels_set4 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpabx3qor_.rs:33:27\n\
    \   |\n33 |     let mut vowels_set5 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpabx3qor_.rs:37:27\n\
    \   |\n37 |     let mut vowels_set6 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpabx3qor_.rs:41:27\n\
    \   |\n41 |     let mut vowels_set7 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider impor"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels_iter.cloned();\n    let mut\
    \ vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprgvqk985.rs:55:11\n   |\n\
    55 |     let mu\n   |           ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: the trait bound `str: Clone` is not satisfied\n  -->\
    \ /tmp/tmprgvqk985.rs:19:39\n   |\n19 |     let mut vowels_iter = vowels_iter.cloned();\n\
    \   |                                       ^^^^^^ the trait `Clone` is not implemented\
    \ for `str`\n\nerror[E0599]: the method `cloned` exists for struct `Cloned<Cloned<std::slice::Iter<'_,\
    \ &str>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmprgvqk985.rs:20:39\n\
    \   |\n20 |       let mut vowels_iter = vowels_iter.cloned();\n   |          \
    \                               ^^^^^^ method cannot be called on `Cloned<Cloned<std::slice::Iter<'_,\
    \ &str>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `Cloned<Cloned<std::slice::Iter<'_, &str>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Cloned<std::slice::Iter<'_,\
    \ &str>>>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprgvqk985.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp3vdr26mq.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid_iter = vowels_mid.iter();\n    let mut vowels_mid_end\
    \ = vowels_mid_iter.next();\n    let mut vowels_mid_start = vowels_mid_iter.next();\n\
    \    let mut vowels_mid_mid = vowels_mid_iter.next();\n    let mut vowels_mid_mid_iter\
    \ = vowels_mid_mid.iter();\n    let mut vowels_mid_mid_end = vowels_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid\
    \ = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_start = vowels_mid_mid_mid_iter.next();\n    let mut\
    \ vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid_start = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_mid_iter = vowels_mid_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_mid_iter.next();\n    let mut\
    \ vowels_mid_mid_mid_mid_start = vowels_mid_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid_start = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_mid_iter = vowels_mid_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp65r0pmyg.rs:46:61\n   |\n\
    46 |     let mut vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_\n   |      \
    \                                                       ^ help: add `;` here\n\
    47 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `vowels_mid_mid_mid_`\
    \ in this scope\n  --> /tmp/tmp65r0pmyg.rs:46:42\n   |\n46 |     let mut vowels_mid_mid_mid_mid_end\
    \ = vowels_mid_mid_mid_\n   |                                          ^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels_mid_mid_mid`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp65r0pmyg.rs:15:39\n   |\n15 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |    -----------------     \
    \             ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoox48snd.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_set2 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set2.insert(vowel);\n    }\n    let mut vowels_set3 = HashSet::new();\n\
    \    for vowel in vowels {\n        vowels_set3.insert(vowel);\n    }\n    let\
    \ mut vowels_set4 = HashSet::new();\n    for vowel in vowels {\n        vowels_set4.insert(vowel);\n\
    \    }\n    let mut vowels_set5 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set5.insert(vowel);\n    }\n    let mut vowels_set6 = HashSet::new();\n\
    \    for vowel in vowels {\n        vowels_set6.insert(vowel);\n    }\n    let\
    \ mut vowels_set7 = HashSet::new();\n    for vowel in vowels {\n        vowels_set7.insert(vowel);\n\
    \    }\n    let mut vowels_set8 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set8.insert(vowel);\n    }\n    let mut vowels_set9 = HashSet::new();\n\
    \    for vowel in vowels {\n        vowels_set9.insert(vowel);\n    }\n    let\
    \ mut vowels_set10 = HashSet::new();\n    for vowel in vowels {\n        vowels_set10.insert(vowel);\n\
    \    }\n    let mut vowels_set11 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set11.insert(vowel);\n    }\n    let mut vowels_set12 = HashSet::new();\n\
    \    for vowel in vowels {\n        vowels_set12.insert(vowel);\n    }\n    let\
    \ mut vowels_set13 = HashSet::new();\n    for vowel in vowels {\n        vowels_set13.insert(vowel);\n\
    \    }\n    let mut vowels_set14 = HashSet::new();\n    for vowel in vowels {\n\
    \        vowels_set14.insert(vowel);\n    }\n    let mut vowels_set15 = HashSet::new();\n\
    \    for vowel in vowels {\n        vowels_set15.insert(vowel);\n    }\n    let\
    \ mut vowels_set16 = HashSet::new();\n    for vowel in vowels {\n        vowels_set16.insert(vowel);\n\
    \    }\n    let mut vowels_set17 = HashSet::new\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmper8pohmq.rs:81:40\n   |\n\
    81 |     let mut vowels_set17 = HashSet::new\n   |                           \
    \             ^ help: add `;` here\n82 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmper8pohmq.rs:81:28\n\
    \   |\n81 |     let mut vowels_set17 = HashSet::new\n   |                    \
    \        ^^^^^^^ use of undeclared type `HashSet`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmper8pohmq.rs:17:26\n   |\n17\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmper8pohmq.rs:21:27\n   |\n21\
    \ |     let mut vowels_set2 = HashSet::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmper8pohmq.rs:25:27\n   |\n25\
    \ |     let mut vowels_set3 = HashSet::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmper8pohmq.rs:29:27\n   |\n29\
    \ |     let mut vowels_set4 = HashSet::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmper8pohmq.rs:33:27\n   |\n33\
    \ |     let mut vowels_set5 = HashSet::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmper8pohmq.rs:37:27\n   |\n37\
    \ | "
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jo_cctw.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4x9c1taz.rs:46:35\n   |\n\
    46 |     let mut vowels_index = vowels_\n   |                                \
    \   ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `vowels_` in this scope\n  --> /tmp/tmp4x9c1taz.rs:46:28\n   |\n\
    46 |     let mut vowels_index = vowels_\n   |                            ^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels`\n\nerror[E0282]:\
    \ type annotations needed\n  --> /tmp/tmp4x9c1taz.rs:19:28\n   |\n18 |     let\
    \ mut vowels_index = vowels_index.iter().cloned().collect();\n   |         ----------------\
    \ consider giving `vowels_index` a type\n19 |     let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \   |                            ^^^^^^^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4x9c1taz.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj928mecv.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj928mecv.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoox48snd.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jo_cctw.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels_iter.skip(1);\n    let mut\
    \ vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaxbo5mb0.rs:55:11\n   |\n\
    55 |     let mu\n   |           ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxbo5mb0.rs:15:39\n \
    \  |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found =\
    \ HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdlk08u6z.rs:59:40\n   |\n\
    59 |     let mut vowels_found = HashSet::new\n   |                           \
    \             ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpdlk08u6z.rs:59:28\n\
    \   |\n59 |     let mut vowels_found = HashSet::new\n   |                    \
    \        ^^^^^^^ use of undeclared type `HashSet`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdlk08u6z.rs:17:26\n   |\n17\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdlk08u6z.rs:21:28\n   |\n21\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdlk08u6z.rs:22:28\n   |\n22\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdlk08u6z.rs:23:28\n   |\n23\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdlk08u6z.rs:24:28\n   |\n24\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdlk08u6z.rs:25:28\n  "
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).next();\n  \
    \  let mut vowels_idx = vowels_idx.unwrap();\n    let mut vowels_idx = vowels_idx.1;\n\
    \    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = vowels_idx - 1;\n    let mut vowels_idx = vowels_idx\
    \ - 1;\n    let mut vowels_idx = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpf1q6r7q7.rs:61:1\n\
    \   |\n61 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf1q6r7q7.rs:17:84\n   |\n17 |     let mut vowels_idx = word.chars().enumerate().filter(|&(_,\
    \ c)| vowels.contains(c)).next();\n   |                                      \
    \                                              ^ expected `&&str`, found `char`\n\
    \nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpf1q6r7q7.rs:20:37\n\
    \   |\n20 |     let mut vowels_idx = vowels_idx - 1;\n   |                   \
    \       ---------- ^ - {integer}\n   |                          |\n   |      \
    \                    char\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n        vowels_set.insert(vowel);\n\
    \    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(&c.to_ascii_lowercase()) {\n            vowels_set.insert(c.to_ascii_lowercase());\n\
    \        }\n    });\n    vowels_set.iter().next().unwrap()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5ggc8ved.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp5ggc8ved.rs:21:26\n\
    \   |\n21 |     let mut vowels_set = HashSet::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n        vowels_set.insert(vowel.to_lowercase());\n\
    \    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_lowercase()) {\n            vowels_set.insert(c.to_lowercase());\n\
    \        }\n    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_lowercase()) {\n            vowels_set.insert(c.to_lowercase());\n\
    \        }\n    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_lowercase()) {\n            vowels_set.insert(c.to_lowercase());\n\
    \        }\n    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_lowercase()) {\n            vowels_set.insert(c.to_lowercase());\n\
    \        }\n    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_lowercase()) {\n            vowels_set.insert(c.to_lowercase());\n\
    \        }\n    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_lowercase()) {\n            vowels_set.insert(c.to_lowercase());\n\
    \        }\n    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_lowercase()) {\n            vowels_set.insert(c.to_lowercase());\n\
    \        }\n    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_lowercase()) {\n            vowels_set.insert(c.to_lowercase());\n\
    \        }\n    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_lowercase()) {\n            vowels_set.insert(c.to_lowercase());\n\
    \        }\n    });\n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_lowercase()) {\n            vowel\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfzfdulni.rs:96:3\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n76 |     word.chars().for_each(|c|\
    \ {\n   |                          -    - unclosed delimiter\n   |           \
    \               |\n   |                          unclosed delimiter\n77 |    \
    \     if vowels_set.contains(c.to_lowercase()) {\n   |                       \
    \                           - this delimiter might not be properly closed...\n\
    78 |             vowel\n79 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n96 | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpfzfdulni.rs:17:26\n   |\n17 |     let\
    \ mut vowels_set = HashSet::new();\n   |                          ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpfzfdulni.rs:21:26\n   |\n21 |  \
    \   let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpfzfdulni.rs:27:26\n   |\n27\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpfzfdulni.rs:33:26\n   |\n33\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpfzfdulni.rs:39:26\n   |\n39\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not "
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect();\n    let mut vowels_index\
    \ = vowels_index.iter().cloned().collect();\n    let mut vowels_\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzc3iwiph.rs:46:20\n   |\n\
    46 |     let mut vowels_\n   |                    ^ help: add `;` here\n47 | }\n\
    \   | - unexpected token\n\nerror[E0282]: type annotations needed\n  --> /tmp/tmpzc3iwiph.rs:19:28\n\
    \   |\n18 |     let mut vowels_index = vowels_index.iter().cloned().collect();\n\
    \   |         ---------------- consider giving `vowels_index` a type\n19 |   \
    \  let mut vowels_index = vowels_index.iter().cloned().collect();\n   |      \
    \                      ^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must\
    \ be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzc3iwiph.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308.\nFor more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_set2 = HashSet::new();\n    for vowel in vowels.iter()\
    \ {\n        vowels_set2.insert(vowel);\n    }\n    let mut vowels_set3 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set3.insert(vowel);\n    }\n\
    \    let mut vowels_set4 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set4.insert(vowel);\n    }\n    let mut vowels_set5 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set5.insert(vowel);\n    }\n\
    \    let mut vowels_set6 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set6.insert(vowel);\n    }\n    let mut vowels_set7 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set7.insert(vowel);\n    }\n\
    \    let mut vowels_set8 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set8.insert(vowel);\n    }\n    let mut vowels_set9 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set9.insert(vowel);\n    }\n\
    \    let mut vowels_set10 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set10.insert(vowel);\n    }\n    let mut vowels_set11 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set11.insert(vowel);\n    }\n\
    \    let mut vowels_set12 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set12.insert(vowel);\n    }\n    let mut vowels_set13 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set13.insert(vowel);\n    }\n\
    \    let mut vowels_set14 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set14.insert(vowel);\n    }\n    let mut vowels_set15 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set15.insert(vowel);\n    }\n\
    \    let mut vowels_set16 = HashSet::new();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpi1c59hgu.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:21:27\n\
    \   |\n21 |     let mut vowels_set2 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:25:27\n\
    \   |\n25 |     let mut vowels_set3 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:29:27\n\
    \   |\n29 |     let mut vowels_set4 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:33:27\n\
    \   |\n33 |     let mut vowels_set5 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:37:27\n\
    \   |\n37 |     let mut vowels_set6 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:41:27\n\
    \   |\n41 |     let mut vowels_set7 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider impor"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_count = vowels.len();\n    let mut vowels_index = 0;\n\
    \    let mut vowels_index_count = 0;\n    let mut vowels_index_count_max = 0;\n\
    \    let mut vowels_index_count_min = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n    let mut vowels_index_count_min_index\
    \ = 0;\n    let mut vowels_index_count_max_index = 0;\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpj8lnvcn1.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj8lnvcn1.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_index = word.chars().enumerate().filter(|&(_, c)| vowels_set.contains(c)).map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    vowels_index.sort_by_key(|&i| i);\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_index = vowels_index.iter().cloned().collect\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeii959h3.rs:41:64\n   |\n\
    41 |     let mut vowels_index = vowels_index.iter().cloned().collect\n   |   \
    \                                                             ^ help: add `;`\
    \ here\n42 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpeii959h3.rs:17:26\n   |\n17 |  \
    \   let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0615]: attempted to take value\
    \ of method `collect` on type `Cloned<std::slice::Iter<'_, char>>`\n  --> /tmp/tmpeii959h3.rs:41:57\n\
    \   |\n41 |     let mut vowels_index = vowels_index.iter().cloned().collect\n\
    \   |                                                         ^^^^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n41 |    \
    \ let mut vowels_index = vowels_index.iter().cloned().collect()\n   |        \
    \                                                        ++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeii959h3.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433, E0615.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_set2 = HashSet::new();\n    for vowel in vowels.iter()\
    \ {\n        vowels_set2.insert(vowel);\n    }\n    let mut vowels_set3 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set3.insert(vowel);\n    }\n\
    \    let mut vowels_set4 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set4.insert(vowel);\n    }\n    let mut vowels_set5 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set5.insert(vowel);\n    }\n\
    \    let mut vowels_set6 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set6.insert(vowel);\n    }\n    let mut vowels_set7 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set7.insert(vowel);\n    }\n\
    \    let mut vowels_set8 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set8.insert(vowel);\n    }\n    let mut vowels_set9 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set9.insert(vowel);\n    }\n\
    \    let mut vowels_set10 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set10.insert(vowel);\n    }\n    let mut vowels_set11 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set11.insert(vowel);\n    }\n\
    \    let mut vowels_set12 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set12.insert(vowel);\n    }\n    let mut vowels_set13 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set13.insert(vowel);\n    }\n\
    \    let mut vowels_set14 = HashSet::new();\n    for vowel in vowels.iter() {\n\
    \        vowels_set14.insert(vowel);\n    }\n    let mut vowels_set15 = HashSet::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_set15.insert(vowel);\n    }\n\
    \    let mut vowels_set16 = HashSet::new();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpi1c59hgu.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:21:27\n\
    \   |\n21 |     let mut vowels_set2 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:25:27\n\
    \   |\n25 |     let mut vowels_set3 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:29:27\n\
    \   |\n29 |     let mut vowels_set4 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:33:27\n\
    \   |\n33 |     let mut vowels_set5 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:37:27\n\
    \   |\n37 |     let mut vowels_set6 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpi1c59hgu.rs:41:27\n\
    \   |\n41 |     let mut vowels_set7 = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider impor"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found =\
    \ HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvtzsmdte.rs:59:35\n   |\n\
    59 |     let mut vowels_found = HashSet\n   |                                \
    \   ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:17:26\n\
    \   |\n17 |     let mut vowels_set = HashSet::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:21:28\n   |\n21\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:22:28\n   |\n22\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:23:28\n   |\n23\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:24:28\n   |\n24\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:25:28\n   |\n25\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to reso"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpirfoume3.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len = vowels.len();\n    let mut\
    \ vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_len\
    \ = vowels_len.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_len =\
    \ vowels_len.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_len\
    \ = vowels_len.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_len =\
    \ vowels_len.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_len\
    \ = vowels_len.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_len =\
    \ vowels_len.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_len = vowels_len.iter\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpz3gowm_6.rs:39:41\n   |\n\
    39 |     let mut vowels_len = vowels_len.iter\n   |                          \
    \               ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0599]:\
    \ no method named `iter` found for type `usize` in the current scope\n  --> /tmp/tmpz3gowm_6.rs:20:37\n\
    \   |\n20 |     let mut vowels_len = vowels_len.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                     ^^^^ method not found in `usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpz3gowm_6.rs:15:39\n   |\n15 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |    -----------------     \
    \             ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp3vdr26mq.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n        vowels_set.insert(vowel.to_string());\n\
    \    });\n    \n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    \n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    \n    if vowels_set.len() == 0 {\n        return String::from(\"\
    \");\n    }\n    \n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    \n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    \n    if vowels_set.len() == 0 {\n        return String::from(\"\
    \");\n    }\n    \n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    \n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    \n    if vowels_set.len() == 0 {\n        return String::from(\"\
    \");\n    }\n    \n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    \n    let mut vowels_set = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    \n    if vowels_set.len() == 0 {\n        return String::from(\"\
    \");\n    }\n    \n    let mut vowels_set = HashSet\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdacyxe27.rs:94:33\n   |\n\
    94 |     let mut vowels_set = HashSet\n   |                                 ^\
    \ help: add `;` here\n95 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpdacyxe27.rs:17:26\n\
    \   |\n17 |     let mut vowels_set = HashSet::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdacyxe27.rs:22:26\n   |\n22\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdacyxe27.rs:29:26\n   |\n29\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdacyxe27.rs:40:26\n   |\n40\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdacyxe27.rs:47:26\n   |\n47\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpdacyxe27.rs:58:26\n   |\n58\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared t"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoox48snd.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found =\
    \ HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet::new();\n    let mut vowels_found\
    \ = HashSet::new();\n    let mut vowels_found = HashSet\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvtzsmdte.rs:59:35\n   |\n\
    59 |     let mut vowels_found = HashSet\n   |                                \
    \   ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:17:26\n\
    \   |\n17 |     let mut vowels_set = HashSet::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:21:28\n   |\n21\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:22:28\n   |\n22\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:23:28\n   |\n23\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:24:28\n   |\n24\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpvtzsmdte.rs:25:28\n   |\n25\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to reso"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n        vowels_set.insert(vowel.to_lowercase());\n\
    \    });\n    let mut vowels_set2 = HashSet::new();\n    vowels.iter().for_each(|vowel|\
    \ {\n        vowels_set2.insert(vowel.to_lowercase());\n    });\n    let mut vowels_set3\
    \ = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n        vowels_set3.insert(vowel.to_lowercase());\n\
    \    });\n    let mut vowels_set4 = HashSet::new();\n    vowels.iter().for_each(|vowel|\
    \ {\n        vowels_set4.insert(vowel.to_lowercase());\n    });\n    let mut vowels_set5\
    \ = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n        vowels_set5.insert(vowel.to_lowercase());\n\
    \    });\n    let mut vowels_set6 = HashSet::new();\n    vowels.iter().for_each(|vowel|\
    \ {\n        vowels_set6.insert(vowel.to_lowercase());\n    });\n    let mut vowels_set7\
    \ = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n        vowels_set7.insert(vowel.to_lowercase());\n\
    \    });\n    let mut vowels_set8 = HashSet::new();\n    vowels.iter().for_each(|vowel|\
    \ {\n        vowels_set8.insert(vowel.to_lowercase());\n    });\n    let mut vowels_set9\
    \ = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n        vowels_set9.insert(vowel.to_lowercase());\n\
    \    });\n    let mut vowels_set10 = HashSet::new();\n    vowels.iter().for_each(|vowel|\
    \ {\n        vowels_set10.insert(vowel.to_lowercase());\n    });\n    let mut\
    \ vowels_set11 = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n     \
    \   vowels_set11.insert(vowel.to_lowercase());\n    });\n    let mut vowels_set12\
    \ = HashSet::new();\n    vowels.iter().for_each(|vowel| {\n        vowels_set12.insert(vowel.to_lowercase());\n\
    \    });\n    let mut vowels_set13 = HashSet::new();\n    vowels.iter().for_each(|vowel|\
    \ {\n        vowels_set13.insert(vowel.to_lowercase());\n    });\n    let \n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpqtzvbvn3.rs:70:1\n  \
    \ |\n70 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpqtzvbvn3.rs:17:26\n   |\n17 |     let\
    \ mut vowels_set = HashSet::new();\n   |                          ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpqtzvbvn3.rs:21:27\n   |\n21 |  \
    \   let mut vowels_set2 = HashSet::new();\n   |                           ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpqtzvbvn3.rs:25:27\n   |\n25\
    \ |     let mut vowels_set3 = HashSet::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpqtzvbvn3.rs:29:27\n   |\n29\
    \ |     let mut vowels_set4 = HashSet::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpqtzvbvn3.rs:33:27\n   |\n33\
    \ |     let mut vowels_set5 = HashSet::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpqtzvbvn3.rs:37:27\n   |\n37\
    \ |     let mut vowels_set6 = HashSet::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpqtzvbvn3.rs:41:27\n   |\n41\
    \ |     let mut vowels_set7 = H"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|&vowel| {\n        vowels_set.insert(vowel);\n\
    \    });\n    let mut vowels_index = word.chars().enumerate().filter(|&(_, c)|\
    \ {\n        vowels_set.contains(c)\n    }).map(|(_, c)| c).collect::<Vec<_>>();\n\
    \    vowels_index.sort_by_key(|&i| {\n        vowels[i]\n    });\n    vowels_index.last().unwrap()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp1svj_3oh.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]:\
    \ the type `[&str]` cannot be indexed by `char`\n  --> /tmp/tmp1svj_3oh.rs:25:9\n\
    \   |\n25 |         vowels[i]\n   |         ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `Index<char>` for `Vec<&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1svj_3oh.rs:27:5\n   |\n15 | fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n27 |     vowels_index.last().unwrap()\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoox48snd.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|v| vowels_set.insert(v));\n \
    \   let mut vowels_index = word.chars().enumerate().filter(|&(_, c)| vowels_set.contains(c)).collect::<Vec<_>>();\n\
    \    vowels_index.sort_by_key(|&(_, c)| c.to_ascii_lowercase());\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_index = vowels_index.iter().cloned().collect::<Vec\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `+`, `,`, `::`, `:`, `<`, `=`, or `>`,\
    \ found `}`\n  --> /tmp/tmphxoi3ehd.rs:40:1\n   |\n39 |     let mut vowels_index\
    \ = vowels_index.iter().cloned().collect::<Vec\n   |                         \
    \                                             - expected one of 9 possible tokens\n\
    40 | }\n   | ^ unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmphxoi3ehd.rs:17:26\n   |\n17 |     let mut vowels_set\
    \ = HashSet::new();\n   |                          ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut consonants_set = HashSet::new();\n\
    \    for consonant in consonants.iter() {\n        consonants_set.insert(consonant);\n\
    \    }\n    let mut vowels_index = word.chars().enumerate().filter(|&(_, c)| vowels_set.contains(c)).next();\n\
    \    let mut consonants_index = word.chars().enumerate().filter(|&(_, c)| consonants_set.contains(c)).next();\n\
    \    let mut vowels_index = match vowels_index {\n        Some(v) => v,\n    \
    \    None => return String::from(\"\"),\n    };\n    let mut consonants_index\
    \ = match consonants_index {\n        Some(c) => c,\n        None => return String::from(\"\
    \"),\n    };\n    let mut vowels_index = match vowels_index {\n        Some(v)\
    \ => v,\n        None => return String::from(\"\"),\n    };\n    let mut consonants_index\
    \ = match consonants_index {\n        Some(c) => c,\n        None => return String::from(\"\
    \"),\n    };\n    let mut vowels_index = match vowels_index {\n        Some(v)\
    \ => v,\n        None => return String::from(\"\"),\n    };\n    let mut consonants_index\
    \ = match consonants_index {\n        Some(c) => c,\n        None => return String::from(\"\
    \"),\n    };\n    let mut vowels_index = match vowels_index {\n        Some(v)\
    \ => v,\n        None => return String::from(\"\"),\n    };\n    let mut consonants_index\
    \ = match consonants_index {\n        Some(c) => c,\n        None => return String::from(\"\
    \"),\n    };\n    let mut vowels_index = match vowels_index {\n        Some(v)\
    \ => v,\n        None => return String::from(\"\"),\n    };\n    let mut consonants_index\
    \ = match consonants_index {\n        Some(c) => c,\n        None => return String::from(\"\
    \"),\n    };\n    let mut vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpurnybyxt.rs:68:18\n   |\n\
    68 |     let mut vowel\n   |                  ^ help: add `;` here\n69 | }\n \
    \  | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpurnybyxt.rs:17:26\n   |\n17 |     let mut vowels_set\
    \ = HashSet::new();\n   |                          ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpurnybyxt.rs:22:30\n   |\n22 |     let mut consonants_set = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpurnybyxt.rs:37:9\n   |\n\
    36 |     let mut vowels_index = match vowels_index {\n   |                   \
    \               ------------ this expression has type `(usize, char)`\n37 |  \
    \       Some(v) => v,\n   |         ^^^^^^^ expected tuple, found enum `Option`\n\
    \   |\n   = note: expected tuple `(usize, char)`\n               found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpurnybyxt.rs:38:9\n   |\n36 | \
    \    let mut vowels_index = match vowels_index {\n   |                       \
    \           ------------ this expression has type `(usize, char)`\n37 |      \
    \   Some(v) => v,\n38 |         None => return String::from(\"\"),\n   |     \
    \    ^^^^ expected tuple, found enum `Option`\n   |\n   = note: expected tuple\
    \ `(usize, char)`\n               found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpurnybyxt.rs:41:9\n   |\n40 |     let mut consonants_index\
    \ = match consonants_index {\n   |                                      ----------------\
    \ this expression has type `(usize, char)`\n41 |         Some(c) => c,\n   | \
    \        ^^^^^^^ expected tuple, found enum `Option`\n   |\n   = note: expected\
    \ tuple `(usize, char)`\n               found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpurnybyxt.rs:42:9\n   |\n40"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = vowels_end.clone();\n    let mut vowels_iter = vowels_start.clone();\n\
    \    let mut vowels_end = vowels_end.clone();\n    let mut vowels_start = vowels_end.clone();\n\
    \    let mut vowels_iter = vowels_start.clone();\n    let mut vowels_end = vowels_end.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpirfoume3.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels.iter().rev();\n    let mut\
    \ vowels_start = vowels.iter().rev();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = vowels_iter.clone();\n    let mut vowels_iter = vowels_end.clone();\n\
    \    let mut vowels_end = vowels_start.clone();\n    let mut vowels_start = vowels_iter.clone();\n\
    \    let mut vowels_iter = vowels_end.clone();\n    let mut vowels_end = vowels_start.clone();\n\
    \    let mut vowels_start = \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp3vdr26mq.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).collect::<Vec<_>>();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx\
    \ = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx =\
    \ vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx\
    \ = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx =\
    \ vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx\
    \ = vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx =\
    \ vowels_idx.iter().cloned().collect::<Vec<_>>();\n    let mut vowels_idx = vowels_idx.iter().cloned().collect::<Vec<_>>();\n\
    \    let \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpamg4h5uh.rs:40:1\n  \
    \ |\n40 | }\n   | ^ expected pattern\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpamg4h5uh.rs:17:84\n   |\n17 |     let mut vowels_idx = word.chars().enumerate().filter(|&(_,\
    \ c)| vowels.contains(c)).collect::<Vec<_>>();\n   |                         \
    \                                                           ^ expected `&&str`,\
    \ found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748666
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels_iter.cloned();\n    let mut\
    \ vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprgvqk985.rs:55:11\n   |\n\
    55 |     let mu\n   |           ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: the trait bound `str: Clone` is not satisfied\n  -->\
    \ /tmp/tmprgvqk985.rs:19:39\n   |\n19 |     let mut vowels_iter = vowels_iter.cloned();\n\
    \   |                                       ^^^^^^ the trait `Clone` is not implemented\
    \ for `str`\n\nerror[E0599]: the method `cloned` exists for struct `Cloned<Cloned<std::slice::Iter<'_,\
    \ &str>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmprgvqk985.rs:20:39\n\
    \   |\n20 |       let mut vowels_iter = vowels_iter.cloned();\n   |          \
    \                               ^^^^^^ method cannot be called on `Cloned<Cloned<std::slice::Iter<'_,\
    \ &str>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `Cloned<Cloned<std::slice::Iter<'_, &str>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Cloned<std::slice::Iter<'_,\
    \ &str>>>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprgvqk985.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index2\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index3 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index4 = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index5\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index6 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index7 = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index8\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index9 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index10 = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index11\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index12 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_count_index13 = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index14\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index15 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_count_index16 = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index17\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index18 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_count_index19 = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index20\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index21 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_count_index22 = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index23\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index24 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_count_index25 = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index26\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index27 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_count_index28 = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index29\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index30 = vec![0, 1, 2, 3,\
    \ 4];\n    let \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpux41i1cv.rs:50:1\n  \
    \ |\n50 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748666
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid_iter = vowels_mid.iter();\n    let mut vowels_mid_end\
    \ = vowels_mid_iter.next();\n    let mut vowels_mid_start = vowels_mid_iter.next();\n\
    \    let mut vowels_mid_mid = vowels_mid_iter.next();\n    let mut vowels_mid_mid_iter\
    \ = vowels_mid_mid.iter();\n    let mut vowels_mid_mid_end = vowels_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid\
    \ = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_start = vowels_mid_mid_mid_iter.next();\n    let mut\
    \ vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid_start = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_mid_iter = vowels_mid_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_mid_iter.next();\n    let mut\
    \ vowels_mid_mid_mid_mid_start = vowels_mid_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid_start = vowels_mid_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_mid = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_mid_iter = vowels_mid_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp65r0pmyg.rs:46:61\n   |\n\
    46 |     let mut vowels_mid_mid_mid_mid_end = vowels_mid_mid_mid_\n   |      \
    \                                                       ^ help: add `;` here\n\
    47 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `vowels_mid_mid_mid_`\
    \ in this scope\n  --> /tmp/tmp65r0pmyg.rs:46:42\n   |\n46 |     let mut vowels_mid_mid_mid_mid_end\
    \ = vowels_mid_mid_mid_\n   |                                          ^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels_mid_mid_mid`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp65r0pmyg.rs:15:39\n   |\n15 | fn\
    \ get_closest_vowel(word: String) -> String {\n   |    -----------------     \
    \             ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748665
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jo_cctw.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
