name: HumanEval_118_get_closest_vowel
language: rs
results:
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf_qks2oz.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf_qks2oz.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptqrq69cj.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqrq69cj.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj928mecv.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj928mecv.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgdlutru.rs:56:20\n   |\n\
    56 |     let mut vowels_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgdlutru.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels_iter.skip(1);\n    let mut\
    \ vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaxbo5mb0.rs:55:11\n   |\n\
    55 |     let mu\n   |           ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxbo5mb0.rs:15:39\n \
    \  |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels_index = vowels_index.iter().cloned().collect::<Vec<_>>();\n\
    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jo_cctw.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_lowercase()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_uppercase()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter()));\n    let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp7rbuwab4.rs:36:1\n   |\n36 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp7rbuwab4.rs:35:68\n   |\n15 | fn get_closest_vowel(word: String) ->\
    \ String {\n   |                                              - closing delimiter\
    \ possibly meant for this\n...\n35 |     let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_letter\n   |                                                   \
    \                 ^ unclosed delimiter\n36 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0271]: type mismatch resolving `<SkipWhile<Chars<'_>, [closure@/tmp/tmp7rbuwab4.rs:18:69:\
    \ 18:97]> as IntoIterator>::Item == &&str`\n   --> /tmp/tmp7rbuwab4.rs:18:39\n\
    \    |\n18  |     let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_lowercase()));\n    |                                       ^^^^^\
    \ expected `&&str`, found `char`\n    |\nnote: required by a bound in `std::iter::Iterator::chain`\n\
    \nerror[E0599]: the method `chain` exists for struct `std::iter::Chain<std::slice::Iter<'_,\
    \ &str>, SkipWhile<Chars<'_>, [closure@/tmp/tmp7rbuwab4.rs:18:69: 18:97]>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmp7rbuwab4.rs:19:39\n   |\n\
    19 |       let mut vowels_iter = vowels_iter.chain(word.chars().skip_while(|&c|\
    \ !c.is_ascii_uppercase()));\n   |                                         ^^^^^\
    \ method cannot be called on `std::iter::Chain<std::slice::Iter<'_, &str>, SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp7rbuwab4.rs:18:69: 18:97]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp7rbuwab4.rs:18:69: 18:97]> as Iterator>::Item = &&str`\n  \
    \         which is required by `std::iter::Chain<std::slice::Iter<'_, &str>, SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp7rbuwab4.rs:18:69: 18:97]>>: Iterator`\n           `std::iter::Chain<std::slice::Iter<'_,\
    \ &str>, SkipWhile<Chars<'_>, [closu"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len = word.len();\n    let mut vowels_idx2\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len2 = word.len();\n    let mut vowels_idx3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len3 = word.len();\n    let mut vowels_idx4\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len4 = word.len();\n    let mut vowels_idx5\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len5 = word.len();\n    let mut vowels_idx6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len6 = word.len();\n    let mut vowels_idx7\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len7 = word.len();\n    let mut vowels_idx8\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len8 = word.len();\n    let mut vowels_idx9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len9 = word.len();\n    let mut vowels_idx10\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len10 = word.len();\n    let mut\
    \ vowels_idx11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len11 = word.len();\n\
    \    let mut vowels_idx12 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len12 = word.len();\n\
    \    let mut vowels_idx13 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len13 = word.len();\n\
    \    let mut vowels_idx14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len14 = word.len();\n\
    \    let mut vowels_idx15 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len15 = word.len();\n\
    \    let mut vowels_idx16 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len16 = word.len();\n\
    \    let mut vowels_idx17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len17 = word.len();\n\
    \    let mut vowels_idx18 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len18 = word.len();\n\
    \    let mut vowels_idx19 = vec![0, 1, 2, 3, 4];\n    let mut vowels_len19 = word.len();\n\
    \    let mut vowels_idx20\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfbjswfi7.rs:55:25\n   |\n\
    55 |     let mut vowels_idx20\n   |                         ^ help: add `;` here\n\
    56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfbjswfi7.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj2nrle7l.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj2nrle7l.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4fnkhsgt.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4fnkhsgt.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index_end = vec![0];\n    let mut vowels_index_start\
    \ = vec![0];\n    let mut vowels_index_start_end = vec![0];\n    let mut vowels_index_start_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end = vec![0];\n    let mut\
    \ vowels_index_start_end_end_end_end = vec![0];\n    let mut vowels_index_start_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end = vec![0];\n\
    \    let mut vowels_index_start_end_end_end_end_end_end_end = vec![0];\n    let\
    \ mut vowels_index_start_end_end_end_end_end_end_end_end = vec![0];\n    let mut\
    \ vowels_index_start_end_end_end_end_end_end_end_end_end = vec![0];\n    let mut\
    \ vowels_index_start_end_end_end_end_end_end_end_end_end_end = vec![0];\n    let\
    \ mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end = vec![0];\n\
    \    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcenj1n95.rs:41:80\n   |\n\
    41 |     let mut vowels_index_start_end_end_end_end_end_end_end_end_end_end_end_end_\n\
    \   |                                                                        \
    \        ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcenj1n95.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmmiyhfuv.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmmiyhfuv.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx1z_dk17.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1z_dk17.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n    let mut\
    \ vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid_iter = vowels_mid.iter();\n    let mut vowels_mid_end\
    \ = vowels_mid_iter.next();\n    let mut vowels_mid_start = vowels_mid_iter.next();\n\
    \    let mut vowels_mid_mid_iter = vowels_mid_mid.iter();\n    let mut vowels_mid_mid_end\
    \ = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_start\
    \ = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzdqd5s6s.rs:48:54\n   |\n\
    48 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_\n   |             \
    \                                         ^ help: add `;` here\n49 | }\n   | -\
    \ unexpected token\n\nerror[E0425]: cannot find value `vowels_mid_mid` in this\
    \ scope\n  --> /tmp/tmpzdqd5s6s.rs:24:35\n   |\n24 |     let mut vowels_mid_mid_iter\
    \ = vowels_mid_mid.iter();\n   |                                   ^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels_mid_end`\n\nerror[E0425]:\
    \ cannot find value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmpzdqd5s6s.rs:27:39\n\
    \   |\n27 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmpzdqd5s6s.rs:30:39\n\
    \   |\n30 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmpzdqd5s6s.rs:33:39\n\
    \   |\n33 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmpzdqd5s6s.rs:36:39\n\
    \   |\n36 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmpzdqd5s6s.rs:39:39\n\
    \   |\n39 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `v"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    vowels.iter().for_each(|v| vowels_set.insert(v));\n \
    \   let mut vowels_count = vowels.len();\n    let mut vowels_index = 0;\n    let\
    \ mut vowels_index2 = 0;\n    let mut vowels_index3 = 0;\n    let mut vowels_index4\
    \ = 0;\n    let mut vowels_index5 = 0;\n    let mut vowels_index6 = 0;\n    let\
    \ mut vowels_index7 = 0;\n    let mut vowels_index8 = 0;\n    let mut vowels_index9\
    \ = 0;\n    let mut vowels_index10 = 0;\n    let mut vowels_index11 = 0;\n   \
    \ let mut vowels_index12 = 0;\n    let mut vowels_index13 = 0;\n    let mut vowels_index14\
    \ = 0;\n    let mut vowels_index15 = 0;\n    let mut vowels_index16 = 0;\n   \
    \ let mut vowels_index17 = 0;\n    let mut vowels_index18 = 0;\n    let mut vowels_index19\
    \ = 0;\n    let mut vowels_index20 = 0;\n    let mut vowels_index21 = 0;\n   \
    \ let mut vowels_index22 = 0;\n    let mut vowels_index23 = 0;\n    let mut vowels_index24\
    \ = 0;\n    let mut vowels_index25 = 0;\n    let mut vowels_index26 = 0;\n   \
    \ let mut vowels_index27 = 0;\n    let mut vowels_index28 = 0;\n    let mut vowels_index29\
    \ = 0;\n    let mut vowels_index30 = 0;\n    let mut vowels_index31 = 0;\n   \
    \ let mut vowels_index32 = 0;\n    let mut vowels_index33 = 0;\n    let mut vowels_index34\
    \ = 0;\n    let mut vowels_index35 = 0;\n    let mut vowels_index36 = 0;\n   \
    \ let mut vowels_index37 = 0;\n    let mut vowels_index38 = 0;\n    let mut vowels_index39\
    \ = 0;\n    let mut vowels_index40 = 0;\n    let mut vowels_index41 = 0;\n   \
    \ let mut vowels_index42 = 0;\n    let mut vowels_index43 = 0;\n    let mut vowels_index44\
    \ = 0;\n    let mut vowels_index45 = 0;\n    let mut vowels_index46 = 0;\n   \
    \ let mut vowels_index47 = 0;\n    let mut vowels_index48 = 0;\n    let mut vowels_index49\
    \ = 0;\n    let mut vowels_index50 = 0;\n    let mut vowels_index51 = 0;\n\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp0ilk_vkg.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0ilk_vkg.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_be0jz_.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9_be0jz_.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).count();\n \
    \   let mut vowels_idx_end = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).count();\n\
    \    vowels_idx_end += 1;\n    \n    if vowels_idx > vowels_idx_end {\n      \
    \  vowels_idx = 0;\n    }\n    \n    let mut vowels_idx = vowels_idx;\n    let\
    \ mut vowels_idx_end = vowels_idx_end;\n    \n    while vowels_idx < vowels_idx_end\
    \ {\n        if word.chars().nth(vowels_idx).unwrap().is_uppercase() {\n     \
    \       break;\n        }\n        vowels_idx += 1;\n    }\n    \n    let mut\
    \ vowels_idx = vowels_idx;\n    let mut vowels_idx_end = vowels_idx_end;\n   \
    \ \n    while vowels_idx < vowels_idx_end {\n        if word.chars().nth(vowels_idx).unwrap().is_lowercase()\
    \ {\n            break;\n        }\n        vowels_idx += 1;\n    }\n    \n  \
    \  if vowels_idx == 0 {\n        return String::from(\"\");\n    }\n    \n   \
    \ let mut vowels_idx = vowels_idx;\n    let mut vowels_idx_end = vowels_idx_end;\n\
    \    \n    while vowels_idx < vowels_idx_end {\n        if word.chars().nth(vowels_idx).unwrap().is_uppercase()\
    \ {\n            break;\n        }\n        vowels_idx += 1;\n    }\n    \n  \
    \  let mut vowels_idx = vowels_idx;\n    let mut vowels_idx_end = vowels_idx_end;\n\
    \    \n    while vowels_idx < vowels_idx_end {\n        if word.chars().nth(vowels_idx).unwrap().is_lowercase()\
    \ {\n            break;\n        }\n        vowels_idx += 1;\n    }\n    \n  \
    \  if vowels_idx == 0 {\n        return String::from(\"\");\n    }\n    \n   \
    \ let mut vowels_idx = vowels_idx;\n    let mut vowels_idx_end = vowels_idx_end;\n\
    \    \n    while vowels_idx < vowels_idx_end {\n        if word.chars().nth(vowels_idx).unwrap().is_uppercase()\
    \ {\n            break;\n        }\n        vowels_idx += 1;\n    }\n    \n  \
    \  let mut vowels_idx = vowels_idx;\n    let mut vowels_idx_end = vowels_idx_end;\n\
    \    \n    while vowels_idx < vowels_idx_end {\n        if word.chars().nth\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9r1s67go.rs:105:3\n\
    \    |\n15  | fn get_closest_vowel(word: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n86  |     while\
    \ vowels_idx < vowels_idx_end {\n    |                                       -\
    \ this delimiter might not be properly closed...\n87  |         if word.chars().nth\n\
    88  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    105 | }\n    |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp9r1s67go.rs:88:1\n\
    \   |\n87 |         if word.chars().nth\n   |         -- this `if` expression\
    \ has a condition, but no block\n88 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9r1s67go.rs:17:84\n   |\n17 |     let mut vowels_idx\
    \ = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).count();\n \
    \  |                                                                         \
    \           ^ expected `&&str`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9r1s67go.rs:18:88\n   |\n18 |     let mut vowels_idx_end = word.chars().enumerate().filter(|&(_,\
    \ c)| vowels.contains(c)).count();\n   |                                     \
    \                                                   ^ expected `&&str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9r1s67go.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_set\
    \ = HashSet::new();\n    for vowel in vowels.iter() {\n        vowels_set.insert(vowel);\n\
    \    }\n    let mut vowels_index = word.chars().enumerate().filter(|&(_, c)| vowels_set.contains(c)).next();\n\
    \    let mut vowels_index = vowels_index.unwrap();\n    let mut vowels_index =\
    \ vowels_index.0;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index\
    \ = vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowels_index -\
    \ 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut vowels_index =\
    \ vowels_index - 1;\n    let mut vowels_index = vowels_index - 1;\n    let mut\
    \ vowels_index = vowels_index - 1;\n    let mut vowels_index = vowel\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb7zeawin.rs:58:33\n   |\n\
    58 |     let mut vowels_index = vowel\n   |                                 ^\
    \ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpb7zeawin.rs:17:26\n\
    \   |\n17 |     let mut vowels_set = HashSet::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `vowel` in this scope\n  --> /tmp/tmpb7zeawin.rs:58:28\n   |\n58 |   \
    \  let mut vowels_index = vowel\n   |                            ^^^^^ help: a\
    \ local variable with a similar name exists: `vowels`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb7zeawin.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyvtxj0g.rs:66:18\n   |\n\
    66 |     let mut vowel\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyvtxj0g.rs:15:39\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_len = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_len = word.len();\n    let mut vowels_idx = word.len() - 1;\n   \
    \ let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len() -\
    \ 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.len() - 1;\n    let mut vowels_idx = word.len()\
    \ - 1;\n    let mut vowels_idx = word.\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpkejp4bqk.rs:62:1\n   |\n62\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpkejp4bqk.rs:61:31\n\
    \   |\n61 |     let mut vowels_idx = word.\n   |                             \
    \  ^ help: add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkejp4bqk.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
