name: HumanEval_83_starts_one_ends
language: rs
prompt: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) ->\
  \ isize {\n"
tests: "}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
  \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n \
  \   assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
completions: ["    match n {\n        0 => 0,\n        1 => 1,\n        _ => n,\n\
    \    }", "    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  debug_assert!(n > 0);\n    debug_assert!(n % 10 == 1);\n    (n - 1).count_digits(|d|\
    \ d % 10 == 1)", "    if n < 10 { return 1 }\n    if n < 100 { return 2 }\n  \
    \  if n < 1000 { return 3 }\n    if n < 10000 { return 4 }\n    if n < 100000\
    \ { return 5 }\n    if n < 1000000 { return 6 }\n    if n < 10000000 { return\
    \ 7 }\n    if n < 100000000 { return 8 }\n    if n < 1000000000 { return 9 }\n\
    \    if n < 10000000000 { return 10 }\n    if n < 100000000000 { return 11 }\n\
    \    if n < 1000000000000 { return 12 }\n    if n < 10000000000000 { return 13\
    \ }\n    if n < 100000000000000 { return 14 }\n    if n < 1000000000000000 { return\
    \ 15 }\n    if n < 10000000000000000 { return 16 }\n    if n < 100000000000000000\
    \ { return 17 }\n    if n < 1000000000000000010 { return 18 }\n    if n < 1000000000000000010\
    \ { return 19 }\n    if n < 1000000000000000010 { return 20 }\n    if n < 1000000000000000010\
    \ { return 21 }\n    if n < 1000000000000000010 { return 22 }\n    if n < 1000000000000000010\
    \ { return 23 }\n    if n < 1000000000000000010 { return 24 }\n    if n < 1000000000000000010\
    \ { return 25 }\n    if n < 1000000000000000010 { return 26 }\n    if n < 1000000000000000010\
    \ { return 27 }\n    if n < 1000000000000000010 { return 28 }\n    if n < 1000000000000000010\
    \ { return 29 }\n    if n < 1000000000000000010 { return 30 }\n    if n < 1000000000000000010\
    \ { return 31 }\n    if n < 1000000000000000010 { return 32 }\n    if n < 1000000000000000010\
    \ { return 33 }\n    if n < 1000000000000000010 { return 34 }\n    if n < 1000000000000000010\
    \ { return 35 }\n    if n < 1000000000000000010 { return 36 }\n    if n < 1000000000000000010\
    \ { return 37 }\n    if n < 1000000000000000010 { return 38 }\n    if n < 1000000000000000010\
    \ { return 39 }\n    if n < 1000000000000000010 { return 40 }\n    if n < 1000000000000000010\
    \ { return 41 }\n    if n < 1000000000000000010 { return 42 }\n    if n < 1000000000000000010\
    \ { return 43 }\n    if n < 1000000000000000010 { return 44 }\n    if n < 1000000000000000010\
    \ { return 45 }\n    if n < 1000000000000000010 { return 46 }\n    if n < 1000000000000000010\
    \ { return 47 }\n    if n < 1000000000000000010 { return 48 }\n    if n < 1000000000000000010\
    \ { return 49 }\n    if n < 1000000000000000010 { return 50 }\n    if n < 1000000000000000010\
    \ { return 51 }\n    if n < 1000000000000000010 { return 52 }\n    if n < 1000000000000000010\
    \ { return 53 }\n", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", '    n / 10 + 1', "    let mut count = 0;\n    while n != 0 {\n\
    \        if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    let mut count = 0;\n    while n > 0 {\n        count\
    \ += n / 10;\n        n /= 10;\n    }\n    count", "    let mut count = 0;\n \
    \   while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n      \
    \  }\n        n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    let\
    \ mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    let mut count =\
    \ 0;\n    while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n\
    \        }\n        n /= 10;\n    }\n    count", "    let mut count = 0;\n   \
    \ while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n\
    \        n /= 10;\n    }\n    count", "    let mut count = 0;\n    while n > 0\
    \ {\n        if n % 10 == 1 {\n            count += 1;\n        }\n        n /=\
    \ 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    let mut count = 0;\n\
    \    while n > 0 {\n        count += n / 10;\n        n /= 10;\n    }\n    count",
  "    debug_assert!(n > 0);\n    debug_assert!(n % 10 == 1);\n    (1..n).filter(|x|\
    \ x % 10 == 1).count()", '    n / 10 + 1', "    debug_assert!(n >= 0);\n    let\
    \ mut n = 0;\n    while n <= n / 10 {\n        n += 1;\n    }\n    n", '    n.checked_mul(10).unwrap().checked_add((n
    - 1).checked_mul(10).unwrap()).unwrap()', "    if n < 0 {\n        0\n    } else\
    \ {\n        (1..=n).filter(|x| x % 10 == 1).count()\n    }", "    match n {\n\
    \        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    debug_assert!(n\
    \ > 0);\n    debug_assert!(n % 10 == 1);\n    let mut count = 0;\n    while n\
    \ > 0 {\n        n /= 10;\n        count += 1;\n    }\n    count", "    let mut\
    \ count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count +=\
    \ 1;\n        }\n        n /= 10;\n    }\n    count", "    if n < 10 {\n     \
    \   return 0;\n    }\n    if n % 10 == 1 {\n        return 1;\n    }\n    if n\
    \ % 10 == 0 {\n        return 1 + starts_one_ends(n / 10);\n    }\n    return\
    \ 1 + starts_one_ends(n / 10) + starts_one_ends(n % 10);", "    let mut count\
    \ = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n\
    \        }\n        n /= 10;\n    }\n    count", '    n.checked_mul(10).unwrap().checked_div(10).unwrap().checked_div(10).unwrap().checked_div(10).unwrap()',
  "    debug_assert!(n > 0);\n    debug_assert!(n % 10 == 0);\n    let mut count =\
    \ 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n \
    \       }\n        n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n \
    \   let mut count = 0;\n    while n != 1 {\n        if n % 10 == 1 {\n       \
    \     count += 1;\n        }\n        n /= 10;\n    }\n    count", "    match\
    \ n {\n        0 => 0,\n        _ => n,\n    }", "    match n {\n        0 =>\
    \ 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    debug_assert!(n >=\
    \ 0);\n    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n \
    \           count += 1;\n        }\n        n /= 10;\n    }\n    count", '    n.checked_mul(10).unwrap().checked_sub(1).unwrap()',
  '    n / 10 + 1', "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while\
    \ n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n   \
    \     n /= 10;\n    }\n    count", "    match n {\n        0 => 0,\n        _\
    \ => 1,\n    }", "    if n < 1 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut i = 1;\n    while i <= n {\n        if i % 10 == 1 {\n   \
    \         count += 1;\n        }\n        i += 1;\n    }\n    count", "    match\
    \ n {\n        0 => 0,\n        _ => if n % 10 == 1 {\n            1\n       \
    \ } else {\n            1 + starts_one_ends(n / 10)\n        }\n    }", '    n.checked_mul(10).unwrap().checked_div(10).unwrap().checked_div(10).unwrap()',
  "    if n < 10 {\n        return 1;\n    }\n    if n < 100 {\n        return 2;\n\
    \    }\n    if n < 1000 {\n        return 3;\n    }\n    if n < 10000 {\n    \
    \    return 4;\n    }\n    if n < 100000 {\n        return 5;\n    }\n    if n\
    \ < 1000000 {\n        return 6;\n    }\n    if n < 10000000 {\n        return\
    \ 7;\n    }\n    if n < 100000000 {\n        return 8;\n    }\n    if n < 1000000000\
    \ {\n        return 9;\n    }\n    if n < 10000000000 {\n        return 10;\n\
    \    }\n    if n < 100000000000 {\n        return 11;\n    }\n    if n < 1000000000000\
    \ {\n        return 12;\n    }\n    if n < 10000000000000 {\n        return 13;\n\
    \    }\n    if n < 100000000000000 {\n        return 14;\n    }\n    if n < 1000000000000000\
    \ {\n        return 15;\n    }\n    if n < 10000000000000000 {\n        return\
    \ 16;\n    }\n    if n < 100000000000000000 {\n        return 17;\n    }\n   \
    \ if n < 100000000000000001 {\n        return 18;\n    }\n    if n < 1000000000000000010\
    \ {\n        return 19;\n    }\n    if n < 10000000000000000100 {\n        return\
    \ 20;\n    }\n    if n < 100000000000000001000 {\n        return 21;\n    }\n\
    \    if n < 1000000000000000010000 {\n        return 22;\n    }\n    if n < 10000000000000000100000\
    \ {\n        return 23;\n    }\n    if n < 100000000000000001000000 {\n      \
    \  return 24;\n    }\n    if n < 1000000000000000010000000 {\n        return 25;\n\
    \    }\n    if n < 10000000000000000100000000 {\n        return 26;\n    }\n \
    \   if n < 100000000000000001000000000 {\n        return 27;\n    }\n    if n\
    \ < 1000000000000000010000000000 {\n        return 28;\n    }\n    if n < 10000000000000000100000000000\
    \ {\n        return 29;\n    }\n    if n < 100000000000000001000000000000 {\n\
    \        return 30;\n    }\n    if n < 1000000000000000010000000000000 {\n   \
    \     return 31;\n    }\n    if n < 10000000000000000100000000000000 {\n     \
    \   return 32;\n    }\n    if n < 100000000000000001000000000000000 {\n      \
    \  return 33;\n    }\n    if n < 1000000000000000010000000000000000 {\n      \
    \  return 34;\n    }\n    if n < 10000000000000000100000000000000000 {\n     \
    \   return 35;\n    }\n    if n < 10000000000000000100000000000000000000 {\n \
    \       return 36;\n    }\n    if n < 100000000000000001000000000000000000000\
    \ {\n        return 37;\n    }\n    if n < 1000000000000000010000000000000000000000\
    \ {\n        return 38;\n    }\n    if n < 1000000000000000010000000000000000000000",
  "    debug_assert!(n >= 0);\n    let mut n = 0;\n    while n <= n / 10 {\n     \
    \   if n % 10 == 1 {\n            n += 1;\n        } else {\n            break;\n\
    \        }\n    }\n    n", "    debug_assert!(n >= 0);\n    let mut count = 0;\n\
    \    while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n     \
    \   }\n        n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    let\
    \ mut count = 0;\n    while n != 1 {\n        n /= 10;\n        count += 1;\n\
    \    }\n    count", "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while\
    \ n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n   \
    \     n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n    let mut count\
    \ = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n\
    \        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n\
    \    let mut count = 0;\n    while n > 0 {\n        count += n / 10;\n       \
    \ n /= 10;\n    }\n    count", "    match n {\n        0 => 0,\n        _ => 1\
    \ + starts_one_ends(n - 1),\n    }", "    debug_assert!(n >= 0);\n    let mut\
    \ count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    let mut count =\
    \ 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n \
    \       }\n        n /= 10;\n    }\n    count", "    match n {\n        0 => 0,\n\
    \        _ => 1 + starts_one_ends(n - 1),\n    }", "    match n {\n        0 =>\
    \ 0,\n        _ => if n % 10 == 1 {\n            1\n        } else {\n       \
    \     starts_one_ends(n / 10) + 1\n        }\n    }", "    debug_assert!(n >=\
    \ 0);\n    debug_assert!(n <= 10);\n    let mut count = 0;\n    while n != 0 {\n\
    \        if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    let mut count = 0;\n    while n != 0 {\n        if n\
    \ % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n \
    \   count", "    match n {\n        1 => 1,\n        _ => n,\n    }", "    match\
    \ n {\n        0 => 0,\n        _ => 1,\n    }", "    match n {\n        1 =>\
    \ 1,\n        _ => n,\n    }", "    let mut count = 0;\n    while n > 0 {\n  \
    \      if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    debug_assert!(n >= 0);\n    debug_assert!(n <= 10);\n\
    \n    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n        if i\
    \ % 10 == 1 {\n            i += 1;\n            count += 1;\n        }\n     \
    \   i += 1;\n    }\n    count", "    match n {\n        0 => 0,\n        _ =>\
    \ 1 + starts_one_ends(n / 10),\n    }", "    if n == 0 {\n        return 0;\n\
    \    }\n    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n     \
    \   if i % 10 == 1 {\n            i += 1;\n            count += 1;\n        }\n\
    \        i += 1;\n    }\n    count", "    debug_assert!(n >= 0);\n    debug_assert!(n\
    \ <= 10);\n    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }",
  "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while n != 0 {\n      \
    \  if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n  \
    \  }\n    count", "    debug_assert!(n >= 0);\n    debug_assert!(n <= 9);\n  \
    \  debug_assert!(n % 10 == 0);\n    let mut count = 0;\n    let mut i = 1;\n \
    \   while i <= n {\n        if i % 10 == 1 {\n            i += 1;\n          \
    \  count += 1;\n        }\n        else {\n            i += 1;\n        }\n  \
    \  }\n    count", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", "    debug_assert!(n > 0);\n    let mut count = 0;\n    while\
    \ n != 1 {\n        n /= 10;\n        count += 1;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    let mut count = 0;\n    while n > 0 {\n        count += n / 10;\n\
    \        n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    debug_assert!(n\
    \ <= 9);\n    debug_assert!(n % 10 == 0);\n    let mut count = 0;\n    while n\
    \ > 0 {\n        count += n / 10;\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    let mut count = 0;\n    while n > 0 {\n        count += n / 10;\n\
    \        n /= 10;\n    }\n    count", "    match n {\n        1 => 1,\n      \
    \  _ => n,\n    }", "    debug_assert!(n >= 0);\n    debug_assert!(n <= 9);\n\
    \    let mut count = 0;\n    for digit in n.to_string().chars().take(9) {\n  \
    \      if digit == '1' {\n            count += 1;\n        }\n    }\n    count",
  "    debug_assert!(n > 0);\n    let mut count = 0;\n    while n > 0 {\n        if\
    \ n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n\
    \    count", "    if n < 10 { return 1 }\n    if n < 100 { return 2 }\n    if\
    \ n < 1000 { return 3 }\n    if n < 10000 { return 4 }\n    if n < 100000 { return\
    \ 5 }\n    if n < 1000000 { return 6 }\n    if n < 10000000 { return 7 }\n   \
    \ if n < 100000000 { return 8 }\n    if n < 1000000000 { return 9 }\n    if n\
    \ < 10000000000 { return 10 }\n    if n < 100000000000 { return 11 }\n    if n\
    \ < 1000000000000 { return 12 }\n    if n < 10000000000000 { return 13 }\n   \
    \ if n < 100000000000000 { return 14 }\n    if n < 1000000000000000 { return 15\
    \ }\n    if n < 10000000000000000 { return 16 }\n    if n < 100000000000000000\
    \ { return 17 }\n    if n < 1000000000000000010 { return 18 }\n    if n < 10000000000000000100\
    \ { return 19 }\n    if n < 100000000000000001000 { return 20 }\n    if n < 1000000000000000010000\
    \ { return 21 }\n    if n < 10000000000000000100000 { return 22 }\n    if n <\
    \ 100000000000000001000000 { return 23 }\n    if n < 1000000000000000010000000\
    \ { return 24 }\n    if n < 10000000000000000100000000 { return 25 }\n    if n\
    \ < 100000000000000001000000000 { return 26 }\n    if n < 1000000000000000010000000000\
    \ { return 27 }\n    if n < 10000000000000000100000000000 { return 28 }\n    if\
    \ n < 100000000000000001000000000000 { return 29 }\n    if n < 1000000000000000010000000000000\
    \ { return 30 }\n    if n < 10000000000000000100000000000000 { return 31 }\n \
    \   if n < 100000000000000001000000000000000 { return 32 }\n    if n < 1000000000000000010000000000000000\
    \ { return 33 }\n    if n < 10000000000000000100000000000000000 { return 34 }\n\
    \    if n < 100000000000000001000000000000000010 { return 35 }\n    if n < 1000000000000000010000000000000000100\
    \ { return 36 }\n    if n < 10000000000000000100000000000000001000 { return 37\
    \ }\n    if n < 100000000000000001000000000000000010000 { return 38 }\n    if\
    \ n < 1000000000000000010000000000000000100000 { return 39 }\n    if n < 10000000000000000100000000000000001000000\
    \ { return 40 }\n    if n < 100000000000000001000000000000000010000000 { return\
    \ 41 }\n    if n < 1000000000000000010000000000000000100000000 { return 42 }\n\
    \    if n < 10000000000000000100000000000000001000000000 { return 43 }\n    if\
    \ n < 100000000000000001000000000000000010000000000 { return 44 }\n    if n <\
    \ 1000000000000000010000000000000000100000000000 { return 45 }\n    if n < 10000000000000000100000000000000001000000000000 ",
  "    debug_assert!(n > 0);\n    let mut count = 0;\n    while n > 0 {\n        count\
    \ += n / 10;\n        n /= 10;\n    }\n    count", "    if n < 0 {\n        panic!(\"\
    starts_one_ends called with negative n\");\n    }\n    if n == 0 {\n        return\
    \ 0;\n    }\n    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n\
    \        if i % 10 == 1 {\n            count += 1;\n        }\n        i += 1;\n\
    \    }\n    count", "    let mut count = 0;\n    while n > 0 {\n        if n %\
    \ 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n   \
    \ count", "    if n < 0 {\n        panic!(\"starts_one_ends called with negative\
    \ n\");\n    }\n    if n == 0 {\n        return 0;\n    }\n    if n == 1 {\n \
    \       return 1;\n    }\n    if n % 2 == 0 {\n        return starts_one_ends(n\
    \ - 1) + 1;\n    }\n    return starts_one_ends(n / 2) + 1;", "    debug_assert!(n\
    \ >= 0);\n    debug_assert!(n <= 10);\n\n    let mut count = 0;\n    let mut i\
    \ = 1;\n    while i <= n {\n        if i % 10 == 1 {\n            count += 1;\n\
    \        }\n        i += 1;\n    }\n    count", "    let mut count = 0;\n    while\
    \ n > 0 {\n        count += n / 10;\n        n /= 10;\n    }\n    count", "  \
    \  let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n         \
    \   count += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    let mut count = 0;\n    while n != 1 {\n        n /= 10;\n     \
    \   count += 1;\n    }\n    count", "    match n {\n        0 => 0,\n        _\
    \ => 1,\n    }", "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while\
    \ n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n   \
    \     n /= 10;\n    }\n    count", '    n / 10 + 1', "    let mut count = 0;\n\
    \    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n      \
    \  }\n        n /= 10;\n    }\n    count", "    match n {\n        0 => 0,\n \
    \       1 => 1,\n        _ => n,\n    }", "    if n < 10 { return 1 }\n    if\
    \ n < 100 { return 2 }\n    if n < 1000 { return 3 }\n    if n < 10000 { return\
    \ 4 }\n    if n < 100000 { return 5 }\n    if n < 1000000 { return 6 }\n    if\
    \ n < 10000000 { return 7 }\n    if n < 100000000 { return 8 }\n    if n < 1000000000\
    \ { return 9 }\n    if n < 10000000000 { return 10 }\n    if n < 100000000000\
    \ { return 11 }\n    if n < 1000000000000 { return 12 }\n    if n < 10000000000000\
    \ { return 13 }\n    if n < 100000000000000 { return 14 }\n    if n < 1000000000000000\
    \ { return 15 }\n    if n < 10000000000000000 { return 16 }\n    if n < 100000000000000000\
    \ { return 17 }\n    if n < 1000000000000000010 { return 18 }\n    if n < 10000000000000000100\
    \ { return 19 }\n    if n < 100000000000000001000 { return 20 }\n    if n < 1000000000000000010000\
    \ { return 21 }\n    if n < 10000000000000000100000 { return 22 }\n    if n <\
    \ 100000000000000001000000 { return 23 }\n    if n < 1000000000000000010000000\
    \ { return 24 }\n    if n < 10000000000000000100000000 { return 25 }\n    if n\
    \ < 100000000000000001000000000 { return 26 }\n    if n < 1000000000000000010000000000\
    \ { return 27 }\n    if n < 10000000000000000100000000000 { return 28 }\n    if\
    \ n < 100000000000000001000000000000 { return 29 }\n    if n < 1000000000000000010000000000000\
    \ { return 30 }\n    if n < 10000000000000000100000000000000 { return 31 }\n \
    \   if n < 100000000000000001000000000000000 { return 32 }\n    if n < 1000000000000000010000000000000000\
    \ { return 33 }\n    if n < 10000000000000000100000000000000000 { return 34 }\n\
    \    if n < 100000000000000001000000000000000010 { return 35 }\n    if n < 1000000000000000010000000000000000100\
    \ { return 36 }\n    if n < 10000000000000000100000000000000001000 { return 37\
    \ }\n    if n < 100000000000000001000000000000000010000 { return 38 }\n    if\
    \ n < 1000000000000000010000000000000000100000 { return 39 }\n    if n < 10000000000000000100000000000000001000000\
    \ { return 40 }\n    if n < 100000000000000001000000000000000010000000 { return\
    \ 41 }\n    if n < 1000000000000000010000000000000000100000000 { return 42 }\n\
    \    if n < 10000000000000000100000000000000001000000000 { return 43 }\n    if\
    \ n < 100000000000000001000000000000000010000000000 { return 44 }\n    if n <\
    \ 1000000000000000010000000000000000100000000000 { return 45 }\n    if n < 10000000000000000100000000000000001000000000000 ",
  "    debug_assert!(n >= 0);\n    debug_assert!(n <= 10);\n\n    let mut count =\
    \ 0;\n    let mut i = 1;\n    while i <= n {\n        if i % 10 == 1 {\n     \
    \       i += 1;\n            count += 1;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    count", "    match n {\n        0 => 0,\n        _ => 1,\n\
    \    }", "    debug_assert!(n >= 0);\n    debug_assert!(n <= 10);\n    debug_assert!(n\
    \ % 10 == 0);\n\n    let mut count = 0;\n    let mut i = 1;\n    while i <= n\
    \ {\n        if i % 10 == 1 {\n            i += 1;\n            count += 1;\n\
    \        }\n        i += 1;\n    }\n    count", "    if n < 10 { return 1 }\n\
    \    if n < 100 { return 2 }\n    if n < 1000 { return 3 }\n    if n < 10000 {\
    \ return 4 }\n    if n < 100000 { return 5 }\n    if n < 1000000 { return 6 }\n\
    \    if n < 10000000 { return 7 }\n    if n < 100000000 { return 8 }\n    if n\
    \ < 1000000000 { return 9 }\n    if n < 10000000000 { return 10 }\n    if n <\
    \ 100000000000 { return 11 }\n    if n < 1000000000000 { return 12 }\n    if n\
    \ < 10000000000000 { return 13 }\n    if n < 100000000000000 { return 14 }\n \
    \   if n < 1000000000000000 { return 15 }\n    if n < 10000000000000000 { return\
    \ 16 }\n    if n < 100000000000000000 { return 17 }\n    if n < 1000000000000000000\
    \ { return 18 }\n    if n < 10000000000000000000 { return 19 }\n    if n < 100000000000000000000\
    \ { return 20 }\n    if n < 1000000000000000000000 { return 21 }\n    if n < 10000000000000000000000\
    \ { return 22 }\n    if n < 100000000000000000000000 { return 23 }\n    if n <\
    \ 1000000000000000000000000 { return 24 }\n    if n < 10000000000000000000000000\
    \ { return 25 }\n    if n < 100000000000000000000000000 { return 26 }\n    if\
    \ n < 1000000000000000000000000000 { return 27 }\n    if n < 10000000000000000000000000000\
    \ { return 28 }\n    if n < 100000000000000000000000000000 { return 29 }\n   \
    \ if n < 1000000000000000000000000000000 { return 30 }\n    if n < 10000000000000000000000000000000\
    \ { return 31 }\n    if n < 100000000000000000000000000000000 { return 32 }\n\
    \    if n < 1000000000000000000000000000000000 { return 33 }\n    if n < 10000000000000000000000000000000000\
    \ { return 34 }\n    if n < 100000000000000000000000000000000000 { return 35 }\n\
    \    if n < 1000000000000000000000000000000000000 { return 36 }\n    if n < 10000000000000000000000000000000000000\
    \ { return 37 }\n    if n < 100000000000000000000000000000000000000 { return 38\
    \ }\n    if n < 1000000000000000000000000000000000000000 { return 39 }\n    if\
    \ n < 10000000000000000000000000000000000000000 { return 40 }\n    if n < 100000000000000000000000000000000000000000\
    \ { return 41 }\n    if n < 1000000000000000000000000000000000000000000 { return\
    \ 42 }\n    if n < 10000000000000000000000000000000000000000000 { return 43 }\n\
    \    if n < 100000000000000000000000000000000000000000000 { return 44 }\n    if\
    \ n < 1000000000000000000000000000000000000000000000 { return 45 }\n    if n <\
    \ 1000000000000000000000000000000000000000 { return 46 }\n    if n < 10000000000000000000000000000000000000000\
    \ { return 47 }\n    if n < 100000000000000000000000000000000000000000 { return\
    \ 48 }\n    if n < 1000000000000000000000000000000000000000000 { return 49 }\n\
    \    if n < 10000000000000000000000000000000000000000000 { return 50 }\n    if\
    \ n < 10000000000000000000000000000000000", "    match n {\n        0 => 0,\n\
    \        1 => 1,\n        _ => n,\n    }", "    let mut count = 0;\n    while\
    \ n >= 10 {\n        n /= 10;\n        count += 1;\n    }\n    count", '    n.checked_mul(10).unwrap().checked_div(10).unwrap().checked_div(10).unwrap()',
  "    match n {\n        1 => 1,\n        _ => n,\n    }", "    match n {\n     \
    \   0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    match n {\n\
    \        0 => 0,\n        _ => 1,\n    }", "    debug_assert!(n > 0);\n    let\
    \ mut count = 0;\n    while n != 1 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    match n {\n    \
    \    0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    debug_assert!(n\
    \ > 0);\n    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n         \
    \   count += 1;\n        }\n        n /= 10;\n    }\n    count", "    if n ==\
    \ 0 {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut i = 1;\n\
    \    while i <= n {\n        if n % i == 0 {\n            count += 1;\n      \
    \      i += 1;\n        }\n        i += 1;\n    }\n    count", "    debug_assert!(n\
    \ > 0);\n    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  debug_assert!(n > 0);\n    debug_assert!(n % 10 == 1);\n    let mut count =\
    \ 0;\n    while n >= 10 {\n        count += n / 10;\n        n %= 10;\n    }\n\
    \    count += n;\n    count", "    let mut count = 0;\n    while n > 0 {\n   \
    \     if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while\
    \ n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n   \
    \     n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n    debug_assert!(n\
    \ % 10 == 0);\n    let mut count = 0;\n    for i in 1..n {\n        if i % 10\
    \ == 1 {\n            count += 1;\n        }\n    }\n    count", "    match n\
    \ {\n        0 => 0,\n        _ => 1,\n    }", "    let mut count = 0;\n    while\
    \ n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n   \
    \     n /= 10;\n    }\n    count", "    match n {\n        0 => 0,\n        1\
    \ => 1,\n        _ => n,\n    }", "    debug_assert!(n > 0);\n    let mut count\
    \ = 0;\n    while n != 1 {\n        if n % 10 == 1 {\n            count += 1;\n\
    \        }\n        n /= 10;\n    }\n    count", "    match n {\n        0 =>\
    \ 0,\n        _ => 1,\n    }", "    if n < 10 {\n        return 0;\n    }\n  \
    \  let mut count = 0;\n    for i in 1..n {\n        if i % 10 == 1 {\n       \
    \     count += 1;\n        }\n    }\n    count", "    if n < 10 {\n        return\
    \ 0;\n    }\n    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n\
    \        if n % i == 0 {\n            i += 1;\n            count += 1;\n     \
    \   }\n        i += 1;\n    }\n    count", "    debug_assert!(n > 0);\n    debug_assert!(n\
    \ % 10 == 1);\n    let mut count = 0;\n    for i in 0..n {\n        if i % 10\
    \ == 1 {\n            count += 1;\n        }\n    }\n    count", "    match n\
    \ {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    match\
    \ n {\n        0 => 0,\n        _ => 1,\n    }", "    match n {\n        1 =>\
    \ 1,\n        _ => n,\n    }", "    match n {\n        0 => 0,\n        1 => 1,\n\
    \        _ => n,\n    }", "    debug_assert!(n > 0);\n    let mut count = 0;\n\
    \    while n > 0 {\n        count += n / 10;\n        n /= 10;\n    }\n    count",
  "    debug_assert!(n > 0);\n    let mut count = 0;\n    while n > 0 {\n        if\
    \ n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n\
    \    count", "    debug_assert!(n > 0);\n    let mut count = 0;\n    while n !=\
    \ 1 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n        n\
    \ /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    debug_assert!(n\
    \ <= 9);\n    debug_assert!(n % 10 == 0);\n    let mut count = 0;\n    for i in\
    \ 0..n {\n        if i == 0 || i % 10 == 1 {\n            count += 1;\n      \
    \  }\n    }\n    count", "    if n < 0 {\n        return 0;\n    }\n    if n ==\
    \ 1 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        return starts_one_ends(n\
    \ / 2) + 1;\n    }\n    return starts_one_ends(n / 2) + 1;", '    n / 10 + 1',
  "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while n > 0 {\n       \
    \ count += n / 10;\n        n /= 10;\n    }\n    count", "    if n < 10 {\n  \
    \      return 0;\n    }\n    let mut count = 0;\n    let mut i = 1;\n    while\
    \ i <= n {\n        if i / 10 == 1 {\n            count += 1;\n        }\n   \
    \     i += 1;\n    }\n    count", "    match n {\n        0 => 0,\n        _ =>\
    \ 1 + starts_one_ends(n - 1),\n    }", "    match n {\n        1 => 1,\n     \
    \   _ => n,\n    }", "    debug_assert!(n >= 0);\n    let mut count = 0;\n   \
    \ while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n\
    \        n /= 10;\n    }\n    count", "    match n {\n        0 => 0,\n      \
    \  1 => 1,\n        _ => n,\n    }", "    debug_assert!(n >= 0);\n    let mut\
    \ count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count +=\
    \ 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n >=\
    \ 0);\n    let mut count = 0;\n    while n > 0 {\n        count += n / 10;\n \
    \       n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    let mut\
    \ count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ > 0);\n    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  if n < 1 {\n        return 0;\n    }\n    let mut count = 0;\n    let mut i\
    \ = 1;\n    while i <= n {\n        if i % 10 == 1 {\n            i += 1;\n  \
    \          count += 1;\n        }\n        i += 1;\n    }\n    count", "    match\
    \ n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "  \
    \  match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }",
  "    debug_assert!(n > 0);\n    debug_assert!(n % 10 == 1);\n    let mut count =\
    \ 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n \
    \       }\n        n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n \
    \   let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n        \
    \    count += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n         \
    \   count += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n        \
    \    count += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    let mut count = 0;\n    while n != 0 {\n        count += n / 10;\n\
    \        n %= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    let mut\
    \ count = 0;\n    while n != 1 {\n        n /= 10;\n        count += 1;\n    }\n\
    \    count", "    let mut count = 0;\n    while n > 0 {\n        if n % 10 ==\
    \ 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n    count",
  '    n.checked_mul(10).unwrap().checked_sub(1isize).unwrap()', "    match n {\n\
    \        0 => 0,\n        _ => if n % 10 == 1 {\n            1\n        } else\
    \ {\n            starts_one_ends(n / 10) + 1\n        }\n    }", "    debug_assert!(n\
    \ >= 0);\n    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  match n {\n        0 => 0,\n        _ => 1,\n    }", "    if n < 0 {\n    \
    \    return 0;\n    }\n\n    let mut count = 0;\n    let mut i = 1;\n    while\
    \ i <= n {\n        if i % 10 == 1 {\n            i += 1;\n            count +=\
    \ 1;\n        }\n        i += 1;\n    }\n    count", "    debug_assert!(n > 0);\n\
    \    let mut count = 0;\n    while n != 1 {\n        n /= 10;\n        count +=\
    \ 1;\n    }\n    count", "    debug_assert!(n >= 0);\n    debug_assert!(n <= 10);\n\
    \    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n       \
    \     count += 1;\n        }\n        n /= 10;\n    }\n    count", "    if n <\
    \ 0 {\n        return 0;\n    }\n    if n == 0 {\n        return 1;\n    }\n \
    \   if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return 2;\n\
    \    }\n    if n == 3 {\n        return 3;\n    }\n    if n == 4 {\n        return\
    \ 4;\n    }\n    if n == 5 {\n        return 5;\n    }\n    if n == 6 {\n    \
    \    return 6;\n    }\n    if n == 7 {\n        return 7;\n    }\n    if n ==\
    \ 8 {\n        return 8;\n    }\n    if n == 9 {\n        return 9;\n    }\n \
    \   if n == 10 {\n        return 10;\n    }\n    if n == 11 {\n        return\
    \ 11;\n    }\n    if n == 12 {\n        return 12;\n    }\n    if n == 13 {\n\
    \        return 13;\n    }\n    if n == 14 {\n        return 14;\n    }\n    if\
    \ n == 15 {\n        return 15;\n    }\n    if n == 16 {\n        return 16;\n\
    \    }\n    if n == 17 {\n        return 17;\n    }\n    if n == 18 {\n      \
    \  return 18;\n    }\n    if n == 19 {\n        return 19;\n    }\n    if n ==\
    \ 20 {\n        return 20;\n    }\n    if n == 21 {\n        return 21;\n    }\n\
    \    if n == 22 {\n        return 22;\n    }\n    if n == 23 {\n        return\
    \ 23;\n    }\n    if n == 24 {\n        return 24;\n    }\n    if n == 25 {\n\
    \        return 25;\n    }\n    if n == 26 {\n        return 26;\n    }\n    if\
    \ n == 27 {\n        return 27;\n    }\n    if n == 28 {\n        return 28;\n\
    \    }\n    if n == 29 {\n        return 29;\n    }\n    if n == 30 {\n      \
    \  return 30;\n    }\n    if n == 31 {\n        return 31;\n    }\n    if n ==\
    \ 32 {\n        return 32;\n    }\n    if n == 33 {\n        return 33;\n    }\n\
    \    if n == 34 {\n        return 34;\n    }\n    if n == 35 {\n        return\
    \ 35;\n    }\n    if n == 36 {\n        return 36;\n    }\n    if n == 37 {\n\
    \        return 37;\n    }\n    if n == 38 {\n        return 38;\n    }\n    if\
    \ n == 39 {\n        return 39;\n    }\n    if n == 40 {\n        return 40;\n\
    \    }\n    if n == 41 {\n        return 41;\n    }\n    if n == 42 {\n      \
    \  return 42;\n    }\n    if n == 43 {\n        return 43;\n    }\n    if n ==\
    \ 44 {\n        return 44;\n    }\n    if n == 45 {\n        return 45;\n    }\n\
    \    if n == 46 {\n        return 46;\n    }\n    if n == 47 {\n        return\
    \ 47;\n    }\n", "    match n {\n        0 => 0,\n        1 => 1,\n        _ =>\
    \ 1 + starts_one_ends(n - 1),\n    }", "    if n < 0 {\n        panic!(\"starts_one_ends:\
    \ n must be non-negative\");\n    }\n    if n == 0 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n        if i\
    \ % 10 == 1 {\n            count += 1;\n        }\n        i += 1;\n    }\n  \
    \  count", "    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1\
    \ {\n            count += 1;\n        }\n        n /= 10;\n    }\n    count",
  "    match n {\n        0 => 0,\n        _ => 1,\n    }", "    debug_assert!(n >=\
    \ 0);\n    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  debug_assert!(n >= 0);\n    debug_assert!(n <= 9);\n    let mut count = 0;\n\
    \    while n != 0 {\n        n /= 10;\n        count += 1;\n    }\n    count",
  "    match n {\n        1 => 1,\n        _ => n,\n    }", "    let mut count = 0;\n\
    \    while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n     \
    \   }\n        n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n    let\
    \ mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    match n {\n    \
    \    0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    let mut count\
    \ = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n\
    \        }\n        n /= 10;\n    }\n    count", "    match n {\n        0 =>\
    \ 0,\n        _ => 1,\n    }", "    let mut count = 0;\n    while n != 0 {\n \
    \       if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    if n < 10 {\n        return 1;\n    }\n    if n < 100\
    \ {\n        return 2;\n    }\n    if n < 1000 {\n        return 3;\n    }\n \
    \   if n < 10000 {\n        return 4;\n    }\n    if n < 100000 {\n        return\
    \ 5;\n    }\n    if n < 1000000 {\n        return 6;\n    }\n    if n < 10000000\
    \ {\n        return 7;\n    }\n    if n < 100000000 {\n        return 8;\n   \
    \ }\n    if n < 1000000000 {\n        return 9;\n    }\n    if n < 10000000000\
    \ {\n        return 10;\n    }\n    if n < 100000000000 {\n        return 11;\n\
    \    }\n    if n < 1000000000000 {\n        return 12;\n    }\n    if n < 10000000000000\
    \ {\n        return 13;\n    }\n    if n < 100000000000000 {\n        return 14;\n\
    \    }\n    if n < 1000000000000000 {\n        return 15;\n    }\n    if n < 10000000000000000\
    \ {\n        return 16;\n    }\n    if n < 100000000000000000 {\n        return\
    \ 17;\n    }\n    if n < 1000000000000000000 {\n        return 18;\n    }\n  \
    \  if n < 10000000000000000000 {\n        return 19;\n    }\n    if n < 100000000000000000000\
    \ {\n        return 20;\n    }\n    if n < 1000000000000000000000 {\n        return\
    \ 21;\n    }\n    if n < 10000000000000000000000 {\n        return 22;\n    }\n\
    \    if n < 100000000000000000000000 {\n        return 23;\n    }\n    if n <\
    \ 1000000000000000000000000 {\n        return 24;\n    }\n    if n < 10000000000000000000000000\
    \ {\n        return 25;\n    }\n    if n < 100000000000000000000000000 {\n   \
    \     return 26;\n    }\n    if n < 1000000000000000000000000000 {\n        return\
    \ 27;\n    }\n    if n < 10000000000000000000000000000 {\n        return 28;\n\
    \    }\n    if n < 100000000000000000000000000000 {\n        return 29;\n    }\n\
    \    if n < 1000000000000000000000000000000 {\n        return 30;\n    }\n   \
    \ if n < 10000000000000000000000000000000 {\n        return 31;\n    }\n    if\
    \ n < 100000000000000000000000000000000 {\n        return 32;\n    }\n    if n\
    \ < 1000000000000000000000000000000000 {\n        return 33;\n    }\n    if n\
    \ < 10000000000000000000000000000000000 {\n        return 34;\n    }\n    if n\
    \ < 100000000000000000000000000000000000 {\n        return 35;\n    }\n    if\
    \ n < 1000000000000000000000000000000000000 {\n        return 36;\n    }\n   \
    \ if n < 10000000000000000000000000000000000000 {\n        return 37;\n    }\n\
    \    if n < 100000000000000000000000000000000000000 {\n        return 38;\n  \
    \  }\n    if n < 1000000000000000000000000000000000000000 {\n        return 39;\n\
    \    }\n    if n < 10000000000000000000000000000000000000000 {\n        return\
    \ 40;\n    }\n    if n < 100000000000000000000000000000000000000000 {\n      \
    \  return 41;\n", "    match n {\n        0 => 0,\n        _ => if n % 10 == 1\
    \ {\n            1\n        } else {\n            1 + starts_one_ends(n / 10)\n\
    \        }\n    }", "    debug_assert!(n >= 0);\n    debug_assert!(n <= 9);\n\
    \    let mut count = 0;\n    while n > 0 {\n        count += n & 1;\n        n\
    \ >>= 1;\n    }\n    count", "    debug_assert!(n >= 0);\n    let mut count =\
    \ 0;\n    while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n\
    \        }\n        n /= 10;\n    }\n    count", "    if n < 10 {\n        return\
    \ 0;\n    }\n    if n % 10 == 1 {\n        return 1;\n    }\n    if n % 10 ==\
    \ 0 {\n        return starts_one_ends(n / 10) + 1;\n    }\n    starts_one_ends(n\
    \ / 10) + 1", "    let mut count = 0;\n    while n > 0 {\n        if n % 10 ==\
    \ 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n    count",
  "    match n {\n        0 => 0,\n        _ => 1,\n    }", "    debug_assert!(n >=\
    \ 0);\n    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  debug_assert!(n >= 0);\n    let mut count = 0;\n    while n != 0 {\n      \
    \  n /= 10;\n        count += 1;\n    }\n    count", "    match n {\n        0\
    \ => 0,\n        1 => 1,\n        _ => n,\n    }", "    match n {\n        0 =>\
    \ 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    debug_assert!(n >=\
    \ 0);\n    debug_assert!(n <= 9);\n    let mut count = 0;\n    while n != 0 {\n\
    \        if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    debug_assert!(n > 0);\n    let mut count = 0;\n    while\
    \ n != 1 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n   \
    \     n /= 10;\n    }\n    count", "    match n {\n        1 => 1,\n        _\
    \ => n,\n    }", "    debug_assert!(n >= 0);\n    debug_assert!(n <= 10);\n  \
    \  debug_assert!(n % 10 == 0);\n    let mut count = 0;\n    while n > 0 {\n  \
    \      if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    debug_assert!(n > 0);\n    debug_assert!(n % 10 == 1);\n\
    \n    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n      \
    \      count += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    debug_assert!(n <= 9);\n    debug_assert!(n % 10 == 0);\n\n    let\
    \ mut count = 0;\n    let mut i = 1;\n    while i <= n {\n        if i % 10 ==\
    \ 1 {\n            count += 1;\n        }\n        i += 1;\n    }\n    count",
  "    debug_assert!(n >= 0);\n    debug_assert!(n <= 10);\n    let mut count = 0;\n\
    \    while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n     \
    \   }\n        n /= 10;\n    }\n    count", "    if n < 0 {\n        panic!(\"\
    starts_one_ends called with negative n\");\n    }\n    if n == 0 {\n        return\
    \ 0;\n    }\n    let mut count = 0;\n    while n > 0 {\n        count += n / 10;\n\
    \        n -= n % 10;\n    }\n    count", "    debug_assert!(n > 0);\n    debug_assert!(n\
    \ % 10 == 1);\n    debug_assert!(n >= 1);\n\n    let mut count = 0;\n    for i\
    \ in 1..n {\n        if i % 10 == 1 {\n            count += 1;\n        }\n  \
    \  }\n    count", "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while\
    \ n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n   \
    \     n /= 10;\n    }\n    count", "    if n < 1 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n       \
    \     count += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  if n < 10 {\n        return n;\n    }\n    if n < 100 {\n        return n -\
    \ 1;\n    }\n    if n < 1000 {\n        return n - 2;\n    }\n    if n < 10000\
    \ {\n        return n - 3;\n    }\n    if n < 100000 {\n        return n - 4;\n\
    \    }\n    if n < 1000000 {\n        return n - 5;\n    }\n    if n < 10000000\
    \ {\n        return n - 6;\n    }\n    if n < 100000000 {\n        return n -\
    \ 7;\n    }\n    if n < 1000000000 {\n        return n - 8;\n    }\n    if n <\
    \ 10000000000 {\n        return n - 9;\n    }\n    if n < 100000000000 {\n   \
    \     return n - 10;\n    }\n    if n < 1000000000000 {\n        return n - 11;\n\
    \    }\n    if n < 10000000000000 {\n        return n - 12;\n    }\n    if n <\
    \ 100000000000000 {\n        return n - 13;\n    }\n    if n < 1000000000000000\
    \ {\n        return n - 14;\n    }\n    if n < 10000000000000000 {\n        return\
    \ n - 15;\n    }\n    if n < 100000000000000000 {\n        return n - 16;\n  \
    \  }\n    if n < 1000000000000000000 {\n        return n - 17;\n    }\n    if\
    \ n < 10000000000000000000 {\n        return n - 18;\n    }\n    if n < 100000000000000000000\
    \ {\n        return n - 19;\n    }\n    if n < 1000000000000000000000 {\n    \
    \    return n - 20;\n    }\n    if n < 10000000000000000000000 {\n        return\
    \ n - 21;\n    }\n    if n < 100000000000000000000000 {\n        return n - 22;\n\
    \    }\n    if n < 1000000000000000000000000 {\n        return n - 23;\n    }\n\
    \    if n < 10000000000000000000000000 {\n        return n - 24;\n    }\n    if\
    \ n < 100000000000000000000000000 {\n        return n - 25;\n    }\n    if n <\
    \ 1000000000000000000000000000 {\n        return n - 26;\n    }\n    if n < 10000000000000000000000000000\
    \ {\n        return n - 27;\n    }\n    if n < 100000000000000000000000000000\
    \ {\n        return n - 28;\n    }\n    if n < 1000000000000000000000000000000\
    \ {\n        return n - 29;\n    }\n    if n < 10000000000000000000000000000000\
    \ {\n        return n - 30;\n    }\n    if n < 100000000000000000000000000000000\
    \ {\n        return n - 31;\n    }\n    if n < 1000000000000000000000000000000000\
    \ {\n        return n - 32;\n    }\n    if n < 10000000000000000000000000000000000\
    \ {\n        return n - 33;\n    }\n    if n < 100000000000000000000000000000000000\
    \ {\n        return n - 34;\n    }\n    if n < 1000000000000000000000000000000000000\
    \ {\n        return n - 35;\n    }\n    if n < 10000000000000000000000000000000000000\
    \ {\n        return n - 36;\n    }\n    if n < 100000000000000000000000000000000000000\
    \ {\n        return n - 37;\n    }\n    if n < 10000000000000000000000000000000000",
  "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }",
  "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }",
  '    n / 10 + 1', '    n / 10 + 1', "    match n {\n        0 => 0,\n        _ =>\
    \ 1 + starts_one_ends(n - 1),\n    }", "    match n {\n        0 => 0,\n     \
    \   _ => 1 + starts_one_ends(n - 1),\n    }", "    debug_assert!(n >= 0);\n  \
    \  debug_assert!(n <= 10);\n    let mut count = 0;\n    while n != 0 {\n     \
    \   if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n \
    \   }\n    count", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }"]
stop_tokens:
- "\n}"
