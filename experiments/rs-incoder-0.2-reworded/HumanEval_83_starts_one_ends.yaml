name: HumanEval_83_starts_one_ends
language: rs
prompt: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) ->\
  \ isize {\n"
tests: "}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
  \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n \
  \   assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
completions: ["    match n {\n        0 => 0,\n        1 => 1,\n        _ => n,\n\
    \    }", "    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  debug_assert!(n > 0);\n    debug_assert!(n % 10 == 1);\n    (n - 1).count_digits(|d|\
    \ d % 10 == 1)", "    if n < 10 { return 1 }\n    if n < 100 { return 2 }\n  \
    \  if n < 1000 { return 3 }\n    if n < 10000 { return 4 }\n    if n < 100000\
    \ { return 5 }\n    if n < 1000000 { return 6 }\n    if n < 10000000 { return\
    \ 7 }\n    if n < 100000000 { return 8 }\n    if n < 1000000000 { return 9 }\n\
    \    if n < 10000000000 { return 10 }\n    if n < 100000000000 { return 11 }\n\
    \    if n < 1000000000000 { return 12 }\n    if n < 10000000000000 { return 13\
    \ }\n    if n < 100000000000000 { return 14 }\n    if n < 1000000000000000 { return\
    \ 15 }\n    if n < 10000000000000000 { return 16 }\n    if n < 100000000000000000\
    \ { return 17 }\n    if n < 1000000000000000010 { return 18 }\n    if n < 1000000000000000010\
    \ { return 19 }\n    if n < 1000000000000000010 { return 20 }\n    if n < 1000000000000000010\
    \ { return 21 }\n    if n < 1000000000000000010 { return 22 }\n    if n < 1000000000000000010\
    \ { return 23 }\n    if n < 1000000000000000010 { return 24 }\n    if n < 1000000000000000010\
    \ { return 25 }\n    if n < 1000000000000000010 { return 26 }\n    if n < 1000000000000000010\
    \ { return 27 }\n    if n < 1000000000000000010 { return 28 }\n    if n < 1000000000000000010\
    \ { return 29 }\n    if n < 1000000000000000010 { return 30 }\n    if n < 1000000000000000010\
    \ { return 31 }\n    if n < 1000000000000000010 { return 32 }\n    if n < 1000000000000000010\
    \ { return 33 }\n    if n < 1000000000000000010 { return 34 }\n    if n < 1000000000000000010\
    \ { return 35 }\n    if n < 1000000000000000010 { return 36 }\n    if n < 1000000000000000010\
    \ { return 37 }\n    if n < 1000000000000000010 { return 38 }\n    if n < 1000000000000000010\
    \ { return 39 }\n    if n < 1000000000000000010 { return 40 }\n    if n < 1000000000000000010\
    \ { return 41 }\n    if n < 1000000000000000010 { return 42 }\n    if n < 1000000000000000010\
    \ { return 43 }\n    if n < 1000000000000000010 { return 44 }\n    if n < 1000000000000000010\
    \ { return 45 }\n    if n < 1000000000000000010 { return 46 }\n    if n < 1000000000000000010\
    \ { return 47 }\n    if n < 1000000000000000010 { return 48 }\n    if n < 1000000000000000010\
    \ { return 49 }\n    if n < 1000000000000000010 { return 50 }\n    if n < 1000000000000000010\
    \ { return 51 }\n    if n < 1000000000000000010 { return 52 }\n    if n < 1000000000000000010\
    \ { return 53 }\n", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", '    n / 10 + 1', "    let mut count = 0;\n    while n != 0 {\n\
    \        if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    let mut count = 0;\n    while n > 0 {\n        count\
    \ += n / 10;\n        n /= 10;\n    }\n    count", "    let mut count = 0;\n \
    \   while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n      \
    \  }\n        n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    let\
    \ mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    let mut count =\
    \ 0;\n    while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n\
    \        }\n        n /= 10;\n    }\n    count", "    let mut count = 0;\n   \
    \ while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n\
    \        n /= 10;\n    }\n    count", "    let mut count = 0;\n    while n > 0\
    \ {\n        if n % 10 == 1 {\n            count += 1;\n        }\n        n /=\
    \ 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    let mut count = 0;\n\
    \    while n > 0 {\n        count += n / 10;\n        n /= 10;\n    }\n    count",
  "    debug_assert!(n > 0);\n    debug_assert!(n % 10 == 1);\n    (1..n).filter(|x|\
    \ x % 10 == 1).count()", '    n / 10 + 1', "    debug_assert!(n >= 0);\n    let\
    \ mut n = 0;\n    while n <= n / 10 {\n        n += 1;\n    }\n    n", '    n.checked_mul(10).unwrap().checked_add((n
    - 1).checked_mul(10).unwrap()).unwrap()', "    if n < 0 {\n        0\n    } else\
    \ {\n        (1..=n).filter(|x| x % 10 == 1).count()\n    }"]
stop_tokens:
- "\n}"
