name: HumanEval_82_prime_length
language: rs
results:
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() > 1\n}\n\nfn main() {\n    let candidate = prime_length;\n\
    \    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n\
    \    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"\
    wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n \
    \   assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"\
    Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjsxpxuj0.rs:13:36\n   |\n\
    13 |     string.chars().filter(|c| c >= 'a' && c <= 'z').count() > 1\n   |   \
    \                                 ^^^\n   |                                  \
    \  |\n   |                                    expected `&char`, found `char`\n\
    \   |                                    help: consider borrowing here: `&'a'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjsxpxuj0.rs:13:48\n   |\n13 |\
    \     string.chars().filter(|c| c >= 'a' && c <= 'z').count() > 1\n   |      \
    \                                          ^^^\n   |                         \
    \                       |\n   |                                              \
    \  expected `&char`, found `char`\n   |                                      \
    \          help: consider borrowing here: `&'z'`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() <= 2\n}\n\nfn main() {\n    let candidate = prime_length;\n\
    \    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n\
    \    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"\
    wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n \
    \   assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"\
    Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3r5mt2ub.rs:13:36\n   |\n\
    13 |     string.chars().filter(|c| c >= 'a' && c <= 'z').count() <= 2\n   |  \
    \                                  ^^^\n   |                                 \
    \   |\n   |                                    expected `&char`, found `char`\n\
    \   |                                    help: consider borrowing here: `&'a'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3r5mt2ub.rs:13:48\n   |\n13 |\
    \     string.chars().filter(|c| c >= 'a' && c <= 'z').count() <= 2\n   |     \
    \                                           ^^^\n   |                        \
    \                        |\n   |                                             \
    \   expected `&char`, found `char`\n   |                                     \
    \           help: consider borrowing here: `&'z'`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() == string.chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count()\n}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"\
    Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n\
    \    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"\
    orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n\
    \    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"\
    MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n \
    \   assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprl3f10ez.rs:13:36\n   |\n\
    13 |     string.chars().filter(|c| c >= 'a' && c <= 'z').count() == string.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count()\n   |                                    ^^^\n\
    \   |                                    |\n   |                             \
    \       expected `&char`, found `char`\n   |                                 \
    \   help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprl3f10ez.rs:13:48\n   |\n13 |     string.chars().filter(|c| c >=\
    \ 'a' && c <= 'z').count() == string.chars().filter(|c| c >= 'A' && c <= 'Z').count()\n\
    \   |                                                ^^^\n   |               \
    \                                 |\n   |                                    \
    \            expected `&char`, found `char`\n   |                            \
    \                    help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprl3f10ez.rs:13:95\n   |\n13 |     string.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() == string.chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count()\n   |                                                         \
    \                                      ^^^\n   |                             \
    \                                                                  |\n   |   \
    \                                                                            \
    \                expected `&char`, found `char`\n   |                        \
    \                                                                       help:\
    \ consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprl3f10ez.rs:13:107\n\
    \   |\n13 |     string.chars().filter(|c| c >= 'a' && c <= 'z').count() == string.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count()\n   |                                        \
    \                                                                   ^^^\n   |\
    \                                                                            \
    \                               |\n   |                                      \
    \                 "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut\
    \ prime_length: usize = 0;\n    let mut prime_length_prime: usize = 1;\n    let\
    \ mut prime_length_prime_prime: usize = 2;\n    let mut prime_length_prime_prime_prime:\
    \ usize = 3;\n\n    while prime_length_prime < string.len() {\n        if string.chars().any(|c|\
    \ {\n            prime_length_prime_prime % prime_length_prime == 0 && c != 0\n\
    \        }) {\n            prime_length_prime_prime = prime_length_prime_prime\
    \ + 1;\n        }\n        prime_length_prime = prime_length_prime + 1;\n    }\n\
    \n    while prime_length_prime_prime < string.len() {\n        if string.chars().any(|c|\
    \ {\n            prime_length_prime_prime_prime % prime_length_prime_prime ==\
    \ 0 && c != 0\n        }) {\n            prime_length_prime_prime_prime = prime_length_prime_prime_prime\
    \ + 1;\n        }\n        prime_length_prime_prime = prime_length_prime_prime\
    \ + 1;\n    }\n\n    while prime_length_prime_prime_prime < string.len() {\n \
    \       if string.chars().any(|c| {\n            prime_length_prime_prime_prime_prime\
    \ % prime_length_prime_prime_prime == 0 && c != 0\n        }) {\n            prime_length_prime_prime_prime_prime\
    \ = prime_length_prime_prime_prime_prime + 1;\n        }\n        prime_length_prime_prime_prime\
    \ = prime_length_prime_prime_prime + 1;\n    }\n\n    prime_length_prime_prime_prime\
    \ == string.len()\n}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"\
    Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n\
    \    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"\
    orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n\
    \    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"\
    MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n \
    \   assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `prime_length_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmp92ubqpxi.rs:38:13\n   |\n38 |             prime_length_prime_prime_prime_prime\
    \ % prime_length_prime_prime_prime == 0 && c != 0\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_length_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `prime_length_prime_prime_prime_prime` in this\
    \ scope\n  --> /tmp/tmp92ubqpxi.rs:40:13\n   |\n40 |             prime_length_prime_prime_prime_prime\
    \ = prime_length_prime_prime_prime_prime + 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_length_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `prime_length_prime_prime_prime_prime` in this\
    \ scope\n  --> /tmp/tmp92ubqpxi.rs:40:52\n   |\n40 |             prime_length_prime_prime_prime_prime\
    \ = prime_length_prime_prime_prime_prime + 1;\n   |                          \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `prime_length_prime_prime_prime`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp92ubqpxi.rs:20:72\n   |\n20 |             prime_length_prime_prime\
    \ % prime_length_prime == 0 && c != 0\n   |                                  \
    \                                      ^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp92ubqpxi.rs:29:84\n   |\n29 |             prime_length_prime_prime_prime\
    \ % prime_length_prime_prime == 0 && c != 0\n   |                            \
    \                                                        ^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp92ubqpxi.rs:38:96\n  \
    \ |\n38 |             prime_length_prime_prime_prime_prime % prime_length_prime_prime_prime\
    \ == 0 && c != 0\n   |                                                       \
    \                                         ^ expected `char`, found `u8`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nF"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut\
    \ prime_length: u32 = 1;\n    for c in string.chars() {\n        if c >= 'a' &&\
    \ c <= 'z' {\n            prime_length += 2;\n        }\n        if c >= 'A' &&\
    \ c <= 'Z' {\n            prime_length += 2;\n        }\n        if c >= '0' &&\
    \ c <= '9' {\n            prime_length += 1;\n        }\n    }\n    prime_length\
    \ == string.len()\n}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"\
    Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n\
    \    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"\
    orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n\
    \    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"\
    MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n \
    \   assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_3dq4nai.rs:25:21\n   |\n\
    25 |     prime_length == string.len()\n   |                     ^^^^^^^^^^^^ expected\
    \ `u32`, found `usize`\n   |\nhelp: you can convert a `usize` to a `u32` and panic\
    \ if the converted value doesn't fit\n   |\n25 |     prime_length == string.len().try_into().unwrap()\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut\
    \ prime_numbers = vec![true; string.len()];\n    let mut prime_numbers_index =\
    \ 0;\n    let mut prime_numbers_index2 = 0;\n    let mut prime_numbers_index3\
    \ = 0;\n    let mut prime_numbers_index4 = 0;\n    let mut prime_numbers_index5\
    \ = 0;\n    let mut prime_numbers_index6 = 0;\n    let mut prime_numbers_index7\
    \ = 0;\n    let mut prime_numbers_index8 = 0;\n    let mut prime_numbers_index9\
    \ = 0;\n    let mut prime_numbers_index10 = 0;\n    let mut prime_numbers_index11\
    \ = 0;\n    let mut prime_numbers_index12 = 0;\n    let mut prime_numbers_index13\
    \ = 0;\n    let mut prime_numbers_index14 = 0;\n    let mut prime_numbers_index15\
    \ = 0;\n    let mut prime_numbers_index16 = 0;\n    let mut prime_numbers_index17\
    \ = 0;\n    let mut prime_numbers_index18 = 0;\n    let mut prime_numbers_index19\
    \ = 0;\n    let mut prime_numbers_index20 = 0;\n    let mut prime_numbers_index21\
    \ = 0;\n    let mut prime_numbers_index22 = 0;\n    let mut prime_numbers_index23\
    \ = 0;\n    let mut prime_numbers_index24 = 0;\n    let mut prime_numbers_index25\
    \ = 0;\n    let mut prime_numbers_index26 = 0;\n    let mut prime_numbers_index27\
    \ = 0;\n    let mut prime_numbers_index28 = 0;\n    let mut prime_numbers_index29\
    \ = 0;\n    let mut prime_numbers_index30 = 0;\n    let mut prime_numbers_index31\
    \ = 0;\n    let mut prime_numbers_index32 = 0;\n    let mut prime_numbers_index33\
    \ = 0;\n    let mut prime_numbers_index34 = 0;\n    let mut prime_numbers_index35\
    \ = 0;\n    let mut prime_numbers_index36 = 0;\n    let mut prime_numbers_index37\
    \ = 0;\n    let mut prime_numbers_index38 = 0;\n    let mut prime_numbers_index39\
    \ = 0;\n    let mut prime_numbers_index40 = 0;\n    let mut prime_numbers_index41\
    \ = 0;\n    let mut prime_numbers_index42 = 0;\n    let mut prime_numbers_index43\
    \ = 0;\n    let mut prime_numbers_index44 = 0;\n    let mut prime_numbers_index45\
    \ = 0;\n    let mut prime_numbers_\n}\n\nfn main() {\n    let candidate = prime_length;\n\
    \    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n\
    \    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"\
    wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n \
    \   assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"\
    Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi4jdlma_.rs:59:27\n   |\n\
    59 |     let mut prime_numbers_\n   |                           ^ help: add `;`\
    \ here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi4jdlma_.rs:12:36\n   |\n12 | fn prime_length(string: String) -> bool\
    \ {\n   |    ------------                    ^^^^ expected `bool`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().filter(|c|\
    \ {\n        c >= 'a' && c <= 'z' ||\n        c >= 'A' && c <= 'Z' ||\n      \
    \  c >= '0' && c <= '9'\n    }).count() > 1\n}\n\nfn main() {\n    let candidate\
    \ = prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")), true);\n\
    \    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"\
    kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n\
    \    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n\
    \    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"\
    go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"\
    Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3pnse0kf.rs:14:14\n   |\n\
    14 |         c >= 'a' && c <= 'z' ||\n   |              ^^^\n   |            \
    \  |\n   |              expected `&char`, found `char`\n   |              help:\
    \ consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pnse0kf.rs:14:26\n\
    \   |\n14 |         c >= 'a' && c <= 'z' ||\n   |                          ^^^\n\
    \   |                          |\n   |                          expected `&char`,\
    \ found `char`\n   |                          help: consider borrowing here: `&'z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3pnse0kf.rs:15:14\n   |\n15 |\
    \         c >= 'A' && c <= 'Z' ||\n   |              ^^^\n   |              |\n\
    \   |              expected `&char`, found `char`\n   |              help: consider\
    \ borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pnse0kf.rs:15:26\n\
    \   |\n15 |         c >= 'A' && c <= 'Z' ||\n   |                          ^^^\n\
    \   |                          |\n   |                          expected `&char`,\
    \ found `char`\n   |                          help: consider borrowing here: `&'Z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3pnse0kf.rs:16:14\n   |\n16 |\
    \         c >= '0' && c <= '9'\n   |              ^^^\n   |              |\n \
    \  |              expected `&char`, found `char`\n   |              help: consider\
    \ borrowing here: `&'0'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pnse0kf.rs:16:26\n\
    \   |\n16 |         c >= '0' && c <= '9'\n   |                          ^^^\n\
    \   |                          |\n   |                          expected `&char`,\
    \ found `char`\n   |                          help: consider borrowing here: `&'9'`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut\
    \ prime_numbers = vec![];\n    let mut prime_numbers_len = string.len();\n   \
    \ let mut prime_numbers_counter = 1;\n    let mut prime_numbers_counter_len =\
    \ 1;\n    let mut prime_numbers_counter_len_len = 1;\n    let mut prime_numbers_counter_len_len_len\
    \ = 1;\n    let mut prime_numbers_counter_len_len_len = 1;\n    let mut prime_numbers_counter_len_len_len\
    \ = 1;\n    let mut prime_numbers_counter_len_len_len = 1;\n    let mut prime_numbers_counter_len_len\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter\
    \ = 1;\n    let mut prime_numbers_counter_len = 1;\n    let mut prime_numbers_counter_len\
    \ = 1;\n    let mut prime_\n}\n\nfn main() {\n    let candidate = prime_length;\n\
    \    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n\
    \    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"\
    wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n \
    \   assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"\
    Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa14twb16.rs:59:19\n   |\n\
    59 |     let mut prime_\n   |                   ^ help: add `;` here\n60 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa14twb16.rs:12:36\n\
    \   |\n12 | fn prime_length(string: String) -> bool {\n   |    ------------  \
    \                  ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut\
    \ prime_length: usize = 0;\n    for c in string.chars() {\n        if !is_prime(c.as_bytes())\
    \ {\n            return false;\n        }\n        prime_length += 1;\n    }\n\
    \    prime_length == string.length()\n}\n\nfn main() {\n    let candidate = prime_length;\n\
    \    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n\
    \    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"\
    wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n \
    \   assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"\
    Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpfe3awfwz.rs:15:13\n\
    \   |\n15 |         if !is_prime(c.as_bytes()) {\n   |             ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `as_bytes` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpfe3awfwz.rs:15:24\n   |\n15 |   \
    \      if !is_prime(c.as_bytes()) {\n   |                        ^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpfe3awfwz.rs:20:28\n   |\n20 | \
    \    prime_length == string.length()\n   |                            ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().all(|c|\
    \ {\n        c >= 'a' && c <= 'z' ||\n        c >= 'A' && c <= 'Z' ||\n      \
    \  c >= '0' && c <= '9' ||\n        c >= 'a' && c <= 'z' ||\n        c >= 'A'\
    \ && c <= 'Z' ||\n        c >= '0' && c <= '9'\n    })\n}\n\nfn main() {\n   \
    \ let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"Hello\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"\
    kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n\
    \    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n\
    \    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"\
    go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"\
    Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp88_edh7u.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut\
    \ prime_number = 2;\n    let mut i = 1;\n    while i <= string.len() {\n     \
    \   if string.chars().any(|c| c % prime_number == 0) {\n            return false;\n\
    \        }\n        prime_number += 2;\n        i += 1;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"\
    Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n\
    \    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"\
    orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n\
    \    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"\
    MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n \
    \   assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmpnyli_eht.rs:16:37\n\
    \   |\n16 |         if string.chars().any(|c| c % prime_number == 0) {\n   | \
    \                                  - ^ ------------ {integer}\n   |          \
    \                         |\n   |                                   char\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() == string.length()\n}\n\nfn main() {\n    let\
    \ candidate = prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"\
    kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n\
    \    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n\
    \    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"\
    go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"\
    Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp20lh79r9.rs:13:36\n   |\n\
    13 |     string.chars().filter(|c| c >= 'a' && c <= 'z').count() == string.length()\n\
    \   |                                    ^^^\n   |                           \
    \         |\n   |                                    expected `&char`, found `char`\n\
    \   |                                    help: consider borrowing here: `&'a'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp20lh79r9.rs:13:48\n   |\n13 |\
    \     string.chars().filter(|c| c >= 'a' && c <= 'z').count() == string.length()\n\
    \   |                                                ^^^\n   |               \
    \                                 |\n   |                                    \
    \            expected `&char`, found `char`\n   |                            \
    \                    help: consider borrowing here: `&'z'`\n\nerror[E0599]: no\
    \ method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp20lh79r9.rs:13:71\n   |\n13 |     string.chars().filter(|c| c >= 'a'\
    \ && c <= 'z').count() == string.length()\n   |                              \
    \                                         ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().filter(|c|\
    \ c.is_ascii_lowercase()).count() <= 2\n}\n\nfn main() {\n    let candidate =\
    \ prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")), true);\n \
    \   assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"\
    kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n\
    \    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n\
    \    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"\
    go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"\
    Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb42sg6ul.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().all(|c|\
    \ {\n        c >= 'a' && c <= 'z' &&\n            c >= 'A' && c <= 'Z' &&\n  \
    \          c >= '0' && c <= '9'\n    })\n}\n\nfn main() {\n    let candidate =\
    \ prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")), true);\n \
    \   assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"\
    kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n\
    \    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n\
    \    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"\
    go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"\
    Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0swlskh7.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().all(|c|\
    \ is_prime(c))\n}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"\
    Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n\
    \    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"\
    orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n\
    \    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"\
    MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n \
    \   assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpkwjzfbcf.rs:13:28\n\
    \   |\n13 |     string.chars().all(|c| is_prime(c))\n   |                    \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() == string.chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count()\n}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"\
    Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n\
    \    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"\
    orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n\
    \    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"\
    MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n \
    \   assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1c69r2h6.rs:13:36\n   |\n\
    13 |     string.chars().filter(|c| c >= 'a' && c <= 'z').count() == string.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count()\n   |                                    ^^^\n\
    \   |                                    |\n   |                             \
    \       expected `&char`, found `char`\n   |                                 \
    \   help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1c69r2h6.rs:13:48\n   |\n13 |     string.chars().filter(|c| c >=\
    \ 'a' && c <= 'z').count() == string.chars().filter(|c| c >= 'A' && c <= 'Z').count()\n\
    \   |                                                ^^^\n   |               \
    \                                 |\n   |                                    \
    \            expected `&char`, found `char`\n   |                            \
    \                    help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1c69r2h6.rs:13:95\n   |\n13 |     string.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() == string.chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count()\n   |                                                         \
    \                                      ^^^\n   |                             \
    \                                                                  |\n   |   \
    \                                                                            \
    \                expected `&char`, found `char`\n   |                        \
    \                                                                       help:\
    \ consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1c69r2h6.rs:13:107\n\
    \   |\n13 |     string.chars().filter(|c| c >= 'a' && c <= 'z').count() == string.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count()\n   |                                        \
    \                                                                   ^^^\n   |\
    \                                                                            \
    \                               |\n   |                                      \
    \                 "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut\
    \ prime_length: usize = 0;\n    for c in string.chars() {\n        if c < '0'\
    \ || c > '9' {\n            return false;\n        }\n        let digit = c -\
    \ '0';\n        if digit % 2 == 0 {\n            prime_length += 1;\n        }\n\
    \    }\n    prime_length == string.len()\n}\n\nfn main() {\n    let candidate\
    \ = prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")), true);\n\
    \    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"\
    kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n\
    \    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n\
    \    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"\
    go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"\
    Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp5j6bva6i.rs:18:23\n\
    \   |\n18 |         let digit = c - '0';\n   |                     - ^ --- char\n\
    \   |                     |\n   |                     char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    string.chars().filter(|c|\
    \ c.is_ascii_letter()).count() > 1\n}\n\nfn main() {\n    let candidate = prime_length;\n\
    \    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n\
    \    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"\
    wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n \
    \   assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"\
    Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp800_xjeu.rs:13:33\n   |\n13 |     string.chars().filter(|c|\
    \ c.is_ascii_letter()).count() > 1\n   |                                 ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut\
    \ prime_length: usize = 0;\n    for c in string.chars() {\n        if !is_prime(c.as_bytes())\
    \ {\n            return false;\n        }\n        prime_length += 1;\n    }\n\
    \    prime_length == string.len()\n}\n\nfn main() {\n    let candidate = prime_length;\n\
    \    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n\
    \    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"\
    wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n \
    \   assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"\
    Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp473zsltj.rs:15:13\n\
    \   |\n15 |         if !is_prime(c.as_bytes()) {\n   |             ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `as_bytes` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp473zsltj.rs:15:24\n   |\n15 |   \
    \      if !is_prime(c.as_bytes()) {\n   |                        ^^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a string and returns true if the string\n\
    /// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"\
    Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n\
    /// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"\
    orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut\
    \ prime_length: usize = 0;\n    for c in string.chars() {\n        if !is_prime(c.as_bytes())\
    \ {\n            return false;\n        }\n        prime_length += 1;\n    }\n\
    \    prime_length == string.len()\n}\n\nfn main() {\n    let candidate = prime_length;\n\
    \    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n\
    \    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"\
    wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n \
    \   assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"\
    Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"\
    gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"\
    M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpsoc9zjyq.rs:15:13\n\
    \   |\n15 |         if !is_prime(c.as_bytes()) {\n   |             ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `as_bytes` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpsoc9zjyq.rs:15:24\n   |\n15 |   \
    \      if !is_prime(c.as_bytes()) {\n   |                        ^^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
