name: HumanEval_18_how_many_times
language: rs
prompt: "/// Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"\
  a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n\
  /// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n///\
  \ 3\nfn how_many_times(string: String, substring: String) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
  \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
  ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
  ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
  ), String::from(\"john\")), 1);\n}\n"
completions: ["    let mut counter = 0;\n    let mut index = string.find(substring);\n\
    \    while index != String::npos {\n        counter += 1;\n        index = string.find(substring,\
    \ index + 1);\n    }\n    counter", '    string.chars().filter(|c| c == substring).count()
    + 1', '    string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()',
  "    let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.contains(substring, pos) {\n            count += 1;\n     \
    \   }\n        pos += 1;\n    }\n    count", "    let mut count = 0;\n    let\
    \ mut iter = string.char_indices();\n    let mut sub = substring.char_indices();\n\
    \    while let Some((i, _)) = iter.next() {\n        if let Some((j, _)) = sub.next()\
    \ {\n            if i == j {\n                count += 1;\n            }\n   \
    \     }\n    }\n    count", '    string.chars().zip(substring.chars()).filter(|(a,
    b)| a == b).count()', '    string.chars().filter(|c| substring.contains(&c)).count()',
  '    string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()', " \
    \   let mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.starts_with(substring, pos) {\n            counter += 1;\n\
    \        }\n        pos += 1;\n    }\n    counter", '    string.chars().filter(|c|
    c == substring).count() + 1', '    string.chars().zip(substring.chars()).filter(|(a,
    b)| a == b).count()', '    string.chars().filter(|c| substring.contains(&c)).count()',
  "    let mut count = 0;\n    let mut string_iter = string.chars();\n    let mut\
    \ substring_iter = substring.chars();\n    let mut char_iter = char_iter(&mut\
    \ string_iter);\n    let mut substring_iter = substring_iter.chars();\n    let\
    \ mut char_iter = char_iter(&mut substring_iter);\n    while char_iter.peek()\
    \ != Some(char_iter.next()) {\n        char_iter.next();\n        char_iter.next();\n\
    \        count += 1;\n    }\n    count", '    string.chars().filter(|c| substring.contains(&c)).count()',
  '    string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()', '    string.chars().zip(substring.chars()).filter(|(a,
    b)| a == b).count()', '    string.chars().zip(substring.chars()).filter(|&(a,
    b)| a == b).count()', '    string.chars().zip(substring.chars()).filter(|(a, b)|
    a == b).count()', "    let mut count = 0;\n    let mut pos = 0;\n    while pos\
    \ < string.len() {\n        if string.starts_with(substring, pos) {\n        \
    \    count += 1;\n        }\n        pos += 1;\n    }\n    count", '    string.chars().filter(|c|
    substring.contains(&c)).count()']
stop_tokens:
- "\n}"
