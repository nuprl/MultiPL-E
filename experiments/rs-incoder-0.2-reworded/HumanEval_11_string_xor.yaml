name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
  010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
  \ b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ["    String::from_utf8(\n        a.as_bytes().iter().chain(b.as_bytes().iter()).map(|x|\
    \ x ^ 0xff).collect(),\n    )", '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  "    let mut res = String::new();\n    for &c in a.chars().chain(b.chars()) {\n\
    \        res.push((c ^ b[a.chars().index(c)]) as char);\n    }\n    res", "  \
    \  let mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n  \
    \      *res += if *c != *c { *c };\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    a.iter().chain(b.iter()).filter(|&b| b == '1').collect::<String>()",
  '    a.to_owned() & b.to_owned()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  "    let mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n  \
    \      if *c != *c {\n            res.push_str(&format!(\"{}\", *c));\n      \
    \  } else {\n            res.push_str(&format!(\"{}\", *c ^ *c));\n        }\n\
    \    }\n    res", "    String::from(\n        a.chars().zip(b.chars()).fold(String::new(),\
    \ |mut acc, (char1, char2)| {\n            acc.push_str(char1.to_string() + char2.to_string());\n\
    \            acc\n        }),\n    )", '    String::from(a.to_owned() & b.to_owned())',
  "    let mut result = String::new();\n    for &c in &a & &b {\n        if *c !=\
    \ 0 {\n            result.push(*c);\n        }\n    }\n    result", '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect::<String>()', '    String::from(binary_xor_str(a, b))', '    a.to_string().xor_(b).to_string()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()']
stop_tokens:
- "\n}"
