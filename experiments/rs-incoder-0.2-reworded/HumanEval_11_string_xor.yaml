name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
  010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
  \ b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ["    String::from_utf8(\n        a.as_bytes().iter().chain(b.as_bytes().iter()).map(|x|\
    \ x ^ 0xff).collect(),\n    )", '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  "    let mut res = String::new();\n    for &c in a.chars().chain(b.chars()) {\n\
    \        res.push((c ^ b[a.chars().index(c)]) as char);\n    }\n    res", "  \
    \  let mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n  \
    \      *res += if *c != *c { *c };\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    a.iter().chain(b.iter()).filter(|&b| b == '1').collect::<String>()",
  '    a.to_owned() & b.to_owned()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  "    let mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n  \
    \      if *c != *c {\n            res.push_str(&format!(\"{}\", *c));\n      \
    \  } else {\n            res.push_str(&format!(\"{}\", *c ^ *c));\n        }\n\
    \    }\n    res", "    String::from(\n        a.chars().zip(b.chars()).fold(String::new(),\
    \ |mut acc, (char1, char2)| {\n            acc.push_str(char1.to_string() + char2.to_string());\n\
    \            acc\n        }),\n    )", '    String::from(a.to_owned() & b.to_owned())',
  "    let mut result = String::new();\n    for &c in &a & &b {\n        if *c !=\
    \ 0 {\n            result.push(*c);\n        }\n    }\n    result", '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect::<String>()', '    String::from(binary_xor_str(a, b))', '    a.to_string().xor_(b).to_string()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', "    let mut res =\
    \ String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect());\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res", '    a.to_owned() &
    b.to_owned()', '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        *result .= if *c != *c { *c };\n    }\n    result", "    let mut\
    \ res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a.chars().nth(i).unwrap()\
    \ ^ b.chars().nth(i).unwrap());\n    }\n    res", '    String::from(a.to_owned()
    + b.to_owned())', '    String::from(format!("{:b}", bincode::xor(a.to_string(),
    b.to_string())))', "    a.to_string().xor_eq(&b.to_string())\n        .map(|x|\
    \ x.to_string())\n        .unwrap_or(String::from(\"0\"))", '    a.to_owned()
    & b.to_owned()', "    a.to_string().chars().zip(b.to_string().chars())\n     \
    \   .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()", "    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_string()", "  \
    \  let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a & &b {\n        if *c != 0 {\n            result.push(*c);\n\
    \        }\n    }\n    result", "    let mut result = String::new();\n    for\
    \ &c in &a | &b {\n        if *c != 0 {\n            result.push(*c);\n      \
    \  }\n    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().xor_(b).to_string()', "    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_string()", '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()', '    a.to_string().xor_(b).to_string()',
  '    String::from(format!("{:b}", a.to_u32() ^ b.to_u32()))', '    a.to_owned()
    & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", '    a.to_owned() & b.to_owned()',
  "    let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().map(|x|\
    \ if x == b'1' { b'0' } else { b'1' }).collect::<String>());\n    }\n    for i\
    \ in 0..b.len() {\n        res.push_str(&b[i..].iter().map(|x| if x == b'1' {\
    \ b'0' } else { b'1' }).collect::<String>());\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()',
  "    a.iter().chain(b.iter()).filter(|&b| b == '1').collect::<String>()", '    a.to_owned()
    & b.to_owned()', "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut res = String::new();\n\
    \    for &c in &a | &b {\n        if *c != '0' {\n            res.push_str(&*c\
    \ + '0');\n        } else {\n            res.push_str(&*c + '1');\n        }\n\
    \    }\n    res", '    a.iter().chain(b.iter()).map(|c| c ^ 0xff).collect()',
  '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for &c in &a & &b\
    \ {\n        if *c != 0 {\n            res.push_str(&*c as char);\n        }\n\
    \    }\n    res", '    a.to_owned() & b.to_owned()', '    String::from(a.to_owned()
    ^ b.to_owned())', '    a.to_owned() & b.to_owned()', "    let mut result = String::new();\n\
    \    for &c in &a & &b {\n        match c {\n            '0' => result.push('0'),\n\
    \            '1' => result.push('1'),\n            _ => panic!(\"String contains\
    \ invalid character: {}\", c),\n        }\n    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for &b in &b {\n\
    \        if *b != 0 {\n            res.push_str(&a[*b as usize]);\n        }\n\
    \    }\n    res", "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", '    String::from(a.to_owned()
    ^ b.to_owned())', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for (a, b) in\
    \ a.chars().zip(b.chars()) {\n        if *a != *b {\n            result.push(*a\
    \ ^ *b);\n        }\n    }\n    result", '    a.to_owned() & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() & b.to_owned())', '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].iter().map(|x| if x == b[i] { x } else { 0 }).collect::<String>());\n\
    \    }\n    res", "    let mut res = String::new();\n    for i in 0..a.len() {\n\
    \        res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n    }\n   \
    \ res", '    String::from(a.to_owned() + b.to_owned())', '    a.to_owned() & b.to_owned()',
  "    a.to_string().xor_eq(&b.to_string())\n        .expect(\"String XOR failed\"\
    )\n        .to_string()", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a & &b {\n        if *c != '0' {\n            result.push(*c);\n\
    \        }\n    }\n    result", '    String::from(a.to_owned() ^ b.to_owned())',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut res = String::new();\n    for &c in &a | &b {\n        if *c != 0 {\n\
    \            res.push_str(&*c as char);\n        }\n    }\n    res", '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    a.iter().chain(b.iter()).map(|x| x.to_ascii_lowercase()).fold(String::new(),\
    \ |x, y| {\n        x.chars().zip(y.chars()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \    })", '    a.to_owned() & b.to_owned()', "    let mut res = String::new();\n\
    \    for &c in &a { res += &c ^ &b[c.to_digit(10).unwrap()]; }\n    res", '    a.to_owned()
    & b.to_owned()', "    a.to_string().chars().zip(b.to_string().chars())\n     \
    \   .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()", "    let mut\
    \ result = String::new();\n    for &b in &b {\n        if *b == '1' {\n      \
    \      result.push(*a);\n        }\n        *a = '0';\n        *a = '1';\n   \
    \     *a = '0';\n        *a = '1';\n    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(format!("{:b}", bincode::xor(&a, &b)))',
  '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect::<String>()', "    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_string()", "  \
    \  let mut result = String::new();\n    for &b in b.chars().cloned() {\n     \
    \   if a.chars().any(|c| c == b) {\n            result.push(b);\n        }\n \
    \   }\n    result", "    let mut result = String::new();\n    for &b in &b {\n\
    \        if *b != 0 {\n            result.push(*a);\n        }\n        *a = (*a)\
    \ ^ *b;\n        a++;\n    }\n    result", '    String::from(format!("{:b}", bin::Xor(a.to_string(),
    b.to_string())))', '    a.to_string().xor_(b).to_string()', '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() & b.to_owned())', "    let\
    \ mut result = String::new();\n    for &c in &a & &b {\n        if *c != '0' {\n\
    \            result.push(*c);\n        }\n    }\n    result", '    String::from(a.to_owned()
    + b.to_owned())', "    a.to_string().xor_eq(&b.to_string())\n        .to_string()",
  '    a.to_string().iter().zip(b.to_string().iter()).map(|(a, b)| a ^ b).collect()',
  '    a.to_owned() & b.to_owned()', '    a.iter().zip(b.iter()).map(|(a, b)| a ^
    b).collect()', '    a.to_owned() & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() & b.to_owned())', "    let\
    \ mut result = String::new();\n    for &c in &a & &b {\n        if *c != 0 {\n\
    \            result.push(*c);\n        }\n    }\n    result", "    let mut res\
    \ = String::new();\n    for &c in &a { res.push(c); }\n    for &c in &b { res.push(c);\
    \ }\n    res", "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        *result += if *c != *c { *c };\n    }\n    result", "    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()", "   \
    \ let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a.chars()\n\
    \            .skip(i)\n            .take(b.len())\n            .map(|b| b as char)\n\
    \            .collect::<String>());\n    }\n    res.push_str(&b.chars().collect::<String>());\n\
    \    res", '    a.to_owned() & b.to_owned()', "    let mut res = String::new();\n\
    \    for &c in &a & &b {\n        if *c != 0 {\n            res.push_str(&*c as\
    \ char);\n        }\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.iter().chain(b.iter()).filter(|x| x != 0).collect::<String>()',
  "    let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().map(|c|\
    \ c ^ b[i..]).collect::<String>());\n    }\n    res", "    let mut result = String::new();\n\
    \    for &c in &a | &b {\n        if *c != '0' {\n            result.push(*c);\n\
    \        }\n    }\n    result", "    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    a.to_string().xor_eq(&b.to_string())\n        .to_string()",
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut result = String::new();\n    for &c in &a | &b {\n        if *c !=\
    \ '0' {\n            result.push(*c);\n        }\n    }\n    result", "    let\
    \ mut result = String::new();\n    for &c in &a | &b {\n        if *c != 0 {\n\
    \            result.push(*c);\n        }\n    }\n    result", '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.to_owned() & b.to_owned()', '    a.to_owned() & b.to_owned()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    String::from(format!("{:b}", bincode::xor_encode(a.as_bytes(), b.as_bytes())))',
  '    String::from(binary_xor_impl(a, b).to_string())', "    let mut res = String::new();\n\
    \    for i in 0..a.len() {\n        res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n\
    \    }\n    res", '    a.to_owned() & b.to_owned()', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result", '    a.to_owned() & b.to_owned()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  "    let mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n  \
    \      *res += if *c != *c { *c };\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for &c in &a & &b\
    \ {\n        if *c != 0 {\n            res.push_str(&*c as char);\n        }\n\
    \    }\n    res", '    a.to_string().iter().chain(b.to_string().iter()).map(|x|
    x ^ 1).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)|
    a ^ b).collect()', '    a.to_string().iter().zip(b.to_string().iter()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for &c in &a & &b\
    \ {\n        if *c != 0 {\n            res.push_str(&*c as char);\n        }\n\
    \    }\n    res", "    let mut result = String::new();\n    for &c in &a & &b\
    \ {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n  \
    \  result", "    a.to_string().xor_eq(&b.to_string())\n        .to_string()",
  "    let mut res = String::new();\n    for &c in &a { res.push(c); }\n    for &c\
    \ in &b { res.push(c); }\n    res", "    let mut result = String::new();\n   \
    \ for &c in &a & &b {\n        if *c != 0 {\n            result.push(*c);\n  \
    \      }\n    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for i in a.chars().zip(b.chars()).filter(|&(a,\
    \ b)| a == b).map(|&(a, b)| {\n        res.push_str(&format!(\"{}\", a ^ b));\n\
    \    });\n    res", "    String::from(\n        a.chars().filter(|c| b.get(c)\
    \ != Some(1))\n            .chain(b.get(c).unwrap().chars().filter(|c| a.get(c)\
    \ != Some(1)))\n            .collect::<String>()\n            .join(),\n    )",
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  '    a.to_owned() & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    a.to_string().xor_eq(&b.to_string())\n        .to_string()",
  '    a.to_string().xor_eq(&b.to_string()).to_string()', '    a.to_owned() & b.to_owned()',
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", '    String::from(a.to_owned() & b.to_owned())',
  "    a.iter().chain(b.iter()).filter(|&b| b == '1').collect::<String>()", '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.to_string().xor_eq(&b.to_string()).to_string()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    String::from(a.to_owned() + b.to_owned())', "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a & &b {\n        if *c !=\
    \ 0 {\n            result.push(*c);\n        }\n    }\n    result", "    let mut\
    \ result = String::new();\n    for &c in &a & &b {\n        if *c != 0 {\n   \
    \         result.push(*c);\n        }\n    }\n    result", '    String::from(a.to_owned()
    & b.to_owned())', '    String::from(a.to_owned() & b.to_owned())', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push(a[i] ^ b[i]);\n    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() ^ b.to_owned())', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()']
stop_tokens:
- "\n}"
