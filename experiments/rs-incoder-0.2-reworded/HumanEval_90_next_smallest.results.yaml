language: rs
name: HumanEval_90_next_smallest
results:
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_index = 1;\n        }\n        if i == smallest {\n\
    \            smallest_index += 1;\n        }\n    }\n    Some(smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ln3s2h2.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = 0;\n    let mut smallest_val = lst.iter().min().unwrap();\n \
    \   for &v in lst {\n        if v < smallest_val {\n            smallest_val =\
    \ v;\n            smallest_idx = lst.iter().position(|&x| x == smallest_val).unwrap();\n\
    \        }\n        smallest[smallest_idx] = v;\n    }\n    smallest\n       \
    \ .iter()\n        .position(|&x| x == smallest_val)\n        .map(|idx| smallest[smallest_idx])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrhdhsbb.rs:16:9\n   |\n\
    16 |     for &v in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `v`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphrhdhsbb.rs:19:58\n   |\n19 |             smallest_idx = lst.iter().position(|&x|\
    \ x == smallest_val).unwrap();\n   |                                         \
    \                 ^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |             smallest_idx = lst.iter().position(|&x|\
    \ x == *smallest_val).unwrap();\n   |                                        \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphrhdhsbb.rs:21:34\n\
    \   |\n21 |         smallest[smallest_idx] = v;\n   |         ----------------------\
    \   ^ expected integer, found `&isize`\n   |         |\n   |         expected\
    \ due to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         smallest[smallest_idx] = *v;\n   |                       \
    \           +\n\nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmphrhdhsbb.rs:25:26\n\
    \   |\n25 |         .position(|&x| x == smallest_val)\n   |                  \
    \        ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index + 1).unwrap();\n    if smallest_value == smallest\
    \ {\n        smallest_value = lst.iter().nth(smallest_index).unwrap();\n    }\n\
    \    Some(smallest_value)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4wxyhcz3.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4wxyhcz3.rs:19:21\n   |\n19 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4wxyhcz3.rs:25:10\n\
    \   |\n25 |     Some(smallest_value)\n   |          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n25 |  \
    \   Some(*smallest_value)\n   |          +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, elem)| elem\
    \ < lst.iter().next().unwrap()).map(|(_, elem)| elem)\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(2)`', /tmp/tmp77p7s4bn.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxx4mgyc3.rs:18:60\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxx4mgyc3.rs:23:10\n   |\n23 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_index = 1;\n        }\n        if i == smallest {\n\
    \            smallest_index += 1;\n        }\n    }\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvgwgsu4i.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if smallest[0] < elt {\n            smallest[0] = elt;\n\
    \        }\n        if smallest[1] < elt {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:15:26\n   |\n\
    15 |         if smallest[0] < elt {\n   |                          ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if smallest[0]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:16:27\n   |\n16 |\
    \             smallest[0] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:18:26\n\
    \   |\n18 |         if smallest[1] < elt {\n   |                          ^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n18 |         if smallest[1]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:19:27\n   |\n19 |\
    \             smallest[1] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:25:14\n\
    \   |\n25 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_idx = 1;\n        } else if x == smallest {\n     \
    \       smallest_idx += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvk305r6c.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len()\
    \ - 2)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0js9ck5s.rs:13:55\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len() - 2)\n  \
    \ |                                                       ^^^^^^^^^^^^^ expected\
    \ `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0js9ck5s.rs:13:5\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                               ------------- expected `Option<isize>` because\
    \ of return type\n13 |     lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len()\
    \ - 2)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<(usize, isize)>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst[0];\n    let mut smallest_index = 1;\n    for &i in\
    \ lst {\n        if i < smallest {\n            smallest = i;\n            smallest_index\
    \ = 1;\n        } else if i == smallest {\n            smallest_index += 1;\n\
    \        }\n    }\n    Some(smallest + smallest_index * 2)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnd4kdoe6.rs:18:9\n   |\n\
    18 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    if\
    \ smallest == lst.len() {\n        return None;\n    }\n    let mut smallest_index\
    \ = smallest;\n    for index in lst.iter().rev() {\n        if index == smallest_index\
    \ {\n            continue;\n        }\n        if index < smallest_index {\n \
    \           smallest_index = index;\n        }\n    }\n    Some(smallest_index)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9d8k0q1o.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n\
    \  --> /tmp/tmp9d8k0q1o.rs:14:17\n   |\n14 |     if smallest == lst.len() {\n\
    \   |                 ^^ no implementation for `&isize == usize`\n   |\n   = help:\
    \ the trait `PartialEq<usize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9d8k0q1o.rs:26:10\n   |\n26 |\
    \     Some(smallest_index)\n   |          ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n26 |     Some(*smallest_index)\n\
    \   |          +\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_index = 0;\n    let mut smallest_value = lst.iter().min().unwrap();\n\
    \    for &x in lst {\n        if x < smallest_value {\n            smallest_value\
    \ = x;\n            smallest_index = 0;\n        }\n        if x == smallest_value\
    \ {\n            smallest_index += 1;\n        }\n        smallest[smallest_index]\
    \ = x;\n    }\n    smallest.iter().nth(1).cloned()\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb0et44bz.rs:16:9\n   |\n\
    16 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb0et44bz.rs:24:36\n   |\n24 |         smallest[smallest_index]\
    \ = x;\n   |         ------------------------   ^ expected integer, found `&isize`\n\
    \   |         |\n   |         expected due to the type of this binding\n   |\n\
    help: consider dereferencing the borrow\n   |\n24 |         smallest[smallest_index]\
    \ = *x;\n   |                                    +\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtnzjgvp.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmtnzjgvp.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    if smallest_index == 0 {\n \
    \       smallest_index = 1;\n    }\n    while smallest_index != 0 {\n        if\
    \ smallest_value < lst.iter().nth(smallest_index - 1).unwrap() {\n           \
    \ smallest_value = lst.iter().nth(smallest_index).unwrap();\n            smallest_index\
    \ = smallest_index - 1;\n        } else {\n            smallest_index = 0;\n \
    \       }\n    }\n    Some(smallest_value)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp10rdahyn.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp10rdahyn.rs:30:10\n   |\n30 |     Some(smallest_value)\n\
    \   |          ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n30 |     Some(*smallest_value)\n   |       \
    \   +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ &x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n  \
    \      }\n        if x > smallest[1] {\n            smallest[1] = x;\n       \
    \ }\n    }\n    if smallest[0] == smallest[1] {\n        None\n    } else {\n\
    \        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf81f16hm.rs:14:9\n   |\n\
    14 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf81f16hm.rs:25:14\n   |\n25 |         Some(smallest[1])\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    25 |         Some(smallest[1].try_into().unwrap())\n   |                     \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, elem)| elem\
    \ < lst.iter().next().unwrap()).map(|(_, elem)| elem)\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(2)`', /tmp/tmpb1m5ruz8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() <= 1 {\n        return None;\n    }\n \
    \   let mut smallest = vec![0; lst.len()];\n    smallest[0] = lst[0];\n    smallest[1]\
    \ = lst[1];\n    for i in 2..lst.len() {\n        if smallest[i] > smallest[i\
    \ - 1] {\n            smallest[i] = smallest[i - 1];\n        }\n    }\n    smallest\n\
    \        .iter()\n        .next()\n        .cloned()\n        .ok_or(Error::NoSuchElement)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Error`\n  -->\
    \ /tmp/tmp9ngp9m4x.rs:28:16\n   |\n28 |         .ok_or(Error::NoSuchElement)\n\
    \   |                ^^^^^ use of undeclared type `Error`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9ngp9m4x.rs:24:5\n   |\n12 |   fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                        -------------\
    \ expected `Option<isize>` because of return type\n...\n24 | /     smallest\n\
    25 | |         .iter()\n26 | |         .next()\n27 | |         .cloned()\n28 |\
    \ |         .ok_or(Error::NoSuchElement)\n   | |____________________________________^\
    \ expected enum `Option`, found enum `Result`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found enum `Result<isize, _>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmpp1bg3x4k.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0608`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    let mut smallest_index = lst.iter().position(|x|\
    \ *x == smallest_value).unwrap();\n    if smallest_index == lst.len() - 1 {\n\
    \        return Some(smallest);\n    }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpt_w0ez3_.rs:57:1\n   |\n57\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpt_w0ez3_.rs:56:41\n\
    \   |\n56 |     let mut smallest_value = lst.iter().\n   |                   \
    \                      ^ help: add `;` here\n57 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt_w0ez3_.rs:17:60\n   |\n17 |\
    \     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt_w0ez3_.rs:19:21\n   |\n19 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_w0ez3_.rs:22:60\n\
    \   |\n22 |     let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \   |                                                            ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest_value).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt_w0ez3_.rs:24:21\n   |\n24 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_w0ez3_.rs:27:60\n\
    \   |\n27 |     let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \   |                                                            ^^^^^^^^^^^^^^\
    \ expected "
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = vec![0; lst.len()];\n    let mut smallest_idx = 1;\n  \
    \  let mut smallest_val = lst[0];\n    for &i in lst {\n        if smallest[smallest_idx]\
    \ < i {\n            smallest[smallest_idx] = i;\n            smallest_idx = smallest_idx\
    \ + 1;\n        }\n    }\n    if smallest_idx == lst.len() {\n        return None;\n\
    \    }\n    Some(smallest[smallest_idx])\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9trj8nil.rs:19:9\n   |\n\
    19 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = x;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        smallest\n    } else {\n\
    \        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpalzfo0lo.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpalzfo0lo.rs:22:9\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n22 |         smallest\n\
    \   |         ^^^^^^^^ expected enum `Option`, found struct `Vec`\n   |\n   =\
    \ note: expected enum `Option<isize>`\n            found struct `Vec<i32>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    let mut second_smallest\
    \ = lst.iter().skip(smallest_index + 1).min().unwrap();\n    if second_smallest\
    \ == smallest {\n        return None;\n    }\n    Some(second_smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzm3wgx9n.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzm3wgx9n.rs:22:10\n   |\n22 |     Some(second_smallest)\n\
    \   |          ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     Some(*second_smallest)\n   |      \
    \    +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() - 1 {\n       \
    \ return Some(smallest);\n    }\n    let mut smallest_value = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    if smallest_value < smallest {\n        smallest = smallest_value;\n\
    \        smallest_index = smallest_index + 1;\n    }\n    Some(smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_iqzd8fn.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_iqzd8fn.rs:19:21\n   |\n19 |         return Some(smallest);\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<&isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_iqzd8fn.rs:22:25\n   |\n22 |  \
    \   if smallest_value < smallest {\n   |                         ^^^^^^^^ expected\
    \ `&isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n\
    \                   found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_iqzd8fn.rs:23:20\n   |\n23 |         smallest = smallest_value;\n\
    \   |                    ^^^^^^^^^^^^^^\n   |                    |\n   |     \
    \               expected enum `Option`, found `&isize`\n   |                 \
    \   help: try using a variant of the expected enum: `Some(smallest_value)`\n \
    \  |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_iqzd8fn.rs:26:10\n\
    \   |\n26 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<&isize>`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst[0];\n    let mut smallest_index = 0;\n\n    for &x\
    \ in lst {\n        if x < smallest {\n            smallest = x;\n           \
    \ smallest_index = 0;\n        }\n\n        if x == smallest {\n            smallest_index\
    \ += 1;\n        }\n    }\n\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp907pfwwh.rs:20:9\n   |\n\
    20 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if smallest[0] < elt {\n            smallest[0] = elt;\n\
    \        }\n        if smallest[1] < elt {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:15:26\n   |\n\
    15 |         if smallest[0] < elt {\n   |                          ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if smallest[0]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:16:27\n   |\n16 |\
    \             smallest[0] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:18:26\n\
    \   |\n18 |         if smallest[1] < elt {\n   |                          ^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n18 |         if smallest[1]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:19:27\n   |\n19 |\
    \             smallest[1] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:25:14\n\
    \   |\n25 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ - 1 {\n        return Some(smallest);\n    }\n    let mut smallest_idx = smallest_idx\
    \ + 1;\n    while smallest_idx < lst.len() {\n        if lst.iter()[smallest_idx]\
    \ > smallest {\n            break;\n        }\n        smallest_idx += 1;\n  \
    \  }\n    Some(lst.iter()[smallest_idx])\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl0xtiw8d.rs:17:58\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl0xtiw8d.rs:19:21\n   |\n19 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0608]: cannot index into a value of type\
    \ `std::slice::Iter<'_, isize>`\n  --> /tmp/tmpl0xtiw8d.rs:23:12\n   |\n23 | \
    \        if lst.iter()[smallest_idx] > smallest {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `std::slice::Iter<'_, isize>`\n\
    \  --> /tmp/tmpl0xtiw8d.rs:28:10\n   |\n28 |     Some(lst.iter()[smallest_idx])\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    let mut next_smallest\
    \ = lst.iter().skip(smallest_index + 1).min().unwrap();\n    let mut next_smallest_index\
    \ = lst.iter().position(|&x| x == next_smallest).unwrap();\n\n    if next_smallest_index\
    \ == lst.len() - 1 {\n        return Some(next_smallest);\n    }\n\n    Some(next_smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmsp1bjvw.rs:18:60\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmsp1bjvw.rs:21:21\n   |\n21 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmsp1bjvw.rs:25:65\n\
    \   |\n25 |     let mut next_smallest_index = lst.iter().position(|&x| x == next_smallest).unwrap();\n\
    \   |                                                                 ^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n25 |     let mut next_smallest_index = lst.iter().position(|&x| x == *next_smallest).unwrap();\n\
    \   |                                                                 +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmsp1bjvw.rs:28:21\n   |\n28 |         return\
    \ Some(next_smallest);\n   |                     ^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n28 |  \
    \       return Some(*next_smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmsp1bjvw.rs:31:10\n   |\n31 |     Some(next_smallest)\n\
    \   |          ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n31 |     Some(*next_smallest)\n   |        \
    \  +\n\nerror: aborting due to 5 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    let mut smallest_index2 = lst.iter().position(|&x|\
    \ x == smallest_value).unwrap();\n    if smallest_index2 == lst.len() {\n    \
    \    return None;\n    }\n    let mut smallest_value2 = lst.iter().nth(smallest_index2).unwrap();\n\
    \    if smallest_value2 < smallest {\n        smallest = smallest_value2;\n  \
    \      smallest_index = smallest_index2;\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpli3g5c94.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpli3g5c94.rs:19:61\n   |\n19 |     let mut smallest_index2\
    \ = lst.iter().position(|&x| x == smallest_value).unwrap();\n   |            \
    \                                                 ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |  \
    \   let mut smallest_index2 = lst.iter().position(|&x| x == *smallest_value).unwrap();\n\
    \   |                                                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpli3g5c94.rs:28:10\n   |\n28 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n28 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_index = i;\n        }\n    }\n    Some(smallest_index)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpapiacb9w.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    if smallest_value == smallest\
    \ {\n        smallest_index += 1;\n    }\n    Some(smallest_value)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpppvpfj69.rs:22:10\n   |\n\
    22 |     Some(smallest_value)\n   |          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \   Some(*smallest_value)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_index = 1;\n        } else {\n            smallest_index\
    \ += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm4swvvu5.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() <= 1 {\n        return None;\n    }\n \
    \   let mut smallest = lst[0];\n    let mut smallest_index = 1;\n    for &i in\
    \ lst {\n        if i < smallest {\n            smallest = i;\n            smallest_index\
    \ = 1;\n        } else {\n            smallest_index += 1;\n        }\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1cdmdmba.rs:18:9\n   |\n\
    18 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtnzjgvp.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmtnzjgvp.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2lom6eff.rs:71:3\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n58 |\
    \     if smallest_index == lst.len() - 1 {\n   |                             \
    \           - this delimiter might not be properly closed...\n59 |         return\
    \ Some(smallest\n60 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n71 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp2lom6eff.rs:59:20\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - closing delimiter possibly meant\
    \ for this\n...\n59 |         return Some(smallest\n   |                    ^\
    \ unclosed delimiter\n60 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2lom6eff.rs:17:60\n   |\n17 |     let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n   |                  \
    \                                          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |     let mut smallest_index\
    \ = lst.iter().position(|x| *x == *smallest).unwrap();\n   |                 \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2lom6eff.rs:19:21\n   |\n19 |         return Some(smallest);\n\
    \   |                     ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n19 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2lom6eff.rs:22:52\n\
    \   |\n22 |     smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                    ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \   smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n   |\
    \                                                    +\n\nerror[E0308]: mismatched "
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    smallest[0]\
    \ = std::i32::MAX;\n    smallest[1] = std::i32::MAX;\n    for elt in lst {\n \
    \       if smallest[0] < elt {\n            smallest[0] = elt;\n        }\n  \
    \      if smallest[1] < elt {\n            smallest[1] = elt;\n        }\n   \
    \ }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else {\n     \
    \   Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyvehzh53.rs:17:26\n   |\n\
    17 |         if smallest[0] < elt {\n   |                          ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n17 |         if smallest[0]\
    \ < elt.try_into().unwrap() {\n   |                          ~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyvehzh53.rs:18:27\n   |\n18 |\
    \             smallest[0] = elt;\n   |                           ^^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyvehzh53.rs:20:26\n\
    \   |\n20 |         if smallest[1] < elt {\n   |                          ^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |         if smallest[1]\
    \ < elt.try_into().unwrap() {\n   |                          ~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyvehzh53.rs:21:27\n   |\n21 |\
    \             smallest[1] = elt;\n   |                           ^^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyvehzh53.rs:27:14\n\
    \   |\n27 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n27 |         Some(smallest[1].try_into().unwrap())\n\
    \   |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp46druj9p.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest * smallest_index\
    \ + 1)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg1e385p5.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg1e385p5.rs:21:21\n   |\n21 |     Some(smallest\
    \ * smallest_index + 1)\n   |                     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot multiply `&isize` by `usize`\n  --> /tmp/tmpg1e385p5.rs:21:19\n\
    \   |\n21 |     Some(smallest * smallest_index + 1)\n   |                   ^\
    \ no implementation for `&isize * usize`\n   |\n   = help: the trait `Mul<usize>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest =\
    \ lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index += 1;\n\n \
    \   Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf7ddoav1.rs:21:21\n   |\n\
    21 |         return Some(smallest);\n   |                     ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    21 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf7ddoav1.rs:27:10\n   |\n27 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n27 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    let mut second_smallest\
    \ = lst.iter().skip(smallest_index + 1).min().unwrap();\n    let mut second_smallest_index\
    \ = lst.iter().position(|x| *x == second_smallest).unwrap();\n    if second_smallest_index\
    \ == lst.len() - 1 {\n        return Some(second_smallest);\n    }\n\n    Some(second_smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmputz9iswp.rs:18:60\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmputz9iswp.rs:20:21\n   |\n20 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n20 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmputz9iswp.rs:24:67\n\
    \   |\n24 |     let mut second_smallest_index = lst.iter().position(|x| *x ==\
    \ second_smallest).unwrap();\n   |                                           \
    \                        ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n24 |     let mut second_smallest_index\
    \ = lst.iter().position(|x| *x == *second_smallest).unwrap();\n   |          \
    \                                                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmputz9iswp.rs:26:21\n   |\n26 |         return Some(second_smallest);\n\
    \   |                     ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n26 |         return Some(*second_smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmputz9iswp.rs:29:10\n\
    \   |\n29 |     Some(second_smallest)\n   |          ^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    29 |     Some(*second_smallest)\n   |          +\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    if\
    \ smallest == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest).min().unwrap();\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz43bailk.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n\
    \  --> /tmp/tmpz43bailk.rs:14:17\n   |\n14 |     if smallest == lst.len() {\n\
    \   |                 ^^ no implementation for `&isize == usize`\n   |\n   = help:\
    \ the trait `PartialEq<usize>` is not implemented for `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz43bailk.rs:17:32\n   |\n17 |     smallest =\
    \ lst.iter().skip(smallest).min().unwrap();\n   |                            \
    \    ^^^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz43bailk.rs:18:10\n   |\n18 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_idx\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmp576ishgm.rs:14:54\n\
    \   |\n14 |     let mut smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n\
    \   |                                                      ^^ no implementation\
    \ for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `Option<&isize>`\n  --> /tmp/tmp576ishgm.rs:19:46\n   |\n19 |     smallest_idx\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n   |                   \
    \                           ^^ no implementation for `&isize == Option<&isize>`\n\
    \   |\n   = help: the trait `PartialEq<Option<&isize>>` is not implemented for\
    \ `&isize`\n\nerror[E0277]: can't compare `&isize` with `Option<&isize>`\n  -->\
    \ /tmp/tmp576ishgm.rs:24:46\n   |\n24 |     smallest_idx = lst.iter().position(|x|\
    \ x == smallest).unwrap();\n   |                                             \
    \ ^^ no implementation for `&isize == Option<&isize>`\n   |\n   = help: the trait\
    \ `PartialEq<Option<&isize>>` is not implemented for `&isize`\n\nerror[E0277]:\
    \ can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmp576ishgm.rs:29:46\n\
    \   |\n29 |     smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n\
    \   |                                              ^^ no implementation for `&isize\
    \ == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>` is\
    \ not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with `Option<&isize>`\n\
    \  --> /tmp/tmp576ishgm.rs:34:46\n   |\n34 |     smallest_idx = lst.iter().position(|x|\
    \ x == smallest).unwrap();\n   |                                             \
    \ ^^ no implementation for `&isize == Option<&isize>`\n   |\n   = help: the trait\
    \ `PartialEq<Option<&isize>>` is not implemented for `&isize`\n\nerror[E0277]:\
    \ can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmp576ishgm.rs:39:46\n\
    \   |\n39 |     smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n\
    \   |                                              ^^ no implementation fo"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ - 1 {\n        smallest_idx = 0;\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiqqay9cp.rs:17:58\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiqqay9cp.rs:21:10\n   |\n21 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &i in lst {\n        if *i < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        smallest\n    } else {\n\
    \        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvzn_2j2x.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvzn_2j2x.rs:22:9\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n22 |         smallest\n\
    \   |         ^^^^^^^^ expected enum `Option`, found struct `Vec`\n   |\n   =\
    \ note: expected enum `Option<isize>`\n            found struct `Vec<i32>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ - 1 {\n        return Some(smallest);\n    }\n\n    smallest = lst.iter().skip(smallest_idx\
    \ + 1).min().unwrap();\n    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n\
    \    if smallest_idx == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \n    smallest = lst.iter().skip(smallest_idx + 1).min().unwrap();\n    smallest_idx\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ - 1 {\n        return Some(smallest);\n    }\n\n    smallest = lst.iter().skip(smallest_idx\
    \ + 1).min().unwrap();\n    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n\
    \    if smallest_idx == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \n    smallest = lst.iter().skip(smallest_idx + 1).min().unwrap();\n    smallest_idx\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ - 1 {\n        return Some(smallest);\n    }\n\n    smallest = lst.iter().skip(smallest_idx\
    \ + 1).min().unwrap();\n    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n\
    \    if smallest_idx == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \n    smallest = lst.iter().skip(smallest_idx + 1).min().unwrap();\n    smallest_idx\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ - 1 {\n        return Some(smallest);\n    }\n\n    smallest = lst.iter().skip(smallest_idx\
    \ + 1).min().unwrap();\n    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n\
    \    if smallest_idx == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \n    smallest = lst.iter().skip(smallest_idx + 1).min().unwrap();\n    smallest_idx\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ - \n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpqcjme1ox.rs:68:1\n\
    \   |\n68 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqcjme1ox.rs:20:21\n   |\n20 |         return Some(smallest);\n\
    \   |                     ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n20 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqcjme1ox.rs:26:21\n\
    \   |\n26 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n26 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqcjme1ox.rs:32:21\n   |\n32 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqcjme1ox.rs:38:21\n\
    \   |\n38 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n38 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqcjme1ox.rs:44:21\n   |\n44 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n44 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqcjme1ox.rs:50:21\n\
    \   |\n50 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n50 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqcjme1ox.rs:56:21\n   |\n56 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n56"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().filter(|(i, _)| {\n\
    \        i < (lst.len() - 2)\n    }).next()\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeg88j4x_.rs:14:13\n   |\n\
    14 |         i < (lst.len() - 2)\n   |             ^^^^^^^^^^^^^^^\n   |     \
    \        |\n   |             expected `&usize`, found `usize`\n   |          \
    \   help: consider borrowing here: `&((lst.len() - 2))`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeg88j4x_.rs:13:5\n   |\n12 |   fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                        -------------\
    \ expected `Option<isize>` because of return type\n13 | /     lst.iter().cloned().enumerate().filter(|(i,\
    \ _)| {\n14 | |         i < (lst.len() - 2)\n15 | |     }).next()\n   | |_____________^\
    \ expected `isize`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<(usize, isize)>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    let mut smallest_index\
    \ = smallest_index + 1;\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \n    while smallest_index != lst.len() - 1 {\n        if smallest_value < lst.iter().nth(smallest_index).unwrap()\
    \ {\n            smallest_value = lst.iter().nth(smallest_index).unwrap();\n \
    \           smallest_index = smallest_index + 1;\n        }\n        smallest_index\
    \ = smallest_index + 1;\n    }\n\n    Some(smallest_value)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8oclnk01.rs:21:21\n   |\n\
    21 |         return Some(smallest);\n   |                     ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    21 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8oclnk01.rs:35:10\n   |\n35 |     Some(smallest_value)\n\
    \   |          ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n35 |     Some(*smallest_value)\n   |       \
    \   +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest =\
    \ lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n\n    if smallest_index == lst.len() - 1 {\n     \
    \   return Some(smallest);\n    }\n\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \n    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n \
    \   }\n\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest =\
    \ lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n\n    if smallest_index == lst.len() - 1 {\n     \
    \   return Some(smallest);\n    }\n\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \n    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n \
    \   }\n\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest =\
    \ lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n\n    if smallest_index == lst.len() - 1 {\n     \
    \   return Some(smallest);\n    }\n\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \n    if smallest_index == lst.len() - 1 {\n        return Some(smallest\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4ksj3ekp.rs:89:3\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n76 |\
    \     if smallest_index == lst.len() - 1 {\n   |                             \
    \           - this delimiter might not be properly closed...\n77 |         return\
    \ Some(smallest\n78 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n89 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp4ksj3ekp.rs:77:20\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - closing delimiter possibly meant\
    \ for this\n...\n77 |         return Some(smallest\n   |                    ^\
    \ unclosed delimiter\n78 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4ksj3ekp.rs:18:60\n   |\n18 |     let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n   |                  \
    \                                          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |     let mut smallest_index\
    \ = lst.iter().position(|&x| x == *smallest).unwrap();\n   |                 \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4ksj3ekp.rs:21:21\n   |\n21 |         return Some(smallest);\n\
    \   |                     ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n21 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4ksj3ekp.rs:25:52\n\
    \   |\n25 |     smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                    ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n25 |  \
    \   smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n   |\
    \                                                    +\n\nerror[E0308]: mismatched "
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp917daqrh.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp917daqrh.rs:21:10\n   |\n21 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for elt in lst {\n        if smallest[smallest_idx]\
    \ < elt {\n            smallest[smallest_idx] = elt;\n            smallest_idx\
    \ += 1;\n        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n\
    \    } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf1avjo5e.rs:16:37\n   |\n\
    16 |         if smallest[smallest_idx] < elt {\n   |                         \
    \            ^^^ expected `i32`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to an `i32` and panic if the converted value doesn't fit\n   |\n16 |\
    \         if smallest[smallest_idx] < elt.try_into().unwrap() {\n   |        \
    \                             ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf1avjo5e.rs:17:38\n   |\n17 |             smallest[smallest_idx]\
    \ = elt;\n   |                                      ^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf1avjo5e.rs:22:14\n\
    \   |\n22 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n22 |         Some(smallest[1].try_into().unwrap())\n\
    \   |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    smallest_index += 1;\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_x2ci3q.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2_x2ci3q.rs:18:16\n   |\n18 |     smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |           \
    \     |\n   |                expected enum `Option`, found `&isize`\n   |    \
    \            help: try using a variant of the expected enum: `Some(lst.iter().nth(smallest_index).unwrap())`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2_x2ci3q.rs:23:16\n\
    \   |\n23 |     smallest = lst.iter().nth(smallest_index).unwrap();\n   |    \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                |\n\
    \   |                expected enum `Option`, found `&isize`\n   |            \
    \    help: try using a variant of the expected enum: `Some(lst.iter().nth(smallest_index).unwrap())`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2_x2ci3q.rs:24:10\n\
    \   |\n24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<&isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = x;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7hre1hh1.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7hre1hh1.rs:22:14\n   |\n22 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n22 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().skip(smallest_index).min().unwrap();\n    smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvh7dynik.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvh7dynik.rs:19:52\n   |\n19 |     smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n   |                  \
    \                                  ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |     smallest_index\
    \ = lst.iter().position(|&x| x == *smallest).unwrap();\n   |                 \
    \                                   +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvh7dynik.rs:23:10\n   |\n23 |     Some(smallest)\n   |          ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n23 |     Some(*smallest)\n   |          +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest\
    \ == lst.len() {\n        return None;\n    }\n    let mut smallest_index = smallest;\n\
    \    let mut smallest_value = lst.iter().nth(smallest);\n    while smallest_index\
    \ != smallest {\n        smallest_value = lst.iter().nth(smallest_index);\n  \
    \      smallest_index += 1;\n    }\n    Some(smallest_value)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6tmg3w8h.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6tmg3w8h.rs:18:45\n\
    \   |\n18 |     let mut smallest_value = lst.iter().nth(smallest);\n   |     \
    \                                        ^^^^^^^^ expected `usize`, found enum\
    \ `Option`\n   |\n   = note: expected type `usize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6tmg3w8h.rs:20:41\n   |\n20 |\
    \         smallest_value = lst.iter().nth(smallest_index);\n   |             \
    \                            ^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<&isize>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Option<&isize>`\n\
    \  --> /tmp/tmp6tmg3w8h.rs:21:9\n   |\n21 |         smallest_index += 1;\n   |\
    \         --------------^^^^^\n   |         |\n   |         cannot use `+=` on\
    \ type `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6tmg3w8h.rs:23:10\n\
    \   |\n23 |     Some(smallest_value)\n   |          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3nba3v2e.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmp3nba3v2e.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut second_smallest\
    \ = lst.iter().skip(1).min().unwrap();\n\n    if smallest == second_smallest {\n\
    \        return None;\n    }\n\n    Some(second_smallest)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu_wdlwtl.rs:24:10\n   |\n\
    24 |     Some(second_smallest)\n   |          ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \   Some(*second_smallest)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0xp1fojn.rs:19:10\n   |\n\
    19 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() - 1 {\n        return None;\n    }\n    let mut\
    \ smallest_value = lst.iter().nth(smallest_index + 1).unwrap();\n    if smallest_value\
    \ == smallest {\n        smallest_index += 1;\n    }\n    Some(smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd239bbov.rs:22:10\n   |\n\
    22 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    smallest_index += 1;\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn49nqq8l.rs:24:10\n   |\n\
    24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for el in lst {\n        if el < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = el;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        smallest\n            .iter()\n\
    \            .next()\n            .map(|el| el as isize)\n    } else {\n     \
    \   None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp80kd4dty.rs:16:17\n   |\n\
    16 |         if el < smallest[smallest_idx] {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |         if el < smallest[smallest_idx].try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp80kd4dty.rs:17:38\n   |\n17 |             smallest[smallest_idx]\
    \ = el;\n   |                                      ^^ expected `i32`, found `isize`\n\
    \nerror[E0606]: casting `&i32` as `isize` is invalid\n  --> /tmp/tmp80kd4dty.rs:25:23\n\
    \   |\n25 |             .map(|el| el as isize)\n   |                       --^^^^^^^^^\n\
    \   |                       |\n   |                       cannot cast `&i32` as\
    \ `isize`\n   |                       help: dereference the expression: `*el`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_idx = 1;\n        } else {\n            smallest_idx\
    \ += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd1y2dcg4.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf2ap6eo3.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().nth(smallest_index).unwrap();\n    smallest_index += 1;\n    smallest\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5wa8y3bi.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5wa8y3bi.rs:20:5\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n20 |     smallest\n  \
    \ |     ^^^^^^^^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected\
    \ enum `Option<isize>`\n           found reference `&isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_idx = 1;\n        } else if x == smallest {\n     \
    \       smallest_idx += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvk305r6c.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, x)| x < lst.len()\
    \ - 2).map(|(_, x)| x).ok()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuh4g1uhi.rs:13:55\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, x)| x < lst.len() - 2).map(|(_,\
    \ x)| x).ok()\n   |                                                       ^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0599]: no method named `ok` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpuh4g1uhi.rs:13:86\n  \
    \ |\n13 |     lst.iter().cloned().enumerate().find(|(_, x)| x < lst.len() - 2).map(|(_,\
    \ x)| x).ok()\n   |                                                          \
    \                            ^^ help: there is an associated function with a similar\
    \ name: `or`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    if smallest_index == 0 {\n \
    \       smallest_index = 1;\n    }\n    if smallest_index == lst.len() - 1 {\n\
    \        smallest_index = 0;\n    }\n    smallest_index += 1;\n    smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    Some(smallest_value)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqaol3t1.rs:27:10\n   |\n\
    27 |     Some(smallest_value)\n   |          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n27 |  \
    \   Some(*smallest_value)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    let mut smallest_index = smallest_index;\n\
    \    while smallest_index != lst.len() {\n        if smallest_index == lst.len()\
    \ - 1 {\n            return Some(smallest_value);\n        }\n        if lst.iter().nth(smallest_index).unwrap()\
    \ < smallest_value {\n            smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \            smallest_index = smallest_index;\n        } else {\n            smallest_index\
    \ += 1;\n        }\n    }\n    None\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8sjg6gim.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8sjg6gim.rs:22:25\n   |\n22 |             return\
    \ Some(smallest_value);\n   |                         ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    22 |             return Some(*smallest_value);\n   |                         +\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for el in lst {\n        if el < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = el;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        smallest\n    } else {\n\
    \        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy0gdyvl6.rs:16:17\n   |\n\
    16 |         if el < smallest[smallest_idx] {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |         if el < smallest[smallest_idx].try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy0gdyvl6.rs:17:38\n   |\n17 |             smallest[smallest_idx]\
    \ = el;\n   |                                      ^^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy0gdyvl6.rs:22:9\n   |\n12 | fn\
    \ next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |                    \
    \                  ------------- expected `Option<isize>` because of return type\n\
    ...\n22 |         smallest\n   |         ^^^^^^^^ expected enum `Option`, found\
    \ struct `Vec`\n   |\n   = note: expected enum `Option<isize>`\n            found\
    \ struct `Vec<i32>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ 1;\n    for idx in lst.iter().rev() {\n        if *idx < smallest {\n      \
    \      smallest = *idx;\n            smallest_idx = idx;\n        }\n    }\n \
    \   Some(smallest_idx)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4mh4o5rc.rs:19:19\n   |\n\
    19 |         if *idx < smallest {\n   |                   ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |  \
    \       if *idx < *smallest {\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4mh4o5rc.rs:20:24\n   |\n20 |             smallest = *idx;\n\
    \   |                        ^^^^\n   |                        |\n   |       \
    \                 expected `&isize`, found `isize`\n   |                     \
    \   help: consider borrowing here: `&*idx`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4mh4o5rc.rs:21:28\n   |\n21 |             smallest_idx = idx;\n\
    \   |                            ^^^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n21 |             smallest_idx =\
    \ *idx;\n   |                            +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \    smallest_index += 1;\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    smallest\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzlkd4tm0.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzlkd4tm0.rs:26:5\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n26 |     smallest\n  \
    \ |     ^^^^^^^^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected\
    \ enum `Option<isize>`\n           found reference `&isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ el in lst {\n        if el < smallest[0] {\n            smallest[0] = el;\n\
    \        }\n        if el < smallest[1] {\n            smallest[1] = el;\n   \
    \     }\n    }\n    if smallest[0] == smallest[1] {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2aemzow1.rs:15:17\n   |\n\
    15 |         if el < smallest[0] {\n   |                 ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if el < smallest[0].try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2aemzow1.rs:16:27\n   |\n16 |             smallest[0] =\
    \ el;\n   |                           ^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2aemzow1.rs:18:17\n   |\n18 |         if el\
    \ < smallest[1] {\n   |                 ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if el < smallest[1].try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2aemzow1.rs:19:27\n   |\n19 |             smallest[1] =\
    \ el;\n   |                           ^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2aemzow1.rs:25:14\n   |\n25 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj77cextx.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj77cextx.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr1s5rhpq.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr1s5rhpq.rs:19:50\n   |\n19 |     smallest_idx\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n   |                  \
    \                                ^^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n19 |     smallest_idx = lst.iter().position(|&x|\
    \ x == *smallest).unwrap();\n   |                                            \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr1s5rhpq.rs:24:50\n\
    \   |\n24 |     smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                  ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \   smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n   |  \
    \                                                +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr1s5rhpq.rs:29:50\n   |\n29 |     smallest_idx = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n   |                                             \
    \     ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n29 |     smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr1s5rhpq.rs:34:50\n   |\n34 |     smallest_idx = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n   |                                             \
    \     ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |     smallest_idx = lst.iter().position(|&x|"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find_map(|(i, elem)| {\n    \
    \    if elem < lst[i - 1] {\n            Some(elem)\n        } else {\n      \
    \      None\n        }\n    })\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpczno0acw.rs:14:19\n   |\n\
    14 |         if elem < lst[i - 1] {\n   |                   ^^^^^^^^^^\n   | \
    \                  |\n   |                   expected `&isize`, found `isize`\n\
    \   |                   help: consider borrowing here: `&lst[i - 1]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpczno0acw.rs:13:5\n   |\n12 |   fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                       \
    \ ------------- expected `Option<isize>` because of return type\n13 | /     lst.iter().enumerate().find_map(|(i,\
    \ elem)| {\n14 | |         if elem < lst[i - 1] {\n15 | |             Some(elem)\n\
    16 | |         } else {\n17 | |             None\n18 | |         }\n19 | |   \
    \  })\n   | |______^ expected `isize`, found `&isize`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found enum `Option<&isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = lst.iter().enumerate().min_by(|&(i, _)| i.1).unwrap();\n    for i in lst.iter().skip(smallest_index.1).take(smallest_index.0)\
    \ {\n        if *i < smallest {\n            smallest = *i;\n            smallest_index\
    \ = i;\n        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n\
    \  --> /tmp/tmp5onlc192.rs:14:53\n   |\n14 |     let mut smallest_index = lst.iter().enumerate().min_by(|&(i,\
    \ _)| i.1).unwrap();\n   |                                                   \
    \  ^^^^^^ --------- takes 1 argument\n   |                                   \
    \                  |\n   |                                                   \
    \  expected closure that takes 2 arguments\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5onlc192.rs:15:30\n   |\n15 |     for i in lst.iter().skip(smallest_index.1).take(smallest_index.0)\
    \ {\n   |                              ^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5onlc192.rs:18:30\n\
    \   |\n18 |             smallest_index = i;\n   |                            \
    \  ^ expected tuple, found `&isize`\n   |\n   = note:  expected tuple `(usize,\
    \ &isize)`\n           found reference `&isize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0593.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().nth(smallest_index).unwrap();\n    smallest_index += 1;\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkazig33_.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkazig33_.rs:20:10\n   |\n20 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfo_5sr3z.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().nth(smallest_index).unwrap();\n    smallest_index += 1;\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx4ce5j7w.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx4ce5j7w.rs:24:10\n   |\n24 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().skip(1).next()\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpi4vw3arz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp46druj9p.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = 0;\n    for index in lst.iter().rev() {\n        if index == smallest {\n\
    \            smallest_index += 1;\n        }\n        if index == smallest_index\
    \ {\n            return Some(index);\n        }\n    }\n    None\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpp6_r4jfy.rs:22:18\n\
    \   |\n22 |         if index == smallest_index {\n   |                  ^^ no\
    \ implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp6_r4jfy.rs:23:25\n\
    \   |\n23 |             return Some(index);\n   |                         ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n23 |             return Some(*index);\n   |                         +\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    smallest_index += 1;\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn49nqq8l.rs:24:10\n   |\n\
    24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n   \
    \     }\n        if x < smallest[1] {\n            smallest[1] = x;\n        }\n\
    \    }\n    if smallest[0] == smallest[1] {\n        None\n    } else {\n    \
    \    Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3kxzjq58.rs:15:16\n   |\n\
    15 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n15 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3kxzjq58.rs:16:27\n   |\n16 |             smallest[0] =\
    \ x;\n   |                           ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3kxzjq58.rs:18:16\n   |\n18 |         if x <\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if x < smallest[1].try_into().unwrap()\
    \ {\n   |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3kxzjq58.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |                           ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3kxzjq58.rs:25:14\n   |\n25 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x < smallest).unwrap();\n    let mut second_smallest\
    \ = smallest;\n    for &x in lst {\n        if x < second_smallest {\n       \
    \     second_smallest = x;\n        }\n        if x == smallest {\n          \
    \  smallest_index += 1;\n        }\n    }\n    if smallest_index == lst.len()\
    \ {\n        return None;\n    }\n    Some(second_smallest)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw8n8fa7k.rs:16:9\n   |\n\
    16 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n    let mut second_smallest\
    \ = lst.iter().skip(smallest_index + 1).min().unwrap();\n    let mut second_smallest_index\
    \ = lst.iter().position(|&x| x == second_smallest).unwrap();\n    if second_smallest_index\
    \ == lst.len() - 1 {\n        return Some(second_smallest);\n    }\n    let mut\
    \ third_smallest = lst.iter().skip(second_smallest_index + 1).min().unwrap();\n\
    \    let mut third_smallest_index = lst.iter().position(|&x| x == third_smallest).unwrap();\n\
    \    if third_smallest_index == lst.len() - 1 {\n        return Some(third_smallest);\n\
    \    }\n    let mut fourth_smallest = lst.iter().skip(third_smallest_index + 1).min().unwrap();\n\
    \    let mut fourth_smallest_index = lst.iter().position(|&x| x == fourth_smallest).unwrap();\n\
    \    if fourth_smallest_index == lst.len() - 1 {\n        return Some(fourth_smallest);\n\
    \    }\n    let mut fifth_smallest = lst.iter().skip(fourth_smallest_index + 1).min().unwrap();\n\
    \    let mut fifth_smallest_index = lst.iter().position(|&x| x == fifth_smallest).unwrap();\n\
    \    if fifth_smallest_index == lst.len() - 1 {\n        return Some(fifth_smallest);\n\
    \    }\n    let mut sixth_smallest = lst.iter().skip(fifth_smallest_index + 1).min().unwrap();\n\
    \    let mut sixth_smallest_index = lst.iter().position(|&x| x == sixth_smallest).unwrap();\n\
    \    if sixth_smallest_index == lst.len() - 1 {\n        return Some(sixth_smallest);\n\
    \    }\n    let mut seventh_smallest = lst.iter().skip(sixth_smallest_index +\
    \ 1).min().unwrap();\n    let mut seventh_smallest_index = lst.iter().position(|&x|\
    \ x == seventh_smallest).unwrap();\n    if seventh_smallest_index == lst.len()\
    \ - 1 {\n        return Some(seventh_smallest);\n    }\n    let mut eighth_smallest\
    \ = l\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl94_npjr.rs:51:32\n   |\n\
    51 |     let mut eighth_smallest = l\n   |                                ^ help:\
    \ add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `l` in this scope\n  --> /tmp/tmpl94_npjr.rs:51:31\n   |\n51 |     let mut eighth_smallest\
    \ = l\n   |                               ^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl94_npjr.rs:17:60\n   |\n17 |     let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n   |                  \
    \                                          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |     let mut smallest_index\
    \ = lst.iter().position(|&x| x == *smallest).unwrap();\n   |                 \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl94_npjr.rs:19:21\n   |\n19 |         return Some(smallest);\n\
    \   |                     ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n19 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl94_npjr.rs:22:67\n\
    \   |\n22 |     let mut second_smallest_index = lst.iter().position(|&x| x ==\
    \ second_smallest).unwrap();\n   |                                           \
    \                        ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n22 |     let mut second_smallest_index\
    \ = lst.iter().position(|&x| x == *second_smallest).unwrap();\n   |          \
    \                                                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl94_npjr.rs:24:21\n   |\n24 |         return Some(second_smallest);\n\
    \   |                     ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n24 |         return Some(*second_smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl94_npjr.rs:27:66\n\
    \   |\n27 |     let mut third_smallest_index "
  stdout: ''
  timestamp: 1659748384
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst[0];\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x < smallest).unwrap();\n    if smallest_index == lst.len() - 1 {\n        return\
    \ Some(smallest);\n    }\n    for i in 1..smallest_index {\n        if lst[i]\
    \ < smallest {\n            smallest = lst[i];\n            smallest_index = i;\n\
    \        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpkahqppch.rs:17:69

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_idx = 1;\n        }\n        if x == smallest {\n \
    \           smallest_idx += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3bcw2d7i.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb57hy281.rs:19:10\n   |\n\
    19 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = 0;\n\n    for index in lst.iter().rev() {\n        if index == smallest {\n\
    \            smallest_index += 1;\n            continue;\n        }\n\n      \
    \  if index == smallest_index {\n            return Some(index);\n        }\n\n\
    \        if index > smallest {\n            break;\n        }\n    }\n\n    None\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmploi0xwpl.rs:26:18\n\
    \   |\n26 |         if index == smallest_index {\n   |                  ^^ no\
    \ implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmploi0xwpl.rs:27:25\n\
    \   |\n27 |             return Some(index);\n   |                         ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n27 |             return Some(*index);\n   |                         +\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    for el in lst.iter().rev()\
    \ {\n        if el < smallest {\n            smallest = el;\n        }\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1fqpypuj.rs:15:17\n   |\n\
    15 |         if el < smallest {\n   |                 ^^^^^^^^\n   |         \
    \        |\n   |                 expected `&isize`, found `isize`\n   |      \
    \           help: consider borrowing here: `&smallest`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1fqpypuj.rs:16:24\n   |\n16 |             smallest = el;\n\
    \   |                        ^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n16 |             smallest = *el;\n\
    \   |                        +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = lst.iter().position(|x| x < smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return None;\n    }\n    for i in smallest_index +\
    \ 1 .. lst.len() {\n        if lst[i] < smallest {\n            smallest = lst[i];\n\
    \            smallest_index = i;\n        }\n    }\n    Some(smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsealrc4x.rs:14:58\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| x < smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^\n   |\
    \                                                          |\n   |           \
    \                                               expected `&isize`, found `isize`\n\
    \   |                                                          help: consider\
    \ borrowing here: `&smallest`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if smallest[0] < elt {\n            smallest[0] = elt;\n\
    \        }\n        if smallest[1] < elt {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:15:26\n   |\n\
    15 |         if smallest[0] < elt {\n   |                          ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if smallest[0]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:16:27\n   |\n16 |\
    \             smallest[0] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:18:26\n\
    \   |\n18 |         if smallest[1] < elt {\n   |                          ^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n18 |         if smallest[1]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:19:27\n   |\n19 |\
    \             smallest[1] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwzn8ckv.rs:25:14\n\
    \   |\n25 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_index = 1;\n        }\n        if i == smallest {\n\
    \            smallest_index += 1;\n        }\n    }\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvgwgsu4i.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_index = 1;\n        }\n        if i == smallest {\n\
    \            smallest_index += 1;\n        }\n    }\n    Some(smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ln3s2h2.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0q671hsy.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0q671hsy.rs:21:10\n   |\n21 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    if\
    \ smallest == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest).min().unwrap();\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz43bailk.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n\
    \  --> /tmp/tmpz43bailk.rs:14:17\n   |\n14 |     if smallest == lst.len() {\n\
    \   |                 ^^ no implementation for `&isize == usize`\n   |\n   = help:\
    \ the trait `PartialEq<usize>` is not implemented for `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz43bailk.rs:17:32\n   |\n17 |     smallest =\
    \ lst.iter().skip(smallest).min().unwrap();\n   |                            \
    \    ^^^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz43bailk.rs:18:10\n   |\n18 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = 0;\n    for &i in lst {\n        if *i < smallest {\n \
    \           smallest = i;\n            smallest_index += 1;\n        }\n    }\n\
    \    Some(smallest + smallest_index as isize)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc65oqndy.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtnzjgvp.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmtnzjgvp.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    smallest[0]\
    \ = std::i32::MAX;\n    smallest[1] = std::i32::MAX;\n    for elt in lst {\n \
    \       if elt < smallest[0] {\n            smallest[0] = elt;\n        }\n  \
    \      if elt < smallest[1] {\n            smallest[1] = elt;\n        }\n   \
    \ }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else {\n     \
    \   Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy89bx9t_.rs:17:18\n   |\n\
    17 |         if elt < smallest[0] {\n   |                  ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n17 |         if elt < smallest[0].try_into().unwrap()\
    \ {\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy89bx9t_.rs:18:27\n   |\n18 |             smallest[0] =\
    \ elt;\n   |                           ^^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy89bx9t_.rs:20:18\n   |\n20 |         if elt\
    \ < smallest[1] {\n   |                  ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         if elt < smallest[1].try_into().unwrap()\
    \ {\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy89bx9t_.rs:21:27\n   |\n21 |             smallest[1] =\
    \ elt;\n   |                           ^^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy89bx9t_.rs:27:14\n   |\n27 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_idx == 0\
    \ {\n        smallest_idx = None;\n    }\n\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_k5jr47o.rs:21:24\n   |\n\
    21 |         smallest_idx = None;\n   |                        ^^^^ expected `usize`,\
    \ found enum `Option`\n   |\n   = note: expected type `usize`\n              found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_k5jr47o.rs:24:10\n\
    \   |\n24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n   \
    \     }\n        if x > smallest[1] {\n            smallest[1] = x;\n        }\n\
    \    }\n    if smallest[1] == std::i32::MAX {\n        return None;\n    }\n \
    \   Some(smallest[1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwcrvt4fz.rs:15:16\n   |\n\
    15 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n15 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwcrvt4fz.rs:16:27\n   |\n16 |             smallest[0] =\
    \ x;\n   |                           ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwcrvt4fz.rs:18:16\n   |\n18 |         if x >\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if x > smallest[1].try_into().unwrap()\
    \ {\n   |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwcrvt4fz.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |                           ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwcrvt4fz.rs:25:10\n   |\n25 |     Some(smallest[1])\n\
    \   |          ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n25 |     Some(smallest[1].try_into().unwrap())\n   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = 0;\n    for index in lst.iter().rev() {\n        if index\
    \ == smallest {\n            smallest_index = index;\n            break;\n   \
    \     }\n    }\n    if smallest_index == lst.len() - 1 {\n        return None;\n\
    \    }\n    smallest.swap(smallest_index);\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ju5e1pc.rs:17:30\n   |\n\
    17 |             smallest_index = index;\n   |                              ^^^^^\
    \ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |             smallest_index = *index;\n   |                       \
    \       +\n\nerror[E0599]: no method named `swap` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp9ju5e1pc.rs:24:14\n   |\n24 |     smallest.swap(smallest_index);\n\
    \   |              ^^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9ju5e1pc.rs:25:10\n   |\n25 |     Some(smallest)\n   |\
    \          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n25 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_index = 1;\n        }\n        if i == smallest {\n\
    \            smallest_index += 1;\n        }\n    }\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvgwgsu4i.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf3ujzakh.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmpf3ujzakh.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx\
    \ + 1).min().unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9gbqmv5h.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9gbqmv5h.rs:19:50\n   |\n19 |     smallest_idx\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n   |                  \
    \                                ^^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n19 |     smallest_idx = lst.iter().position(|x|\
    \ *x == *smallest).unwrap();\n   |                                           \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gbqmv5h.rs:24:10\n\
    \   |\n24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() <= 1 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        smallest_index = 0;\n    }\n\n    Some(lst[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(4)`,\n right: `Some(2)`', /tmp/tmpxqs4f9ha.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x < smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    for i in 1..smallest_index {\n\
    \        if lst[i] < smallest {\n            smallest = lst[i];\n            smallest_index\
    \ = i;\n        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp5gd01iym.rs:14:69

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_index = 0;\n        }\n        if i == smallest {\n\
    \            smallest_index += 1;\n        }\n    }\n    if smallest_index ==\
    \ 0 {\n        None\n    } else {\n        Some(smallest)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_0610tv.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() - 1 {\n        return None;\n    }\n    smallest\
    \ = lst.iter().skip(smallest_index + 1).min().unwrap();\n    smallest_index =\
    \ lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index == lst.len()\
    \ - 1 {\n        return None;\n    }\n    Some(smallest)\n}\n\nfn main() {\n \
    \   let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptbgkz6dh.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index + 1).unwrap();\n    if smallest_value == smallest\
    \ {\n        smallest_index += 1;\n    }\n    if smallest_index == lst.len() -\
    \ 1 {\n        return Some(smallest);\n    }\n    let mut smallest_value = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    if smallest_value == smallest {\n        smallest_index\
    \ += 1;\n    }\n    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n\
    \    }\n    let mut smallest_value = lst.iter().nth(smallest_index + 1).unwrap();\n\
    \    if smallest_value == smallest {\n        smallest_index += 1;\n    }\n  \
    \  if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \    let mut smallest_value = lst.iter().nth(smallest_index + 1).unwrap();\n \
    \   if smallest_value == smallest {\n        smallest_index += 1;\n    }\n   \
    \ if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \    let mut smallest_value = lst.iter().nth(smallest_index + 1).unwrap();\n \
    \   if smallest_value == smallest {\n        smallest_index += 1;\n    }\n   \
    \ if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \    let mut smallest_value = lst.iter().nth(smallest_index + 1).unwrap();\n \
    \   if smallest_value == smallest {\n        smallest_index += 1;\n    }\n   \
    \ if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \    let mut smallest_value = lst.iter().nth(smallest_index + 1).unwrap();\n \
    \   if smallest_value == smallest {\n        smallest_index += 1;\n    }\n   \
    \ if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \    let mut smallest_value = lst.iter().nth(smallest_index + 1).unwrap();\n \
    \   if smallest_value == smallest {\n        smallest_index += 1;\n    }\n   \
    \ if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \    let mut smallest_\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpym4g57ri.rs:77:22\n   |\n\
    77 |     let mut smallest_\n   |                      ^ help: add `;` here\n78\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpym4g57ri.rs:19:21\n\
    \   |\n19 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpym4g57ri.rs:26:21\n   |\n26 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n26 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpym4g57ri.rs:33:21\n\
    \   |\n33 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n33 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpym4g57ri.rs:40:21\n   |\n40 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n40 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpym4g57ri.rs:47:21\n\
    \   |\n47 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n47 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpym4g57ri.rs:54:21\n   |\n54 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n54 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpym4g57ri.rs:61:21\n\
    \   |\n61 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, fo"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_idx = 1;\n        } else {\n            smallest_idx\
    \ += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd1y2dcg4.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx\
    \ + 1).min().unwrap();\n    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \    if smallest_idx == lst.len() {\n        return None;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp2tl568b.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp2tl568b.rs:19:50\n   |\n19 |     smallest_idx\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n   |                  \
    \                                ^^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n19 |     smallest_idx = lst.iter().position(|&x|\
    \ x == *smallest).unwrap();\n   |                                            \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp2tl568b.rs:23:10\n\
    \   |\n23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    if\
    \ smallest == lst.len() {\n        return None;\n    }\n    let mut smallest_index\
    \ = smallest;\n    let mut smallest_value = lst.iter().nth(smallest).unwrap();\n\
    \    for &i in lst {\n        if i == smallest_value {\n            continue;\n\
    \        }\n        if i < smallest_value {\n            smallest_value = i;\n\
    \            smallest_index = i;\n        }\n    }\n    Some(smallest_index)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwcyrcek0.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n\
    \  --> /tmp/tmpwcyrcek0.rs:14:17\n   |\n14 |     if smallest == lst.len() {\n\
    \   |                 ^^ no implementation for `&isize == usize`\n   |\n   = help:\
    \ the trait `PartialEq<usize>` is not implemented for `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwcyrcek0.rs:18:45\n   |\n18 |     let mut smallest_value\
    \ = lst.iter().nth(smallest).unwrap();\n   |                                 \
    \            ^^^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwcyrcek0.rs:19:9\n   |\n19 |     for &i in lst {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwcyrcek0.rs:28:10\n\
    \   |\n28 |     Some(smallest_index)\n   |          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n28 |  \
    \   Some(*smallest_index)\n   |          +\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ lst.iter().position(|x| *x == smallest).unwrap();\n\n    if smallest_idx ==\
    \ lst.len() - 1 {\n        return None;\n    }\n\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    smallest_idx = 0;\n\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm0pz06cg.rs:18:58\n   |\n\
    18 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm0pz06cg.rs:27:10\n   |\n27 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n27 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n\n    for i in lst.iter().enumerate() {\n\
    \        smallest[i] = *i;\n        smallest_idx[i] = i;\n    }\n\n    smallest_idx\n\
    \        .iter()\n        .enumerate()\n        .filter(|(_, idx)| smallest[idx]\
    \ < smallest[smallest_idx[idx]])\n        .next()\n        .map(|(_, idx)| smallest[idx])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `(usize, &isize)` cannot be dereferenced\n  --> /tmp/tmpblnhpef2.rs:17:23\n\
    \   |\n17 |         smallest[i] = *i;\n   |                       ^^\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `(usize, &isize)`\n  --> /tmp/tmpblnhpef2.rs:17:9\n\
    \   |\n17 |         smallest[i] = *i;\n   |         ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `(usize, &isize)`\n   = note: required because of the\
    \ requirements on the impl of `Index<(usize, &isize)>` for `Vec<{integer}>`\n\n\
    error[E0277]: the type `[{integer}]` cannot be indexed by `(usize, &isize)`\n\
    \  --> /tmp/tmpblnhpef2.rs:18:9\n   |\n18 |         smallest_idx[i] = i;\n   |\
    \         ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `(usize,\
    \ &isize)`\n   = note: required because of the requirements on the impl of `Index<(usize,\
    \ &isize)>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `&&{integer}`\n  --> /tmp/tmpblnhpef2.rs:24:28\n   |\n24 |   \
    \      .filter(|(_, idx)| smallest[idx] < smallest[smallest_idx[idx]])\n   | \
    \                           ^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `&&{integer}`\n   = note: required because of the requirements\
    \ on the impl of `Index<&&{integer}>` for `Vec<{integer}>`\n\nerror[E0277]: the\
    \ type `[{integer}]` cannot be indexed by `&&{integer}`\n  --> /tmp/tmpblnhpef2.rs:24:53\n\
    \   |\n24 |         .filter(|(_, idx)| smallest[idx] < smallest[smallest_idx[idx]])\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `&&{integer}`\n   = note: required\
    \ because of the requirements on the impl of `Index<&&{integer}>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` "
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if *x < smallest[0] {\n            smallest[0] = x;\n  \
    \      }\n        if *x > smallest[1] {\n            smallest[1] = x;\n      \
    \  }\n    }\n    if smallest[0] == std::i32::MAX {\n        return None;\n   \
    \ }\n    Some(smallest[1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpw_tlppsy.rs:15:12\n\
    \   |\n15 |         if *x < smallest[0] {\n   |            ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw_tlppsy.rs:16:27\n   |\n16 |             smallest[0]\
    \ = x;\n   |                           ^ expected `i32`, found `isize`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpw_tlppsy.rs:18:12\n   |\n\
    18 |         if *x > smallest[1] {\n   |            ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw_tlppsy.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |                           ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw_tlppsy.rs:25:10\n   |\n25 |     Some(smallest[1])\n\
    \   |          ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n25 |     Some(smallest[1].try_into().unwrap())\n   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_idx\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_idx ==\
    \ lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqhluyqg5.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqhluyqg5.rs:18:16\n   |\n18 |     smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                |\n   |                expected enum `Option`, found `&isize`\n\
    \   |                help: try using a variant of the expected enum: `Some(lst.iter().nth(smallest_idx\
    \ + 1).unwrap())`\n   |\n   = note:   expected enum `Option<&isize>`\n       \
    \    found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqhluyqg5.rs:19:10\n\
    \   |\n19 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<&isize>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppn5w60d3.rs:80:3\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n67 |\
    \     if smallest_index == lst.len() - 1 {\n   |                             \
    \           - this delimiter might not be properly closed...\n68 |         return\
    \ Some(smallest\n69 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n80 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmppn5w60d3.rs:68:20\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - closing delimiter possibly meant\
    \ for this\n...\n68 |         return Some(smallest\n   |                    ^\
    \ unclosed delimiter\n69 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppn5w60d3.rs:18:60\n   |\n18 |     let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n   |                  \
    \                                          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |     let mut smallest_index\
    \ = lst.iter().position(|&x| x == *smallest).unwrap();\n   |                 \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppn5w60d3.rs:20:21\n   |\n20 |         return Some(smallest);\n\
    \   |                     ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n20 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppn5w60d3.rs:24:52\n\
    \   |\n24 |     smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                    ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \   smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n   |\
    \                                                    +\n\nerror[E0308]: mismatched "
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() - 1 {\n       \
    \ return Some(smallest);\n    }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = smallest_index + 1;\n    while smallest_index <\
    \ lst.len() {\n        if lst.iter().nth(smallest_index).unwrap() < smallest_value\
    \ {\n            smallest_value = lst.iter().nth(smallest_index).unwrap();\n \
    \           smallest_index = smallest_index + 1;\n        }\n        smallest_index\
    \ = smallest_index + 1;\n    }\n    Some(smallest_value)\n}\n\nfn main() {\n \
    \   let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppyg_4ds4.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppyg_4ds4.rs:19:21\n   |\n19 |         return Some(smallest);\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<&isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmppyg_4ds4.rs:30:10\n   |\n30 |  \
    \   Some(smallest_value)\n   |          ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n30 |     Some(*smallest_value)\n\
    \   |          +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n    let mut smallest_val = vec![0; lst.len()];\n\
    \    for &i in lst {\n        smallest[i] += 1;\n        smallest_idx[i] += 1;\n\
    \        smallest_val[i] = i;\n    }\n    for i in 0..lst.len() {\n        if\
    \ smallest[i] > 0 {\n            if smallest[smallest_idx[i]] > 0 {\n        \
    \        return Some(smallest_val[smallest_idx[i]]);\n            }\n        }\n\
    \    }\n    None\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2gt1vmqc.rs:16:9\n   |\n\
    16 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = vec![lst[0]];\n    let mut smallest_idx = 1;\n    for &i\
    \ in lst {\n        if *i < smallest[smallest_idx] {\n            smallest[smallest_idx]\
    \ = *i;\n            smallest_idx += 1;\n        }\n    }\n    smallest[smallest_idx..]\n\
    \        .iter()\n        .next()\n        .cloned()\n        .ok_or(std::io::Error::new(\n\
    \            std::io::ErrorKind::Other,\n            \"No such element\",\n  \
    \      ))\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpow0kmso5.rs:18:9\n   |\n\
    18 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpow0kmso5.rs:24:5\n   |\n12 |   fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                        -------------\
    \ expected `Option<isize>` because of return type\n...\n24 | /     smallest[smallest_idx..]\n\
    25 | |         .iter()\n26 | |         .next()\n27 | |         .cloned()\n...\
    \  |\n30 | |             \"No such element\",\n31 | |         ))\n   | |__________^\
    \ expected enum `Option`, found enum `Result`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found enum `Result<isize, std::io::Error>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    smallest[0]\
    \ = std::i32::MAX;\n    smallest[1] = std::i32::MAX;\n    for x in lst {\n   \
    \     if x < smallest[0] {\n            smallest[0] = x;\n        }\n        if\
    \ x < smallest[1] {\n            smallest[1] = x;\n        }\n    }\n    if smallest[0]\
    \ == std::i32::MAX {\n        None\n    } else {\n        Some(smallest[1])\n\
    \    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3pv905y8.rs:17:16\n   |\n\
    17 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n17 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3pv905y8.rs:18:27\n   |\n18 |             smallest[0] =\
    \ x;\n   |                           ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3pv905y8.rs:20:16\n   |\n20 |         if x <\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         if x < smallest[1].try_into().unwrap()\
    \ {\n   |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3pv905y8.rs:21:27\n   |\n21 |             smallest[1] =\
    \ x;\n   |                           ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3pv905y8.rs:27:14\n   |\n27 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    if\
    \ smallest == lst.len() {\n        return None;\n    }\n    let mut smallest_idx\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_idx ==\
    \ lst.len() {\n        return None;\n    }\n    smallest_idx += 1;\n    smallest.clone()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa4ld2dp_.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n\
    \  --> /tmp/tmpa4ld2dp_.rs:14:17\n   |\n14 |     if smallest == lst.len() {\n\
    \   |                 ^^ no implementation for `&isize == usize`\n   |\n   = help:\
    \ the trait `PartialEq<usize>` is not implemented for `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa4ld2dp_.rs:17:58\n   |\n17 |     let mut smallest_idx\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n   |                  \
    \                                        ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |     let mut smallest_idx\
    \ = lst.iter().position(|&x| x == *smallest).unwrap();\n   |                 \
    \                                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa4ld2dp_.rs:22:5\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n22 |     smallest.clone()\n\
    \   |     ^^^^^^^^^^^^^^^^\n   |     |\n   |     expected enum `Option`, found\
    \ `isize`\n   |     help: try using a variant of the expected enum: `Some(smallest.clone())`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `isize`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    if\
    \ lst.len() > 1 {\n        smallest = lst.iter().skip(1).min().unwrap();\n   \
    \ }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzcr7h6d_.rs:17:10\n   |\n\
    17 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    if\
    \ smallest == lst.len() - 1 {\n        return None;\n    }\n    smallest.next().unwrap()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwmu142e4.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() - 1 {\n   |                    ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `usize`\n  --> /tmp/tmpwmu142e4.rs:14:17\n   |\n14 |     if smallest == lst.len()\
    \ - 1 {\n   |                 ^^ no implementation for `&isize == usize`\n   |\n\
    \   = help: the trait `PartialEq<usize>` is not implemented for `&isize`\n\nerror[E0599]:\
    \ no method named `next` found for reference `&isize` in the current scope\n \
    \ --> /tmp/tmpwmu142e4.rs:17:14\n   |\n17 |     smallest.next().unwrap()\n   |\
    \              ^^^^ method not found in `&isize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest);\n    if smallest_index == lst.len()\
    \ {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index\
    \ + 1);\n    smallest_index = lst.iter().position(|&x| x == smallest);\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index\
    \ + 1);\n    smallest_index = lst.iter().position(|&x| x == smallest);\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index\
    \ + 1);\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp27xgm7dk.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest);\n \
    \  |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp27xgm7dk.rs:15:26\n   |\n15 |     if smallest_index == lst.len() {\n\
    \   |                          ^^^^^^^^^\n   |                          |\n  \
    \ |                          expected enum `Option`, found `usize`\n   |     \
    \                     help: try using a variant of the expected enum: `Some(lst.len())`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp27xgm7dk.rs:18:46\n\
    \   |\n18 |     smallest = lst.iter().nth(smallest_index + 1);\n   |         \
    \                      -------------- ^ - {integer}\n   |                    \
    \           |\n   |                               Option<usize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp27xgm7dk.rs:19:52\n   |\n19 |     smallest_index\
    \ = lst.iter().position(|&x| x == smallest);\n   |                           \
    \                         ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n\
    \   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp27xgm7dk.rs:20:26\n   |\n20 |\
    \     if smallest_index == lst.len() {\n   |                          ^^^^^^^^^\n\
    \   |                          |\n   |                          expected enum\
    \ `Option`, found `usize`\n   |                          help: try using a variant\
    \ of the expected enum: `Some(lst.len())`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp27xgm7dk.rs:23:46\n   |\n23 |     smallest = lst.iter().nth(smallest_index\
    \ + 1);\n   |                               -------------- ^ - {integer}\n   |\
    \                         "
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkhs43fgb.rs:18:60\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmpkhs43fgb.rs:23:10\n\
    \   |\n23 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().filter(|(_, v)| v < lst.iter().next().unwrap()).next()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbg2ebcgt.rs:13:48\n   |\n\
    13 |     lst.iter().enumerate().filter(|(_, v)| v < lst.iter().next().unwrap()).next()\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbg2ebcgt.rs:13:5\n   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize>\
    \ {\n   |                                      ------------- expected `Option<isize>`\
    \ because of return type\n13 |     lst.iter().enumerate().filter(|(_, v)| v <\
    \ lst.iter().next().unwrap()).next()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<(usize, &isize)>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().nth(smallest_index).unwrap();\n    smallest_index += 1;\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx4ce5j7w.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx4ce5j7w.rs:24:10\n   |\n24 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_idx\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_idx ==\
    \ lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjcnqla4i.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjcnqla4i.rs:18:16\n   |\n18 |     smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |      \
    \          |\n   |                expected enum `Option`, found `&isize`\n   |\
    \                help: try using a variant of the expected enum: `Some(lst.iter().skip(smallest_idx).min().unwrap())`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjcnqla4i.rs:19:50\n\
    \   |\n19 |     smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                  ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjcnqla4i.rs:23:10\n\
    \   |\n23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<&isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x < smallest).unwrap();\n    let mut smallest_value\
    \ = smallest;\n    for &x in lst {\n        if x < smallest {\n            smallest\
    \ = x;\n            smallest_index = lst.iter().position(|&x| x < smallest).unwrap();\n\
    \            smallest_value = smallest;\n        }\n    }\n    Some(smallest_value)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjqbd7g1r.rs:16:9\n   |\n\
    16 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest\
    \ == lst.len() {\n        return None;\n    }\n    let mut smallest_index = smallest;\n\
    \    let mut smallest_value = lst.iter().nth(smallest).unwrap();\n    for i in\
    \ lst.iter().skip(smallest + 1) {\n        if smallest_value < i {\n         \
    \   smallest_value = i;\n            smallest_index = i;\n        }\n    }\n \
    \   Some(smallest_index)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaudaznqv.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaudaznqv.rs:18:45\n\
    \   |\n18 |     let mut smallest_value = lst.iter().nth(smallest).unwrap();\n\
    \   |                                             ^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0369]: cannot add `{integer}` to `Option<&isize>`\n\
    \  --> /tmp/tmpaudaznqv.rs:19:39\n   |\n19 |     for i in lst.iter().skip(smallest\
    \ + 1) {\n   |                              -------- ^ - {integer}\n   |     \
    \                         |\n   |                              Option<&isize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpaudaznqv.rs:22:30\n   |\n22 |\
    \             smallest_index = i;\n   |                              ^\n   | \
    \                             |\n   |                              expected enum\
    \ `Option`, found `&isize`\n   |                              help: try using\
    \ a variant of the expected enum: `Some(i)`\n   |\n   = note:   expected enum\
    \ `Option<&isize>`\n           found reference `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaudaznqv.rs:25:10\n   |\n25 |     Some(smallest_index)\n\
    \   |          ^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<&isize>`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(_, elem)| elem < lst.iter().next().unwrap()).map(|(_,\
    \ elem)| elem)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpicd65jzy.rs:13:52\n   |\n\
    13 |     lst.iter().enumerate().find(|(_, elem)| elem < lst.iter().next().unwrap()).map(|(_,\
    \ elem)| elem)\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpicd65jzy.rs:13:5\n   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize>\
    \ {\n   |                                      ------------- expected `Option<isize>`\
    \ because of return type\n13 |     lst.iter().enumerate().find(|(_, elem)| elem\
    \ < lst.iter().next().unwrap()).map(|(_, elem)| elem)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_index = 0;\n        }\n        if x == smallest {\n\
    \            smallest_index += 1;\n        }\n    }\n    if smallest_index ==\
    \ 0 {\n        None\n    } else {\n        Some(smallest)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf0f2ahvd.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    if smallest_value == smallest\
    \ {\n        smallest_index += 1;\n    }\n    if smallest_index == lst.len() {\n\
    \        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_qcmdnpp.rs:26:10\n   |\n\
    26 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n26 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = 0;\n    for &x in lst {\n        if x < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = x;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == lst.len() {\n        return None;\n\
    \    }\n    smallest[smallest_idx]\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8bnv5k7k.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8bnv5k7k.rs:24:5\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n24 |     smallest[smallest_idx]\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^\n   |     |\n   |     expected enum `Option`,\
    \ found integer\n   |     help: try using a variant of the expected enum: `Some(smallest[smallest_idx])`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `{integer}`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index).min();\n\
    \    smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoz8tqsig.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoz8tqsig.rs:19:52\n   |\n19 |     smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n   |                                             \
    \       ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<&isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoz8tqsig.rs:23:10\n   |\n23 |     Some(smallest)\n   |\
    \          ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<&isize>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().filter(|(_, i)| i < lst.len()\
    \ - 1).next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_vra0rqn.rs:13:48\n   |\n\
    13 |     lst.iter().enumerate().filter(|(_, i)| i < lst.len() - 1).next()\n  \
    \ |                                                ^^^^^^^^^^^^^ expected `&&isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_vra0rqn.rs:13:5\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                               ------------- expected `Option<isize>` because\
    \ of return type\n13 |     lst.iter().enumerate().filter(|(_, i)| i < lst.len()\
    \ - 1).next()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<(usize, &isize)>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest =\
    \ lst.iter().skip(smallest_index + 1).min().unwrap();\n    smallest_index = lst.iter().position(|x|\
    \ x == smallest).unwrap();\n\n    if smallest_index == lst.len() - 1 {\n     \
    \   return Some(smallest);\n    }\n\n    smallest = lst.iter().skip(smallest_index\
    \ + 1).min().unwrap();\n    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n\
    \n    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n \
    \   }\n\n    smallest = lst.iter().skip(smallest_index + 1).min().unwrap();\n\
    \    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n\n   \
    \ if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \n    smallest = lst.iter().skip(smallest_index + 1).min().unwrap();\n    smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest =\
    \ lst.iter().skip(smallest_index + 1).min().unwrap();\n    smallest_index = lst.iter().position(|x|\
    \ x == smallest).unwrap();\n\n    if smallest_index == lst.len() - 1 {\n     \
    \   return Some(smallest);\n    }\n\n    smallest = lst.iter().skip(smallest_index\
    \ + 1).min().unwrap();\n    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n\
    \n    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n \
    \   }\n\n    smallest = lst.iter().skip(smallest_index + 1).min().unwrap();\n\
    \    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n\n   \
    \ if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n    }\n\
    \n    smallest = lst.iter().skip(smallest_index + 1).min().unwrap();\n    smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - \n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpmd4cd0oj.rs:77:1\n\
    \   |\n77 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmd4cd0oj.rs:21:21\n   |\n21 |         return Some(smallest);\n\
    \   |                     ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n21 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmd4cd0oj.rs:28:21\n\
    \   |\n28 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n28 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmd4cd0oj.rs:35:21\n   |\n35 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmd4cd0oj.rs:42:21\n\
    \   |\n42 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n42 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmd4cd0oj.rs:49:21\n   |\n49 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n49 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmd4cd0oj.rs:56:21\n\
    \   |\n56 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n56 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmd4cd0oj.rs:63:21\n   |\n63 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n63"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().filter(|(i, _)| {\n        i\
    \ != 0 && lst[i] < lst[i - 1]\n    }).next()\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `{integer}`\n  --> /tmp/tmpz88i1wqs.rs:14:11\n\
    \   |\n14 |         i != 0 && lst[i] < lst[i - 1]\n   |           ^^ no implementation\
    \ for `&usize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&usize`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `&usize`\n  --> /tmp/tmpz88i1wqs.rs:14:19\n   |\n14 |         i !=\
    \ 0 && lst[i] < lst[i - 1]\n   |                   ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&usize>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz88i1wqs.rs:13:5\n   |\n12 |   fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                        -------------\
    \ expected `Option<isize>` because of return type\n13 | /     lst.iter().enumerate().filter(|(i,\
    \ _)| {\n14 | |         i != 0 && lst[i] < lst[i - 1]\n15 | |     }).next()\n\
    \   | |_____________^ expected `isize`, found tuple\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found enum `Option<(usize, &isize)>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(_, x)| x < lst.iter().skip(1).next().unwrap()).map(|(_,\
    \ x)| x)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnqawwms6.rs:13:46\n   |\n\
    13 |     lst.iter().enumerate().find(|(_, x)| x < lst.iter().skip(1).next().unwrap()).map(|(_,\
    \ x)| x)\n   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnqawwms6.rs:13:5\n   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize>\
    \ {\n   |                                      ------------- expected `Option<isize>`\
    \ because of return type\n13 |     lst.iter().enumerate().find(|(_, x)| x < lst.iter().skip(1).next().unwrap()).map(|(_,\
    \ x)| x)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgol32c3f.rs:23:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n...\n23 |     smallest\n   |     ^^^^^^^^ expected enum `Option`, found\
    \ `&isize`\n   |\n   = note:   expected enum `Option<isize>`\n           found\
    \ reference `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    if smallest_value == smallest\
    \ {\n        smallest_index += 1;\n    }\n    Some(smallest_value)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpovf6oe3h.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpovf6oe3h.rs:22:10\n   |\n22 |     Some(smallest_value)\n\
    \   |          ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     Some(*smallest_value)\n   |       \
    \   +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &i in lst {\n        if *i < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpub3ykcl1.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpub3ykcl1.rs:22:14\n   |\n22 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n22 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    let mut smallest_val\
    \ = lst.iter().nth(smallest_idx).unwrap();\n    if smallest_val < smallest {\n\
    \        smallest = smallest_val;\n        smallest_idx = smallest_idx;\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp109s3z8r.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp109s3z8r.rs:23:10\n   |\n23 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp6iqha_9g.rs:72:3\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n60 |\
    \     if smallest_idx == lst.len() {\n   |                                  -\
    \ this delimiter might not be properly closed...\n61 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n72 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6iqha_9g.rs:12:38\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |    -------------                     ^^^^^^^^^^^^^\
    \ expected enum `Option`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note:   expected\
    \ enum `Option<isize>`\n           found unit type `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    for ele in lst.iter().rev()\
    \ {\n        if ele < smallest[0] {\n            smallest[0] = ele;\n        }\n\
    \    }\n    smallest.iter().next().map(|x| x).ok()\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqn1yw65s.rs:15:18\n   |\n\
    15 |         if ele < smallest[0] {\n   |                  ^^^^^^^^^^^\n   | \
    \                 |\n   |                  expected `&isize`, found `isize`\n\
    \   |                  help: consider borrowing here: `&smallest[0]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqn1yw65s.rs:16:27\n   |\n16 |             smallest[0]\
    \ = ele;\n   |                           ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n16 |             smallest[0]\
    \ = *ele;\n   |                           +\n\nerror[E0599]: no method named `ok`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpqn1yw65s.rs:19:39\n\
    \   |\n19 |     smallest.iter().next().map(|x| x).ok()\n   |                 \
    \                      ^^ help: there is an associated function with a similar\
    \ name: `or`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest\
    \ == lst.len() {\n        return None;\n    }\n    smallest.next().unwrap()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa0xnr3u3.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `usize`\n\nerror[E0599]: no method named `next` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpa0xnr3u3.rs:17:14\n  \
    \ |\n17 |     smallest.next().unwrap()\n   |              ^^^^ method not found\
    \ in `Option<&isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf3ujzakh.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmpf3ujzakh.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = vec![0; lst.len()];\n    let mut smallest_idx = 0;\n  \
    \  let mut smallest_val = lst[0];\n    for &x in lst {\n        if x < smallest_val\
    \ {\n            smallest_val = x;\n            smallest_idx = 1;\n        }\n\
    \        if x == smallest_val {\n            smallest_idx += 1;\n        }\n \
    \       smallest[smallest_idx] = x;\n    }\n    smallest[smallest_idx..]\n   \
    \     .iter()\n        .cloned()\n        .next()\n        .map(|x| x)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpatz0p_k1.rs:19:9\n   |\n\
    19 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().filter(|(i, _)| {\n        if\
    \ i == 0 {\n            true\n        } else {\n            lst[i] < lst[i - 1]\n\
    \        }\n    }).next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `{integer}`\n  --> /tmp/tmpj23tmwfh.rs:14:14\n\
    \   |\n14 |         if i == 0 {\n   |              ^^ no implementation for `&usize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&usize`\n\
    \  --> /tmp/tmpj23tmwfh.rs:17:13\n   |\n17 |             lst[i] < lst[i - 1]\n\
    \   |             ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&usize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj23tmwfh.rs:13:5\n\
    \   |\n12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |     \
    \                                   ------------- expected `Option<isize>` because\
    \ of return type\n13 | /     lst.iter().enumerate().filter(|(i, _)| {\n14 | |\
    \         if i == 0 {\n15 | |             true\n16 | |         } else {\n17 |\
    \ |             lst[i] < lst[i - 1]\n18 | |         }\n19 | |     }).next()\n\
    \   | |_____________^ expected `isize`, found tuple\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found enum `Option<(usize, &isize)>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len()\
    \ - 2)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0js9ck5s.rs:13:55\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len() - 2)\n  \
    \ |                                                       ^^^^^^^^^^^^^ expected\
    \ `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0js9ck5s.rs:13:5\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                               ------------- expected `Option<isize>` because\
    \ of return type\n13 |     lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len()\
    \ - 2)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<(usize, isize)>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() - 1 {\n        return None;\n    }\n    let mut\
    \ smallest_value = lst.iter().nth(smallest_index + 1).unwrap();\n    if smallest_value\
    \ < smallest {\n        smallest = smallest_value;\n        smallest_index = smallest_index;\n\
    \    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxp88qgsw.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n\n    for &i in lst {\n        smallest[smallest_idx[i]]\
    \ = i;\n        smallest_idx[i] = i;\n    }\n\n    let mut smallest_val = vec![0;\
    \ lst.len()];\n\n    for &i in &smallest {\n        smallest_val[i] = i;\n   \
    \ }\n\n    let mut smallest_idx = vec![0; lst.len()];\n\n    for &i in &smallest_val\
    \ {\n        smallest_idx[i] = i;\n    }\n\n    let mut smallest_val = vec![0;\
    \ lst.len()];\n\n    for &i in &smallest {\n        smallest_val[i] = i;\n   \
    \ }\n\n    smallest_idx[smallest_idx[lst.len()-1]] = lst.len()-1;\n\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n\n    for &i in &smallest {\n        smallest_idx[i]\
    \ = i;\n    }\n\n    let mut smallest_val = vec![0; lst.len()];\n\n    for &i\
    \ in &smallest {\n        smallest_val[i] = i;\n    }\n\n    smallest_idx[smallest_idx[lst.len()-1]]\
    \ = lst.len()-1;\n\n    let mut smallest_idx = vec![0; lst.len()];\n\n    for\
    \ &i in &smallest {\n        smallest_idx[i] = i;\n    }\n\n    let mut smallest_val\
    \ = vec![0; lst.len()];\n\n    for &i in &smallest {\n        smallest_val[i]\
    \ = i;\n    }\n\n    smallest_idx[smallest_idx[lst.len()-1]] = lst.len()-1;\n\n\
    \    let mut smallest_idx = vec![0; lst.len()];\n\n    for &i in &smallest {\n\
    \        smallest_idx[i] = i;\n    }\n\n    let mut smallest_val = vec![0; lst.len()];\n\
    \n    for &i in &smallest {\n        smallest_val[i] = i;\n    }\n\n    smallest_idx[smallest_idx[lst.len()-1]]\
    \ = lst.len()-1;\n\n    let mut smallest_idx = vec![0; lst.len()];\n\n    for\
    \ &i in &smallest {\n        smallest_idx[i] = i;\n    }\n\n    let mut smallest_val\
    \ = vec![0; lst.len()];\n\n    for &i in &smallest {\n        smallest_val[i]\
    \ = i;\n    }\n\n    smallest_idx[smallest_idx[lst.len()-1]] = lst.len()-1;\n\n\
    \    let mut smallest_idx = vec![0; lst.len()];\n\n    for &i in &smallest {\n\
    \        smallest_idx[i] = \n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpw9mvk4tv.rs:112:3\n\
    \    |\n12  | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    |    \
    \                                                - unclosed delimiter\n...\n99\
    \  |     for &i in &smallest {\n    |                         - this delimiter\
    \ might not be properly closed...\n100 |         smallest_idx[i] = \n101 | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n112 | }\n\
    \    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmpw9mvk4tv.rs:101:1\n\
    \    |\n101 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw9mvk4tv.rs:16:9\n   |\n16 |     for &i in lst {\n   |        \
    \ ^^    --- this expression has type `isize`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9mvk4tv.rs:12:38\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |    -------------\
    \                     ^^^^^^^^^^^^^ expected enum `Option`, found `()`\n   | \
    \   |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note:   expected enum `Option<isize>`\n           found unit type\
    \ `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x < smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return None;\n    }\n    for i in 1..smallest_index\
    \ {\n        if lst[i] < smallest {\n            smallest = lst[i];\n        \
    \    smallest_index = i;\n        }\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp6qpv5iwd.rs:14:69

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = lst.iter().enumerate().find(|&(i, _)| i < smallest).unwrap();\n    let mut\
    \ smallest_value = smallest;\n    loop {\n        smallest_index += 1;\n     \
    \   if smallest_index >= lst.len() {\n            return None;\n        }\n  \
    \      let mut value = lst[smallest_index];\n        if value < smallest {\n \
    \           smallest = value;\n            smallest_index = smallest_index;\n\
    \            smallest_value = value;\n        }\n        if value == smallest\
    \ {\n            return Some(smallest_value);\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy2a8528x.rs:14:72\n   |\n\
    14 |     let mut smallest_index = lst.iter().enumerate().find(|&(i, _)| i < smallest).unwrap();\n\
    \   |                                                                        ^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n14 |     let mut\
    \ smallest_index = lst.iter().enumerate().find(|&(i, _)| i < smallest.try_into().unwrap()).unwrap();\n\
    \   |                                                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `(usize,\
    \ &isize)`\n  --> /tmp/tmpy2a8528x.rs:17:9\n   |\n17 |         smallest_index\
    \ += 1;\n   |         --------------^^^^^\n   |         |\n   |         cannot\
    \ use `+=` on type `(usize, &isize)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpy2a8528x.rs:18:30\n   |\n18 |         if smallest_index >= lst.len()\
    \ {\n   |                              ^^^^^^^^^ expected tuple, found `usize`\n\
    \   |\n   = note: expected tuple `(usize, &isize)`\n               found type\
    \ `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `(usize, &isize)`\n\
    \  --> /tmp/tmpy2a8528x.rs:21:25\n   |\n21 |         let mut value = lst[smallest_index];\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `(usize, &isize)`\n   = note: required because of the requirements\
    \ on the impl of `Index<(usize, &isize)>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    if\
    \ smallest == lst.len() {\n        return None;\n    }\n    let mut smallest_index\
    \ = smallest;\n    for index in lst.iter().rev() {\n        if index == smallest_index\
    \ {\n            continue;\n        }\n        if index > smallest {\n       \
    \     break;\n        }\n        smallest_index = index;\n    }\n    Some(smallest_index)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0je8yzek.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n\
    \  --> /tmp/tmp0je8yzek.rs:14:17\n   |\n14 |     if smallest == lst.len() {\n\
    \   |                 ^^ no implementation for `&isize == usize`\n   |\n   = help:\
    \ the trait `PartialEq<usize>` is not implemented for `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0je8yzek.rs:27:10\n   |\n27 |     Some(smallest_index)\n\
    \   |          ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n27 |     Some(*smallest_index)\n   |       \
    \   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut second_smallest\
    \ = lst.iter().skip(1).min().unwrap();\n\n    if smallest == second_smallest {\n\
    \        return None;\n    }\n\n    Some(second_smallest)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu_wdlwtl.rs:24:10\n   |\n\
    24 |     Some(second_smallest)\n   |          ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \   Some(*second_smallest)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx] {\n       \
    \     smallest[smallest_idx] = x;\n            smallest_idx += 1;\n        }\n\
    \    }\n    smallest[smallest_idx..].iter().next().map(|x| x).ok()\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx4smbxwe.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0599]: no\
    \ method named `ok` found for enum `Option` in the current scope\n  --> /tmp/tmpx4smbxwe.rs:21:55\n\
    \   |\n21 |     smallest[smallest_idx..].iter().next().map(|x| x).ok()\n   | \
    \                                                      ^^ help: there is an associated\
    \ function with a similar name: `or`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = lst.iter().position(|x| x < smallest).unwrap();\n    for i in lst.iter().skip(smallest_index\
    \ + 1) {\n        if *i < smallest {\n            smallest = *i;\n           \
    \ smallest_index = i;\n        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4taap9t8.rs:14:58\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| x < smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^\n   |\
    \                                                          |\n   |           \
    \                                               expected `&isize`, found `isize`\n\
    \   |                                                          help: consider\
    \ borrowing here: `&smallest`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4taap9t8.rs:18:30\n\
    \   |\n18 |             smallest_index = i;\n   |                            \
    \  ^ expected `usize`, found `&isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest =\
    \ lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index = lst.iter().position(|x|\
    \ *x == smallest).unwrap();\n\n    if smallest_index == lst.len() - 1 {\n    \
    \    return Some(smallest);\n    }\n\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \n    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n \
    \   }\n\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest =\
    \ lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index = lst.iter().position(|x|\
    \ *x == smallest).unwrap();\n\n    if smallest_index == lst.len() - 1 {\n    \
    \    return Some(smallest);\n    }\n\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \n    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n \
    \   }\n\n    smallest = lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    smallest =\
    \ lst.iter().nth(smallest_index + 1).unwrap();\n    smallest_index = lst.iter().position(|x|\
    \ *x == smallest).unwrap();\n\n    if smallest_index == lst.len() - 1 {\n    \
    \    return Some(smallest);\n    }\n\n    smallest = lst.iter().nth(smallest_index\
    \ + 1).unwrap();\n    smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \n    if smallest_index == lst.len() - 1 {\n        return Some(smallest\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpf38tgbsh.rs:89:3\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n76 |\
    \     if smallest_index == lst.len() - 1 {\n   |                             \
    \           - this delimiter might not be properly closed...\n77 |         return\
    \ Some(smallest\n78 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n89 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpf38tgbsh.rs:77:20\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - closing delimiter possibly meant\
    \ for this\n...\n77 |         return Some(smallest\n   |                    ^\
    \ unclosed delimiter\n78 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf38tgbsh.rs:18:60\n   |\n18 |     let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n   |                  \
    \                                          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |     let mut smallest_index\
    \ = lst.iter().position(|x| *x == *smallest).unwrap();\n   |                 \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf38tgbsh.rs:21:21\n   |\n21 |         return Some(smallest);\n\
    \   |                     ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n21 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf38tgbsh.rs:25:52\n\
    \   |\n25 |     smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                    ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n25 |  \
    \   smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n   |\
    \                                                    +\n\nerror[E0308]: mismatched "
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().filter(|(i, _)| {\n        i\
    \ != 0 && lst[i] < lst[i - 1]\n    }).next()\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `{integer}`\n  --> /tmp/tmpz88i1wqs.rs:14:11\n\
    \   |\n14 |         i != 0 && lst[i] < lst[i - 1]\n   |           ^^ no implementation\
    \ for `&usize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&usize`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `&usize`\n  --> /tmp/tmpz88i1wqs.rs:14:19\n   |\n14 |         i !=\
    \ 0 && lst[i] < lst[i - 1]\n   |                   ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&usize>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz88i1wqs.rs:13:5\n   |\n12 |   fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                        -------------\
    \ expected `Option<isize>` because of return type\n13 | /     lst.iter().enumerate().filter(|(i,\
    \ _)| {\n14 | |         i != 0 && lst[i] < lst[i - 1]\n15 | |     }).next()\n\
    \   | |_____________^ expected `isize`, found tuple\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found enum `Option<(usize, &isize)>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().nth(smallest_index + 1).unwrap();\n    Some(smallest)\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp03jl_f92.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp03jl_f92.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index\
    \ + 1).min().unwrap();\n    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() {\n        return None;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj8eh_jqf.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst[0];\n    let mut smallest_index = 0;\n    for i in\
    \ 1..lst.len() {\n        if smallest * i == lst[i] {\n            smallest_index\
    \ = i;\n        }\n    }\n    if smallest_index == lst.len() - 1 {\n        return\
    \ None;\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuwlxln5h.rs:19:23\n   |\n\
    19 |         if smallest * i == lst[i] {\n   |                       ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize` by `usize`\n\
    \  --> /tmp/tmpuwlxln5h.rs:19:21\n   |\n19 |         if smallest * i == lst[i]\
    \ {\n   |                     ^ no implementation for `isize * usize`\n   |\n\
    \   = help: the trait `Mul<usize>` is not implemented for `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp46druj9p.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n    let mut smallest_index\
    \ = smallest_index + 1;\n    while smallest_index < lst.len() {\n        if lst.iter()[smallest_index]\
    \ > lst.iter()[smallest_index + 1] {\n            smallest_index += 1;\n     \
    \   } else {\n            break;\n        }\n    }\n    Some(lst.iter()[smallest_index])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzxexzhnr.rs:19:21\n   |\n\
    19 |         return Some(smallest);\n   |                     ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |         return Some(*smallest);\n   |                     +\n\nerror[E0608]:\
    \ cannot index into a value of type `std::slice::Iter<'_, isize>`\n  --> /tmp/tmpzxexzhnr.rs:23:12\n\
    \   |\n23 |         if lst.iter()[smallest_index] > lst.iter()[smallest_index\
    \ + 1] {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `std::slice::Iter<'_, isize>`\n  --> /tmp/tmpzxexzhnr.rs:23:41\n\
    \   |\n23 |         if lst.iter()[smallest_index] > lst.iter()[smallest_index\
    \ + 1] {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `std::slice::Iter<'_, isize>`\n\
    \  --> /tmp/tmpzxexzhnr.rs:29:10\n   |\n29 |     Some(lst.iter()[smallest_index])\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if elt < smallest[0] {\n            smallest[0] = elt;\n\
    \        }\n        if elt < smallest[1] {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfh4xjhy4.rs:15:18\n   |\n\
    15 |         if elt < smallest[0] {\n   |                  ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if elt < smallest[0].try_into().unwrap()\
    \ {\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfh4xjhy4.rs:16:27\n   |\n16 |             smallest[0] =\
    \ elt;\n   |                           ^^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfh4xjhy4.rs:18:18\n   |\n18 |         if elt\
    \ < smallest[1] {\n   |                  ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if elt < smallest[1].try_into().unwrap()\
    \ {\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfh4xjhy4.rs:19:27\n   |\n19 |             smallest[1] =\
    \ elt;\n   |                           ^^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfh4xjhy4.rs:25:14\n   |\n25 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest_index\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8qii614n.rs:23:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n...\n23 |     smallest_index\n   |     ^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest\
    \ == lst.len() {\n        return None;\n    }\n    let mut smallest_index = smallest;\n\
    \    let mut smallest_value = lst.iter().nth(smallest).unwrap();\n    for index\
    \ in lst.iter().skip(smallest + 1) {\n        if lst.iter().nth(index).unwrap()\
    \ < smallest_value {\n            smallest_value = lst.iter().nth(index).unwrap();\n\
    \            smallest_index = index;\n        }\n    }\n    Some(smallest_index)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77188xk8.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77188xk8.rs:18:45\n\
    \   |\n18 |     let mut smallest_value = lst.iter().nth(smallest).unwrap();\n\
    \   |                                             ^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0369]: cannot add `{integer}` to `Option<&isize>`\n\
    \  --> /tmp/tmp77188xk8.rs:19:43\n   |\n19 |     for index in lst.iter().skip(smallest\
    \ + 1) {\n   |                                  -------- ^ - {integer}\n   | \
    \                                 |\n   |                                  Option<&isize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp77188xk8.rs:20:27\n   |\n20 |\
    \         if lst.iter().nth(index).unwrap() < smallest_value {\n   |         \
    \                  ^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp77188xk8.rs:21:45\n   |\n21 |             smallest_value\
    \ = lst.iter().nth(index).unwrap();\n   |                                    \
    \         ^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp77188xk8.rs:22:30\n   |\n22 |             smallest_index = index;\n\
    \   |                              ^^^^^\n   |                              |\n\
    \   |                              expected enum `Option`, found `&isize`\n  \
    \ |                              help: try using a variant of the expected enum:\
    \ `Some(index)`\n   |\n   = note:   expected enum `Option<&isize>`\n         \
    \  found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77188xk8.rs:25:10\n\
    \   |\n25 |     Some(smallest_index)\n   |          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror: aborting due to 7 previous errors\n\nSome errors\
    \ have d"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    if\
    \ lst.len() > 1 {\n        smallest = lst.iter().skip(1).min().unwrap();\n   \
    \ }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzcr7h6d_.rs:17:10\n   |\n\
    17 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    for ele in lst.iter().rev()\
    \ {\n        if ele < smallest {\n            smallest = ele;\n        }\n   \
    \ }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj4zk5kpe.rs:15:18\n   |\n\
    15 |         if ele < smallest {\n   |                  ^^^^^^^^\n   |       \
    \           |\n   |                  expected `&isize`, found `isize`\n   |  \
    \                help: consider borrowing here: `&smallest`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj4zk5kpe.rs:16:24\n   |\n16 |             smallest = ele;\n\
    \   |                        ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n16 |             smallest = *ele;\n\
    \   |                        +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    let mut smallest_val = std::i32::MAX;\n    for &x\
    \ in lst {\n        if x < smallest_val {\n            smallest_val = x;\n   \
    \         smallest_idx = 1;\n        }\n        if x == smallest_val {\n     \
    \       smallest_idx += 1;\n        }\n        if smallest_idx == 2 {\n      \
    \      smallest[0] = smallest_val;\n            smallest[1] = x;\n           \
    \ return Some(smallest[1]);\n        }\n    }\n    None\n}\n\nfn main() {\n  \
    \  let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp004usi9s.rs:16:9\n   |\n\
    16 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp004usi9s.rs:27:25\n   |\n27 |             return Some(smallest[1]);\n\
    \   |                         ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n27 |             return Some(smallest[1].try_into().unwrap());\n\
    \   |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = 0;\n    for &i in lst {\n        if *i < smallest {\n \
    \           smallest = i;\n            smallest_index += 1;\n        }\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyoicn008.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyoicn008.rs:21:10\n   |\n21 |     Some(smallest)\n   |\
    \          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = lst.iter().enumerate().find(|(_, elem)| elem < smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.swap_remove(smallest_index).unwrap();\n\
    \    smallest_index += 1;\n    smallest_index\n        .clone()\n        .unwrap()\n\
    \        .and_then(|index| lst.swap_remove(index))\n        .unwrap()\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxkxzrvzr.rs:14:77\n   |\n\
    14 |     let mut smallest_index = lst.iter().enumerate().find(|(_, elem)| elem\
    \ < smallest).unwrap();\n   |                                                \
    \                             ^^^^^^^^ expected `&&isize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxkxzrvzr.rs:15:26\n   |\n15 |     if smallest_index\
    \ == lst.len() {\n   |                          ^^^^^^^^^ expected tuple, found\
    \ `usize`\n   |\n   = note: expected tuple `(usize, &isize)`\n               found\
    \ type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxkxzrvzr.rs:18:32\n\
    \   |\n18 |     smallest = lst.swap_remove(smallest_index).unwrap();\n   |   \
    \                             ^^^^^^^^^^^^^^ expected `usize`, found tuple\n \
    \  |\n   = note: expected type `usize`\n             found tuple `(usize, &isize)`\n\
    \nerror[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpxkxzrvzr.rs:18:48\n   |\n18 |     smallest = lst.swap_remove(smallest_index).unwrap();\n\
    \   |                                                ^^^^^^ method not found in\
    \ `isize`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `(usize, &isize)`\n  --> /tmp/tmpxkxzrvzr.rs:19:5\n   |\n19 |     smallest_index\
    \ += 1;\n   |     --------------^^^^^\n   |     |\n   |     cannot use `+=` on\
    \ type `(usize, &isize)`\n\nerror[E0599]: no method named `unwrap` found for tuple\
    \ `(usize, &isize)` in the current scope\n  --> /tmp/tmpxkxzrvzr.rs:22:10\n  \
    \ |\n22 |         .unwrap()\n   |          ^^^^^^ method not found in `(usize,\
    \ &isize)`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0368, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst[0];\n    let mut smallest_index = 0;\n    for &i in\
    \ lst {\n        if i < smallest {\n            smallest = i;\n            smallest_index\
    \ = 1;\n        }\n        if i == smallest {\n            smallest_index += 1;\n\
    \        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9n7bnsx7.rs:18:9\n   |\n\
    18 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    let mut second_smallest\
    \ = lst.iter().skip(smallest_index + 1).min().unwrap();\n    if second_smallest\
    \ == smallest {\n        return None;\n    }\n    Some(second_smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps0t3ss43.rs:22:10\n   |\n\
    22 |     Some(second_smallest)\n   |          ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \   Some(*second_smallest)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp46druj9p.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_idx = 1;\n        } else {\n            smallest_idx\
    \ += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd1y2dcg4.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_idx = 1;\n        }\n        if x == smallest {\n \
    \           smallest_idx += 1;\n        }\n    }\n    if smallest_idx == lst.len()\
    \ {\n        return None;\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfrh890s6.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return None;\n    }\n    let mut second_smallest =\
    \ lst.iter().skip(smallest_index + 1).min().unwrap();\n    if second_smallest\
    \ == smallest {\n        return None;\n    }\n    Some(second_smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpybx6njko.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpybx6njko.rs:25:10\n   |\n25 |     Some(second_smallest)\n\
    \   |          ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |     Some(*second_smallest)\n   |      \
    \    +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = 0;\n    let mut smallest_value = lst.iter().min().unwrap();\n    for &x in\
    \ lst {\n        if x < smallest {\n            smallest_value = x;\n        \
    \    smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n    \
    \    }\n    }\n    Some(smallest_value)\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqjhypi6r.rs:16:9\n   |\n\
    16 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0277]: can't\
    \ compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpqjhypi6r.rs:17:14\n  \
    \ |\n17 |         if x < smallest {\n   |              ^ no implementation for\
    \ `&isize < Option<&isize>` and `&isize > Option<&isize>`\n   |\n   = help: the\
    \ trait `PartialOrd<Option<&isize>>` is not implemented for `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqjhypi6r.rs:19:60\n   |\n19 |             smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n   |                  \
    \                                          ^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqjhypi6r.rs:22:10\n   |\n22 |\
    \     Some(smallest_value)\n   |          ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |     Some(*smallest_value)\n\
    \   |          +\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    smallest_index += 1;\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn49nqq8l.rs:24:10\n   |\n\
    24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, elem)| elem\
    \ < lst.iter().cloned().next().unwrap()).map(|(_, elem)| elem)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbsveaq88.rs:13:61\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, elem)| elem < lst.iter().cloned().next().unwrap()).map(|(_,\
    \ elem)| elem)\n   |                                                         \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                               \
    \                              |\n   |                                       \
    \                      expected `&isize`, found `isize`\n   |                \
    \                                             help: consider borrowing here: `&lst.iter().cloned().next().unwrap()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtnzjgvp.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmtnzjgvp.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    let mut smallest_val\
    \ = lst.iter().nth(smallest_idx).unwrap();\n    if smallest_val < smallest {\n\
    \        smallest = smallest_val;\n        smallest_idx = smallest_idx;\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfherdvm6.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = 0;\n    for &i in lst {\n        if *i < smallest {\n \
    \           smallest = i;\n            smallest_index = i;\n        }\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr7l26g9j.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr7l26g9j.rs:21:10\n   |\n21 |     Some(smallest)\n   |\
    \          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst[0];\n    let mut smallest_index = 0;\n    for &i in\
    \ lst {\n        if i < smallest {\n            smallest = i;\n            smallest_index\
    \ = 1;\n        }\n        if i == smallest {\n            smallest_index += 1;\n\
    \        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9n7bnsx7.rs:18:9\n   |\n\
    18 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min().unwrap();\n\
    \    smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx\
    \ == lst.len() {\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp6iqha_9g.rs:72:3\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n60 |\
    \     if smallest_idx == lst.len() {\n   |                                  -\
    \ this delimiter might not be properly closed...\n61 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n72 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6iqha_9g.rs:12:38\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |    -------------                     ^^^^^^^^^^^^^\
    \ expected enum `Option`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note:   expected\
    \ enum `Option<isize>`\n           found unit type `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748384
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() - 1 {\n       \
    \ smallest_index = 0;\n    }\n    smallest.next().unwrap()\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpja75ozub.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0599]: no method named `next`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpja75ozub.rs:21:14\n\
    \   |\n21 |     smallest.next().unwrap()\n   |              ^^^^ method not found\
    \ in `Option<&isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &i in lst {\n        if *i < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        smallest\n    } else {\n\
    \        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvzn_2j2x.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvzn_2j2x.rs:22:9\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n22 |         smallest\n\
    \   |         ^^^^^^^^ expected enum `Option`, found struct `Vec`\n   |\n   =\
    \ note: expected enum `Option<isize>`\n            found struct `Vec<i32>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &x in lst {\n        if *x < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = x;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp59u1xtlz.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp59u1xtlz.rs:22:14\n   |\n22 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n22 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    if smallest_value == smallest\
    \ {\n        smallest_index += 1;\n    }\n    Some(smallest_value)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpppvpfj69.rs:22:10\n   |\n\
    22 |     Some(smallest_value)\n   |          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \   Some(*smallest_value)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len()\
    \ - 2).map(|(_, i)| lst[i + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7uuv68wo.rs:13:55\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len() - 2).map(|(_,\
    \ i)| lst[i + 1])\n   |                                                      \
    \ ^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7uuv68wo.rs:13:83\n   |\n13 |  \
    \   lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len() - 2).map(|(_,\
    \ i)| lst[i + 1])\n   |                                                      \
    \                             ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_idx = 1;\n        } else if x == smallest {\n     \
    \       smallest_idx += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvk305r6c.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = vec![0; lst.len()];\n    let mut smallest_idx = vec![0;\
    \ lst.len()];\n    let mut smallest_val = vec![0; lst.len()];\n    for i in lst.iter().enumerate()\
    \ {\n        smallest[i] = i;\n        smallest_idx[i] = i;\n        smallest_val[i]\
    \ = i;\n    }\n    for i in lst.iter().rev().enumerate() {\n        if smallest[i]\
    \ < i {\n            smallest[i] = i;\n            smallest_idx[i] = i;\n    \
    \        smallest_val[i] = i;\n        }\n    }\n    for i in lst.iter().rev().enumerate()\
    \ {\n        if smallest[i] == i {\n            return Some(smallest[smallest_idx[i]]);\n\
    \        }\n    }\n    None\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `(usize, &isize)`\n\
    \  --> /tmp/tmpuevjqj7x.rs:20:9\n   |\n20 |         smallest[i] = i;\n   |   \
    \      ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `(usize,\
    \ &isize)`\n   = note: required because of the requirements on the impl of `Index<(usize,\
    \ &isize)>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `(usize, &isize)`\n  --> /tmp/tmpuevjqj7x.rs:21:9\n   |\n21 |\
    \         smallest_idx[i] = i;\n   |         ^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `(usize, &isize)`\n   = note: required because of the\
    \ requirements on the impl of `Index<(usize, &isize)>` for `Vec<{integer}>`\n\n\
    error[E0277]: the type `[{integer}]` cannot be indexed by `(usize, &isize)`\n\
    \  --> /tmp/tmpuevjqj7x.rs:22:9\n   |\n22 |         smallest_val[i] = i;\n   |\
    \         ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `(usize,\
    \ &isize)`\n   = note: required because of the requirements on the impl of `Index<(usize,\
    \ &isize)>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `(usize, &isize)`\n  --> /tmp/tmpuevjqj7x.rs:25:12\n   |\n25 |\
    \         if smallest[i] < i {\n   |            ^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `(usize, &isize)`\n   = note: required because of the\
    \ requirements on the impl of `Index<(usize, &isize)>` for `Vec<{integer}>`\n\n\
    error[E0277]: the type `[{integer}]` cannot be indexed by `(usize, &isize)`\n\
    \  --> /tmp/tmpuevjqj7x.rs:26:13\n   |\n26 |             smallest[i] = i;\n  \
    \ |             ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `(usize,\
    \ &isize)`\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|&(i, _)| lst.len() > i\
    \ + 1).map(|(_, j)| j)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4wv3nvnh.rs:13:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n13 |     lst.iter().enumerate().find(|&(i, _)| lst.len() > i + 1).map(|(_,\
    \ j)| j)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = 0;\n    for idx in 0..lst.len() {\n        if smallest[idx] <\
    \ smallest[smallest_idx] {\n            smallest[idx] = smallest[smallest_idx];\n\
    \            smallest_idx = idx;\n        }\n    }\n    if smallest_idx == lst.len()\
    \ {\n        return None;\n    }\n    smallest[smallest_idx] = lst.len();\n  \
    \  smallest\n        .iter()\n        .cloned()\n        .skip(smallest_idx +\
    \ 1)\n        .next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4uld4kg7.rs:25:5\n   |\n\
    12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |            \
    \                            ------------- expected `Option<isize>` because of\
    \ return type\n...\n25 | /     smallest\n26 | |         .iter()\n27 | |      \
    \   .cloned()\n28 | |         .skip(smallest_idx + 1)\n29 | |         .next()\n\
    \   | |_______________^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found enum `Option<usize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    let mut second_smallest\
    \ = lst.iter().skip(smallest_index + 1).min().unwrap();\n    if second_smallest\
    \ == smallest {\n        return None;\n    }\n    Some(second_smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzm3wgx9n.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzm3wgx9n.rs:22:10\n   |\n22 |     Some(second_smallest)\n\
    \   |          ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     Some(*second_smallest)\n   |      \
    \    +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748383
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        smallest[0] = elt;\n        if smallest[0] < smallest[1]\
    \ {\n            smallest[1] = smallest[0];\n        }\n    }\n    if smallest[0]\
    \ == std::i32::MAX {\n        return None;\n    }\n    Some(smallest[1])\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvdc8cvme.rs:15:23\n   |\n\
    15 |         smallest[0] = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvdc8cvme.rs:23:10\n\
    \   |\n23 |     Some(smallest[1])\n   |          ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     Some(smallest[1].try_into().unwrap())\n\
    \   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748385
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_index = 0;\n        }\n        if x == smallest {\n\
    \            smallest_index += 1;\n        }\n    }\n    if smallest_index ==\
    \ 0 {\n        return None;\n    }\n    Some(smallest)\n}\n\nfn main() {\n   \
    \ let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgzr2opy3.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748385
