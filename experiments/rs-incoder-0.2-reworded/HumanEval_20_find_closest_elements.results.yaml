name: HumanEval_20_find_closest_elements
language: rs
results:
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for i in 1..numbers.len() {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i];\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i];\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp7fnyilx5.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for &n in\
    \ numbers {\n        let dist = std::f64::MAX;\n        for &m in numbers {\n\
    \            if *n < m {\n                dist = std::f64::MAX;\n            \
    \    break;\n            }\n            dist = std::f64::MAX if *n > m {\n   \
    \             dist = std::f64::MAX;\n                break;\n            }\n \
    \           dist = std::f64::MAX if *n < m {\n                dist = std::f64::MAX;\n\
    \                break;\n            }\n        }\n        if dist < min_dist\
    \ {\n            min_dist = dist;\n            min_number = n;\n        }\n  \
    \      if dist > max_dist {\n            max_dist = dist;\n            max_number\
    \ = n;\n        }\n    }\n    (min_number, max_number)\n}\n\nfn main() {\n   \
    \ let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpgz97h0hc.rs:18:34\n   |\n18 |            \
    \ dist = std::f64::MAX if *n > m {\n   |                                  ^^ expected\
    \ one of 8 possible tokens\n\nerror[E0425]: cannot find value `max_dist` in this\
    \ scope\n  --> /tmp/tmpgz97h0hc.rs:31:19\n   |\n31 |         if dist > max_dist\
    \ {\n   |                   ^^^^^^^^ help: a local variable with a similar name\
    \ exists: `min_dist`\n\nerror[E0425]: cannot find value `max_dist` in this scope\n\
    \  --> /tmp/tmpgz97h0hc.rs:32:13\n   |\n32 |             max_dist = dist;\n  \
    \ |             ^^^^^^^^ help: a local variable with a similar name exists: `min_dist`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgz97h0hc.rs:11:9\n   |\n11 | \
    \    for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgz97h0hc.rs:13:13\n   |\n13 |         for &m\
    \ in numbers {\n   |             ^^    ------- this expression has type `Option<f64>`\n\
    \   |             |\n   |             expected `f64`, found reference\n   |  \
    \           help: you can probably remove the explicit borrow: `m`\n   |\n   =\
    \ note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_number = numbers[0];\n    let\
    \ mut largest_number = numbers[0];\n    for number in numbers {\n        if number\
    \ < smallest_number {\n            smallest_number = number;\n        }\n    \
    \    if number > largest_number {\n            largest_number = number;\n    \
    \    }\n    }\n    (smallest_number, largest_number)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpbyal0r52.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for &n in numbers {\n        if n < smallest {\n        \
    \    smallest = n;\n        }\n        if n > largest {\n            largest =\
    \ n;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsmqtdtea.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_element = numbers[0];\n    let mut max_element = numbers[0];\n    for &n\
    \ in numbers {\n        let dist = std::f64::MAX;\n        for &m in numbers {\n\
    \            if *m > n {\n                continue;\n            }\n         \
    \   let dist = dist * std::f64::MAX + std::f64::MAX * (*n - m);\n        }\n \
    \       if dist < min_dist {\n            min_dist = dist;\n            min_element\
    \ = n;\n        }\n        if dist > max_dist {\n            max_dist = dist;\n\
    \            max_element = n;\n        }\n    }\n    (min_element, max_element)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `max_dist` in this scope\n  --> /tmp/tmpg3vonnur.rs:23:19\n\
    \   |\n23 |         if dist > max_dist {\n   |                   ^^^^^^^^ help:\
    \ a local variable with a similar name exists: `min_dist`\n\nerror[E0425]: cannot\
    \ find value `max_dist` in this scope\n  --> /tmp/tmpg3vonnur.rs:24:13\n   |\n\
    24 |             max_dist = dist;\n   |             ^^^^^^^^ help: a local variable\
    \ with a similar name exists: `min_dist`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpg3vonnur.rs:11:9\n   |\n11 |     for &n in numbers {\n   |     \
    \    ^^    ------- this expression has type `Option<f64>`\n   |         |\n  \
    \ |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg3vonnur.rs:13:13\n\
    \   |\n13 |         for &m in numbers {\n   |             ^^    ------- this expression\
    \ has type `Option<f64>`\n   |             |\n   |             expected `f64`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `m`\n   |\n   = note:   expected type `f64`\n           found reference\
    \ `&_`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for &n in numbers {\n        if n < smallest {\n        \
    \    smallest = n;\n        }\n        if n > largest {\n            largest =\
    \ n;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy0mkh53_.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_number = std::f64::MAX;\n    for n in numbers {\n        let dist = n.abs()\
    \ - min_dist;\n        if dist < min_dist {\n            min_dist = dist;\n  \
    \          min_number = n;\n        }\n    }\n    (min_number, min_dist)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, -1.7976931348623157e308)`,\n right: `(3.9, 4.0)`', /tmp/tmp05h_757s.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for n in numbers {\n        if n < smallest {\n         \
    \   smallest = n;\n        }\n        if n > largest {\n            largest =\
    \ n;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp0k81ksgb.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for &n in numbers {\n        if n < smallest {\n        \
    \    smallest = n;\n        }\n        if n > largest {\n            largest =\
    \ n;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi5coepf5.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for &n in numbers {\n        if n < smallest {\n        \
    \    smallest = n;\n        }\n        if n > largest {\n            largest =\
    \ n;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpry1oy0ac.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for i in 1..numbers.len() {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i];\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i];\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp0hrzmb1g.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for i in 1..numbers.len() {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i];\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i];\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpfznccsid.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_distance = std::f64::MAX;\n\
    \    let mut smallest_number = std::f64::MAX;\n    let mut largest_distance =\
    \ std::f64::MIN;\n    let mut largest_number = std::f64::MIN;\n\n    for n in\
    \ numbers {\n        let distance = n.abs() - smallest_distance;\n        if distance\
    \ < smallest_distance {\n            smallest_distance = distance;\n         \
    \   smallest_number = n;\n        }\n        if distance > largest_distance {\n\
    \            largest_distance = distance;\n            largest_number = n;\n \
    \       }\n    }\n\n    (smallest_number, largest_number)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpucb02rq_.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for &n in numbers {\n        if n < smallest {\n        \
    \    smallest = n;\n        }\n        if n > largest {\n            largest =\
    \ n;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsqxkypct.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for n in numbers {\n        if n < smallest {\n         \
    \   smallest = n;\n        }\n        if n > largest {\n            largest =\
    \ n;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp56grdeuf.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for &n in numbers {\n        if n < smallest {\n        \
    \    smallest = n;\n        }\n        if n > largest {\n            largest =\
    \ n;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjqo09qko.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_number = std::f64::MAX;\n    for n in numbers {\n        let dist = n.abs()\
    \ - min_dist;\n        if dist < min_dist {\n            min_dist = dist;\n  \
    \          min_number = n;\n        }\n    }\n    (min_number, min_dist)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, -1.7976931348623157e308)`,\n right: `(3.9, 4.0)`', /tmp/tmpepu6halq.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_number = std::f64::MAX;\n    for number in numbers {\n        let dist =\
    \ std::f64::MAX;\n        for other in numbers {\n            if other == number\
    \ {\n                continue;\n            }\n            let distance = std::f64::abs(number\
    \ - other);\n            if distance < dist {\n                dist = distance;\n\
    \            }\n        }\n        if dist < min_dist {\n            min_dist\
    \ = dist;\n            min_number = number;\n        }\n    }\n    (min_number,\
    \ min_dist)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmp7_oohlox.rs:16:38\n\
    \   |\n16 |             let distance = std::f64::abs(number - other);\n   |  \
    \                                    ^^^ not found in `std::f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for i in 1..numbers.len() {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i];\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i];\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpr5ou3bb3.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for\
    \ number in numbers.iter().rev() {\n        let distance = number.powf(2.0) -\
    \ min_number.powf(2.0);\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = number;\n        }\n        if distance\
    \ > max_distance {\n            max_distance = distance;\n            max_number\
    \ = number;\n        }\n    }\n    (min_number, max_number)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `max_distance` in this scope\n  --> /tmp/tmpoudz338b.rs:17:23\n\
    \   |\n17 |         if distance > max_distance {\n   |                       ^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `min_distance`\n\nerror[E0425]:\
    \ cannot find value `max_distance` in this scope\n  --> /tmp/tmpoudz338b.rs:18:13\n\
    \   |\n18 |             max_distance = distance;\n   |             ^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `min_distance`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoudz338b.rs:15:26\n   |\n9  |     let mut min_number\
    \ = numbers[0];\n   |                          ---------- expected due to this\
    \ value\n...\n15 |             min_number = number;\n   |                    \
    \      ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |             min_number = *number;\n   |             \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoudz338b.rs:19:26\n\
    \   |\n10 |     let mut max_number = numbers[0];\n   |                       \
    \   ---------- expected due to this value\n...\n19 |             max_number =\
    \ number;\n   |                          ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |             max_number\
    \ = *number;\n   |                          +\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
