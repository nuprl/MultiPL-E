language: rs
name: HumanEval_93_encode
results:
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for c in message.chars() {\n        if !vowels.contains(&c) {\n         \
    \   result.push(c);\n        } else {\n            result.push((&vowels[&c] -\
    \ &c).to_string());\n        }\n        vowels.insert(c);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpbu80yvz6.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmppi4a1nri.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmppi4a1nri.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut index = 0;\n    let mut next_vowel = vowels.len();\n    \n    for\
    \ c in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == c) {\n            result.push_str(&vowels[(index - next_vowel + vowel)\
    \ as usize]);\n            next_vowel = vowel;\n        }\n        result.push_str(&c);\n\
    \        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp902b74nt.rs:18:37\n   |\n18 |         if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == c) {\n   |                              \
    \       ^^^^ method not found in `&str`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n18 |         if let Some(vowel) = vowels.chars().position(|&x|\
    \ x == c) {\n   |                                     ~~~~~\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `usize`\n  --> /tmp/tmp902b74nt.rs:19:30\n \
    \  |\n19 |             result.push_str(&vowels[(index - next_vowel + vowel) as\
    \ usize]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp902b74nt.rs:22:25\n\
    \   |\n22 |         result.push_str(&c);\n   |                         ^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut vowels_counter = 0;\n   \
    \ let mut alphabet_counter = 0;\n    for c in message.chars() {\n        if c.is_uppercase()\
    \ {\n            alphabet.insert(c.to_lowercase());\n        } else {\n      \
    \      alphabet.insert(c.to_uppercase());\n        }\n    }\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            if alphabet.contains(c.to_lowercase())\
    \ {\n                result.push(c);\n            } else {\n                result.push(c.to_lowercase());\n\
    \            }\n        } else {\n            if alphabet.contains(c.to_uppercase())\
    \ {\n                result.push(c);\n            } else {\n                result.push(c.to_uppercase());\n\
    \            }\n        }\n        if c.is_uppercase() {\n            vowels.insert(c.to_lowercase());\n\
    \        } else {\n            vowels.insert(c.to_uppercase());\n        }\n \
    \   }\n    for c in result.chars() {\n        if c.is_uppercase() {\n        \
    \    if vowels.contains(c.to_lowercase()) {\n                vowels_counter +=\
    \ 2;\n            } else {\n                vowels_counter += 1;\n           \
    \ }\n        } else {\n            if vowels.contains(c.to_uppercase()) {\n  \
    \              vowels_counter += 2;\n            } else {\n                vowels_counter\
    \ += 1;\n            }\n        }\n    }\n    if vowels_counter > alphabet_counter\
    \ {\n        for c in result.chars() {\n            if c.is_uppercase() {\n  \
    \              alphabet_counter += 2;\n            } else {\n                alphabet_counter\
    \ += 1;\n            }\n        }\n    }\n    result.push_str(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmpdnaagelh.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpdnaagelh.rs:68:860\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |                                      - closing delimiter possibly\
    \ meant for this\n...\n68 |     result.push_str(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encode(&encod...\n\
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                       "
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n \
    \   let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut letter_counter8\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n\
    \    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let mut letter_counter15\
    \ = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n\
    \    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let mut letter_counter22\
    \ = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n\
    \    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let mut letter_counter29\
    \ = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n\
    \    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n    let\
    \ mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let mut letter_counter36\
    \ = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n\
    \    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n    let\
    \ mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let mut letter_counter43\
    \ = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n\
    \    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n    let\
    \ mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let mut letter_counter50\
    \ = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n\
    \    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n    let\
    \ mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnrevbjvc.rs:70:11\n   |\n\
    70 |     let mu\n   |           ^ help: add `;` here\n71 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnrevbjvc.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_next = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next2\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next3 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next4 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next5\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next6 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next7 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next8\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next9 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next10 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next11\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next12 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next13 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next14\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next15 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next16 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next17\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next18 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next19 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next20\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next21 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next22 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next23\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next24 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next25 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next26\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next27 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next28 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next29\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next30 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_mmagsw5.rs:45:30\n   |\n\
    45 |     let mut vowels_index_next\n   |                              ^ help:\
    \ add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_mmagsw5.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n \
    \   let mut index5 = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n  \
    \  let mut index8 = 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n  \
    \  let mut index11 = 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n\
    \    let mut index14 = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n\
    \    let mut index17 = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n\
    \    let mut index20 = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n\
    \    let mut index23 = 0;\n    let mut index24 = 0;\n    let mut index25 = 0;\n\
    \    let mut index26 = 0;\n    let mut index27 = 0;\n    let mut index28 = 0;\n\
    \    let mut index29 = 0;\n    let mut index30 = 0;\n    let mut index31 = 0;\n\
    \    let mut index32 = 0;\n    let mut index33 = 0;\n    let mut index34 = 0;\n\
    \    let mut index35 = 0;\n    let mut index36 = 0;\n    let mut index37 = 0;\n\
    \    let mut index38 = 0;\n    let mut index39 = 0;\n    let mut index40 = 0;\n\
    \    let mut index41 = 0;\n    let mut index42 = 0;\n    let mut index43 = 0;\n\
    \    let mut index44 = 0;\n    let mut index45 = 0;\n    let mut index46 = 0;\n\
    \    let mut index47 = 0;\n    let mut index48 = 0;\n    let mut index49 = 0;\n\
    \    let mut index50 = 0;\n    let mut index51 = 0;\n    let mut index52 = 0;\n\
    \    let mut index53 = 0;\n    let mut index54 = 0;\n    let mut index55 = 0;\n\
    \    let mut index56 = 0;\n    let mut index57 = 0;\n    let mut index58 = 0;\n\
    \    let mut index59 = 0;\n    let mut index60 = 0;\n    let mut index61 = 0;\n\
    \    let mut index62 = 0;\n    let mut index63 = 0;\n    let mut index64 = 0;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3qpncrx3.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter.is_lowercase()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_uppercase()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_digit()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_punctuation()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_whitespace()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_symbol()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_alphabet()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_control()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_graph()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_modifier()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_privateuse()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_ascii()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_digit()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_punctuation()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_whitespace()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_symbol()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_alphabet()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_control()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_graph()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_modifier()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_privateuse()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_ascii()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_digit()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_punctuation()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_whitespace()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_symbol()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_alphabet()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_control()\
    \ {\n            alphabet.insert(letter);\n        }\n        if letter.is_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpefbyv6nw.rs:112:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n17  |     for letter in message.chars()\
    \ {\n    |                                   - this delimiter might not be properly\
    \ closed...\n...\n103 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n112 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   -->\
    \ /tmp/tmpefbyv6nw.rs:103:1\n    |\n102 |         if letter.is_\n    |       \
    \  -- this `if` expression has a condition, but no block\n103 | }\n    | ^ expected\
    \ `{`\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpefbyv6nw.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpefbyv6nw.rs:14:24\n\
    \   |\n14 |     let mut alphabet = HashSet::new();\n   |                     \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpefbyv6nw.rs:24:19\n\
    \    |\n24  |         if letter.is_digit() {\n    |                   ^^^^^^^^-\
    \ supplied 0 arguments\n    |                   |\n    |                   expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ method named `is_punctuation` found for type `char` in the current scope\n \
    \ --> /tmp/tmpefbyv6nw.rs:27:19\n   |\n27 |         if letter.is_punctuation()\
    \ {\n   |                   ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii_punctuation`\n\nerror[E0599]: no method named\
    \ `is_symbol` found for type `char` in the current scope\n  --> /tmp/tmpefbyv6nw.rs:33:19\n\
    \   |\n33 |         if letter.is_symbol() {\n   |                   ^^^^^^^^^\
    \ method not found in `char`\n\nerr"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n \
    \   let mut index5 = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n  \
    \  let mut index8 = 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n  \
    \  let mut index11 = 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n\
    \    let mut index14 = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n\
    \    let mut index17 = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n\
    \    let mut index20 = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n\
    \    let mut index23 = 0;\n    let mut index24 = 0;\n    let mut index25 = 0;\n\
    \    let mut index26 = 0;\n    let mut index27 = 0;\n    let mut index28 = 0;\n\
    \    let mut index29 = 0;\n    let mut index30 = 0;\n    let mut index31 = 0;\n\
    \    let mut index32 = 0;\n    let mut index33 = 0;\n    let mut index34 = 0;\n\
    \    let mut index35 = 0;\n    let mut index36 = 0;\n    let mut index37 = 0;\n\
    \    let mut index38 = 0;\n    let mut index39 = 0;\n    let mut index40 = 0;\n\
    \    let mut index41 = 0;\n    let mut index42 = 0;\n    let mut index43 = 0;\n\
    \    let mut index44 = 0;\n    let mut index45 = 0;\n    let mut index46 = 0;\n\
    \    let mut index47 = 0;\n    let mut index48 = 0;\n    let mut index49 = 0;\n\
    \    let mut index50 = 0;\n    let mut index51 = 0;\n    let mut index52 = 0;\n\
    \    let mut index53 = 0;\n    let mut index54 = 0;\n    let mut index55 = 0;\n\
    \    let mut index56 = 0;\n    let mut index57 = 0;\n    let mut index58 = 0;\n\
    \    let mut index59 = 0;\n    let mut index60 = 0;\n    let mut index61 = 0;\n\
    \    let mut index62 = 0;\n    let mut index63 = 0;\n    let mut index64 = 0;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugqdttiv.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut vowels_encoded_counter\
    \ = 0;\n    let mut vowels_encoded_counter2 = 0;\n    let mut vowels_encoded_counter3\
    \ = 0;\n    let mut vowels_encoded_counter4 = 0;\n    let mut vowels_encoded_counter5\
    \ = 0;\n    let mut vowels_encoded_counter6 = 0;\n    let mut vowels_encoded_counter7\
    \ = 0;\n    let mut vowels_encoded_counter8 = 0;\n    let mut vowels_encoded_counter9\
    \ = 0;\n    let mut vowels_encoded_counter10 = 0;\n    let mut vowels_encoded_counter11\
    \ = 0;\n    let mut vowels_encoded_counter12 = 0;\n    let mut vowels_encoded_counter13\
    \ = 0;\n    let mut vowels_encoded_counter14 = 0;\n    let mut vowels_encoded_counter15\
    \ = 0;\n    let mut vowels_encoded_counter16 = 0;\n    let mut vowels_encoded_counter17\
    \ = 0;\n    let mut vowels_encoded_counter18 = 0;\n    let mut vowels_encoded_counter19\
    \ = 0;\n    let mut vowels_encoded_counter20 = 0;\n    let mut vowels_encoded_counter21\
    \ = 0;\n    let mut vowels_encoded_counter22 = 0;\n    let mut vowels_encoded_counter23\
    \ = 0;\n    let mut vowels_encoded_counter24 = 0;\n    let mut vowels_encoded_counter25\
    \ = 0;\n    let mut vowels_encoded_counter26 = 0;\n    let mut vowels_encoded_counter27\
    \ = 0;\n    let mut vowels_encoded_counter28 = 0;\n    let mut vowels_encoded_counter29\
    \ = 0;\n    let mut vowels_encoded_counter30 = 0;\n    let mut vowels_encoded_counter31\
    \ = 0;\n    let mut vowels_encoded_counter32 = 0;\n    let mut vowels_encoded_counter33\
    \ = 0;\n    let mut vowels_encoded_counter34 = 0;\n    let mut vowels_encoded_counter35\
    \ = 0;\n    let mut vowels_encoded_counter36 = 0;\n    let mut vowels_encoded_counter37\
    \ = 0;\n    let mut vowels_encoded_counter38 = 0;\n    let mut vowels_encoded_counter39\
    \ = 0;\n    let mut vowels_encoded_counter40 = 0;\n    let mut vowels_encoded_counter41\
    \ = 0;\n    let mut vowels_encoded_counter42 = 0;\n    let mut vowels_encoded_counter43\
    \ = 0;\n    let mut vowels_encoded_counter44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpl9m6f83b.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpl9m6f83b.rs:14:30\n\
    \   |\n14 |     let mut vowels_encoded = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl9m6f83b.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n   \
    \ let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 = vec![0];\n\
    \    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5 =\
    \ vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40 = vec\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvw8nt7z0.rs:55:39\n   |\n\
    55 |     let mut letter_count_index40 = vec\n   |                            \
    \           ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0423]:\
    \ expected value, found macro `vec`\n  --> /tmp/tmpvw8nt7z0.rs:55:36\n   |\n55\
    \ |     let mut letter_count_index40 = vec\n   |                             \
    \       ^^^ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvw8nt7z0.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut vowels_encoded = String::new();\n    let mut vowels_encoded1 = String::new();\n\
    \    let mut vowels_encoded2 = String::new();\n    let mut vowels_encoded3 = String::new();\n\
    \    let mut vowels_encoded4 = String::new();\n    let mut vowels_encoded5 = String::new();\n\
    \    let mut vowels_encoded6 = String::new();\n    let mut vowels_encoded7 = String::new();\n\
    \    let mut vowels_encoded8 = String::new();\n    let mut vowels_encoded9 = String::new();\n\
    \    let mut vowels_encoded10 = String::new();\n    let mut vowels_encoded11 =\
    \ String::new();\n    let mut vowels_encoded12 = String::new();\n    let mut vowels_encoded13\
    \ = String::new();\n    let mut vowels_encoded14 = String::new();\n    let mut\
    \ vowels_encoded15 = String::new();\n    let mut vowels_encoded16 = String::new();\n\
    \    let mut vowels_encoded17 = String::new();\n    let mut vowels_encoded18 =\
    \ String::new();\n    let mut vowels_encoded19 = String::new();\n    let mut vowels_encoded20\
    \ = String::new();\n    let mut vowels_encoded21 = String::new();\n    let mut\
    \ vowels_encoded22 = String::new();\n    let mut vowels_encoded23 = String::new();\n\
    \    let mut vowels_encoded24 = String::new();\n    let mut vowels_encoded25 =\
    \ String::new();\n    let mut vowels_encoded26 = String::new();\n    let mut vowels_encoded27\
    \ = String::new();\n    let mut vowels_encoded28 = String::new();\n    let mut\
    \ vowels_encoded29 = String::new();\n    let mut vowels_encoded30 = String::new();\n\
    \    let mut vowels_encoded31 = String::new();\n    let mut vowels_encoded32 =\
    \ String::new();\n    let mut vowels_encoded33 = String::new();\n    let mut vowels_encoded34\
    \ = String::new();\n    let mut vowels_encoded35 = String::new();\n    let mut\
    \ vowels_encoded36 = String::new();\n    let mut vowels_encoded37 = String::new();\n\
    \    let mut vowels_encoded38 = String::new\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpy74t6b9c.rs:52:43\n   |\n\
    52 |     let mut vowels_encoded38 = String::new\n   |                        \
    \                   ^ help: add `;` here\n53 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy74t6b9c.rs:11:31\n   |\n11 | fn\
    \ encode(message: String) -> String {\n   |    ------                     ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letters = \"bcdfghjklmnpqrstvwxyz\".to_string();\n\
    \    for c in message.chars() {\n        if let Some(pos) = vowels.find(c) {\n\
    \            result.push_str(&letters[pos - 2]);\n        } else {\n         \
    \   result.push_str(&letters[c - 'a']);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzy94r1fj.rs:17:30\n\
    \   |\n17 |             result.push_str(&letters[pos - 2]);\n   |            \
    \                  ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpzy94r1fj.rs:19:40\n\
    \   |\n19 |             result.push_str(&letters[c - 'a']);\n   |            \
    \                          - ^ --- char\n   |                                \
    \      |\n   |                                      char\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0369.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.find(&letter) {\n            result.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n        } else {\n            result.push_str(&letter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp30xceas6.rs:16:42\n\
    \     |\n16   |         if let Some(index) = vowels.find(&letter) {\n     |  \
    \                                   ---- ^^^^^^^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n     |                                     |\n     |         \
    \                            required by a bound introduced by this call\n   \
    \  |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::find`\n\
    help: consider dereferencing here\n     |\n16   |         if let Some(index) =\
    \ vowels.find(*&letter) {\n     |                                          +\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp30xceas6.rs:17:30\n\
    \   |\n17 |             result.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp30xceas6.rs:19:29\n\
    \   |\n19 |             result.push_str(&letter);\n   |                      \
    \       ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  result.push_str(&letters[letter - 'a']);\n        }\n    }\n    for vowel in\
    \ vowels {\n        result.push_str(&letters[vowel - 'a']);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpznqsxojz.rs:19:45\n\
    \   |\n19 |             result.push_str(&letters[letter - 'a']);\n   |       \
    \                               ------ ^ --- char\n   |                      \
    \                |\n   |                                      char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpznqsxojz.rs:23:40\n   |\n\
    23 |         result.push_str(&letters[vowel - 'a']);\n   |                   \
    \               ----- ^ --- char\n   |                                  |\n  \
    \ |                                  char\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\
    \ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,\
    \ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\
    \ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\
    \ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\
    \ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\
    \ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,\
    \ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\
    \ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\
    \ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,\
    \ 256, 257, 258, 259, \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp_vb90vcw.rs:16:1\n   |\n16 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp_vb90vcw.rs:15:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n15 |     let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28,...\n   |                                ^ unclosed delimiter\n16 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_idx = 0;\n    let mut vowels_idx_prev = 0;\n    let mut vowels_idx_next\
    \ = 0;\n    let mut vowels_idx_next2 = 0;\n    let mut vowels_idx_next3 = 0;\n\
    \    let mut vowels_idx_next4 = 0;\n    let mut vowels_idx_next5 = 0;\n    let\
    \ mut vowels_idx_next6 = 0;\n    let mut vowels_idx_next7 = 0;\n    let mut vowels_idx_next8\
    \ = 0;\n    let mut vowels_idx_next9 = 0;\n    let mut vowels_idx_next10 = 0;\n\
    \    let mut vowels_idx_next11 = 0;\n    let mut vowels_idx_next12 = 0;\n    let\
    \ mut vowels_idx_next13 = 0;\n    let mut vowels_idx_next14 = 0;\n    let mut\
    \ vowels_idx_next15 = 0;\n    let mut vowels_idx_next16 = 0;\n    let mut vowels_idx_next17\
    \ = 0;\n    let mut vowels_idx_next18 = 0;\n    let mut vowels_idx_next19 = 0;\n\
    \    let mut vowels_idx_next20 = 0;\n    let mut vowels_idx_next21 = 0;\n    let\
    \ mut vowels_idx_next22 = 0;\n    let mut vowels_idx_next23 = 0;\n    let mut\
    \ vowels_idx_next24 = 0;\n    let mut vowels_idx_next25 = 0;\n    let mut vowels_idx_next26\
    \ = 0;\n    let mut vowels_idx_next27 = 0;\n    let mut vowels_idx_next28 = 0;\n\
    \    let mut vowels_idx_next29 = 0;\n    let mut vowels_idx_next30 = 0;\n    let\
    \ mut vowels_idx_next31 = 0;\n    let mut vowels_idx_next32 = 0;\n    let mut\
    \ vowels_idx_next33 = 0;\n    let mut vowels_idx_next34 = 0;\n    let mut vowels_idx_next35\
    \ = 0;\n    let mut vowels_idx_next36 = 0;\n    let mut vowels_idx_next37 = 0;\n\
    \    let mut vowels_idx_next38 = 0;\n    let mut vowels_idx_next39 = 0;\n    let\
    \ mut vowels_idx_next40 = 0;\n    let mut vowels_idx_next41 = 0;\n    let mut\
    \ vowels_idx_next42 = 0;\n    let mut vowels_idx_next43 = 0;\n    let mut vowels_idx_next44\
    \ = 0;\n    let mut vowels_idx_next45 = 0;\n    let mut vowels_idx_next46 = 0;\n\
    \    let mut vowels_idx_next47 = 0;\n    let mut vowels_idx_next48 = 0;\n\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp7113r0g5.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7113r0g5.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut letters = message.chars();\n\
    \    let mut i = 0;\n    while i < letters.len() {\n        let letter = letters.nth(i);\n\
    \        if letter.is_uppercase() {\n            alphabet.insert(letter);\n  \
    \      }\n        if letter.is_lowercase() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_digit() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_punctuation() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_whitespace() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_control() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_graph() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_symbol() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_alphabet() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_digit() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_punctuation() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_whitespace() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_control() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_graph() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_symbol() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_alphabet() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_digit() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_punctuation() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_whitespace() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_control() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_graph() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_symbol() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_alphabet() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_digit() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_punctuation() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_whitespace() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_control() {\n            alphabet.insert(letter);\n\
    \        }\n        if letter.is_graph() {\n            alphabet.insert(letter);\n\
    \        }\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpmk10kdtr.rs:113:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n17  |     while i < letters.len()\
    \ {\n    |                             - this delimiter might not be properly\
    \ closed...\n...\n104 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n113 | }\n    |   ^\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpmk10kdtr.rs:13:22\n   |\n13 |  \
    \   let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpmk10kdtr.rs:14:24\n   |\n14 |     let mut alphabet = HashSet::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpmk10kdtr.rs:17:23\n\
    \   |\n17 |     while i < letters.len() {\n   |                       ^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0599]: no method named `is_uppercase` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpmk10kdtr.rs:19:19\n  \
    \ |\n19 |         if letter.is_uppercase() {\n   |                   ^^^^^^^^^^^^\
    \ method not found in `Option<char>`\n\nerror[E0599]: no method named `is_lowercase`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpmk10kdtr.rs:22:19\n\
    \   |\n22 |         if letter.is_lowercase() {\n   |                   ^^^^^^^^^^^^\
    \ method not found in `Option<char>`\n\nerror[E0599]: no method named `is_digit`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpmk10kdtr.rs:25:19\n\
    \   |\n25 |         if letter.is_digit() {\n   |                   ^^^^^^^^ method\
    \ not found in `Option<char>`\n\nerror[E0599]: no method named `is_punctuation`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpmk10kdtr.rs:28"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut index = 0;\n    for c in message.chars() {\n        if let Some(vowel)\
    \ = vowels.binary_search(&c) {\n            result.push_str(&letters[(index +\
    \ vowel) % letters.len()]);\n        } else {\n            result.push_str(&c);\n\
    \        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiuznzwly.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \     ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpiuznzwly.rs:20:29\n   |\n20 |             result.push_str(&c);\n   |\
    \                             ^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for c in message.chars() {\n        if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == c) {\n            result.push_str(&letters[vowel\
    \ + 2]);\n        } else {\n            result.push_str(&letters[letters.iter().position(|&x|\
    \ x == c).unwrap() + 2]);\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3klm71ff.rs:17:29\n   |\n\
    17 |             result.push_str(&letters[vowel + 2]);\n   |                 \
    \            ^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3klm71ff.rs:19:29\n   |\n19 |             result.push_str(&letters[letters.iter().position(|&x|\
    \ x == c).unwrap() + 2]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
    \ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,\
    \ 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\
    \ 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, 34, \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpzp5bs7s5.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpzp5bs7s5.rs:17:34\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut vowels_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 2...\n   |                                  ^ unclosed delimiter\n18 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for c in message.chars() {\n    \
    \    if let Some(vowel) = vowels.binary_search(&c) {\n            vowel_counter\
    \ += 1;\n            result.push(*vowel);\n        } else {\n            result.push(*c);\n\
    \        }\n        if let Some(letter) = letters.binary_search(&c) {\n      \
    \      letter_counter += 1;\n            result.push(*letter);\n        } else\
    \ {\n            result.push(*c);\n        }\n    }\n    if vowel_counter > 1\
    \ {\n        result.push(*vowels[vowel_counter - 2]);\n    }\n    if letter_counter\
    \ > 1 {\n        result.push(*letters[letter_counter - 2]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppk4rql3p.rs:18:51\n   |\n\
    18 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \                                        ^^ expected `&str`, found `char`\n  \
    \ |\n   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppk4rql3p.rs:18:16\n   |\n18 |\
    \         if let Some(vowel) = vowels.binary_search(&c) {\n   |              \
    \  ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmppk4rql3p.rs:22:25\n   |\n22 |             result.push(*c);\n  \
    \ |                         ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppk4rql3p.rs:24:53\n\
    \   |\n24 |         if let Some(letter) = letters.binary_search(&c) {\n   |  \
    \                                                   ^^ expected `&str`, found\
    \ `char`\n   |\n   = note: expected reference `&&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppk4rql3p.rs:24:16\n\
    \   |\n24 |         if let Some(letter) = letters.binary_search(&c) {\n   |  \
    \              ^^^^^^^^^^^^   ------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmppk4rql3p.rs:28:25\n   |\n28 |             result.push(*c);\n\
    \   |                         ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppk4rql3p.rs:32:21\n\
    \   |\n32 |         result.push(*vowels[vowel_counter - 2]);\n   |           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppk4rql3p.rs:35:21\n   |\n35 |         result.push(*letters[lett"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowels_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            vowels_counter += 1;\n            result.push((&vowels[vowels_counter]).to_string());\n\
    \        } else {\n            result.push((&letter).to_string());\n         \
    \   letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqd7frk8.rs:17:28\n   |\n\
    17 |         if vowels.contains(&letter) {\n   |                            ^^^^^^^\
    \ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmqd7frk8.rs:19:25\n   |\n19 |             result.push((&vowels[vowels_counter]).to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmqd7frk8.rs:21:25\n\
    \   |\n21 |             result.push((&letter).to_string());\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    let mut i = 0;\n    while i < message.len() {\n        if message[i]\
    \ == ' ' {\n            encoded.push_str(\" \");\n            i += 1;\n      \
    \      continue;\n        }\n        if message[i] == 'a' || message[i] == 'e'\
    \ || message[i] == 'i' || message[i] == 'o' || message[i] == 'u' || message[i]\
    \ == 'y' {\n            encoded.push_str(vowels[vowel_counter]);\n           \
    \ vowel_counter += 1;\n            i += 1;\n            continue;\n        }\n\
    \        if message[i] == 'b' || message[i] == 'c' || message[i] == 'd' || message[i]\
    \ == 'f' || message[i] == 'g' || message[i] == 'h' || message[i] == 'j' || message[i]\
    \ == 'k' || message[i] == 'l' || message[i] == 'm' || message[i] == 'n' || message[i]\
    \ == 'p' || message[i] == 'q' || message[i] == 'r' || message[i] == 's' || message[i]\
    \ == 't' || message[i] == 'u' || message[i] == 'v' || message[i] == 'w' || message[i]\
    \ == 'x' || message[i] == 'y' || message[i] == 'z' {\n            encoded.push_str(consonants[consonant_counter]);\n\
    \            consonant_counter += 1;\n            i += 1;\n            continue;\n\
    \        }\n        encoded.push_str(&message[i]);\n        i += 1;\n    }\n \
    \   encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpr3loqhof.rs:19:12\n\
    \   |\n19 |         if message[i] == ' ' {\n   |            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpr3loqhof.rs:24:12\n   |\n24 |         if message[i]\
    \ == 'a' || message[i] == 'e' || message[i] == 'i' || message[i] == 'o' || message[i]\
    \ == 'u' || message[i] == 'y' {\n   |            ^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpr3loqhof.rs:24:33\n   |\n24 |         if message[i] == 'a' || message[i]\
    \ == 'e' || message[i] == 'i' || message[i] == 'o' || message[i] == 'u' || message[i]\
    \ == 'y' {\n   |                                 ^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpr3loqhof.rs:24:54\n   |\n24 |         if message[i] == 'a' || message[i]\
    \ == 'e' || message[i] == 'i' || message[i] == 'o' || message[i] == 'u' || message[i]\
    \ == 'y' {\n   |                                                      ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpr3loqhof.rs:24:75\n   |\n24 |         if message[i]\
    \ == 'a' || message[i] == 'e' || message[i] == 'i' || message[i] == 'o' || message[i]\
    \ == 'u' || message[i] == 'y' {\n   |                                        \
    \                                   ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpr3loqhof.rs:24:96\n\
    \   |\n24 |         if message[i] == 'a' || me"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut letter_positions = vec![];\n\
    \    for letter in message.chars() {\n        if let Some(index) = vowels.binary_search(&letter)\
    \ {\n            vowels_index = index;\n        }\n        if let Some(index)\
    \ = vowels.binary_search(&letter + &vowels[vowels_index]) {\n            vowels_index\
    \ = index;\n        }\n        if let Some(index) = vowels.binary_search(&letter\
    \ + &vowels[vowels_index - 1]) {\n            vowels_index = index;\n        }\n\
    \        if let Some(index) = vowels.binary_search(&letter + &vowels[vowels_index\
    \ + 1]) {\n            vowels_index = index;\n        }\n        if let Some(index)\
    \ = vowels.binary_search(&letter + &vowels[vowels_index - 2]) {\n            vowels_index\
    \ = index;\n        }\n        if let Some(index) = vowels.binary_search(&letter\
    \ + &vowels[vowels_index - 3]) {\n            vowels_index = index;\n        }\n\
    \        if let Some(index) = vowels.binary_search(&letter + &vowels[vowels_index\
    \ - 4]) {\n            vowels_index = index;\n        }\n        if let Some(index)\
    \ = vowels.binary_search(&letter + &vowels[vowels_index - 5]) {\n            vowels_index\
    \ = index;\n        }\n        if let Some(index) = vowels.binary_search(&letter\
    \ + &vowels[vowels_index - 6]) {\n            vowels_index = index;\n        }\n\
    \        if let Some(index) = vowels.binary_search(&letter + &vowels[vowels_index\
    \ - 7]) {\n            vowels_index = index;\n        }\n        if let Some(index)\
    \ = vowels.binary_search(&letter + &vowels[vowels_index - 8]) {\n            vowels_index\
    \ = index;\n        }\n        if let Some(index) = vowels.binary_search(&letter\
    \ + &vowels[vowels_index - 9]) {\n            vowels_index = index;\n        }\n\
    \        if let Some(index) = vowels.binary_search(&letter + &vowels[vowels_index\
    \ - 10]) {\n            vowels_index = index;\n        }\n        if let Some(index)\
    \ = vowels.binary_search(&letter + &vowels[vowels_index - 11]) {\n           \
    \ vowels_index = index;\n        }\n        if let Some(index) = vowels.binary_search(&letter\
    \ + &vowels[vowels_index - 12]) {\n            vowels_index = index;\n       \
    \ }\n        if let Some(index) = vowels.binary_search(&letter + &\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpc1fxfa3l.rs:72:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n16 |     for letter in message.chars()\
    \ {\n   |                                   - this delimiter might not be properly\
    \ closed...\n...\n63 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n72 | }\n   |   ^\n\nerror: expected expression, found `)`\n  --> /tmp/tmpc1fxfa3l.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpc1fxfa3l.rs:62:50\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |                                      - closing delimiter possibly\
    \ meant for this\n...\n62 |         if let Some(index) = vowels.binary_search(&letter\
    \ + &\n   |                                                  ^ unclosed delimiter\n\
    63 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `binary_search`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpc1fxfa3l.rs:17:37\n\
    \   |\n17 |         if let Some(index) = vowels.binary_search(&letter) {\n   |\
    \                                     ^^^^^^^^^^^^^ method not found in `&str`\n\
    \nerror[E0599]: no method named `binary_search` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmpc1fxfa3l.rs:20:37\n   |\n20 |         if let\
    \ Some(index) = vowels.binary_search(&letter + &vowels[vowels_index]) {\n   |\
    \                                     ^^^^^^^^^^^^^ method not found in `&str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpc1fxfa3l.rs:20:62\n\
    \   |\n20 |         if let Some(index) = vowels.binary_search(&letter + &vowels[vowels_index])\
    \ {\n   |                                                              ^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<usize>` for `str`\n\nerror[E0369]: cannot add `&_` to\
    \ `&char`\n  --> /tmp/tmpc1fxfa3l.rs"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_counts = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index2 = vec![0, 1, 2,\
    \ 3, 4, 5];\n    let mut letter_counts_index3 = vec![0, 1, 2, 3, 4, 5];\n    let\
    \ mut letter_counts_index4 = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index5\
    \ = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index6 = vec![0, 1, 2,\
    \ 3, 4, 5];\n    let mut letter_counts_index7 = vec![0, 1, 2, 3, 4, 5];\n    let\
    \ mut letter_counts_index8 = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index9\
    \ = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index10 = vec![0, 1, 2,\
    \ 3, 4, 5];\n    let mut letter_counts_index11 = vec![0, 1, 2, 3, 4, 5];\n   \
    \ let mut letter_counts_index12 = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index13\
    \ = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index14 = vec![0, 1, 2,\
    \ 3, 4, 5];\n    let mut letter_counts_index15 = vec![0, 1, 2, 3, 4, 5];\n   \
    \ let mut letter_counts_index16 = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index17\
    \ = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index18 = vec![0, 1, 2,\
    \ 3, 4, 5];\n    let mut letter_counts_index19 = vec![0, 1, 2, 3, 4, 5];\n   \
    \ let mut letter_counts_index20 = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index21\
    \ = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index22 = vec![0, 1, 2,\
    \ 3, 4, 5];\n    let mut letter_counts_index23 = vec![0, 1, 2, 3, 4, 5];\n   \
    \ let mut letter_counts_index24 = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index25\
    \ = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index26 = vec![0, 1, 2,\
    \ 3, 4, 5];\n    let mut letter_counts_index27 = vec![0, 1, 2, 3, 4, 5];\n   \
    \ let mut letter_counts_index28 = vec![0, 1, 2, \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp2k1eu8l7.rs:44:1\n   |\n44 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp2k1eu8l7.rs:43:41\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n43 |     let mut letter_counts_index28 = vec![0, 1, 2, \n   |\
    \                                         ^ unclosed delimiter\n44 | }\n   | ^\
    \ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n    let mut index64 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdad_3pni.rs:79:11\n   |\n\
    79 |     let mu\n   |           ^ help: add `;` here\n80 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdad_3pni.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants = vec!['B',\
    \ 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'W',\
    \ 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\
    \ 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\
    \ 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut consonants_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut vowels_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\
    \ 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\
    \ 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp0gk4xq65.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp0gk4xq65.rs:17:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut vowels_count = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28,...\n   |                                ^ unclosed delimiter\n18 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = -1;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter_counter % 2 == 0 {\n            result.push((&vowels[vowels_index]).to_string());\n\
    \        } else {\n            result.push((&vowels[vowels_index + 1]).to_string());\n\
    \        }\n        vowels_index += 1;\n        letter_counter += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmp1344feij.rs:18:27\n\
    \   |\n18 |             result.push((&vowels[vowels_index]).to_string());\n  \
    \ |                           ^^^^^^^^^^^^^^^^^^^^ string indices are ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented for\
    \ `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n \
    \          for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = note: required because of the requirements on the impl of `Index<{integer}>`\
    \ for `str`\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp1344feij.rs:20:27\n   |\n20 |             result.push((&vowels[vowels_index\
    \ + 1]).to_string());\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `{integer}`\n   = note: you can use `.chars().nth()`\
    \ or `.bytes().nth()`\n           for more information, see chapter 8 in The Book:\
    \ <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = note: required because of the requirements on the impl of `Index<{integer}>`\
    \ for `str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut current_letter = String::new();\n\
    \    let mut current_vowel = String::new();\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(current_vowel);\n\
    \            current_vowel = String::new();\n            current_letter = String::new();\n\
    \        } else {\n            if letter in vowels {\n                current_vowel.push_str(letters[index]);\n\
    \                index += 2;\n            } else {\n                current_letter.push_str(letters[index]);\n\
    \                index += 1;\n            }\n        }\n    }\n    result.push_str(current_vowel);\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpkx85mjm2.rs:24:23\n\
    \   |\n24 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkx85mjm2.rs:20:29\n\
    \   |\n20 |             result.push_str(current_vowel);\n   |                \
    \             ^^^^^^^^^^^^^\n   |                             |\n   |        \
    \                     expected `&str`, found struct `String`\n   |           \
    \                  help: consider borrowing here: `&current_vowel`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkx85mjm2.rs:33:21\n   |\n33 |     result.push_str(current_vowel);\n\
    \   |                     ^^^^^^^^^^^^^\n   |                     |\n   |    \
    \                 expected `&str`, found struct `String`\n   |               \
    \      help: consider borrowing here: `&current_vowel`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut i = 0;\n    for letter in message.chars() {\n \
    \       if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            result.push_str(&letters[letters.len() - i]);\n        }\n  \
    \      if letter == vowels[vowels.len() - i] {\n            result.push_str(&vowels[vowels.len()\
    \ - i - 1]);\n            i += 2;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn3tvf3ky.rs:20:29\n   |\n\
    20 |             result.push_str(&letters[letters.len() - i]);\n   |         \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn3tvf3ky.rs:23:29\n   |\n23 |\
    \             result.push_str(&vowels[vowels.len() - i - 1]);\n   |          \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptzwxyv2n.rs:51:20\n   |\n\
    51 |     let mut vowels_\n   |                    ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptzwxyv2n.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let mut letters_index = letters.len();\n    let mut vowels_count = vowels.len();\n\
    \    let mut letters_count = letters.len();\n    let mut i = 0;\n    for letter\
    \ in message {\n        if letter == ' ' {\n            result.push_str(&\" \"\
    );\n        } else {\n            let mut letter_index = letters.len();\n    \
    \        while letter_index < letters_index {\n                if letters[letter_index]\
    \ == letter {\n                    letter_index += 1;\n                    break;\n\
    \                }\n                letter_index += 1;\n            }\n      \
    \      let mut vowel_index = vowels.len();\n            while vowel_index < vowels_index\
    \ {\n                if vowels[vowel_index] == letter {\n                    vowel_index\
    \ += 1;\n                    break;\n                }\n                vowel_index\
    \ += 1;\n            }\n            if vowel_index < vowels_index {\n        \
    \        result.push_str(&vowels[vowel_index]);\n                vowels_count\
    \ -= 1;\n            } else {\n                result.push_str(&letters[letter_index]);\n\
    \                letters_count -= 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    if vowels_count > 0 {\n        result.push_str(&vowels[vowels_index]);\n\
    \    }\n    if letters_count > 0 {\n        result.push_str(&letters[letters_index]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmphjkj64q5.rs:20:19\n\
    \    |\n20  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphjkj64q5.rs:26:20\n   |\n26 |                 if letters[letter_index]\
    \ == letter {\n   |                    ^^^^^^^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmphjkj64q5.rs:34:20\n   |\n34 |                 if vowels[vowel_index]\
    \ == letter {\n   |                    ^^^^^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmphjkj64q5.rs:41:34\n   |\n41 |                 result.push_str(&vowels[vowel_index]);\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmphjkj64q5.rs:44:34\n   |\n44 |                 result.push_str(&letters[letter_index]);\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]:"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    vowels.insert(\"a\".to_string(), 0);\n    vowels.insert(\"e\".to_string(),\
    \ 1);\n    vowels.insert(\"i\".to_string(), 2);\n    vowels.insert(\"o\".to_string(),\
    \ 3);\n    vowels.insert(\"u\".to_string(), 4);\n    vowels.insert(\"y\".to_string(),\
    \ 5);\n    vowels.insert(\"A\".to_string(), 6);\n    vowels.insert(\"E\".to_string(),\
    \ 7);\n    vowels.insert(\"I\".to_string(), 8);\n    vowels.insert(\"O\".to_string(),\
    \ 9);\n    vowels.insert(\"U\".to_string(), 10);\n    vowels.insert(\"Y\".to_string(),\
    \ 11);\n    vowels.insert(\"a\".to_string(), 12);\n    vowels.insert(\"e\".to_string(),\
    \ 13);\n    vowels.insert(\"i\".to_string(), 14);\n    vowels.insert(\"o\".to_string(),\
    \ 15);\n    vowels.insert(\"u\".to_string(), 16);\n    vowels.insert(\"y\".to_string(),\
    \ 17);\n    vowels.insert(\"A\".to_string(), 18);\n    vowels.insert(\"E\".to_string(),\
    \ 19);\n    vowels.insert(\"I\".to_string(), 20);\n    vowels.insert(\"O\".to_string(),\
    \ 21);\n    vowels.insert(\"U\".to_string(), 22);\n    vowels.insert(\"Y\".to_string(),\
    \ 23);\n    let mut i = 0;\n    for ch in message {\n        if let Some(key)\
    \ = vowels.get(&ch) {\n            result.push_str(&message[i..(i + key.0)]);\n\
    \            result.push_str(&vowels.get(&ch).unwrap().to_string());\n       \
    \     i += key.0;\n        } else {\n            result.push_str(&message[i..(i\
    \ + 1)]);\n            result.push_str(&ch.to_string());\n            i += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpxlyuy7ac.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ `String` is not an iterator\n   --> /tmp/tmpxlyuy7ac.rs:39:15\n    |\n39  |\
    \     for ch in message {\n    |               ^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator`\
    \ is not implemented for `String`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\nnote: required by `into_iter`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letter_map = HashMap::new();\n\
    \    for letter in message.chars() {\n        if let Some(index) = vowels.iter().position(|&vowel|\
    \ vowel == letter) {\n            result.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \        } else {\n            result.push_str(&letter);\n        }\n        letter_map.insert(letter,\
    \ letter);\n    }\n    for vowel in vowels.iter() {\n        let index = letter_map.get(&vowel);\n\
    \        if let Some(index) = index {\n            result.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp21jac7e6.rs:14:26\n   |\n14 |     let mut letter_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmp21jac7e6.rs:16:68\n   |\n16\
    \ |         if let Some(index) = vowels.iter().position(|&vowel| vowel == letter)\
    \ {\n   |                                                                    ^^\
    \ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp21jac7e6.rs:19:29\n\
    \   |\n19 |             result.push_str(&letter);\n   |                      \
    \       ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letters = HashMap::new();\n    let\
    \ mut letters_counter = 0;\n    for letter in message.chars() {\n        if letter.is_uppercase()\
    \ {\n            letters.insert(letter, letters_counter);\n            letters_counter++;\n\
    \        } else {\n            vowels.insert(letter, vowels_counter);\n      \
    \      vowels_counter++;\n        }\n    }\n    for vowel in vowels.keys() {\n\
    \        let vowel_counter = vowels.get(vowel);\n        let vowel_letter = message.chars().nth(vowel_counter).unwrap();\n\
    \        result.push_str(&vowel_letter);\n    }\n    for letter in letters.keys()\
    \ {\n        let letter_counter = letters.get(letter);\n        let letter_letter\
    \ = message.chars().nth(letter_counter).unwrap();\n        result.push_str(&letter_letter);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpy1d31ogz.rs:20:29\n\
    \   |\n20 |             letters_counter++;\n   |                             ^\
    \ expected expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpy1d31ogz.rs:23:28\n\
    \   |\n23 |             vowels_counter++;\n   |                            ^ expected\
    \ expression\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \  --> /tmp/tmpy1d31ogz.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpy1d31ogz.rs:15:23\n\
    \   |\n15 |     let mut letters = HashMap::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy1d31ogz.rs:29:25\n   |\n29 |         result.push_str(&vowel_letter);\n\
    \   |                         ^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy1d31ogz.rs:34:25\n   |\n34 |\
    \         result.push_str(&letter_letter);\n   |                         ^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = 0;\n    let mut vowels_index2 = 0;\n    let mut vowels_index3\
    \ = 0;\n    let mut vowels_index4 = 0;\n    let mut vowels_index5 = 0;\n    let\
    \ mut vowels_index6 = 0;\n    let mut vowels_index7 = 0;\n    let mut vowels_index8\
    \ = 0;\n    let mut vowels_index9 = 0;\n    let mut vowels_index10 = 0;\n    let\
    \ mut vowels_index11 = 0;\n    let mut vowels_index12 = 0;\n    let mut vowels_index13\
    \ = 0;\n    let mut vowels_index14 = 0;\n    let mut vowels_index15 = 0;\n   \
    \ let mut vowels_index16 = 0;\n    let mut vowels_index17 = 0;\n    let mut vowels_index18\
    \ = 0;\n    let mut vowels_index19 = 0;\n    let mut vowels_index20 = 0;\n   \
    \ let mut vowels_index21 = 0;\n    let mut vowels_index22 = 0;\n    let mut vowels_index23\
    \ = 0;\n    let mut vowels_index24 = 0;\n    let mut vowels_index25 = 0;\n   \
    \ let mut vowels_index26 = 0;\n    let mut vowels_index27 = 0;\n    let mut vowels_index28\
    \ = 0;\n    let mut vowels_index29 = 0;\n    let mut vowels_index30 = 0;\n   \
    \ let mut vowels_index31 = 0;\n    let mut vowels_index32 = 0;\n    let mut vowels_index33\
    \ = 0;\n    let mut vowels_index34 = 0;\n    let mut vowels_index35 = 0;\n   \
    \ let mut vowels_index36 = 0;\n    let mut vowels_index37 = 0;\n    let mut vowels_index38\
    \ = 0;\n    let mut vowels_index39 = 0;\n    let mut vowels_index40 = 0;\n   \
    \ let mut vowels_index41 = 0;\n    let mut vowels_index42 = 0;\n    let mut vowels_index43\
    \ = 0;\n    let mut vowels_index44 = 0;\n    let mut vowels_index45 = 0;\n   \
    \ let mut vowels_index46 = 0;\n    let mut vowels_index47 = 0;\n    let mut vowels_index48\
    \ = 0;\n    let mut vowels_index49 = 0;\n    let mut vowels_index50 = 0;\n   \
    \ let mut vowels_index51 = 0;\n    let mut vowels_index52 = 0;\n    let mut vowels_index53\
    \ = 0;\n    let mut vowels_index54 = 0;\n    let mut vowels_index55 = 0;\n   \
    \ let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpgsyahwsf.rs:70:1\n  \
    \ |\n70 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpgsyahwsf.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut i = 0;\n    for letter in message {\n    \
    \    if letter in vowels {\n            result.push((letters[i as usize] as char).to_string());\n\
    \            i += 1;\n        } else {\n            result.push((letters[i as\
    \ usize] as char).to_string());\n            i += 1;\n            result.push((letters[i\
    \ as usize] as char).to_string());\n            i += 1;\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpicydaqzi.rs:17:19\n\
    \   |\n17 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpicydaqzi.rs:16:19\n\
    \    |\n16  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    vowels.insert(\"a\".to_string(), \"A\".to_string());\n    vowels.insert(\"\
    e\".to_string(), \"E\".to_string());\n    vowels.insert(\"i\".to_string(), \"\
    I\".to_string());\n    vowels.insert(\"o\".to_string(), \"O\".to_string());\n\
    \    vowels.insert(\"u\".to_string(), \"U\".to_string());\n    vowels.insert(\"\
    y\".to_string(), \"Y\".to_string());\n    vowels.insert(\"A\".to_string(), \"\
    a\".to_string());\n    vowels.insert(\"E\".to_string(), \"e\".to_string());\n\
    \    vowels.insert(\"I\".to_string(), \"i\".to_string());\n    vowels.insert(\"\
    O\".to_string(), \"o\".to_string());\n    vowels.insert(\"U\".to_string(), \"\
    u\".to_string());\n    vowels.insert(\"Y\".to_string(), \"y\".to_string());\n\
    \    for letter in message.chars() {\n        if let Some(key) = vowels.get(&letter.to_string())\
    \ {\n            result.push_str(key);\n        } else {\n            result.push_str(letter.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpot4fxb_h.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpot4fxb_h.rs:30:29\n   |\n30 |             result.push_str(letter.to_string());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^\n   |                   \
    \          |\n   |                             expected `&str`, found struct `String`\n\
    \   |                             help: consider borrowing here: `&letter.to_string()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut letter_counter = 0;\n    let mut letter_counter_index = 0;\n\
    \    let mut letter_counter_index2 = 0;\n    let mut letter_counter_index3 = 0;\n\
    \    let mut letter_counter_index4 = 0;\n    let mut letter_counter_index5 = 0;\n\
    \    let mut letter_counter_index6 = 0;\n    let mut letter_counter_index7 = 0;\n\
    \    let mut letter_counter_index8 = 0;\n    let mut letter_counter_index9 = 0;\n\
    \    let mut letter_counter_index10 = 0;\n    let mut letter_counter_index11 =\
    \ 0;\n    let mut letter_counter_index12 = 0;\n    let mut letter_counter_index13\
    \ = 0;\n    let mut letter_counter_index14 = 0;\n    let mut letter_counter_index15\
    \ = 0;\n    let mut letter_counter_index16 = 0;\n    let mut letter_counter_index17\
    \ = 0;\n    let mut letter_counter_index18 = 0;\n    let mut letter_counter_index19\
    \ = 0;\n    let mut letter_counter_index20 = 0;\n    let mut letter_counter_index21\
    \ = 0;\n    let mut letter_counter_index22 = 0;\n    let mut letter_counter_index23\
    \ = 0;\n    let mut letter_counter_index24 = 0;\n    let mut letter_counter_index25\
    \ = 0;\n    let mut letter_counter_index26 = 0;\n    let mut letter_counter_index27\
    \ = 0;\n    let mut letter_counter_index28 = 0;\n    let mut letter_counter_index29\
    \ = 0;\n    let mut letter_counter_index30 = 0;\n    let mut letter_counter_index31\
    \ = 0;\n    let mut letter_counter_index32 = 0;\n    let mut letter_counter_index33\
    \ = 0;\n    let mut letter_counter_index34 = 0;\n    let mut letter_counter_index35\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3pbul3jm.rs:50:35\n   |\n\
    50 |     let mut letter_counter_index35\n   |                                \
    \   ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3pbul3jm.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_map = HashMap::new();\n    let mut letter_map_reverse\
    \ = HashMap::new();\n    let mut letter_counter = 0;\n    let mut letter_counter_reverse\
    \ = 0;\n    let mut letter_counter_reverse_temp = 0;\n    let mut letter_counter_reverse_temp2\
    \ = 0;\n    let mut letter_counter_reverse_temp3 = 0;\n    let mut letter_counter_reverse_temp4\
    \ = 0;\n    let mut letter_counter_reverse_temp5 = 0;\n    let mut letter_counter_reverse_temp6\
    \ = 0;\n    let mut letter_counter_reverse_temp7 = 0;\n    let mut letter_counter_reverse_temp8\
    \ = 0;\n    let mut letter_counter_reverse_temp9 = 0;\n    let mut letter_counter_reverse_temp10\
    \ = 0;\n    let mut letter_counter_reverse_temp11 = 0;\n    let mut letter_counter_reverse_temp12\
    \ = 0;\n    let mut letter_counter_reverse_temp13 = 0;\n    let mut letter_counter_reverse_temp14\
    \ = 0;\n    let mut letter_counter_reverse_temp15 = 0;\n    let mut letter_counter_reverse_temp16\
    \ = 0;\n    let mut letter_counter_reverse_temp17 = 0;\n    let mut letter_counter_reverse_temp18\
    \ = 0;\n    let mut letter_counter_reverse_temp19 = 0;\n    let mut letter_counter_reverse_temp20\
    \ = 0;\n    let mut letter_counter_reverse_temp21 = 0;\n    let mut letter_counter_reverse_temp22\
    \ = 0;\n    let mut letter_counter_reverse_temp23 = 0;\n    let mut letter_counter_reverse_temp24\
    \ = 0;\n    let mut letter_counter_reverse_temp25 = 0;\n    let mut letter_counter_reverse_temp26\
    \ = 0;\n    let mut letter_counter_reverse_temp27 = 0;\n    let mut letter_counter_reverse_temp28\
    \ = 0;\n    let mut letter_counter_reverse_temp29 = 0;\n    let mut letter_counter_reverse_temp30\
    \ = 0;\n    let mut letter_counter_reverse_temp31 = 0;\n    let mut letter_counter_reverse_temp32\
    \ = 0;\n    let mut letter_counter_reverse_temp33 = 0;\n    let mut letter_counter_reverse_temp34\
    \ = 0;\n    let mut letter_counter_reverse_temp35 = 0;\n    let mut letter_counter_reverse_temp36\
    \ = 0;\n    let mut letter_counter_reverse_temp37 = 0;\n    let mut letter_counter_reverse_temp38\
    \ = 0;\n    let mut letter_counter_reverse_temp39 = 0;\n    let mut letter_counter_reverse_temp\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd4_hjxjy.rs:58:40\n   |\n\
    58 |     let mut letter_counter_reverse_temp\n   |                           \
    \             ^ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpd4_hjxjy.rs:15:26\n\
    \   |\n15 |     let mut letter_map = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpd4_hjxjy.rs:16:34\n   |\n16\
    \ |     let mut letter_map_reverse = HashMap::new();\n   |                   \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd4_hjxjy.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\
    \ 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\
    \ 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\
    \ 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103,\
    \ 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\
    \ 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135,\
    \ 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151,\
    \ 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\
    \ 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,\
    \ 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199,\
    \ 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215,\
    \ 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231,\
    \ 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,\
    \ 248, 249, 250, 251, 252, 253, 254, 255];\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8qqa04d.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppc4hj3pc.rs:47:20\n   |\n\
    47 |     let mut vowels_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppc4hj3pc.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut letter_pos = 0;\n   \
    \ let mut letter_pos_index = 0;\n    let mut letter_pos_index2 = 0;\n    let mut\
    \ letter_pos_index3 = 0;\n    let mut letter_pos_index4 = 0;\n    let mut letter_pos_index5\
    \ = 0;\n    let mut letter_pos_index6 = 0;\n    let mut letter_pos_index7 = 0;\n\
    \    let mut letter_pos_index8 = 0;\n    let mut letter_pos_index9 = 0;\n    let\
    \ mut letter_pos_index10 = 0;\n    let mut letter_pos_index11 = 0;\n    let mut\
    \ letter_pos_index12 = 0;\n    let mut letter_pos_index13 = 0;\n    let mut letter_pos_index14\
    \ = 0;\n    let mut letter_pos_index15 = 0;\n    let mut letter_pos_index16 =\
    \ 0;\n    let mut letter_pos_index17 = 0;\n    let mut letter_pos_index18 = 0;\n\
    \    let mut letter_pos_index19 = 0;\n    let mut letter_pos_index20 = 0;\n  \
    \  let mut letter_pos_index21 = 0;\n    let mut letter_pos_index22 = 0;\n    let\
    \ mut letter_pos_index23 = 0;\n    let mut letter_pos_index24 = 0;\n    let mut\
    \ letter_pos_index25 = 0;\n    let mut letter_pos_index26 = 0;\n    let mut letter_pos_index27\
    \ = 0;\n    let mut letter_pos_index28 = 0;\n    let mut letter_pos_index29 =\
    \ 0;\n    let mut letter_pos_index30 = 0;\n    let mut letter_pos_index31 = 0;\n\
    \    let mut letter_pos_index32 = 0;\n    let mut letter_pos_index33 = 0;\n  \
    \  let mut letter_pos_index34 = 0;\n    let mut letter_pos_index35 = 0;\n    let\
    \ mut letter_pos_index36 = 0;\n    let mut letter_pos_index37 = 0;\n    let mut\
    \ letter_pos_index38 = 0;\n    let mut letter_pos_index39 = 0;\n    let mut letter_pos_index40\
    \ = 0;\n    let mut letter_pos_index41 = 0;\n    let mut letter_pos_index42 =\
    \ 0;\n    let mut letter_pos_index43 = 0;\n    let mut letter_pos_index44 = 0;\n\
    \    let mut letter_pos_index45 = 0;\n    let mut letter_pos_index46 = 0;\n  \
    \  let mut letter_pos_index47 = 0;\n    let mut letter_pos_index48 = 0;\n    let\
    \ mut letter_pos_index49 = 0;\n    let mut letter_pos_index50 = 0;\n    let mut\
    \ letter_pos_index51 = 0;\n    let mut letter_pos_index52 = 0;\n    let mut letter_pos_index53\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4j4ce2_l.rs:70:1\n  \
    \ |\n70 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for c\
    \ in message.chars() {\n        if vowels.contains(&c) {\n            vowel_counter\
    \ += 1;\n            result.push(c);\n        } else {\n            letter_counter\
    \ += 1;\n            if letter_counter >= 2 {\n                result.push((&vowels[vowel_counter\
    \ - 2]).to_string());\n            }\n            result.push(c);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpdz7a7w69.rs:17:28\n\
    \   |\n17 |         if vowels.contains(&c) {\n   |                           \
    \ ^^ expected an `Fn<(char,)>` closure, found `char`\n   |\n   = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n   = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n   = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpdz7a7w69.rs:23:31\n\
    \   |\n23 |                 result.push((&vowels[vowel_counter - 2]).to_string());\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = note: required because of the requirements on the impl of `Index<{integer}>`\
    \ for `str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut vowels_counter2 = 0;\n    let mut\
    \ vowels_counter3 = 0;\n    let mut vowels_counter4 = 0;\n    let mut vowels_counter5\
    \ = 0;\n    let mut vowels_counter6 = 0;\n    let mut vowels_counter7 = 0;\n \
    \   let mut vowels_counter8 = 0;\n    let mut vowels_counter9 = 0;\n    let mut\
    \ vowels_counter10 = 0;\n    let mut vowels_counter11 = 0;\n    let mut vowels_counter12\
    \ = 0;\n    let mut vowels_counter13 = 0;\n    let mut vowels_counter14 = 0;\n\
    \    let mut vowels_counter15 = 0;\n    let mut vowels_counter16 = 0;\n    let\
    \ mut vowels_counter17 = 0;\n    let mut vowels_counter18 = 0;\n    let mut vowels_counter19\
    \ = 0;\n    let mut vowels_counter20 = 0;\n    let mut vowels_counter21 = 0;\n\
    \    let mut vowels_counter22 = 0;\n    let mut vowels_counter23 = 0;\n    let\
    \ mut vowels_counter24 = 0;\n    let mut vowels_counter25 = 0;\n    let mut vowels_counter26\
    \ = 0;\n    let mut vowels_counter27 = 0;\n    let mut vowels_counter28 = 0;\n\
    \    let mut vowels_counter29 = 0;\n    let mut vowels_counter30 = 0;\n    let\
    \ mut vowels_counter31 = 0;\n    let mut vowels_counter32 = 0;\n    let mut vowels_counter33\
    \ = 0;\n    let mut vowels_counter34 = 0;\n    let mut vowels_counter35 = 0;\n\
    \    let mut vowels_counter36 = 0;\n    let mut vowels_counter37 = 0;\n    let\
    \ mut vowels_counter38 = 0;\n    let mut vowels_counter39 = 0;\n    let mut vowels_counter40\
    \ = 0;\n    let mut vowels_counter41 = 0;\n    let mut vowels_counter42 = 0;\n\
    \    let mut vowels_counter43 = 0;\n    let mut vowels_counter44 = 0;\n    let\
    \ mut vowels_counter45 = 0;\n    let mut vowels_counter46 = 0;\n    let mut vowels_counter47\
    \ = 0;\n    let mut vowels_counter48 = 0;\n    let mut vowels_counter49 = 0;\n\
    \    let mut vowels_counter50 = 0;\n    let mut vowels_counter51 = 0;\n    let\
    \ mut vowels_counter52 = 0;\n    let mut vowels_counter53 = 0;\n    let mut vowels_counter54\
    \ = 0;\n    let mut vowels_counter55 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgqtrqwkw.rs:69:11\n   |\n\
    69 |     let mu\n   |           ^ help: add `;` here\n70 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpgqtrqwkw.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqtrqwkw.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letter_counts = HashMap::new();\n    let mut letter_counts_iter =\
    \ letter_counts.iter();\n    let mut letter_counts_iter2 = letter_counts.iter();\n\
    \    let mut letter_counts_iter3 = letter_counts.iter();\n    let mut letter_counts_iter4\
    \ = letter_counts.iter();\n    let mut letter_counts_iter5 = letter_counts.iter();\n\
    \    let mut letter_counts_iter6 = letter_counts.iter();\n    let mut letter_counts_iter7\
    \ = letter_counts.iter();\n    let mut letter_counts_iter8 = letter_counts.iter();\n\
    \    let mut letter_counts_iter9 = letter_counts.iter();\n    let mut letter_counts_iter10\
    \ = letter_counts.iter();\n    let mut letter_counts_iter11 = letter_counts.iter();\n\
    \    let mut letter_counts_iter12 = letter_counts.iter();\n    let mut letter_counts_iter13\
    \ = letter_counts.iter();\n    let mut letter_counts_iter14 = letter_counts.iter();\n\
    \    let mut letter_counts_iter15 = letter_counts.iter();\n    let mut letter_counts_iter16\
    \ = letter_counts.iter();\n    let mut letter_counts_iter17 = letter_counts.iter();\n\
    \    let mut letter_counts_iter18 = letter_counts.iter();\n    let mut letter_counts_iter19\
    \ = letter_counts.iter();\n    let mut letter_counts_iter20 = letter_counts.iter();\n\
    \    let mut letter_counts_iter21 = letter_counts.iter();\n    let mut letter_counts_iter22\
    \ = letter_counts.iter();\n    let mut letter_counts_iter23 = letter_counts.iter();\n\
    \    let mut letter_counts_iter24 = letter_counts.iter();\n    let mut letter_counts_iter25\
    \ = letter_counts.iter();\n    let mut letter_counts_iter26 = letter_counts.iter();\n\
    \    let mut letter_counts_iter27 = letter_counts.iter();\n    let mut letter_counts_iter28\
    \ = letter_counts.iter();\n    let mut letter_counts_iter29 = letter_counts.iter();\n\
    \    let mut letter_counts_iter30 = letter_counts.iter();\n    let mut letter_counts_iter31\
    \ = letter_counts.iter();\n    let mut letter_counts_iter32 = letter_counts.iter();\n\
    \    let mut letter_counts_iter33 = letter_counts.iter();\n    let mut letter_counts_iter34\
    \ = letter_counts.iter();\n    let mut letter_counts_iter35 = letter_counts.iter();\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1p7mhm0z.rs:50:11\n   |\n\
    50 |     let mu\n   |           ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmp1p7mhm0z.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp1p7mhm0z.rs:14:29\n\
    \   |\n14 |     let mut letter_counts = HashMap::new();\n   |                \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1p7mhm0z.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    for letter in message.chars() {\n      \
    \  if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u' {\n            result.push_str(&vowels[letter - 'a']);\n            vowels_counter\
    \ += 1;\n        } else {\n            result.push_str(&vowels[letter]);\n   \
    \     }\n    }\n    if vowels_counter > 2 {\n        result.push_str(&vowels[vowels_counter\
    \ - 2]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpv5zr29q_.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpv5zr29q_.rs:17:44\n   |\n\
    17 |             result.push_str(&vowels[letter - 'a']);\n   |               \
    \                      ------ ^ --- char\n   |                               \
    \      |\n   |                                     char\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0369, E0433.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpxe1zilkc.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    let mut alphabet = HashMap::new();\n    alphabet.insert(\"a\".to_string(),\
    \ \"A\".to_string());\n    alphabet.insert(\"b\".to_string(), \"B\".to_string());\n\
    \    alphabet.insert(\"c\".to_string(), \"C\".to_string());\n    alphabet.insert(\"\
    d\".to_string(), \"D\".to_string());\n    alphabet.insert(\"e\".to_string(), \"\
    E\".to_string());\n    alphabet.insert(\"f\".to_string(), \"F\".to_string());\n\
    \    alphabet.insert(\"g\".to_string(), \"G\".to_string());\n    alphabet.insert(\"\
    h\".to_string(), \"H\".to_string());\n    alphabet.insert(\"i\".to_string(), \"\
    I\".to_string());\n    alphabet.insert(\"j\".to_string(), \"J\".to_string());\n\
    \    alphabet.insert(\"k\".to_string(), \"K\".to_string());\n    alphabet.insert(\"\
    l\".to_string(), \"L\".to_string());\n    alphabet.insert(\"m\".to_string(), \"\
    M\".to_string());\n    alphabet.insert(\"n\".to_string(), \"N\".to_string());\n\
    \    alphabet.insert(\"o\".to_string(), \"O\".to_string());\n    alphabet.insert(\"\
    p\".to_string(), \"P\".to_string());\n    alphabet.insert(\"q\".to_string(), \"\
    Q\".to_string());\n    alphabet.insert(\"r\".to_string(), \"R\".to_string());\n\
    \    alphabet.insert(\"s\".to_string(), \"S\".to_string());\n    alphabet.insert(\"\
    t\".to_string(), \"T\".to_string());\n    alphabet.insert(\"u\".to_string(), \"\
    U\".to_string());\n    alphabet.insert(\"v\".to_string(), \"V\".to_string());\n\
    \    alphabet.insert(\"w\".to_string(), \"W\".to_string());\n    alphabet.insert(\"\
    x\".to_string(), \"X\".to_string());\n    alphabet.insert(\"y\".to_string(), \"\
    Y\".to_string());\n    alphabet.insert(\"z\".to_string(), \"Z\".to_string());\n\
    \    alphabet.insert(\"A\".to_string(), \"a\".to_string());\n    alphabet.insert(\"\
    B\".to_string(), \"b\".to_string());\n    alphabet.insert(\"C\".to_string(), \"\
    c\".to_string());\n    alphabet.insert(\"D\".to_string(), \"d\".to_string());\n\
    \    alphabet.insert(\"E\".to_string(), \"e\".to_string());\n    alphabet.insert(\"\
    F\".to_string(), \"f\".to_string());\n    alphabet.insert(\"G\".to_string(), \"\
    g\".to_string());\n    alphabet.insert(\"H\".to_string(), \"h\".to_string());\n\
    \    alphabet.insert(\"I\".to_string(), \"i\".to_string());\n    alphabet.insert(\"\
    J\".to_string(), \"j\".to_string());\n    alphabet.insert(\"K\".to_string(), \"\
    k\".to_string());\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpo5pq17ou.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpo5pq17ou.rs:14:24\n\
    \   |\n14 |     let mut alphabet = HashMap::new();\n   |                     \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo5pq17ou.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if let Some(vowel) = vowels.find(|x| x == c) {\n            result.push(c);\n\
    \        } else {\n            result.push(c);\n            letters.insert(c);\n\
    \        }\n    }\n    for c in letters.iter() {\n        for vowel in vowels.iter()\
    \ {\n            if c == vowel {\n                result.push(c);\n          \
    \      result.push(vowel);\n                break;\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp61dvjr8p.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp61dvjr8p.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_map = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\
    \ 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut letter_map_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n\
    \    let mut letter_map_reverse = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\
    \ 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\
    \ 'Y', 'Z'];\n    let mut letter_map_reverse_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, 28, 29, 30, 31];\n    let mut letter_map_reverse2 = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letter_map_reverse2_index =\
    \ vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\
    \ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letter_map_reverse3\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letter_map_reverse3_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letter_map_reverse4\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letter_map_reverse4_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letter_map_reverse5\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', '\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp2h2dz5xe.rs:25:95\n\
    \   |\n25 |     let mut letter_map_reverse5 = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', '\n   |                                           \
    \                                                    ^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n   \
    \     } else {\n            letters.insert(c.to_uppercase());\n        }\n   \
    \ }\n    for c in letters.iter() {\n        if vowels.contains(&c) {\n       \
    \     result.push(c);\n        } else {\n            result.push(c.to_ascii_lowercase().to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmptz0gwud3.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmptz0gwud3.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptz0gwud3.rs:26:25\n   |\n26 |             result.push(c.to_ascii_lowercase().to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants = vec!['B',\
    \ 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z'];\n    let mut index = 0;\n    let mut current_letter = String::new();\n\
    \    let mut current_vowel = String::new();\n    let mut current_consonant = String::new();\n\
    \    let mut current_consonant_index = -1;\n    let mut current_vowel_index =\
    \ -1;\n    let mut current_vowel_letter = String::new();\n    let mut current_consonant_letter\
    \ = String::new();\n    let mut current_letter_index = -1;\n    let mut current_letter\
    \ = String::new();\n    let mut current_vowel = String::new();\n    let mut current_consonant\
    \ = String::new();\n    let mut current_consonant_index = -1;\n    let mut current_vowel_index\
    \ = -1;\n    let mut current_vowel_letter = String::new();\n    let mut current_consonant_letter\
    \ = String::new();\n    let mut current_letter_index = -1;\n    let mut current_letter\
    \ = String::new();\n    let mut current_vowel = String::new();\n    let mut current_consonant\
    \ = String::new();\n    let mut current_consonant_index = -1;\n    let mut current_vowel_index\
    \ = -1;\n    let mut current_vowel_letter = String::new();\n    let mut current_consonant_letter\
    \ = String::new();\n    let mut current_letter_index = -1;\n    let mut current_letter\
    \ = String::new();\n    let mut current_vowel = String::new();\n    let mut current_consonant\
    \ = String::new();\n    let mut current_consonant_index = -1;\n    let mut current_vowel_index\
    \ = -1;\n    let mut current_vowel_letter = String::new();\n    let mut current_consonant_letter\
    \ = String::new();\n    let mut current_letter_index = -1;\n    let mut current_letter\
    \ = String\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqcoskc10.rs:48:36\n   |\n\
    48 |     let mut current_letter = String\n   |                               \
    \     ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0423]: expected\
    \ value, found struct `String`\n   --> /tmp/tmpqcoskc10.rs:48:30\n    |\n48  |\
    \       let mut current_letter = String\n    |                               \
    \ ^^^^^^ help: use struct literal syntax instead: `String { vec: val }`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqcoskc10.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if let Some(index) = vowels.binary_search(&letter) {\n            result.push_str(&vowels_index[index]);\n\
    \            vowels_index[index] += 2;\n        } else {\n            result.push_str(&letter);\n\
    \            letter_counter += 1;\n        }\n    }\n    if letter_counter > 0\
    \ {\n        result.push_str(&vowels_index[vowels.len() - 1]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp03569cmv.rs:17:51\n   |\n\
    17 |         if let Some(index) = vowels.binary_search(&letter) {\n   |      \
    \                                             ^^^^^^^ expected `&str`, found `char`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp03569cmv.rs:17:16\n   |\n17 |\
    \         if let Some(index) = vowels.binary_search(&letter) {\n   |         \
    \       ^^^^^^^^^^^   ----------------------------- this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp03569cmv.rs:21:29\n   |\n21 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp03569cmv.rs:26:25\n   |\n26 |\
    \         result.push_str(&vowels_index[vowels.len() - 1]);\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found integer\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&{integer}`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let mut\
    \ letter_counter3 = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5\
    \ = 0;\n    let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n \
    \   let mut letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut\
    \ letter_counter10 = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12\
    \ = 0;\n    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n\
    \    let mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let\
    \ mut letter_counter17 = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19\
    \ = 0;\n    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n\
    \    let mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let\
    \ mut letter_counter24 = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26\
    \ = 0;\n    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n\
    \    let mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let\
    \ mut letter_counter31 = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33\
    \ = 0;\n    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n\
    \    let mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let\
    \ mut letter_counter38 = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40\
    \ = 0;\n    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n\
    \    let mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let\
    \ mut letter_counter45 = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47\
    \ = 0;\n    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n\
    \    let mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let\
    \ mut letter_counter52 = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54\
    \ = 0;\n    let mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n\
    \    let mut letter_counter57 = 0;\n    let mut letter_counter58 = 0;\n    let\
    \ mut letter_counter59 = 0;\n    let mut letter_counter60 = 0;\n    let mut letter_counter61\
    \ = 0;\n    let mut letter_counter62 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp3dz1z1tq.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmp3dz1z1tq.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut index = 0;\n    let mut letter = String::new();\n \
    \   let mut vowel_counter = 0;\n    for letter in message {\n        if letter.is_lowercase()\
    \ {\n            encoded.push((vowels[vowel_counter].to_string()).to_string());\n\
    \            vowel_counter += 1;\n        } else {\n            encoded.push((letter.to_string()).to_string());\n\
    \        }\n    }\n    return encoded;\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpgr5zj9ql.rs:17:19\n\
    \    |\n17  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpgr5zj9ql.rs:19:27\n   |\n19 |             encoded.push((vowels[vowel_counter].to_string()).to_string());\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpyxwpmjpr.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyxwpmjpr.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for letter in message.chars() {\n        if letter.is_lowercase() {\n   \
    \         result.push_str(&format!(\"{}{}\", letter.to_lowercase(), letter.to_lowercase()));\n\
    \        } else {\n            result.push_str(&format!(\"{}{}\", letter.to_uppercase(),\
    \ letter.to_uppercase()));\n        }\n        if letter.is_uppercase() {\n  \
    \          vowels.insert(letter);\n        }\n    }\n    for vowel in vowels.iter()\
    \ {\n        result.push_str(&format!(\"{}{}\", vowel, vowel));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmph9gne7p7.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_idx = 0;\n    let mut letter_counts = HashMap::new();\n  \
    \  let mut letter_counts_idx = 0;\n    let mut letter_counts_idx2 = 0;\n    let\
    \ mut letter_counts_idx3 = 0;\n    let mut letter_counts_idx4 = 0;\n    let mut\
    \ letter_counts_idx5 = 0;\n    let mut letter_counts_idx6 = 0;\n    let mut letter_counts_idx7\
    \ = 0;\n    let mut letter_counts_idx8 = 0;\n    let mut letter_counts_idx9 =\
    \ 0;\n    let mut letter_counts_idx10 = 0;\n    let mut letter_counts_idx11 =\
    \ 0;\n    let mut letter_counts_idx12 = 0;\n    let mut letter_counts_idx13 =\
    \ 0;\n    let mut letter_counts_idx14 = 0;\n    let mut letter_counts_idx15 =\
    \ 0;\n    let mut letter_counts_idx16 = 0;\n    let mut letter_counts_idx17 =\
    \ 0;\n    let mut letter_counts_idx18 = 0;\n    let mut letter_counts_idx19 =\
    \ 0;\n    let mut letter_counts_idx20 = 0;\n    let mut letter_counts_idx21 =\
    \ 0;\n    let mut letter_counts_idx22 = 0;\n    let mut letter_counts_idx23 =\
    \ 0;\n    let mut letter_counts_idx24 = 0;\n    let mut letter_counts_idx25 =\
    \ 0;\n    let mut letter_counts_idx26 = 0;\n    let mut letter_counts_idx27 =\
    \ 0;\n    let mut letter_counts_idx28 = 0;\n    let mut letter_counts_idx29 =\
    \ 0;\n    let mut letter_counts_idx30 = 0;\n    let mut letter_counts_idx31 =\
    \ 0;\n    let mut letter_counts_idx32 = 0;\n    let mut letter_counts_idx33 =\
    \ 0;\n    let mut letter_counts_idx34 = 0;\n    let mut letter_counts_idx35 =\
    \ 0;\n    let mut letter_counts_idx36 = 0;\n    let mut letter_counts_idx37 =\
    \ 0;\n    let mut letter_counts_idx38 = 0;\n    let mut letter_counts_idx39 =\
    \ 0;\n    let mut letter_counts_idx40 = 0;\n    let mut letter_counts_idx41 =\
    \ 0;\n    let mut letter_counts_idx42 = 0;\n    let mut letter_counts_idx43 =\
    \ 0;\n    let mut letter_counts_idx44 = 0;\n    let mut letter_counts_idx45 =\
    \ 0;\n    let mut letter_counts_idx46 = 0;\n    let mut letter_counts_idx47 =\
    \ 0;\n    let mut letter_counts_idx\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphqp_pikl.rs:63:30\n   |\n\
    63 |     let mut letter_counts_idx\n   |                              ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmphqp_pikl.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n  --> /tmp/tmphqp_pikl.rs:15:29\n   |\n15 |  \
    \   let mut letter_counts = HashMap::new();\n   |                            \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphqp_pikl.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
    \ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,\
    \ 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\
    \ 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut i = 0;\n    for\
    \ letter in message.chars() {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            if letter == letters[letters_index[i]] {\n\
    \                result.push_str(&vowels[vowels_index[i]]);\n            } else\
    \ {\n                result.push_str(&letters[letters_index[i]]);\n          \
    \  }\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprlfa8xct.rs:23:33\n   |\n\
    23 |                 result.push_str(&vowels[vowels_index[i]]);\n   |        \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprlfa8xct.rs:25:33\n   |\n25 |\
    \                 result.push_str(&letters[letters_index[i]]);\n   |         \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"AEIOU\"\
    .to_string();\n    let mut vowels_2 = \"AEIOU\".to_string();\n    let mut vowels_3\
    \ = \"AEIOU\".to_string();\n    let mut vowels_4 = \"AEIOU\".to_string();\n  \
    \  let mut vowels_5 = \"AEIOU\".to_string();\n    let mut vowels_6 = \"AEIOU\"\
    .to_string();\n    let mut vowels_7 = \"AEIOU\".to_string();\n    let mut vowels_8\
    \ = \"AEIOU\".to_string();\n    let mut vowels_9 = \"AEIOU\".to_string();\n  \
    \  let mut vowels_10 = \"AEIOU\".to_string();\n    let mut vowels_11 = \"AEIOU\"\
    .to_string();\n    let mut vowels_12 = \"AEIOU\".to_string();\n    let mut vowels_13\
    \ = \"AEIOU\".to_string();\n    let mut vowels_14 = \"AEIOU\".to_string();\n \
    \   let mut vowels_15 = \"AEIOU\".to_string();\n    let mut vowels_16 = \"AEIOU\"\
    .to_string();\n    let mut vowels_17 = \"AEIOU\".to_string();\n    let mut vowels_18\
    \ = \"AEIOU\".to_string();\n    let mut vowels_19 = \"AEIOU\".to_string();\n \
    \   let mut vowels_20 = \"AEIOU\".to_string();\n    let mut vowels_21 = \"AEIOU\"\
    .to_string();\n    let mut vowels_22 = \"AEIOU\".to_string();\n    let mut vowels_23\
    \ = \"AEIOU\".to_string();\n    let mut vowels_24 = \"AEIOU\".to_string();\n \
    \   let mut vowels_25 = \"AEIOU\".to_string();\n    let mut vowels_26 = \"AEIOU\"\
    .to_string();\n    let mut vowels_27 = \"AEIOU\".to_string();\n    let mut vowels_28\
    \ = \"AEIOU\".to_string();\n    let mut vowels_29 = \"AEIOU\".to_string();\n \
    \   let mut vowels_30 = \"AEIOU\".to_string();\n    let mut vowels_31 = \"AEIOU\"\
    .to_string();\n    let mut vowels_32 = \"AEIOU\".to_string();\n    let mut vowels_33\
    \ = \"AEIOU\".to_string();\n    let mut vowels_34 = \"AEIOU\".to_string();\n \
    \   let mut vowels_35 = \"AEIOU\".to_string();\n    let mut vowels_36 = \"AEIOU\"\
    .to_string();\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfvoch9o5.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = 0;\n\
    \    let mut letters_index = 0;\n    let mut vowels_index2 = 0;\n    let mut letters_index2\
    \ = 0;\n    let mut vowels_index3 = 0;\n    let mut letters_index3 = 0;\n    let\
    \ mut vowels_index4 = 0;\n    let mut letters_index4 = 0;\n    let mut vowels_index5\
    \ = 0;\n    let mut letters_index5 = 0;\n    let mut vowels_index6 = 0;\n    let\
    \ mut letters_index6 = 0;\n    let mut vowels_index7 = 0;\n    let mut letters_index7\
    \ = 0;\n    let mut vowels_index8 = 0;\n    let mut letters_index8 = 0;\n    let\
    \ mut vowels_index9 = 0;\n    let mut letters_index9 = 0;\n    let mut vowels_index10\
    \ = 0;\n    let mut letters_index10 = 0;\n    let mut vowels_index11 = 0;\n  \
    \  let mut letters_index11 = 0;\n    let mut vowels_index12 = 0;\n    let mut\
    \ letters_index12 = 0;\n    let mut vowels_index13 = 0;\n    let mut letters_index13\
    \ = 0;\n    let mut vowels_index14 = 0;\n    let mut letters_index14 = 0;\n  \
    \  let mut vowels_index15 = 0;\n    let mut letters_index15 = 0;\n    let mut\
    \ vowels_index16 = 0;\n    let mut letters_index16 = 0;\n    let mut vowels_index17\
    \ = 0;\n    let mut letters_index17 = 0;\n    let mut vowels_index18 = 0;\n  \
    \  let mut letters_index18 = 0;\n    let mut vowels_index19 = 0;\n    let mut\
    \ letters_index19 = 0;\n    let mut vowels_index20 = 0;\n    let mut letters_index20\
    \ = 0;\n    let mut vowels_index21 = 0;\n    let mut letters_index21 = 0;\n  \
    \  let mut vowels_index22 = 0;\n    let mut letters_index22 = 0;\n    let mut\
    \ vowels_index23 = 0;\n    let mut letters_index23\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi9f5kfux.rs:60:28\n   |\n\
    60 |     let mut letters_index23\n   |                            ^ help: add\
    \ `;` here\n61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi9f5kfux.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut index =\
    \ 0;\n    for c in message.chars() {\n        if let Some(vowel) = vowels.find(c)\
    \ {\n            result.push_str(&letters[(index - vowels.len() + 2) % letters.len()]);\n\
    \            result.push_str(&vowel);\n        } else {\n            result.push_str(&letters[index\
    \ % letters.len()]);\n        }\n        index += 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp1x7_vopo.rs:18:30\n\
    \   |\n18 |             result.push_str(&letters[(index - vowels.len() + 2) %\
    \ letters.len()]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1x7_vopo.rs:19:29\n   |\n19 |             result.push_str(&vowel);\n\
    \   |                             ^^^^^^ expected `str`, found `usize`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&usize`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp1x7_vopo.rs:21:30\n\
    \   |\n21 |             result.push_str(&letters[index % letters.len()]);\n  \
    \ |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_map.insert(vowel, vowel);\n\
    \    }\n    for letter in message.chars() {\n        let mut new_letter = letter;\n\
    \        for vowel in vowels.iter() {\n            let mut new_vowel = vowel;\n\
    \            let mut index = vowels.iter().position(|x| x == vowel);\n       \
    \     if index != -1 {\n                new_vowel = vowels_map.get(&vowels[index\
    \ + 1]).unwrap();\n            }\n            new_letter += new_vowel;\n     \
    \   }\n        result += new_letter;\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5dzl26s5.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5dzl26s5.rs:23:25\n   |\n23 |             if\
    \ index != -1 {\n   |                         ^^\n   |                       \
    \  |\n   |                         expected enum `Option`, found integer\n   |\
    \                         help: try using a variant of the expected enum: `Some(-1)`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp5dzl26s5.rs:24:58\n\
    \   |\n24 |                 new_vowel = vowels_map.get(&vowels[index + 1]).unwrap();\n\
    \   |                                                    ----- ^ - {integer}\n\
    \   |                                                    |\n   |             \
    \                                       Option<usize>\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmp5dzl26s5.rs:26:13\n\
    \   |\n26 |             new_letter += new_vowel;\n   |             ----------^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5dzl26s5.rs:28:19\n   |\n28 |         result\
    \ += new_letter;\n   |                   ^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0369, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  let mut index = vowels.binary_search(&letter);\n            if index == -1\
    \ {\n                index = letters.binary_search(&letter);\n            }\n\
    \            result.push_str(&letters[(index + 1) % letters.len()]);\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphe58ow2n.rs:20:25\n   |\n\
    20 |             if index == -1 {\n   |                         ^^ expected enum\
    \ `Result`, found integer\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found type `{integer}`\nhelp: try using a variant of the expected\
    \ enum\n   |\n20 |             if index == Ok(-1) {\n   |                    \
    \     ~~~~~~\n20 |             if index == Err(-1) {\n   |                   \
    \      ~~~~~~~\n\nerror[E0369]: cannot add `{integer}` to `Result<usize, usize>`\n\
    \  --> /tmp/tmphe58ow2n.rs:23:45\n   |\n23 |             result.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n   |                                       ----- ^\
    \ - {integer}\n   |                                       |\n   |            \
    \                           Result<usize, usize>\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut index = 0;\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \            result.push_str(&letters[(index + 1) % letters.len()]);\n       \
    \ }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"EeIiOoUu\"`,\n right: `\"tgst\"`', /tmp/tmphz66hznr.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n\
    \    let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 =\
    \ vec![0];\n    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5\
    \ = vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40 = \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpwfwt2bqs.rs:56:1\n\
    \   |\n56 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letter_pairs = HashSet::new();\n    for c in message.chars() {\n\
    \        if c.is_uppercase() {\n            result.push(c);\n        } else {\n\
    \            result.push((c + c.to_ascii_lowercase()).to_string());\n        }\n\
    \        if result.len() % 2 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 3 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 5 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 7 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 11 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 13 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 17 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 19 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 23 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 29 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 37 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 53 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 59 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 67 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 73 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 79 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 83 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 89 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 97 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 101 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 103 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 105 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 107 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 109 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 111 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 113 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 115 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 117 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 119 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 121 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 123 == 0 {\n            result.push(c);\n        }\n\
    \        if result.len() % 125 == 0 {\n            result.push(c);\n        }\n\
    \        if result.\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpy570_9_j.rs:127:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n15  |     for c in message.chars()\
    \ {\n    |                              - this delimiter might not be properly\
    \ closed...\n...\n118 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n127 | }\n    |   ^\n\nerror: unexpected token: `}`\n   -->\
    \ /tmp/tmpy570_9_j.rs:118:1\n    |\n118 | }\n    | ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpy570_9_j.rs:118:1\n    |\n117 |         if result.\n   \
    \ |         -- this `if` expression has a condition, but no block\n118 | }\n \
    \   | ^ expected `{`\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `HashSet`\n  --> /tmp/tmpy570_9_j.rs:13:22\n   |\n13 |     let mut vowels =\
    \ HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpy570_9_j.rs:14:28\n   |\n14 |     let mut letter_pairs = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpy570_9_j.rs:19:28\n\
    \   |\n19 |             result.push((c + c.to_ascii_lowercase()).to_string());\n\
    \   |                          - ^ ---------------------- char\n   |         \
    \                 |\n   |                          char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy570_9_j.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 7 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"AEIOUaeiou\"\
    ;\n    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels_index = String\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvkjv6v37.rs:58:34\n   |\n\
    58 |     let mut vowels_index = String\n   |                                 \
    \ ^ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0423]: expected\
    \ value, found struct `String`\n   --> /tmp/tmpvkjv6v37.rs:58:28\n    |\n58  |\
    \       let mut vowels_index = String\n    |                              ^^^^^^\
    \ help: use struct literal syntax instead: `String { vec: val }`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvkjv6v37.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter.is_uppercase() {\n            encoded.push_str(&encode(letter).to_uppercase());\n\
    \        } else {\n            encoded.push_str(&encode(letter));\n        }\n\
    \        if let Some(vowel) = vowels.find(letter) {\n            encoded.push_str(&encode(vowel));\n\
    \            vowel_counter += 1;\n        } else {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        letter_counter += 1;\n  \
    \  }\n    if vowel_counter > 2 {\n        encoded.push_str(&encode(vowels.last().unwrap()));\n\
    \    }\n    if letter_counter > 2 {\n        encoded.push_str(&encode(message.chars().last().unwrap()));\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp58q2ch9y.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp58q2ch9y.rs:18:38\n   |\n18 |             encoded.push_str(&encode(letter).to_uppercase());\n\
    \   |                                      ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                      |\n   |  \
    \                                    expected struct `String`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp58q2ch9y.rs:20:38\n   |\n20 |  \
    \           encoded.push_str(&encode(letter));\n   |                         \
    \             ^^^^^^- help: try using a conversion method: `.to_string()`\n  \
    \ |                                      |\n   |                             \
    \         expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp58q2ch9y.rs:35:34\n   |\n35 |         encoded.push_str(&encode(message.chars().last().unwrap()));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \          |\n   |                                  expected struct `String`,\
    \ found `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut index = 0;\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n\
    \        }\n        if c.is_lowercase() {\n            letters.insert(c.to_uppercase());\n\
    \        }\n        if c.is_digit() {\n            letters.insert(c.to_digit());\n\
    \        }\n        if c.is_punctuation() {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_whitespace() {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii() {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(true) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(false) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(true) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(false) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(true) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(false) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(true) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(false) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(true) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(false) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(true) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(false) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(true) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(false) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(true) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(false) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(true) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(false) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.is_ascii(true) {\n            letters.insert(c.to_ascii_lowercase());\n\
    \        }\n        if c.\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0rio75kl.rs:102:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n16  |     for c in message.chars()\
    \ {\n    |                              - this delimiter might not be properly\
    \ closed...\n...\n93  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n102 | }\n    |   ^\n\nerror: unexpected token: `}`\n  -->\
    \ /tmp/tmp0rio75kl.rs:93:1\n   |\n93 | }\n   | ^\n\nerror: expected `{`, found\
    \ `}`\n  --> /tmp/tmp0rio75kl.rs:93:1\n   |\n92 |         if c.\n   |        \
    \ -- this `if` expression has a condition, but no block\n93 | }\n   | ^ expected\
    \ `{`\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp0rio75kl.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp0rio75kl.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0rio75kl.rs:23:14\n\
    \    |\n23  |         if c.is_digit() {\n    |              ^^^^^^^^- supplied\
    \ 0 arguments\n    |              |\n    |              expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0rio75kl.rs:24:30\n\
    \    |\n24  |             letters.insert(c.to_digit());\n    |               \
    \               ^^^^^^^^- supplied 0 arguments\n    |                        \
    \      |\n    |                              expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0599]: no method named `is_punctuation`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp0rio75kl.r"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = 0;\n    let mut letter_count = 1;\n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push_str(&format!(\"\
    {}\", letter_count));\n            letter_count = 1;\n        } else {\n     \
    \       if vowels.contains(&letter) {\n                result.push_str(&format!(\"\
    {}{}\", vowels_index, letter));\n                vowels_index += letter_count;\n\
    \                letter_count = 1;\n            } else {\n                result.push_str(&format!(\"\
    {}{}\", vowels_index, letter));\n                vowels.insert(letter);\n    \
    \            vowels_index += letter_count;\n                letter_count = 1;\n\
    \            }\n        }\n    }\n    result.push_str(&format!(\"{}\", vowels_index));\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp4gngsbko.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = 0;\n    let mut letter_count = 1;\n    let mut letter_count_index\
    \ = 0;\n    let mut letter_count_index2 = 0;\n    let mut letter_count_index3\
    \ = 0;\n    let mut letter_count_index4 = 0;\n    let mut letter_count_index5\
    \ = 0;\n    let mut letter_count_index6 = 0;\n    let mut letter_count_index7\
    \ = 0;\n    let mut letter_count_index8 = 0;\n    let mut letter_count_index9\
    \ = 0;\n    let mut letter_count_index10 = 0;\n    let mut letter_count_index11\
    \ = 0;\n    let mut letter_count_index12 = 0;\n    let mut letter_count_index13\
    \ = 0;\n    let mut letter_count_index14 = 0;\n    let mut letter_count_index15\
    \ = 0;\n    let mut letter_count_index16 = 0;\n    let mut letter_count_index17\
    \ = 0;\n    let mut letter_count_index18 = 0;\n    let mut letter_count_index19\
    \ = 0;\n    let mut letter_count_index20 = 0;\n    let mut letter_count_index21\
    \ = 0;\n    let mut letter_count_index22 = 0;\n    let mut letter_count_index23\
    \ = 0;\n    let mut letter_count_index24 = 0;\n    let mut letter_count_index25\
    \ = 0;\n    let mut letter_count_index26 = 0;\n    let mut letter_count_index27\
    \ = 0;\n    let mut letter_count_index28 = 0;\n    let mut letter_count_index29\
    \ = 0;\n    let mut letter_count_index30 = 0;\n    let mut letter_count_index31\
    \ = 0;\n    let mut letter_count_index32 = 0;\n    let mut letter_count_index33\
    \ = 0;\n    let mut letter_count_index34 = 0;\n    let mut letter_count_index35\
    \ = 0;\n    let mut letter_count_index36 = 0;\n    let mut letter_count_index37\
    \ = 0;\n    let mut letter_count_index38 = 0;\n    let mut letter_count_index39\
    \ = 0;\n    let mut letter_count_index40 = 0;\n    let mut letter_count_index41\
    \ = 0;\n    let mut letter_count_index42 = 0;\n    let mut letter_count_index43\
    \ = 0;\n    let mut letter_count_index44 = 0;\n    let mut letter_count_index45\
    \ = 0;\n    let mut letter_count_index46 = 0;\n    let mut letter_count_index47\
    \ = 0;\n    let mut letter_count_index48 = 0;\n    let mut letter_count_index49\
    \ = 0;\n    let mut letter_count_index50 = 0;\n    let mut letter_count_index51\
    \ = 0;\n    let mut letter_count_index52 = 0;\n    let mut letter_count_index53\
    \ = 0;\n    let mut letter_count_index\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp30qo4d0w.rs:69:31\n   |\n\
    69 |     let mut letter_count_index\n   |                               ^ help:\
    \ add `;` here\n70 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp30qo4d0w.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3\
    \ = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n \
    \   let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut\
    \ letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10\
    \ = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n\
    \    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let\
    \ mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17\
    \ = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n\
    \    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let\
    \ mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24\
    \ = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n\
    \    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let\
    \ mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31\
    \ = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n\
    \    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let\
    \ mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38\
    \ = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n\
    \    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let\
    \ mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45\
    \ = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n\
    \    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let\
    \ mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52\
    \ = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n\
    \    let mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let\
    \ mut letter_counter57 = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59\
    \ = 0;\n    let mut letter_counter\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpukevmo_y.rs:75:27\n   |\n\
    75 |     let mut letter_counter\n   |                           ^ help: add `;`\
    \ here\n76 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpukevmo_y.rs:13:22\n   |\n13 |  \
    \   let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpukevmo_y.rs:14:24\n   |\n14 |     let mut alphabet = HashSet::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpukevmo_y.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut index = 0;\n    let mut index2 = 0;\n    let mut index3 = 0;\n  \
    \  let mut index4 = 0;\n    let mut index5 = 0;\n    let mut index6 = 0;\n   \
    \ let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9 = 0;\n    let\
    \ mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12 = 0;\n    let\
    \ mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15 = 0;\n    let\
    \ mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18 = 0;\n    let\
    \ mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21 = 0;\n    let\
    \ mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24 = 0;\n    let\
    \ mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27 = 0;\n    let\
    \ mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30 = 0;\n    let\
    \ mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33 = 0;\n    let\
    \ mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36 = 0;\n    let\
    \ mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39 = 0;\n    let\
    \ mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42 = 0;\n    let\
    \ mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45 = 0;\n    let\
    \ mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48 = 0;\n    let\
    \ mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51 = 0;\n    let\
    \ mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54 = 0;\n    let\
    \ mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57 = 0;\n    let\
    \ mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60 = 0;\n    let\
    \ mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63 = 0;\n    let\
    \ mut index64 = 0;\n    let mut index65\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpucety0h_.rs:79:20\n   |\n\
    79 |     let mut index65\n   |                    ^ help: add `;` here\n80 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpucety0h_.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mut \n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3h3w018h.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter.is_uppercase() {\n            encoded.push_str(&encode(&letter));\n\
    \        } else {\n            if vowels.contains(&letter) {\n               \
    \ encoded.push_str(&encode(&vowels[letter_counter]));\n                vowels_counter\
    \ += 1;\n            } else {\n                encoded.push_str(&encode(&letter));\n\
    \                vowels.insert(letter);\n                vowels_counter += 1;\n\
    \            }\n        }\n        letter_counter += 1;\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp62pkylqw.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp62pkylqw.rs:18:38\n   |\n18 |             encoded.push_str(&encode(&letter));\n\
    \   |                                      ^^^^^^^ expected struct `String`, found\
    \ `&char`\n   |\nhelp: try using a conversion method\n   |\n18 |             encoded.push_str(&encode((&letter).to_string()));\n\
    \   |                                      +       +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp62pkylqw.rs:24:42\n   |\n24 |              \
    \   encoded.push_str(&encode(&letter));\n   |                                \
    \          ^^^^^^^ expected struct `String`, found `&char`\n   |\nhelp: try using\
    \ a conversion method\n   |\n24 |                 encoded.push_str(&encode((&letter).to_string()));\n\
    \   |                                          +       +++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpjvcvbr3q.rs:55:1\n\
    \   |\n55 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpyxwpmjpr.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyxwpmjpr.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut index = 0;\n    for ch in message.chars() {\n        if let Some(vowel)\
    \ = vowels.find(|c| c == ch) {\n            let mut new_ch = ch;\n           \
    \ new_ch.swap(vowel, index + 1);\n            result.push_str(&new_ch);\n    \
    \        index = index + 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp8sdaebgj.rs:18:20\n   |\n18 |             new_ch.swap(vowel,\
    \ index + 1);\n   |                    ^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8sdaebgj.rs:19:29\n   |\n19 |             result.push_str(&new_ch);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut\
    \ o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let\
    \ mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n   \
    \ let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut e = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n\
    \    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n\
    \    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut e = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n\
    \    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n\
    \    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut e = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n\
    \    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n\
    \    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0_pquqdi.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_counter = 0;\n    let mut letter_counter_index = 0;\n    let mut\
    \ letter_counter_index2 = 0;\n    let mut letter_counter_index3 = 0;\n    let\
    \ mut letter_counter_index4 = 0;\n    let mut letter_counter_index5 = 0;\n   \
    \ let mut letter_counter_index6 = 0;\n    let mut letter_counter_index7 = 0;\n\
    \    let mut letter_counter_index8 = 0;\n    let mut letter_counter_index9 = 0;\n\
    \    let mut letter_counter_index10 = 0;\n    let mut letter_counter_index11 =\
    \ 0;\n    let mut letter_counter_index12 = 0;\n    let mut letter_counter_index13\
    \ = 0;\n    let mut letter_counter_index14 = 0;\n    let mut letter_counter_index15\
    \ = 0;\n    let mut letter_counter_index16 = 0;\n    let mut letter_counter_index17\
    \ = 0;\n    let mut letter_counter_index18 = 0;\n    let mut letter_counter_index19\
    \ = 0;\n    let mut letter_counter_index20 = 0;\n    let mut letter_counter_index21\
    \ = 0;\n    let mut letter_counter_index22 = 0;\n    let mut letter_counter_index23\
    \ = 0;\n    let mut letter_counter_index24 = 0;\n    let mut letter_counter_index25\
    \ = 0;\n    let mut letter_counter_index26 = 0;\n    let mut letter_counter_index27\
    \ = 0;\n    let mut letter_counter_index28 = 0;\n    let mut letter_counter_index29\
    \ = 0;\n    let mut letter_counter_index30 = 0;\n    let mut letter_counter_index31\
    \ = 0;\n    let mut letter_counter_index32 = 0;\n    let mut letter_counter_index33\
    \ = 0;\n    let mut letter_counter_index34 = 0;\n    let mut letter_counter_index35\
    \ = 0;\n    let mut letter_counter_index36 = 0;\n    let mut letter_counter_index37\
    \ = 0;\n    let mut letter_counter_index38 = 0;\n    let mut letter_counter_index39\
    \ = 0;\n    let mut letter_counter_index40 = 0;\n    let mut letter_counter_index41\
    \ = 0;\n    let mut letter_counter_index42 = 0;\n    let mut letter_counter_index43\
    \ = 0;\n    let mut letter_counter_index44 = 0;\n    let mut letter_counter_index45\
    \ = 0;\n    let mut letter_counter_index46 = 0;\n    let mut letter_counter_index47\
    \ = 0;\n    let mut letter_counter_index48 = 0;\n    let mut letter_counter_index49\
    \ = 0;\n    let mut letter_counter_index50 = 0;\n    let mut letter_counter_index51\
    \ = 0;\n    let mut letter_counter_index52 = 0;\n    let mut letter_\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9rsnt_6o.rs:68:20\n   |\n\
    68 |     let mut letter_\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rsnt_6o.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letter_pairs = vec![\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs2\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut letter_pairs = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\",\
    \ \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs2 = vec![\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut letter_pairs2 = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs = vec![\"b\", \"c\",\
    \ \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs2\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut letter_pairs = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\",\
    \ \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs2 = vec![\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprkvkgdwu.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_idx = 0;\n    let mut\
    \ letters_idx = 0;\n    let mut vowels_idx2 = 0;\n    let mut letters_idx2 = 0;\n\
    \    let mut vowels_idx3 = 0;\n    let mut letters_idx3 = 0;\n    let mut vowels_idx4\
    \ = 0;\n    let mut letters_idx4 = 0;\n    let mut vowels_idx5 = 0;\n    let mut\
    \ letters_idx5 = 0;\n    let mut vowels_idx6 = 0;\n    let mut letters_idx6 =\
    \ 0;\n    let mut vowels_idx7 = 0;\n    let mut letters_idx7 = 0;\n    let mut\
    \ vowels_idx8 = 0;\n    let mut letters_idx8 = 0;\n    let mut vowels_idx9 = 0;\n\
    \    let mut letters_idx9 = 0;\n    let mut vowels_idx10 = 0;\n    let mut letters_idx10\
    \ = 0;\n    let mut vowels_idx11 = 0;\n    let mut letters_idx11 = 0;\n    let\
    \ mut vowels_idx12 = 0;\n    let mut letters_idx12 = 0;\n    let mut vowels_idx13\
    \ = 0;\n    let mut letters_idx13 = 0;\n    let mut vowels_idx14 = 0;\n    let\
    \ mut letters_idx14 = 0;\n    let mut vowels_idx15 = 0;\n    let mut letters_idx15\
    \ = 0;\n    let mut vowels_idx16 = 0;\n    let mut letters_idx16 = 0;\n    let\
    \ mut vowels_idx17 = 0;\n    let mut letters_idx17 = 0;\n    let mut vowels_idx18\
    \ = 0;\n    let mut letters_idx18 = 0;\n    let mut vowels_idx19 = 0;\n    let\
    \ mut letters_idx19 = 0;\n    let mut vowels_idx20 = 0;\n    let mut letters_idx20\
    \ = 0;\n    let mut vowels_idx21 = 0;\n    let mut letters_idx21 = 0;\n    let\
    \ mut vowels_idx22 = 0;\n    let mut letters_idx22 = 0;\n    let mut vowels_idx23\
    \ = 0;\n    let mut letters_idx23 = 0;\n    let mut vowels_idx24 = 0;\n    let\
    \ mut letters_idx24 = 0;\n    let mut vowels_idx25 = 0;\n    let mut letters_idx25\
    \ = 0;\n    let mut vowels_idx26 = 0;\n    let mut letters_idx26 = 0;\n    let\
    \ mut vowels_idx27 = 0;\n    let mut letters_idx27 = 0;\n    let mut vowels_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpso1yk1ag.rs:69:20\n   |\n\
    69 |     let mut vowels_\n   |                    ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpso1yk1ag.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpso1yk1ag.rs:14:23\n   |\n14 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpso1yk1ag.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n\
    \    let mut vowels_index_3 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n    let mut vowels_index_4\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26];\n    let mut vowels_index_5 = vec![0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\
    \ 25, 26];\n    let mut vowels_index_6 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\
    \ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n    let mut\
    \ vowels_index_7 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\
    \ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n    let mut vowels_index_8 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26];\n    let mut vowels_index_9 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n\
    \    let mut vowels_index_10 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n    let mut vowels_index_11\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26];\n    let mut vowels_index_12 = vec![0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\
    \ 25, 26];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\
    \ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n    let mut\
    \ vowels_index_14 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\
    \ 16, 17, \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpngn_bjit.rs:28:1\n   |\n28 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpngn_bjit.rs:27:35\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n27 |     let mut vowels_index_14 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, \n   |                            \
    \       ^ unclosed delimiter\n28 | }\n   | ^ mismatched closing delimiter\n\n\
    error: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_counts = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter = String::new();\n    let mut\
    \ letter_index = String::new();\n    let mut letter_counts_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n\
    \    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n\
    \    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n\
    \    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n\
    \    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n\
    \    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n\
    \    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6];\n    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n\
    \    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj7npg80u.rs:47:20\n   |\n\
    47 |     let mut letter_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj7npg80u.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_2places = HashSet::new();\n    let mut vowels_3places = HashSet::new();\n\
    \    let mut vowels_4places = HashSet::new();\n    let mut vowels_5places = HashSet::new();\n\
    \    let mut vowels_6places = HashSet::new();\n    let mut vowels_7places = HashSet::new();\n\
    \    let mut vowels_8places = HashSet::new();\n    let mut vowels_9places = HashSet::new();\n\
    \    let mut vowels_10places = HashSet::new();\n    let mut vowels_11places =\
    \ HashSet::new();\n    let mut vowels_12places = HashSet::new();\n    let mut\
    \ vowels_13places = HashSet::new();\n    let mut vowels_14places = HashSet::new();\n\
    \    let mut vowels_15places = HashSet::new();\n    let mut vowels_16places =\
    \ HashSet::new();\n    let mut vowels_17places = HashSet::new();\n    let mut\
    \ vowels_18places = HashSet::new();\n    let mut vowels_19places = HashSet::new();\n\
    \    let mut vowels_20places = HashSet::new();\n    let mut vowels_21places =\
    \ HashSet::new();\n    let mut vowels_22places = HashSet::new();\n    let mut\
    \ vowels_23places = HashSet::new();\n    let mut vowels_24places = HashSet::new();\n\
    \    let mut vowels_25places = HashSet::new();\n    let mut vowels_26places =\
    \ HashSet::new();\n    let mut vowels_27places = HashSet::new();\n    let mut\
    \ vowels_28places = HashSet::new();\n    let mut vowels_29places = HashSet::new();\n\
    \    let mut vowels_30places = HashSet::new();\n    let mut vowels_31places =\
    \ HashSet::new();\n    let mut vowels_32places = HashSet::new();\n    let mut\
    \ vowels_33places = HashSet::new();\n    let mut vowels_34places = HashSet::new();\n\
    \    let mut vowels_35places = HashSet::new();\n    let mut vowels_36places =\
    \ HashSet::new();\n    let mu\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp17ou9sye.rs:49:11\n   |\n\
    49 |     let mu\n   |           ^ help: add `;` here\n50 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmp17ou9sye.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp17ou9sye.rs:14:30\n\
    \   |\n14 |     let mut vowels_2places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp17ou9sye.rs:15:30\n\
    \   |\n15 |     let mut vowels_3places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp17ou9sye.rs:16:30\n\
    \   |\n16 |     let mut vowels_4places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp17ou9sye.rs:17:30\n\
    \   |\n17 |     let mut vowels_5places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp17ou9sye.rs:18:30\n\
    \   |\n18 |     let mut vowels_6places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letters = \"bcdfghjklmnpqrstvwxyz\".to_string();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    for c in message.chars() {\n    \
    \    if c.is_uppercase() {\n            result.push_str(&vowels[i as usize]);\n\
    \            i += 1;\n        } else {\n            result.push_str(&letters[i\
    \ as usize]);\n            i += 1;\n        }\n        if i == 2 {\n         \
    \   i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbvlm76vk.rs:19:30\n\
    \   |\n19 |             result.push_str(&vowels[i as usize]);\n   |          \
    \                    ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbvlm76vk.rs:22:30\n\
    \   |\n22 |             result.push_str(&letters[i as usize]);\n   |         \
    \                     ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut letters = String::new();\n    let mut index = 0;\n    \n    for letter\
    \ in message.chars() {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            letters.push_str(&vowels[index\
    \ % vowels.len()]);\n            vowels.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \            index +=1;\n        } else {\n            letters.push_str(&letters[index\
    \ % letters.len()]);\n            index +=1;\n        }\n    }\n    encoded.push_str(&letters);\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnkz7klf_.rs:19:31\n\
    \   |\n19 |             letters.push_str(&vowels[index % vowels.len()]);\n   |\
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnkz7klf_.rs:20:30\n   |\n20 |             vowels.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpnkz7klf_.rs:23:31\n   |\n23 |            \
    \ letters.push_str(&letters[index % letters.len()]);\n   |                   \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut index = 0;\n    for c in message.chars()\
    \ {\n        if let Some(vowel) = vowels.entry(c.to_ascii_lowercase()).or_insert(c)\
    \ {\n            result.push_str(&vowel);\n            letters.insert(index +\
    \ 1);\n        }\n        index += 1;\n    }\n    for c in letters.iter() {\n\
    \        result.push_str(&c.to_string());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpkocf47le.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpkocf47le.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n  --> /tmp/tmpkocf47le.rs:17:21\n\
    \   |\n17 |         if let Some(vowel) = vowels.entry(c.to_ascii_lowercase()).or_insert(c)\
    \ {\n   |                     ^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmpkocf47le.rs:17:16\n\
    \    |\n17  |         if let Some(vowel) = vowels.entry(c.to_ascii_lowercase()).or_insert(c)\
    \ {\n    |                ^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by `Some`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n\
    \    let mut letter_counter = 0;\n    for letter in message {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == vowels[vowel_counter] {\n                vowel_counter = vowel_counter\
    \ + 1;\n            } else {\n                vowel_counter = 0;\n           \
    \ }\n            if letter == letters[letter_counter] {\n                letter_counter\
    \ = letter_counter + 1;\n            } else {\n                letter_counter\
    \ = 0;\n            }\n            result.push_str(&letters[letter_counter]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpu1qf7fhj.rs:17:19\n\
    \    |\n17  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu1qf7fhj.rs:31:29\n\
    \   |\n31 |             result.push_str(&letters[letter_counter]);\n   |     \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp__4vra74.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let mut\
    \ index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut index6\
    \ = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9 =\
    \ 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mu\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq81ramjg.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq81ramjg.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_2places = HashSet::new();\n    let mut letters = HashSet::new();\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            letters.insert(c);\n\
    \        } else {\n            vowels.insert(c);\n        }\n    }\n    for c\
    \ in message.chars() {\n        if c.is_uppercase() {\n            letters.insert(c);\n\
    \        } else {\n            vowels_2places.insert(c);\n        }\n    }\n \
    \   for c in letters {\n        result.push(c);\n    }\n    for c in vowels {\n\
    \        result.push(c);\n    }\n    for c in vowels_2places {\n        result.push(c);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpfny_vtlm.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpfny_vtlm.rs:14:30\n\
    \   |\n14 |     let mut vowels_2places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpfny_vtlm.rs:15:23\n\
    \   |\n15 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut count = 1;\n    let mut\
    \ letter = String::new();\n    let mut vowel = String::new();\n    let mut vowel_pos\
    \ = 0;\n    let mut vowel_pos_index = 0;\n    let mut vowel_pos_index2 = 0;\n\
    \    let mut vowel_pos_index3 = 0;\n    let mut vowel_pos_index4 = 0;\n    let\
    \ mut vowel_pos_index5 = 0;\n    let mut vowel_pos_index6 = 0;\n    let mut vowel_pos_index7\
    \ = 0;\n    let mut vowel_pos_index8 = 0;\n    let mut vowel_pos_index9 = 0;\n\
    \    let mut vowel_pos_index10 = 0;\n    let mut vowel_pos_index11 = 0;\n    let\
    \ mut vowel_pos_index12 = 0;\n    let mut vowel_pos_index13 = 0;\n    let mut\
    \ vowel_pos_index14 = 0;\n    let mut vowel_pos_index15 = 0;\n    let mut vowel_pos_index16\
    \ = 0;\n    let mut vowel_pos_index17 = 0;\n    let mut vowel_pos_index18 = 0;\n\
    \    let mut vowel_pos_index19 = 0;\n    let mut vowel_pos_index20 = 0;\n    let\
    \ mut vowel_pos_index21 = 0;\n    let mut vowel_pos_index22 = 0;\n    let mut\
    \ vowel_pos_index23 = 0;\n    let mut vowel_pos_index24 = 0;\n    let mut vowel_pos_index25\
    \ = 0;\n    let mut vowel_pos_index26 = 0;\n    let mut vowel_pos_index27 = 0;\n\
    \    let mut vowel_pos_index28 = 0;\n    let mut vowel_pos_index29 = 0;\n    let\
    \ mut vowel_pos_index30 = 0;\n    let mut vowel_pos_index31 = 0;\n    let mut\
    \ vowel_pos_index32 = 0;\n    let mut vowel_pos_index33 = 0;\n    let mut \n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpyj1hgd6v.rs:54:1\n\
    \   |\n54 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n\
    \    let mut letter_counter = 0;\n    for c in message.chars() {\n        if letters[letter_counter]\
    \ == c {\n            letter_counter++;\n        } else {\n            letter_counter\
    \ = 0;\n        }\n        if vowels[vowel_counter] == c {\n            vowel_counter++;\n\
    \        } else {\n            vowel_counter = 0;\n        }\n        if letter_counter\
    \ == 2 {\n            result.push(c);\n            result.push(c);\n         \
    \   result.push(c);\n            letter_counter = 0;\n            vowel_counter\
    \ = 0;\n        }\n        if vowel_counter == 2 {\n            result.push(c);\n\
    \            result.push(c);\n            result.push(c);\n            letter_counter\
    \ = 0;\n            vowel_counter = 0;\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpaackjlwu.rs:19:28\n\
    \   |\n19 |             letter_counter++;\n   |                            ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpaackjlwu.rs:24:27\n\
    \   |\n24 |             vowel_counter++;\n   |                           ^ expected\
    \ expression\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplaby6y0e.rs:75:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n16 |     for letter in message.chars()\
    \ {\n   |                                   - this delimiter might not be properly\
    \ closed...\n...\n66 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n75 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmplaby6y0e.rs:66:1\n\
    \   |\n65 |         if letter\n   |         -- this `if` expression has a condition,\
    \ but no block\n66 | }\n   | ^ expected `{`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmplaby6y0e.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplaby6y0e.rs:11:31\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |    ------                     ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if vowels.contains(&letter) {\n            result.push((&vowels[vowel_counter]).to_string());\n\
    \            vowel_counter += 2;\n        } else {\n            result.push((&letter).to_string());\n\
    \            letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpp166rzuq.rs:17:28\n\
    \   |\n17 |         if vowels.contains(&letter) {\n   |                      \
    \      ^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n   |\n   = help:\
    \ the trait `Fn<(char,)>` is not implemented for `char`\n   = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n   = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpp166rzuq.rs:18:27\n\
    \   |\n18 |             result.push((&vowels[vowel_counter]).to_string());\n \
    \  |                           ^^^^^^^^^^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = note: required because of the requirements on the impl of `Index<{integer}>`\
    \ for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp166rzuq.rs:21:25\n\
    \   |\n21 |             result.push((&letter).to_string());\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp3z3kepw3.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmp3z3kepw3.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut currentLetter = String::new();\n    let mut currentVowel = String::new();\n\
    \    for letter in message {\n        if letter == letters[index] {\n        \
    \    currentLetter = letter;\n            currentVowel = vowels[index];\n    \
    \        index += 1;\n        } else {\n            result.push_str(currentLetter);\n\
    \            result.push_str(currentVowel);\n            currentLetter = letter;\n\
    \            currentVowel = vowels[index];\n            index += 1;\n        }\n\
    \    }\n    result.push_str(currentLetter);\n    result.push_str(currentVowel);\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpdj49ffap.rs:18:19\n\
    \    |\n18  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdj49ffap.rs:21:28\n\
    \   |\n21 |             currentVowel = vowels[index];\n   |                  \
    \          ^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdj49ffap.rs:24:29\n\
    \   |\n24 |             result.push_str(currentLetter);\n   |                \
    \             ^^^^^^^^^^^^^\n   |                             |\n   |        \
    \                     expected `&str`, found struct `String`\n   |           \
    \                  help: consider borrowing here: `&currentLetter`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdj49ffap.rs:25:29\n   |\n25 |             result.push_str(currentVowel);\n\
    \   |                             ^^^^^^^^^^^^\n   |                         \
    \    |\n   |                             expected `&str`, found struct `String`\n\
    \   |                             help: consider borrowing here: `&currentVowel`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdj49ffap.rs:27:28\n   |\n27 |\
    \             currentVowel = vowels[index];\n   |                            ^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdj49ffap.rs:31:21\n\
    \   |\n31 |     result.push_str(currentLetter);\n   |                     ^^^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&str`, found struct\
    \ `String`\n   |                     help: consider borrowing here: `&c"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letter_counts = vec![];\n    for\
    \ letter in message.chars() {\n        if let Some(count) = letter_counts.iter().position(|x|\
    \ *x == letter) {\n            letter_counts[count] += 1;\n        } else {\n\
    \            letter_counts.push((letter, 1));\n        }\n    }\n    for count\
    \ in 0..letter_counts.len() {\n        let (letter, count) = (letter_counts[count],\
    \ count);\n        if count > 1 {\n            let mut new_letter = letter;\n\
    \            for _ in 0..count - 1 {\n                new_letter = vowels[vowels.iter().position(|x|\
    \ *x == new_letter).unwrap()]\n            }\n            result += new_letter;\n\
    \        } else {\n            result += letter;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `(char, {integer})` with `char`\n  --> /tmp/tmpm05opj18.rs:16:67\n\
    \   |\n16 |         if let Some(count) = letter_counts.iter().position(|x| *x\
    \ == letter) {\n   |                                                         \
    \          ^^ no implementation for `(char, {integer}) == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `(char, {integer})`\n\nerror[E0277]:\
    \ cannot add-assign `{integer}` to `(char, {integer})`\n  --> /tmp/tmpm05opj18.rs:17:34\n\
    \   |\n17 |             letter_counts[count] += 1;\n   |                     \
    \             ^^ no implementation for `(char, {integer}) += {integer}`\n   |\n\
    \   = help: the trait `AddAssign<{integer}>` is not implemented for `(char, {integer})`\n\
    \nerror[E0277]: can't compare `&str` with `(char, {integer})`\n  --> /tmp/tmpm05opj18.rs:27:67\n\
    \   |\n27 |                 new_letter = vowels[vowels.iter().position(|x| *x\
    \ == new_letter).unwrap()]\n   |                                             \
    \                      ^^ no implementation for `&str == (char, {integer})`\n\
    \   |\n   = help: the trait `PartialEq<(char, {integer})>` is not implemented\
    \ for `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm05opj18.rs:27:30\n\
    \   |\n27 |                 new_letter = vowels[vowels.iter().position(|x| *x\
    \ == new_letter).unwrap()]\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `&str`\n   |\n   = note:  expected tuple `(char, {integer})`\n\
    \           found reference `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm05opj18.rs:29:23\n\
    \   |\n29 |             result += new_letter;\n   |                       ^^^^^^^^^^\
    \ expected `&str`, found tuple\n   |\n   = note: expected reference `&str`\n \
    \                 found tuple `(char, {integer})`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm05opj18.rs:31:23\n   |\n31 |             result += letter;\n\
    \   |                       ^^^^^^ expected `&str`, found tuple\n   |\n   = note:\
    \ expected reference `&str`\n                  found tuple `(char, {integer})`\n\
    \nerror: abor"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let mut\
    \ index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut index6\
    \ = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9 =\
    \ 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mu\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq81ramjg.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq81ramjg.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_map\
    \ = HashMap::new();\n    let mut letter_map = HashMap::new();\n    for letter\
    \ in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n            vowel_map.insert(vowel, letter);\n        }\n  \
    \      if let Some(letter) = letters.iter().position(|&x| x == letter) {\n   \
    \         letter_map.insert(letter, letter);\n        }\n    }\n    for vowel\
    \ in vowels.iter() {\n        result.push_str(&vowel_map.get(&vowel).unwrap());\n\
    \    }\n    for letter in letters.iter() {\n        result.push_str(&letter_map.get(&letter).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpkd4hbloz.rs:15:25\n   |\n15 |     let mut vowel_map = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpkd4hbloz.rs:16:26\n\
    \   |\n16 |     let mut letter_map = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpkd4hbloz.rs:18:60\n   |\n18 |         if let\
    \ Some(vowel) = vowels.iter().position(|&x| x == letter) {\n   |             \
    \                                               ^^ no implementation for `&str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&str`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpkd4hbloz.rs:21:62\n\
    \   |\n21 |         if let Some(letter) = letters.iter().position(|&x| x == letter)\
    \ {\n   |                                                              ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut i = 0;\n    while\
    \ i < message.len() {\n        if message[i] == ' ' {\n            result.push_str(&message[i..i\
    \ + 1]);\n            i += 1;\n        } else {\n            let mut j = i;\n\
    \            while j < message.len() && message[j] == ' ' {\n                j\
    \ += 1;\n            }\n            let mut k = i;\n            while k < j &&\
    \ message[k] == ' ' {\n                k += 1;\n            }\n            let\
    \ mut l = i;\n            while l < j && message[l] == ' ' {\n               \
    \ l += 1;\n            }\n            let mut m = i;\n            while m < j\
    \ && message[m] == ' ' {\n                m += 1;\n            }\n           \
    \ let mut n = i;\n            while n < j && message[n] == ' ' {\n           \
    \     n += 1;\n            }\n            let mut o = i;\n            while o\
    \ < j && message[o] == ' ' {\n                o += 1;\n            }\n       \
    \     let mut p = i;\n            while p < j && message[p] == ' ' {\n       \
    \         p += 1;\n            }\n            let mut q = i;\n            while\
    \ q < j && message[q] == ' ' {\n                q += 1;\n            }\n     \
    \       let mut r = i;\n            while r < j && message[r] == ' ' {\n     \
    \           r += 1;\n            }\n            let mut s = i;\n            while\
    \ s < j && message[s] == ' ' {\n                s += 1;\n            }\n     \
    \       let mut t = i;\n            while t < j && message[t] == ' ' {\n     \
    \           t += 1;\n            }\n            let mut u = i;\n            while\
    \ u < j && message[u] == ' ' {\n                u += 1;\n            }\n     \
    \       let mut v = i;\n            while v < j && message[v] == ' ' {\n     \
    \           v += 1;\n            }\n            let mut w = i;\n            while\
    \ w < j && message[w] == ' ' {\n                w += 1;\n            }\n     \
    \       let mut x = i;\n            while x < j && message[x] == ' ' {\n     \
    \           x += 1;\n            }\n            let mut y = i;\n            while\
    \ y < j && message[y] == ' ' {\n                y += 1;\n            }\n     \
    \       let mut z = \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp228rw2pz.rs:96:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n17 |     while i < message.len()\
    \ {\n   |                             - unclosed delimiter\n...\n21 |        \
    \ } else {\n   |                - this delimiter might not be properly closed...\n\
    ...\n87 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    96 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmp228rw2pz.rs:87:1\n\
    \   |\n87 | }\n   | ^ expected expression\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp228rw2pz.rs:18:12\n   |\n18 |         if\
    \ message[i] == ' ' {\n   |            ^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp228rw2pz.rs:23:40\n\
    \   |\n23 |             while j < message.len() && message[j] == ' ' {\n   | \
    \                                       ^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp228rw2pz.rs:27:28\n   |\n27 |             while k < j && message[k]\
    \ == ' ' {\n   |                            ^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp228rw2pz.rs:31:28\n   |\n31 |             while l < j && message[l]\
    \ == ' ' {\n   |                            ^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp228rw2pz.rs:35:28\n   |\n35 |             while m < j && message[m]\
    \ == ' ' {\n   |                            ^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the tra"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_count = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_count = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, \n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpxs_y2xhh.rs:26:1\n   |\n26 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpxs_y2xhh.rs:25:38\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n25 |     let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, \n   |         \
    \                             ^ unclosed delimiter\n26 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            result.push(c);\n\
    \        } else {\n            result.push((&vowels[c]).to_string());\n      \
    \  }\n    }\n    for c in result.chars() {\n        if c.is_uppercase() {\n  \
    \          vowels.insert(c.to_lowercase());\n        } else {\n            vowels.insert(c.to_uppercase());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp4znshz2f.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            result.push((&vowels[vowel_counter]).to_string());\n        \
    \    vowel_counter += 2;\n        } else {\n            result.push((&letter).to_string());\n\
    \            letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpisuxkrz0.rs:17:28\n   |\n\
    17 |         if vowels.contains(&letter) {\n   |                            ^^^^^^^\
    \ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpisuxkrz0.rs:18:25\n   |\n18 |             result.push((&vowels[vowel_counter]).to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpisuxkrz0.rs:21:25\n\
    \   |\n21 |             result.push((&letter).to_string());\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let\
    \ mut count = 1;\n    let mut prev = 0;\n    let mut next = -1;\n    let mut last\
    \ = 0;\n    let mut lastLetter = 0;\n    let mut lastVowel = 0;\n    let mut lastLetterVowel\
    \ = 0;\n    let mut lastLetterVowelCount = 0;\n    let mut lastVowelCount = 0;\n\
    \    let mut lastVowelCountLetter = 0;\n    let mut lastVowelCountVowel = 0;\n\
    \    let mut lastVowelCountVowelLetter = 0;\n    let mut lastVowelCountVowelVowel\
    \ = 0;\n    let mut lastVowelCountVowelVowelLetter = 0;\n    let mut lastVowelCountVowelVowelVowel\
    \ = 0;\n    let mut lastVowelCountVowelVowelVowelLetter = 0;\n    let mut lastVowelCountVowelVowelVowelLetter\
    \ = 0;\n    let mut lastVowelCountVowelVowelVowelVowel = 0;\n    let mut lastVowelCountVowelVowelVowelVowelLetter\
    \ = 0;\n    let mut lastVowelCountVowelVowelVowelVowelLetter = 0;\n    let mut\
    \ lastVowelCountVowelVowelVowelVowelVowel = 0;\n    let mut lastVowelCountVowelVowelVowelVowelLetter\
    \ = 0;\n    let mut lastVowelCountVowelVowelVowelVowelVowel = 0;\n    let mut\
    \ lastVowelCountVowelVowelVowelVowelVowelLetter = 0;\n    let mut lastVowelCountVowelVowelVowelVowelVowelVowel\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprw_6qb7z.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_index\
    \ = vec![0];\n    let mut letters_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut letters_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut letters_index = vec![0];\n    let mut vowels_count = vec![0];\n \
    \   let mut letters_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut letters_index = vec![0];\n    let mut vowels_count = vec![0];\n   \
    \ let mut letters_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut letters_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ letters_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut letters_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut letters_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut letters_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut letters_count = vec![0];\n \
    \   let mut vowels_index = vec![0];\n    let mut letters_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut letters_count = vec![0];\n   \
    \ let mut vowels_index = vec![0];\n    let mut letters_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut letters_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut letters_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut letters_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut letters_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut letters_count = vec![0];\n    let mut vowels_index = vec![0];\n \
    \   let mut letters_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut letters_count = vec![0];\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_i38srgz.rs:59:11\n   |\n\
    59 |     let mu\n   |           ^ help: add `;` here\n60 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_i38srgz.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter_index = 0;\n    let mut letter_counter_index2\
    \ = 0;\n    let mut letter_counter_index3 = 0;\n    let mut letter_counter_index4\
    \ = 0;\n    let mut letter_counter_index5 = 0;\n    let mut letter_counter_index6\
    \ = 0;\n    let mut letter_counter_index7 = 0;\n    let mut letter_counter_index8\
    \ = 0;\n    let mut letter_counter_index9 = 0;\n    let mut letter_counter_index10\
    \ = 0;\n    let mut letter_counter_index11 = 0;\n    let mut letter_counter_index12\
    \ = 0;\n    let mut letter_counter_index13 = 0;\n    let mut letter_counter_index14\
    \ = 0;\n    let mut letter_counter_index15 = 0;\n    let mut letter_counter_index16\
    \ = 0;\n    let mut letter_counter_index17 = 0;\n    let mut letter_counter_index18\
    \ = 0;\n    let mut letter_counter_index19 = 0;\n    let mut letter_counter_index20\
    \ = 0;\n    let mut letter_counter_index21 = 0;\n    let mut letter_counter_index22\
    \ = 0;\n    let mut letter_counter_index23 = 0;\n    let mut letter_counter_index24\
    \ = 0;\n    let mut letter_counter_index25 = 0;\n    let mut letter_counter_index26\
    \ = 0;\n    let mut letter_counter_index27 = 0;\n    let mut letter_counter_index28\
    \ = 0;\n    let mut letter_counter_index29 = 0;\n    let mut letter_counter_index30\
    \ = 0;\n    let mut letter_counter_index31 = 0;\n    let mut letter_counter_index32\
    \ = 0;\n    let mut letter_counter_index33 = 0;\n    let mut letter_counter_index34\
    \ = 0;\n    let mut letter_counter_index35 = 0;\n    let mut letter_counter_index36\
    \ = 0;\n    let mut letter_counter_index37 = 0;\n    let mut letter_counter_index38\
    \ = 0;\n    let mut letter_counter_index39 = 0;\n    let mut letter_counter_index40\
    \ = 0;\n    let mut letter_counter_index41 = 0;\n    let mut letter_counter_index42\
    \ = 0;\n    let mut letter_counter_index43 = 0;\n    let mut letter_counter_index44\
    \ = 0;\n    let mut letter_counter_index45 = 0;\n    let mut letter_counter_index46\
    \ = 0;\n    let mut letter_counter_index47 = 0;\n    let mut letter_counter_index48\
    \ = 0;\n    let mut letter_counter_index49 = 0;\n    let mut letter_counter_index50\
    \ = 0;\n    let mut letter_counter_index51 = 0;\n    let mut letter_counter_index52\
    \ = 0;\n    let mut letter_counter_index53 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3pcp0kwz.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut current_letter = String::new();\n    let mut current_vowel = String::new();\n\
    \    for letter in message {\n        if letter == ' ' {\n            result.push_str(current_letter);\n\
    \            current_letter = String::new();\n        } else {\n            current_letter.push_str(letters[letter]);\n\
    \        }\n        if index == vowels.len() {\n            result.push_str(current_vowel);\n\
    \            current_vowel = String::new();\n        } else {\n            current_vowel.push_str(vowels[index]);\n\
    \        }\n        index += 1;\n    }\n    result.push_str(current_vowel);\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpcd383tpo.rs:18:19\n\
    \    |\n18  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcd383tpo.rs:20:29\n\
    \   |\n20 |             result.push_str(current_letter);\n   |               \
    \              ^^^^^^^^^^^^^^\n   |                             |\n   |      \
    \                       expected `&str`, found struct `String`\n   |         \
    \                    help: consider borrowing here: `&current_letter`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcd383tpo.rs:26:29\n   |\n26 |             result.push_str(current_vowel);\n\
    \   |                             ^^^^^^^^^^^^^\n   |                        \
    \     |\n   |                             expected `&str`, found struct `String`\n\
    \   |                             help: consider borrowing here: `&current_vowel`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcd383tpo.rs:33:21\n   |\n33 |\
    \     result.push_str(current_vowel);\n   |                     ^^^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&str`, found struct\
    \ `String`\n   |                     help: consider borrowing here: `&current_vowel`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut index = 0;\n    for c in message.chars() {\n        if c.is_uppercase()\
    \ {\n            encoded.push_str(&c.to_lowercase());\n        } else {\n    \
    \        encoded.push_str(&c.to_uppercase());\n        }\n        if !vowels.contains(&c)\
    \ {\n            vowels.insert(c);\n        }\n        if index == 2 {\n     \
    \       encoded.push_str(&vowels.iter().next().unwrap().to_lowercase());\n   \
    \     }\n        index += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpq42numvf.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq42numvf.rs:17:30\n   |\n17 |             encoded.push_str(&c.to_lowercase());\n\
    \   |                              ^^^^^^^^^^^^^^^^^ expected `str`, found struct\
    \ `ToLowercase`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq42numvf.rs:19:30\n\
    \   |\n19 |             encoded.push_str(&c.to_uppercase());\n   |           \
    \                   ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpyxwpmjpr.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyxwpmjpr.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut i = 0;\n\
    \    while i < message.len() {\n        let mut j = i;\n        while j < message.len()\
    \ {\n            let mut k = j;\n            while k < message.len() {\n     \
    \           if message[j] == vowels[k.wrapping_add(1)] {\n                   \
    \ result.push_str(&letters[k.wrapping_add(1)]);\n                    break;\n\
    \                }\n                k += 1;\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpaz3eoy0i.rs:21:20\n\
    \   |\n21 |                 if message[j] == vowels[k.wrapping_add(1)] {\n   |\
    \                    ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpaz3eoy0i.rs:21:34\n\
    \   |\n21 |                 if message[j] == vowels[k.wrapping_add(1)] {\n   |\
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpaz3eoy0i.rs:22:38\n   |\n22 |                     result.push_str(&letters[k.wrapping_add(1)]);\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppc4hj3pc.rs:47:20\n   |\n\
    47 |     let mut vowels_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppc4hj3pc.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowel_counter = 0;\n    for letter in message.chars() {\n       \
    \ if letter.is_uppercase() {\n            result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(),\
    \ vowel_counter));\n            vowels.insert(letter);\n            vowel_counter\
    \ = 0;\n        } else {\n            result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(),\
    \ vowel_counter));\n            vowel_counter++;\n        }\n    }\n    for vowel\
    \ in vowels {\n        result.push_str(&format!(\"{}\", vowel));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp20hbzu9b.rs:22:27\n\
    \   |\n22 |             vowel_counter++;\n   |                           ^ expected\
    \ expression\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmp20hbzu9b.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letter_pairs = vec![];\n    let mut letter_pair = vec![];\n   \
    \ let mut letter_pair_count = 0;\n    let mut letter_pair_index = -1;\n    let\
    \ mut letter_pair_count2 = 0;\n    let mut letter_pair_index2 = -1;\n    let mut\
    \ letter_pair_count3 = 0;\n    let mut letter_pair_index3 = -1;\n    let mut letter_pair_count4\
    \ = 0;\n    let mut letter_pair_index4 = -1;\n    let mut letter_pair_count5 =\
    \ 0;\n    let mut letter_pair_index5 = -1;\n    let mut letter_pair_count6 = 0;\n\
    \    let mut letter_pair_index6 = -1;\n    let mut letter_pair_count7 = 0;\n \
    \   let mut letter_pair_index7 = -1;\n    let mut letter_pair_count8 = 0;\n  \
    \  let mut letter_pair_index8 = -1;\n    let mut letter_pair_count9 = 0;\n   \
    \ let mut letter_pair_index9 = -1;\n    let mut letter_pair_count10 = 0;\n   \
    \ let mut letter_pair_index10 = -1;\n    let mut letter_pair_count11 = 0;\n  \
    \  let mut letter_pair_index11 = -1;\n    let mut letter_pair_count12 = 0;\n \
    \   let mut letter_pair_index12 = -1;\n    let mut letter_pair_count13 = 0;\n\
    \    let mut letter_pair_index13 = -1;\n    let mut letter_pair_count14 = 0;\n\
    \    let mut letter_pair_index14 = -1;\n    let mut letter_pair_count15 = 0;\n\
    \    let mut letter_pair_index15 = -1;\n    let mut letter_pair_count16 = 0;\n\
    \    let mut letter_pair_index16 = -1;\n    let mut letter_pair_count17 = 0;\n\
    \    let mut letter_pair_index17 = -1;\n    let mut letter_pair_count18 = 0;\n\
    \    let mut letter_pair_index18 = -1;\n    let mut letter_pair_count19 = 0;\n\
    \    let mut letter_pair_index19 = -1;\n    let mut letter_pair_count20 = 0;\n\
    \    let mut letter_pair_index20 = -1;\n    let mut letter_pair_count21 = 0;\n\
    \    let mut letter_pair_index21 = -1;\n    let mut letter_pair_count22 = 0;\n\
    \    let mut letter_pair_index22 = -1;\n    let mut letter_pair_count23 = 0;\n\
    \    let mut letter_pair_index23 = -1;\n    let mut letter_pair_count24 = 0;\n\
    \    let mut letter_pair_index24 = -1;\n    let mut letter_pair_count25 = 0;\n\
    \    let mut letter_pair_index25 = -1;\n    let mut letter_pair_count26 = 0;\n\
    \    let mut letter_pair_index26 = \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp9l8wim1o.rs:68:1\n\
    \   |\n68 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashMap::new();\n\
    \    vowels.insert(String::from('a'), String::from('A'));\n    vowels.insert(String::from('e'),\
    \ String::from('E'));\n    vowels.insert(String::from('i'), String::from('I'));\n\
    \    vowels.insert(String::from('o'), String::from('O'));\n    vowels.insert(String::from('u'),\
    \ String::from('U'));\n    vowels.insert(String::from('y'), String::from('Y'));\n\
    \    for letter in message.chars() {\n        let mut encoded = String::new();\n\
    \        for vowel in vowels.keys() {\n            let mut encoded = String::new();\n\
    \            let mut vowel_letter = String::new();\n            let mut vowel_letter_2\
    \ = String::new();\n            let mut vowel_letter_3 = String::new();\n    \
    \        let mut vowel_letter_4 = String::new();\n            let mut vowel_letter_5\
    \ = String::new();\n            let mut vowel_letter_6 = String::new();\n    \
    \        let mut vowel_letter_7 = String::new();\n            let mut vowel_letter_8\
    \ = String::new();\n            let mut vowel_letter_9 = String::new();\n    \
    \        let mut vowel_letter_10 = String::new();\n            let mut vowel_letter_11\
    \ = String::new();\n            let mut vowel_letter_12 = String::new();\n   \
    \         let mut vowel_letter_13 = String::new();\n            let mut vowel_letter_14\
    \ = String::new();\n            let mut vowel_letter_15 = String::new();\n   \
    \         let mut vowel_letter_16 = String::new();\n            let mut vowel_letter_17\
    \ = String::new();\n            let mut vowel_letter_18 = String::new();\n   \
    \         let mut vowel_letter_19 = String::new();\n            let mut vowel_letter_20\
    \ = String::new();\n            let mut vowel_letter_21 = String::new();\n   \
    \         let mut vowel_letter_22 = String::new();\n            let mut vowel_letter_23\
    \ = String::new();\n            let mut vowel_letter_24 = String::new();\n   \
    \         let mut vowel_letter_25 = String::new();\n            let mut vowel_letter_26\
    \ = String::new();\n            let mut vowel_letter_27 = String::new();\n   \
    \         let mut vowel_letter_28 = String::new();\n            let mut vowel_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp62bcsm8m.rs:62:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n20 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n21 |       \
    \  let mut encoded = String::new();\n22 |         for vowel in vowels.keys() {\n\
    \   |                                    - this delimiter might not be properly\
    \ closed...\n...\n53 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n62 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp62bcsm8m.rs:52:27\n\
    \   |\n52 |             let mut vowel_\n   |                           ^ help:\
    \ add `;` here\n53 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp62bcsm8m.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashMap::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp62bcsm8m.rs:20:5\n   |\n11 |   fn encode(message: String) -> String\
    \ {\n   |                                 ------ expected `String` because of\
    \ return type\n...\n20 | /     for letter in message.chars() {\n21 | |       \
    \  let mut encoded = String::new();\n22 | |         for vowel in vowels.keys()\
    \ {\n23 | |             let mut encoded = String::new();\n...  |\n61 | |     assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    62 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter = 0;\n    let mut consonants_counter\
    \ = 0;\n    let mut letters_counter = 0;\n    for letter in message {\n      \
    \  if letter == ' ' {\n            result.push_str(\" \");\n        } else {\n\
    \            if letter in vowels {\n                vowels_counter += 1;\n   \
    \             result.push_str(&vowels[vowels_counter]);\n            } else {\n\
    \                if letter in consonants {\n                    consonants_counter\
    \ += 1;\n                    result.push_str(&consonants[consonants_counter]);\n\
    \                } else {\n                    if letter in letters {\n      \
    \                  letters_counter += 1;\n                        result.push_str(&letters[letters_counter]);\n\
    \                    } else {\n                        result.push_str(&letter);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp7t56fts6.rs:23:23\n\
    \   |\n23 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmp7t56fts6.rs:19:19\n\
    \    |\n19  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            vowels += letter;\n   \
    \         vowel_counter += 1;\n        }\n        else {\n            if letter_counter\
    \ < 2 {\n                encoded += vowels[vowel_counter];\n                vowel_counter\
    \ += 1;\n            }\n            else {\n                encoded += vowels[vowel_counter];\n\
    \                vowel_counter += 1;\n                letter_counter += 1;\n \
    \           }\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb7aqu7a6.rs:18:23\n   |\n\
    18 |             vowels += letter;\n   |                       ^^^^^^ expected\
    \ `&str`, found `char`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `{integer}`\n  --> /tmp/tmpb7aqu7a6.rs:23:28\n   |\n23 |                 encoded\
    \ += vowels[vowel_counter];\n   |                            ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmpb7aqu7a6.rs:27:28\n   |\n27 |        \
    \         encoded += vowels[vowel_counter];\n   |                            ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n   \
    \     } else {\n            letters.insert(c.to_uppercase());\n        }\n   \
    \ }\n    for c in letters.iter() {\n        if vowels.contains(&c) {\n       \
    \     result.push(c);\n        } else {\n            result.push(c.to_lowercase());\n\
    \        }\n    }\n    for c in vowels.iter() {\n        result.push(c);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp0s_tz7gw.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp0s_tz7gw.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0s_tz7gw.rs:26:25\n   |\n26 |             result.push(c.to_lowercase());\n\
    \   |                         ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToLowercase`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_letters\
    \ = vec![\"A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowel_letter_counts\
    \ = vec![0];\n    let mut letter_counts = vec![0];\n    let mut letter_counts_index\
    \ = 0;\n    let mut letter_counts_index2 = 0;\n    let mut letter_counts_index3\
    \ = 0;\n    let mut letter_counts_index4 = 0;\n    let mut letter_counts_index5\
    \ = 0;\n    let mut letter_counts_index6 = 0;\n    let mut letter_counts_index7\
    \ = 0;\n    let mut letter_counts_index8 = 0;\n    let mut letter_counts_index9\
    \ = 0;\n    let mut letter_counts_index10 = 0;\n    let mut letter_counts_index11\
    \ = 0;\n    let mut letter_counts_index12 = 0;\n    let mut letter_counts_index13\
    \ = 0;\n    let mut letter_counts_index14 = 0;\n    let mut letter_counts_index15\
    \ = 0;\n    let mut letter_counts_index16 = 0;\n    let mut letter_counts_index17\
    \ = 0;\n    let mut letter_counts_index18 = 0;\n    let mut letter_counts_index19\
    \ = 0;\n    let mut letter_counts_index20 = 0;\n    let mut letter_counts_index21\
    \ = 0;\n    let mut letter_counts_index22 = 0;\n    let mut letter_counts_index23\
    \ = 0;\n    let mut letter_counts_index24 = 0;\n    let mut letter_counts_index25\
    \ = 0;\n    let mut letter_counts_index26 = 0;\n    let mut letter_counts_index27\
    \ = 0;\n    let mut letter_counts_index28 = 0;\n    let mut letter_counts_index29\
    \ = 0;\n    let mut letter_counts_index30 = 0;\n    let mut letter_counts_index31\
    \ = 0;\n    let mut letter_counts_index32 = 0;\n    let mut letter_counts_index33\
    \ = 0;\n    let mut letter_counts_index34 = 0;\n    let mut letter_counts_index35\
    \ = 0;\n    let mut letter_counts_index36 = 0;\n    let mut letter_counts_index37\
    \ = 0;\n    let mut letter_counts_index38 = 0;\n    let mut letter_counts_index39\
    \ = 0;\n    let mut letter_counts_index40 = 0;\n    let mut letter_count\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprzanweon.rs:58:25\n   |\n\
    58 |     let mut letter_count\n   |                         ^ help: add `;` here\n\
    59 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprzanweon.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels {\n        vowels_map.insert(vowel.to_string(), vowel);\n\
    \    }\n    let mut current_letter = String::new();\n    for letter in message\
    \ {\n        if let Some(vowel) = vowels_map.get(&letter) {\n            result.push_str(vowel);\n\
    \        } else {\n            result.push_str(letter);\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpv74ux9fx.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ `String` is not an iterator\n   --> /tmp/tmpv74ux9fx.rs:19:19\n    |\n19  |\
    \     for letter in message {\n    |                   ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait\
    \ `Iterator` is not implemented for `String`\n    = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if let Some(vowel) = vowels.find(|c| c == letter) {\n            result.push_str(&letters[letter_counter]);\n\
    \            result.push_str(&letters[letter_counter + 1]);\n            result.push_str(&letters[vowel_counter]);\n\
    \            result.push_str(&letters[vowel_counter + 1]);\n            vowel_counter\
    \ += 2;\n            letter_counter += 2;\n        } else {\n            result.push_str(&letters[letter_counter]);\n\
    \            result.push_str(&letters[letter_counter + 1]);\n            result.push_str(&letters[vowel_counter]);\n\
    \            result.push_str(&letters[vowel_counter + 1]);\n            letter_counter\
    \ += 2;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpi2dcr5j8.rs:19:30\n\
    \   |\n19 |             result.push_str(&letters[letter_counter]);\n   |     \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented for\
    \ `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n \
    \          for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = note: required because of the requirements on the impl of `Index<{integer}>`\
    \ for `str`\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpi2dcr5j8.rs:20:30\n   |\n20 |             result.push_str(&letters[letter_counter\
    \ + 1]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `{integer}`\n   = note: you can use `.chars().nth()`\
    \ or `.bytes().nth()`\n           for more information, see chapter 8 in The Book:\
    \ <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = note: required because of the requirements on the impl of `Index<{integer}>`\
    \ for `str`\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpi2dcr5j8.rs:21:30\n   |\n21 |             result.push_str(&letters[vowel_counter]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = note: required because of the requirements on the impl of `Index<{integer}>`\
    \ for `str`\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpi2dcr5j8.rs:22:30\n   |\n22 |             result.push_str(&letters[vowel_counter\
    \ + 1]);\n   |          "
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp3z3kepw3.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmp3z3kepw3.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_index = 0;\n    let\
    \ mut letters_index = 0;\n    let mut vowels_index2 = 0;\n    let mut letters_index2\
    \ = 0;\n    for c in message.chars() {\n        if c.is_uppercase() {\n      \
    \      letters.insert(c);\n            letters_index += 1;\n        } else {\n\
    \            vowels.insert(c);\n            vowels_index += 1;\n        }\n  \
    \  }\n    for c in message.chars() {\n        if c.is_uppercase() {\n        \
    \    if letters_index == 2 {\n                result.push((letters.next_back().unwrap()).to_string());\n\
    \                letters_index = 0;\n            }\n            result.push((letters.next_back().unwrap()).to_string());\n\
    \            letters_index += 1;\n        } else {\n            if vowels_index\
    \ == 2 {\n                result.push((vowels.next_back().unwrap()).to_string());\n\
    \                vowels_index = 0;\n            }\n            result.push((vowels.next_back().unwrap()).to_string());\n\
    \            vowels_index += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpmgrspipp.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpmgrspipp.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    let mut l = message.length();\n    while i < l {\n        if message[i]\
    \ == ' ' {\n            i += 1;\n            continue;\n        }\n        if\
    \ message[i] == 'a' {\n            i += 1;\n            continue;\n        }\n\
    \        if message[i] == 'e' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'i' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'o' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'u' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'A' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'E' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'I' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'O' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'U' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'B' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'C' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'D' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'F' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'G' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'H' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'J' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'K' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'L' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'M' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'N' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'P' {\n            i += 1;\n            continue;\n\
    \        }\n        if message[i] == 'Q' {\n            i += 1;\n            continue;\n\
    \        }\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpr7jjm_wu.rs:125:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n19  |     while i < l {\n    |\
    \                 - this delimiter might not be properly closed...\n...\n116 |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n125\
    \ | }\n    |   ^\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpr7jjm_wu.rs:18:25\n   |\n18 |     let mut\
    \ l = message.length();\n   |                         ^^^^^^ method not found\
    \ in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpr7jjm_wu.rs:20:12\n   |\n20 |         if message[i] == ' ' {\n\
    \   |            ^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpr7jjm_wu.rs:24:12\n\
    \   |\n24 |         if message[i] == 'a' {\n   |            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmpr7jjm_wu.rs:28:12\n   |\n28 |        \
    \ if message[i] == 'e' {\n   |            ^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpr7jjm_wu.rs:32:12\n   |\n32 |         if message[i] == 'i' {\n\
    \   |            ^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpr7jjm_wu.rs:36:12\n\
    \   |\n36 |         if message[i] == 'o' {\n   |            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\ner"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if vowels.contains(&letter) {\n            result.push((letters[vowel_counter]\
    \ + letters[letter_counter]).to_string());\n            vowel_counter += 2;\n\
    \            letter_counter += 1;\n        } else {\n            result.push(letter);\n\
    \            letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf5ivmf2v.rs:18:28\n   |\n\
    18 |         if vowels.contains(&letter) {\n   |                            ^^^^^^^\
    \ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0369]: cannot add `&str` to `&str`\n\
    \  --> /tmp/tmpf5ivmf2v.rs:19:49\n   |\n19 |             result.push((letters[vowel_counter]\
    \ + letters[letter_counter]).to_string());\n   |                          ----------------------\
    \ ^ ----------------------- &str\n   |                          |            \
    \          |\n   |                          |                      `+` cannot\
    \ be used to concatenate two `&str` strings\n   |                          &str\n\
    \   |\nhelp: `to_owned()` can be used to create an owned `String` from a string\
    \ reference. String concatenation appends the string on the right to the string\
    \ on the left and may require reallocation. This requires ownership of the string\
    \ on the left\n   |\n19 |             result.push((letters[vowel_counter].to_owned()\
    \ + letters[letter_counter]).to_string());\n   |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter.is_lowercase()\
    \ {\n            letters.insert(letter);\n        }\n        if letter.is_uppercase()\
    \ {\n            letters.insert(letter);\n        }\n    }\n    for letter in\
    \ letters.iter() {\n        if vowels.contains(letter) {\n            vowel_counter\
    \ += 2;\n        }\n    }\n    for letter in letters.iter() {\n        if vowel_counter\
    \ > 0 {\n            result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(),\
    \ vowels[letter]));\n        } else {\n            result.push_str(&format!(\"\
    {}\", letter.to_ascii_lowercase()));\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5y1dq63z.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp5y1dq63z.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n\
    \    let mut alphabet_encoded = HashSet::new();\n    let mut vowels_encoded =\
    \ HashSet::new();\n    let mut alphabet_encoded = HashSet::new();\n    let mut\
    \ vowels_encoded = HashSet::new();\n    let mut alphabet_encoded = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut alphabet_encoded =\
    \ HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n    let mut alphabet_encoded\
    \ = HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n    let mut\
    \ alphabet_encoded = HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n\
    \    let mut alphabet_encoded = HashSet::new();\n    let mut vowels_encoded =\
    \ HashSet::new();\n    let mut alphabet_encoded = HashSet::new();\n    let mut\
    \ vowels_encoded = HashSet::new();\n    let mut alphabet_encoded = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut alphabet_encoded =\
    \ HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n    let mut alphabet_encoded\
    \ = HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n    let mut\
    \ alphabet_encoded = HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n\
    \    let mut alphabet_encoded = HashSet::new();\n    let mut vowels_encoded =\
    \ HashSet::new();\n    let mut alphabet_encoded = HashSet::new();\n    let mut\
    \ vowels_encoded = HashSet::new();\n    let mut alphabet_encoded = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut alphabet_encoded =\
    \ HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n    let mut alphabet_encoded\
    \ = HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n    let mut\
    \ alphabet_encoded = HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp96j85eeq.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp96j85eeq.rs:14:24\n\
    \   |\n14 |     let mut alphabet = HashSet::new();\n   |                     \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp96j85eeq.rs:15:30\n   |\n15\
    \ |     let mut vowels_encoded = HashSet::new();\n   |                       \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp96j85eeq.rs:16:32\n   |\n16\
    \ |     let mut alphabet_encoded = HashSet::new();\n   |                     \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp96j85eeq.rs:17:30\n\
    \   |\n17 |     let mut vowels_encoded = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp96j85eeq.rs:18:32\n\
    \   |\n18 |     let mut alphabet_encoded = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp96j85eeq.rs:19:30\n\
    \   |\n19 |     let mut vowels_encoded = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n "
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter =\
    \ 0;\n    let mut letters_counter = 0;\n    for letter in message {\n        if\
    \ letter == ' ' {\n            result.push_str(\" \");\n        } else {\n   \
    \         if letter == vowels[vowels_counter] {\n                result.push_str(&vowels[vowels_counter]);\n\
    \                vowels_counter++;\n            } else {\n                result.push_str(&letters[letters_counter]);\n\
    \                letters_counter++;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpt_2g7xwk.rs:23:32\n\
    \   |\n23 |                 vowels_counter++;\n   |                          \
    \      ^ expected expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpt_2g7xwk.rs:26:33\n\
    \   |\n26 |                 letters_counter++;\n   |                         \
    \        ^ expected expression\n\nerror[E0277]: `String` is not an iterator\n\
    \   --> /tmp/tmpt_2g7xwk.rs:17:19\n    |\n17  |     for letter in message {\n\
    \    |                   ^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\nnote: required by `into_iter`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt_2g7xwk.rs:22:33\n   |\n22 |                 result.push_str(&vowels[vowels_counter]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_2g7xwk.rs:25:33\n\
    \   |\n25 |                 result.push_str(&letters[letters_counter]);\n   |\
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n \
    \   let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut letter_counter8\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n\
    \    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let mut letter_counter15\
    \ = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n\
    \    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let mut letter_counter22\
    \ = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n\
    \    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let mut letter_counter29\
    \ = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n\
    \    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n    let\
    \ mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let mut letter_counter36\
    \ = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n\
    \    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n    let\
    \ mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let mut letter_counter43\
    \ = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n\
    \    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n    let\
    \ mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let mut letter_counter50\
    \ = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n\
    \    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n    let\
    \ mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let mut letter_counter57\
    \ = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n\
    \    let mut letter_counter60 = 0;\n    let mut letter_\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpodpv_blm.rs:75:20\n   |\n\
    75 |     let mut letter_\n   |                    ^ help: add `;` here\n76 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpodpv_blm.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_idx_map = vec![];\n    for vowel in vowels {\n        vowels_idx_map.push(vowels_idx);\n\
    \    }\n    for letter in message.chars() {\n        let mut new_letter = letter;\n\
    \        for vowel in vowels {\n            let mut idx = vowels_idx[vowel];\n\
    \            idx += 1;\n            if idx < vowels_idx.len() {\n            \
    \    new_letter += vowel;\n            }\n        }\n        result.push(new_letter);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&str`\n  -->\
    \ /tmp/tmpwhwfl5vf.rs:22:27\n   |\n22 |             let mut idx = vowels_idx[vowel];\n\
    \   |                           ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `Index<&str>` for `Vec<{integer}>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpwhwfl5vf.rs:25:17\n\
    \   |\n25 |                 new_letter += vowel;\n   |                 ----------^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0368.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut vowels_counter2 = 0;\n    let mut\
    \ vowels_counter3 = 0;\n    let mut vowels_counter4 = 0;\n    let mut vowels_counter5\
    \ = 0;\n    let mut vowels_counter6 = 0;\n    let mut vowels_counter7 = 0;\n \
    \   let mut vowels_counter8 = 0;\n    let mut vowels_counter9 = 0;\n    let mut\
    \ vowels_counter10 = 0;\n    let mut vowels_counter11 = 0;\n    let mut vowels_counter12\
    \ = 0;\n    let mut vowels_counter13 = 0;\n    let mut vowels_counter14 = 0;\n\
    \    let mut vowels_counter15 = 0;\n    let mut vowels_counter16 = 0;\n    let\
    \ mut vowels_counter17 = 0;\n    let mut vowels_counter18 = 0;\n    let mut vowels_counter19\
    \ = 0;\n    let mut vowels_counter20 = 0;\n    let mut vowels_counter21 = 0;\n\
    \    let mut vowels_counter22 = 0;\n    let mut vowels_counter23 = 0;\n    let\
    \ mut vowels_counter24 = 0;\n    let mut vowels_counter25 = 0;\n    let mut vowels_counter26\
    \ = 0;\n    let mut vowels_counter27 = 0;\n    let mut vowels_counter28 = 0;\n\
    \    let mut vowels_counter29 = 0;\n    let mut vowels_counter30 = 0;\n    let\
    \ mut vowels_counter31 = 0;\n    let mut vowels_counter32 = 0;\n    let mut vowels_counter33\
    \ = 0;\n    let mut vowels_counter34 = 0;\n    let mut vowels_counter35 = 0;\n\
    \    let mut vowels_counter36 = 0;\n    let mut vowels_counter37 = 0;\n    let\
    \ mut vowels_counter38 = 0;\n    let mut vowels_counter39 = 0;\n    let mut vowels_counter40\
    \ = 0;\n    let mut vowels_counter41 = 0;\n    let mut vowels_counter42 = 0;\n\
    \    let mut vowels_counter43 = 0;\n    let mut vowels_counter44 = 0;\n    let\
    \ mut vowels_counter45 = 0;\n    let mut vowels_counter46 = 0;\n    let mut vowels_counter47\
    \ = 0;\n    let mut vowels_counter48 = 0;\n    let mut vowels_counter49 = 0;\n\
    \    let mut vowels_counter50 = 0;\n    let mut vowels_counter51 = 0;\n    let\
    \ mut vowels_counter52 = 0;\n    let mut vowels_counter53 = 0;\n    let mut vowels_counter54\
    \ = 0;\n    let mut vowels_counter55 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgqtrqwkw.rs:69:11\n   |\n\
    69 |     let mu\n   |           ^ help: add `;` here\n70 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpgqtrqwkw.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqtrqwkw.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747166
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut i = 0;\n\
    \    while i < message.len() {\n        let mut j = i;\n        while j < message.len()\
    \ {\n            if message[j] == vowels[i as usize] {\n                result.push(*letters[i\
    \ as usize]);\n                i += 1;\n                j += 1;\n            }\
    \ else {\n                result.push(*message[j]);\n                j += 1;\n\
    \            }\n        }\n        i = j;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn951bl7s.rs:19:16\n\
    \   |\n19 |             if message[j] == vowels[i as usize] {\n   |          \
    \      ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `str` cannot be indexed by `usize`\n  --> /tmp/tmpn951bl7s.rs:19:30\n   |\n\
    19 |             if message[j] == vowels[i as usize] {\n   |                 \
    \             ^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<usize>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpn951bl7s.rs:20:30\n\
    \   |\n20 |                 result.push(*letters[i as usize]);\n   |         \
    \                     ^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn951bl7s.rs:24:30\n   |\n24 |                 result.push(*message[j]);\n\
    \   |                              ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = HashSet::new();\n    let mut vowels_index2 = HashSet::new();\n\
    \    let mut vowels_index3 = HashSet::new();\n    let mut vowels_index4 = HashSet::new();\n\
    \    let mut vowels_index5 = HashSet::new();\n    let mut vowels_index6 = HashSet::new();\n\
    \    let mut vowels_index7 = HashSet::new();\n    let mut vowels_index8 = HashSet::new();\n\
    \    let mut vowels_index9 = HashSet::new();\n    let mut vowels_index10 = HashSet::new();\n\
    \    let mut vowels_index11 = HashSet::new();\n    let mut vowels_index12 = HashSet::new();\n\
    \    let mut vowels_index13 = HashSet::new();\n    let mut vowels_index14 = HashSet::new();\n\
    \    let mut vowels_index15 = HashSet::new();\n    let mut vowels_index16 = HashSet::new();\n\
    \    let mut vowels_index17 = HashSet::new();\n    let mut vowels_index18 = HashSet::new();\n\
    \    let mut vowels_index19 = HashSet::new();\n    let mut vowels_index20 = HashSet::new();\n\
    \    let mut vowels_index21 = HashSet::new();\n    let mut vowels_index22 = HashSet::new();\n\
    \    let mut vowels_index23 = HashSet::new();\n    let mut vowels_index24 = HashSet::new();\n\
    \    let mut vowels_index25 = HashSet::new();\n    let mut vowels_index26 = HashSet::new();\n\
    \    let mut vowels_index27 = HashSet::new();\n    let mut vowels_index28 = HashSet::new();\n\
    \    let mut vowels_index29 = HashSet::new();\n    let mut vowels_index30 = HashSet::new();\n\
    \    let mut vowels_index31 = HashSet::new();\n    let mut vowels_index32 = HashSet::new();\n\
    \    let mut vowels_index33 = HashSet::new();\n    let mut vowels_index34 = HashSet::new();\n\
    \    let mut vowels_index35 = HashSet::new();\n    let mut vowels_index36 = HashSet::new();\n\
    \    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmptvrdb7r5.rs:51:1\n  \
    \ |\n51 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmptvrdb7r5.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmptvrdb7r5.rs:14:28\n   |\n14 |     let mut vowels_index = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmptvrdb7r5.rs:15:29\n   |\n15 |     let mut vowels_index2 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmptvrdb7r5.rs:16:29\n   |\n16 |     let mut vowels_index3 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmptvrdb7r5.rs:17:29\n   |\n17 |     let mut vowels_index4 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmptvrdb7r5.rs:18:29\n   |\n18 |     let mut vowels_index5 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmptvrdb7r5.rs:19:29\n   |\n19 |     let mut vowel"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letter_pairs = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair_count = HashSet::new();\n    let mut letter_pair_counts\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted = HashSet::new();\n\
    \    let mut letter_pair_counts_sorted_reversed = HashSet::new();\n    let mut\
    \ letter_pair_counts_sorted_reversed_reversed = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu4rtutdd.rs:34:48\n   |\n\
    34 |     let mut letter_pair_counts_sorted_reversed_\n   |                   \
    \                             ^ help: add `;` here\n35 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpu4rtutdd.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpu4rtutdd.rs:14:28\n\
    \   |\n14 |     let mut letter_pairs = HashSet::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpu4rtutdd.rs:15:27\n\
    \   |\n15 |     let mut letter_pair = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpu4rtutdd.rs:16:33\n\
    \   |\n16 |     let mut letter_pair_count = HashSet::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpu4rtutdd.rs:17:34\n\
    \   |\n17 |     let mut letter_pair_counts = HashSet::new();\n   |           \
    \                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpu4rtutdd.rs:18:41\n\
    \   |\n18 |     let mut letter_pair_counts_sorted = HashSet::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | u"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut vowels_encoded_len\
    \ = 0;\n    let mut vowels_encoded_len2 = 0;\n    let mut vowels_encoded_len3\
    \ = 0;\n    let mut vowels_encoded_len4 = 0;\n    let mut vowels_encoded_len5\
    \ = 0;\n    let mut vowels_encoded_len6 = 0;\n    let mut vowels_encoded_len7\
    \ = 0;\n    let mut vowels_encoded_len8 = 0;\n    let mut vowels_encoded_len9\
    \ = 0;\n    let mut vowels_encoded_len10 = 0;\n    let mut vowels_encoded_len11\
    \ = 0;\n    let mut vowels_encoded_len12 = 0;\n    let mut vowels_encoded_len13\
    \ = 0;\n    let mut vowels_encoded_len14 = 0;\n    let mut vowels_encoded_len15\
    \ = 0;\n    let mut vowels_encoded_len16 = 0;\n    let mut vowels_encoded_len17\
    \ = 0;\n    let mut vowels_encoded_len18 = 0;\n    let mut vowels_encoded_len19\
    \ = 0;\n    let mut vowels_encoded_len20 = 0;\n    let mut vowels_encoded_len21\
    \ = 0;\n    let mut vowels_encoded_len22 = 0;\n    let mut vowels_encoded_len23\
    \ = 0;\n    let mut vowels_encoded_len24 = 0;\n    let mut vowels_encoded_len25\
    \ = 0;\n    let mut vowels_encoded_len26 = 0;\n    let mut vowels_encoded_len27\
    \ = 0;\n    let mut vowels_encoded_len28 = 0;\n    let mut vowels_encoded_len29\
    \ = 0;\n    let mut vowels_encoded_len30 = 0;\n    let mut vowels_encoded_len31\
    \ = 0;\n    let mut vowels_encoded_len32 = 0;\n    let mut vowels_encoded_len33\
    \ = 0;\n    let mut vowels_encoded_len34 = 0;\n    let mut vowels_encoded_len35\
    \ = 0;\n    let mut vowels_encoded_len36 = 0;\n    let mut vowels_encoded_len37\
    \ = 0;\n    let mut vowels_encoded_len38 = 0;\n    let mut vowels_encoded_len39\
    \ = 0;\n    let mut vowels_encoded_len40 = 0;\n    let mut vowels_encoded_len41\
    \ = 0;\n    let mut vowels_encoded_len42 = 0;\n    let mut vowels_encoded_len43\
    \ = 0;\n    let mut vowels_encoded_len44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpvx6qvmfs.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpvx6qvmfs.rs:14:30\n\
    \   |\n14 |     let mut vowels_encoded = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvx6qvmfs.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter.is_lowercase() {\n            encoded.push((letter\
    \ + encode(&message[vowels_index..])));\n            letter_counter += 1;\n  \
    \          vowels_index += 1;\n        } else {\n            encoded.push((letter\
    \ + encode(&message[vowels_index..vowels_index+2])));\n            letter_counter\
    \ += 1;\n            vowels_index += 2;\n        }\n        if letter_counter\
    \ == 2 && vowels.contains(&letter) {\n            vowels.insert(letter);\n   \
    \     }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp024m1na4.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nwarning:\
    \ unnecessary parentheses around method argument\n  --> /tmp/tmp024m1na4.rs:18:26\n\
    \   |\n18 |             encoded.push((letter + encode(&message[vowels_index..])));\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help:\
    \ remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmp024m1na4.rs:22:26\n\
    \   |\n22 |             encoded.push((letter + encode(&message[vowels_index..vowels_index+2])));\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp024m1na4.rs:18:43\n\
    \   |\n18 |             encoded.push((letter + encode(&message[vowels_index..])));\n\
    \   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n18 |             encoded.push((letter + encode((&message[vowels_index..]).to_string())));\n\
    \   |                                           +                        +++++++++++++\n\
    \nerror[E0369]: cannot add `String` to `char`\n  --> /tmp/tmp024m1na4.rs:18:34\n\
    \   |\n18 |             encoded.push((letter + encode(&message[vowels_index..])));\n\
    \   |                           ------ ^ -------------------------------- String\n\
    \   |                           |\n   |                           char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp024m1na4.rs:22:43\n   |\n22 |             encoded.push((letter\
    \ + encode(&message[vowels_index..vowels_index+2])));\n   |                  \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n22\
    \ |     "
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_map = HashMap::new();\n    for vowel\
    \ in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n    for c in message.chars()\
    \ {\n        let mut new_c = c;\n        for vowel in vowels {\n            if\
    \ vowels_map.contains_key(&vowel) {\n                new_c = new_c.replace(vowel,\
    \ vowels_map.get(&vowel));\n            }\n        }\n        result.push(new_c);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpry4josyb.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `replace` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpry4josyb.rs:22:31\n   |\n22 |                 new_c = new_c.replace(vowel,\
    \ vowels_map.get(&vowel));\n   |                               ^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0433, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n \
    \   let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut letter_counter8\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n\
    \    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let mut letter_counter15\
    \ = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n\
    \    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let mut letter_counter22\
    \ = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n\
    \    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let mut letter_counter29\
    \ = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n\
    \    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n    let\
    \ mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let mut letter_counter36\
    \ = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n\
    \    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n    let\
    \ mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let mut letter_counter43\
    \ = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n\
    \    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n    let\
    \ mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let mut letter_counter50\
    \ = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n\
    \    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n    let\
    \ mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let mut letter_counter57\
    \ = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n\
    \    let mut letter_counter60 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpq_q2qq_u.rs:76:1\n\
    \   |\n76 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_index = HashMap::new();\n\
    \    let mut letters_index = HashMap::new();\n    let mut vowels_index2 = HashMap::new();\n\
    \    let mut letters_index2 = HashMap::new();\n    let mut vowels_index3 = HashMap::new();\n\
    \    let mut letters_index3 = HashMap::new();\n    let mut vowels_index4 = HashMap::new();\n\
    \    let mut letters_index4 = HashMap::new();\n    let mut vowels_index5 = HashMap::new();\n\
    \    let mut letters_index5 = HashMap::new();\n    let mut vowels_index6 = HashMap::new();\n\
    \    let mut letters_index6 = HashMap::new();\n    let mut vowels_index7 = HashMap::new();\n\
    \    let mut letters_index7 = HashMap::new();\n    let mut vowels_index8 = HashMap::new();\n\
    \    let mut letters_index8 = HashMap::new();\n    let mut vowels_index9 = HashMap::new();\n\
    \    let mut letters_index9 = HashMap::new();\n    let mut vowels_index10 = HashMap::new();\n\
    \    let mut letters_index10 = HashMap::new();\n    let mut vowels_index11 = HashMap::new();\n\
    \    let mut letters_index11 = HashMap::new();\n    let mut vowels_index12 = HashMap::new();\n\
    \    let mut letters_index12 = HashMap::new();\n    let mut vowels_index13 = HashMap::new();\n\
    \    let mut letters_index13 = HashMap::new();\n    let mut vowels_index14 = HashMap::new();\n\
    \    let mut letters_index14 = HashMap::new();\n    let mut vowels_index15 = HashMap::new();\n\
    \    let mut letters_index15 = HashMap::new();\n    let mut vowels_index16 = HashMap::new();\n\
    \    let mut letters_index16 = HashMap::new();\n    let mut vowels_index17 = HashMap::new();\n\
    \    let mut letters_index17 = HashMap::new();\n    let mut vowels_index18 = HashMap::new();\n\
    \    let mut letters_index18 = HashMap::new();\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpxxofzjqg.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpxxofzjqg.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpxxofzjqg.rs:14:23\n   |\n14 |  \
    \   let mut letters = HashSet::new();\n   |                       ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n  --> /tmp/tmpxxofzjqg.rs:15:28\n   |\n15 |  \
    \   let mut vowels_index = HashMap::new();\n   |                            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxxofzjqg.rs:16:29\n   |\n16\
    \ |     let mut letters_index = HashMap::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxxofzjqg.rs:17:29\n   |\n17\
    \ |     let mut vowels_index2 = HashMap::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxxofzjqg.rs:18:30\n   |\n18\
    \ |     let mut letters_index2 = HashMap::new();\n   |                       \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxxofzjqg.rs:19:29\n   |\n19\
    \ |     let mut vowels_in"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letter_counter = 0;\n    for letter in message.chars()\
    \ {\n        if letter_counter < 2 {\n            result.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == letter).unwrap()]);\n        } else {\n            result.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == letter).unwrap() - 2]);\n        }\n        letter_counter += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0kke8tmj.rs:17:29\n   |\n\
    17 |             result.push_str(&vowels[vowels.iter().position(|&x| x == letter).unwrap()]);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0kke8tmj.rs:19:29\n   |\n19 |             result.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == letter).unwrap() - 2]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = 0;\n\
    \    let mut letters_index = 0;\n    for letter in message {\n        if letter\
    \ == ' ' {\n            result.push_str(&letters[letters_index]);\n          \
    \  letters_index += 1;\n        } else {\n            if letter in vowels {\n\
    \                result.push_str(&vowels[vowels_index]);\n                vowels_index\
    \ += 1;\n            } else {\n                result.push_str(&letters[letters_index]);\n\
    \                letters_index += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp0412ix13.rs:22:23\n\
    \   |\n22 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmp0412ix13.rs:17:19\n\
    \    |\n17  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0412ix13.rs:19:29\n\
    \   |\n19 |             result.push_str(&letters[letters_index]);\n   |      \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowels_index\
    \ = letters.len() - vowels.len();\n    let mut letters_index = letters.len() -\
    \ vowels.len() - 1;\n    let mut letters_index2 = 0;\n    let mut letters_index3\
    \ = 0;\n    let mut letters_index4 = 0;\n    let mut letters_index5 = 0;\n   \
    \ let mut letters_index6 = 0;\n    let mut letters_index7 = 0;\n    let mut letters_index8\
    \ = 0;\n    let mut letters_index9 = 0;\n    let mut letters_index10 = 0;\n  \
    \  let mut letters_index11 = 0;\n    let mut letters_index12 = 0;\n    let mut\
    \ letters_index13 = 0;\n    let mut letters_index14 = 0;\n    let mut letters_index15\
    \ = 0;\n    let mut letters_index16 = 0;\n    let mut letters_index17 = 0;\n \
    \   let mut letters_index18 = 0;\n    let mut letters_index19 = 0;\n    let mut\
    \ letters_index20 = 0;\n    let mut letters_index21 = 0;\n    let mut letters_index22\
    \ = 0;\n    let mut letters_index23 = 0;\n    let mut letters_index24 = 0;\n \
    \   let mut letters_index25 = 0;\n    let mut letters_index26 = 0;\n    let mut\
    \ letters_index27 = 0;\n    let mut letters_index28 = 0;\n    let mut letters_index29\
    \ = 0;\n    let mut letters_index30 = 0;\n    let mut letters_index31 = 0;\n \
    \   let mut letters_index32 = 0;\n    let mut letters_index33 = 0;\n    let mut\
    \ letters_index34 = 0;\n    let mut letters_index35 = 0;\n    let mut letters_index36\
    \ = 0;\n    let mut letters_index37 = 0;\n    let mut letters_index38 = 0;\n \
    \   let mut letters_index39 = 0;\n    let mut letters_index40 = 0;\n    let mut\
    \ letters_index41 = 0;\n    let mut letters_index42 = 0;\n    let mut letters_index43\
    \ = 0;\n    let mut letters_index44 = 0;\n    let mut letters_index45 = 0;\n \
    \   let mut letters_index46 = 0;\n    let mut letters_index47 = 0;\n    let mut\
    \ letters_index48 = 0;\n    let mut letters_index49 = 0;\n    let mut letters_index50\
    \ = 0;\n    let mut letters_index51 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4x8_dwxm.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|x|\
    \ x == letter) {\n            encoded.push_str(&vowels[vowel_counter]);\n    \
    \        vowel_counter += 1;\n        } else {\n            encoded.push_str(&letter);\n\
    \            letter_counter += 1;\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpyvrh1343.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyvrh1343.rs:21:30\n   |\n21 |             encoded.push_str(&letter);\n\
    \   |                              ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp__4vra74.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"AEIOUaeiou\"\
    .to_string();\n    let mut letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".to_string();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            if letter_counter < 2 {\n              \
    \  result.push_str(&letters[letter_counter]);\n                letter_counter\
    \ += 1;\n            } else {\n                let mut new_letter = letters[letter_counter];\n\
    \                let mut new_vowel = vowels[vowel_counter];\n                vowel_counter\
    \ += 1;\n                if vowel_counter < vowels.len() {\n                 \
    \   new_vowel = vowels[vowel_counter];\n                    vowel_counter += 1;\n\
    \                }\n                result.push_str(&new_letter);\n          \
    \      result.push_str(&new_vowel);\n                letter_counter = 0;\n   \
    \             vowel_counter = 0;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpzxzfylqy.rs:22:34\n   |\n22 |                 result.push_str(&letters[letter_counter]);\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpzxzfylqy.rs:25:38\n   |\n25 |                \
    \ let mut new_letter = letters[letter_counter];\n   |                        \
    \              ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpzxzfylqy.rs:26:37\n\
    \   |\n26 |                 let mut new_vowel = vowels[vowel_counter];\n   | \
    \                                    ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpzxzfylqy.rs:29:33\n   |\n29 |                    \
    \ new_vowel = vowels[vowel_counter];\n   |                                 ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n  --> /tmp/tmpzxzfylqy.rs:25:21\n\
    \   |\n25 |                 let mut new_letter = letters[letter_counter];\n  \
    \ |                     ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n25 |\
    \                 let mut new_letter = &letters[letter_counter];\n   |       \
    \                               +\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be know"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letters = \"bcdfghjklmnpqrstvwxyz\".to_string();\n\
    \    for letter in message.chars() {\n        if let Some(vowel) = vowels.chars().position(|c|\
    \ c == letter) {\n            result.push_str(&letters[vowel + 2]);\n        }\
    \ else {\n            result.push_str(&letters[vowel]);\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmpnzn3d72f.rs:19:38\n\
    \   |\n19 |             result.push_str(&letters[vowel]);\n   |              \
    \                        ^^^^^ help: a local variable with a similar name exists:\
    \ `vowels`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpnzn3d72f.rs:17:30\n   |\n17 |             result.push_str(&letters[vowel\
    \ + 2]);\n   |                              ^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut count = 1;\n    for\
    \ letter in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            result.push_str(&letters[vowel + index]);\n            count\
    \ += 1;\n        } else {\n            result.push_str(&letters[letter + index]);\n\
    \            count += 1;\n        }\n        index += 1;\n    }\n    if count\
    \ > 2 {\n        result.push_str(&letters[vowels.len() - index]);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprc4337sd.rs:18:16\n   |\n\
    18 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `char`\n  --> /tmp/tmprc4337sd.rs:22:45\n   |\n22 |             result.push_str(&letters[letter\
    \ + index]);\n   |                                      ------ ^ ----- {integer}\n\
    \   |                                      |\n   |                           \
    \           char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprc4337sd.rs:28:25\n\
    \   |\n28 |         result.push_str(&letters[vowels.len() - index]);\n   |   \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    let mut l = letters.len();\n    while i < message.len()\
    \ {\n        if message[i] == ' ' {\n            result.push_str(&message[i..]);\n\
    \            break;\n        }\n        if message[i] == letters[k] {\n      \
    \      result.push_str(&message[i..]);\n            i += 1;\n            k +=\
    \ 1;\n            if k == l {\n                k = 0;\n                i += 1;\n\
    \            }\n            continue;\n        }\n        if message[i] == vowels[j]\
    \ {\n            result.push_str(&message[i..]);\n            i += 1;\n      \
    \      j += 1;\n            if j == l {\n                j = 0;\n            \
    \    i += 1;\n            }\n            continue;\n        }\n        result.push_str(&message[i..]);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd3x85imh.rs:20:12\n\
    \   |\n20 |         if message[i] == ' ' {\n   |            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpd3x85imh.rs:24:12\n   |\n24 |         if message[i]\
    \ == letters[k] {\n   |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd3x85imh.rs:34:12\n\
    \   |\n34 |         if message[i] == vowels[j] {\n   |            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut count = 1;\n    let\
    \ mut last = 0;\n    for c in message.chars() {\n        if let Some(vowel) =\
    \ vowels.binary_search(&c) {\n            if index != 0 {\n                result.push(*last);\n\
    \            }\n            index = vowel;\n            count = 1;\n         \
    \   last = c;\n        } else if let Some(letter) = letters.binary_search(&c)\
    \ {\n            if index != 0 {\n                result.push(*last);\n      \
    \      }\n            index = letter;\n            count = 2;\n            last\
    \ = c;\n        } else {\n            result.push(c);\n        }\n    }\n    if\
    \ index != 0 {\n        result.push(*last);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgdw7_gei.rs:19:16\n   |\n\
    19 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \     ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0614]: type `{integer}` cannot\
    \ be dereferenced\n  --> /tmp/tmpgdw7_gei.rs:21:29\n   |\n21 |               \
    \  result.push(*last);\n   |                             ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgdw7_gei.rs:25:20\n   |\n25 |             last\
    \ = c;\n   |                    ^ expected integer, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgdw7_gei.rs:26:23\n   |\n26 |         } else\
    \ if let Some(letter) = letters.binary_search(&c) {\n   |                    \
    \   ^^^^^^^^^^^^   ------------------------- this expression has type `Result<usize,\
    \ usize>`\n   |                       |\n   |                       expected enum\
    \ `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0614]: type `{integer}`\
    \ cannot be dereferenced\n  --> /tmp/tmpgdw7_gei.rs:28:29\n   |\n28 |        \
    \         result.push(*last);\n   |                             ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgdw7_gei.rs:32:20\n   |\n32 |             last\
    \ = c;\n   |                    ^ expected integer, found `char`\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpgdw7_gei.rs:38:21\n \
    \  |\n38 |         result.push(*last);\n   |                     ^^^^^\n\nerror:\
    \ aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letter_counter = 0;\n    let mut letter_counter2\
    \ = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4 = 0;\n \
    \   let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n    let mut\
    \ letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut letter_counter9\
    \ = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11 = 0;\n\
    \    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n    let\
    \ mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let mut letter_counter16\
    \ = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18 = 0;\n\
    \    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n    let\
    \ mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let mut letter_counter23\
    \ = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25 = 0;\n\
    \    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n    let\
    \ mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let mut letter_counter30\
    \ = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32 = 0;\n\
    \    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n    let\
    \ mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let mut letter_counter37\
    \ = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39 = 0;\n\
    \    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n    let\
    \ mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let mut letter_counter44\
    \ = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46 = 0;\n\
    \    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n    let\
    \ mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let mut letter_counter51\
    \ = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53 = 0;\n\
    \    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n    let\
    \ mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let mut letter_counter58\
    \ = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60 = 0;\n\
    \    let mut letter_counter61 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3tagrsrj.rs:76:1\n\
    \   |\n76 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index = 0;\n    let mut letter_count_index2\
    \ = 0;\n    let mut letter_count_index3 = 0;\n    let mut letter_count_index4\
    \ = 0;\n    let mut letter_count_index5 = 0;\n    let mut letter_count_index6\
    \ = 0;\n    let mut letter_count_index7 = 0;\n    let mut letter_count_index8\
    \ = 0;\n    let mut letter_count_index9 = 0;\n    let mut letter_count_index10\
    \ = 0;\n    let mut letter_count_index11 = 0;\n    let mut letter_count_index12\
    \ = 0;\n    let mut letter_count_index13 = 0;\n    let mut letter_count_index14\
    \ = 0;\n    let mut letter_count_index15 = 0;\n    let mut letter_count_index16\
    \ = 0;\n    let mut letter_count_index17 = 0;\n    let mut letter_count_index18\
    \ = 0;\n    let mut letter_count_index19 = 0;\n    let mut letter_count_index20\
    \ = 0;\n    let mut letter_count_index21 = 0;\n    let mut letter_count_index22\
    \ = 0;\n    let mut letter_count_index23 = 0;\n    let mut letter_count_index24\
    \ = 0;\n    let mut letter_count_index25 = 0;\n    let mut letter_count_index26\
    \ = 0;\n    let mut letter_count_index27 = 0;\n    let mut letter_count_index28\
    \ = 0;\n    let mut letter_count_index29 = 0;\n    let mut letter_count_index30\
    \ = 0;\n    let mut letter_count_index31 = 0;\n    let mut letter_count_index32\
    \ = 0;\n    let mut letter_count_index33 = 0;\n    let mut letter_count_index34\
    \ = 0;\n    let mut letter_count_index35 = 0;\n    let mut letter_count_index36\
    \ = 0;\n    let mut letter_count_index37 = 0;\n    let mut letter_count_index38\
    \ = 0;\n    let mut letter_count_index39 = 0;\n    let mut letter_count_index40\
    \ = 0;\n    let mut letter_count_index41 = 0;\n    let mut letter_count_index42\
    \ = 0;\n    let mut letter_count_index43 = 0;\n    let mut letter_count_index44\
    \ = 0;\n    let mut letter_count_index45 = 0;\n    let mut letter_count_index46\
    \ = 0;\n    let mut letter_count_index47 = 0;\n    let mut letter_count_index48\
    \ = 0;\n    let mut letter_count_index49 = 0;\n    let mut letter_count_index50\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdeu33i5z.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdeu33i5z.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let\
    \ mut current = 0;\n    let mut currentVowel = 0;\n    let mut currentLetter =\
    \ 0;\n    let mut currentLetterVowel = 0;\n    let mut currentLetterVowel2 = 0;\n\
    \    \n    for letter in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            currentVowel = vowel;\n            currentLetter = index;\n \
    \           currentLetterVowel = currentVowel;\n            currentLetterVowel2\
    \ = currentVowel;\n            \n            vowels.remove(vowel);\n         \
    \   \n            encoded.push_str(&vowels[currentVowel]);\n            \n   \
    \         currentVowel = vowel;\n            currentLetter = index;\n        \
    \    currentLetterVowel = currentVowel;\n            currentLetterVowel2 = currentVowel;\n\
    \            \n            vowels.remove(vowel);\n            \n            encoded.push_str(&vowels[currentVowel]);\n\
    \            \n            currentVowel = vowel;\n            currentLetter =\
    \ index;\n            currentLetterVowel = currentVowel;\n            currentLetterVowel2\
    \ = currentVowel;\n            \n            vowels.remove(vowel);\n         \
    \   \n            encoded.push_str(&vowels[currentVowel]);\n            \n   \
    \         currentVowel = vowel;\n            currentLetter = index;\n        \
    \    currentLetterVowel = currentVowel;\n            currentLetterVowel2 = currentVowel;\n\
    \            \n            vowels.remove(vowel);\n            \n            encoded.push_str(&vowels[currentVowel]);\n\
    \            \n            currentVowel = vowel;\n            currentLetter =\
    \ index;\n            currentLetterVowel = currentVowel;\n            currentLetterVowel2\
    \ = currentVowel;\n            \n            vowels.remove(vowel);\n         \
    \   \n            encoded.push_str(&vowels[currentVowel]);\n            \n   \
    \         currentVowel = vowel;\n            currentLetter = index;\n        \
    \    currentLetterVowel = currentVowel;\n            currentLetterVowel2 = currentVowel;\n\
    \            \n            vowel\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpovnl_v2g.rs:83:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n21 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n22 |       \
    \  if let Some(vowel) = vowels.binary_search(&letter) {\n   |                \
    \                                            - this delimiter might not be properly\
    \ closed...\n...\n74 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n83 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpovnl_v2g.rs:22:16\n\
    \   |\n22 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |\
    \                ^^^^^^^^^^^   ----------------------------- this expression has\
    \ type `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpovnl_v2g.rs:30:30\n   |\n30 |             encoded.push_str(&vowels[currentVowel]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpovnl_v2g.rs:39:30\n\
    \   |\n39 |             encoded.push_str(&vowels[currentVowel]);\n   |       \
    \                       ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n \
    \  |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpovnl_v2g.rs:48:30\n   |\n48 |\
    \             encoded.push_str(&vowels[currentVowel]);\n   |                 \
    \             ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpovnl_v2g.rs:57:30\n   |\n57 |             encoded.push_str(&vowels[currentVowel]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter.is_uppercase() {\n            if letter_counter\
    \ < 2 {\n                result.push((&vowels[vowel_counter]).to_string());\n\
    \                vowel_counter++;\n            }\n            result.push((&letter).to_string());\n\
    \            letter_counter++;\n        } else {\n            result.push((&letter).to_string());\n\
    \        }\n    }\n    if letter_counter < 2 {\n        for _ in 0..(letter_counter\
    \ - 1) {\n            result.push((&vowels[vowel_counter]).to_string());\n   \
    \         vowel_counter++;\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpof9v_6hi.rs:20:31\n\
    \   |\n20 |                 vowel_counter++;\n   |                           \
    \    ^ expected expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpof9v_6hi.rs:23:28\n\
    \   |\n23 |             letter_counter++;\n   |                            ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpof9v_6hi.rs:31:27\n\
    \   |\n31 |             vowel_counter++;\n   |                           ^ expected\
    \ expression\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpof9v_6hi.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpof9v_6hi.rs:22:25\n   |\n22 |             result.push((&letter).to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpof9v_6hi.rs:25:25\n\
    \   |\n25 |             result.push((&letter).to_string());\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp86u40m72.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n   \
    \     } else {\n            letters.insert(c.to_uppercase());\n        }\n   \
    \ }\n    for c in letters.iter() {\n        if vowels.contains(&c) {\n       \
    \     result.push(c);\n        } else {\n            result.push((&c + &c.to_lowercase()).to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmplgs9px5p.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmplgs9px5p.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0369]: cannot add `&ToLowercase`\
    \ to `&char`\n  --> /tmp/tmplgs9px5p.rs:26:29\n   |\n26 |             result.push((&c\
    \ + &c.to_lowercase()).to_string());\n   |                          -- ^ -----------------\
    \ &ToLowercase\n   |                          |\n   |                        \
    \  &char\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0369, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0369`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut alphabet = vec![\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"];\n    let mut index = 0;\n    let mut count = 1;\n    for c in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&c) {\n            count\
    \ += 1;\n            vowels.remove(vowel);\n        }\n        if let Some(letter)\
    \ = alphabet.binary_search(&c) {\n            count += 1;\n            alphabet.remove(letter);\n\
    \        }\n        if count == 2 {\n            result += &alphabet[index];\n\
    \            index += 1;\n            count = 1;\n        }\n        result +=\
    \ &c;\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqv3jcc49.rs:18:51\n   |\n\
    18 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \                                        ^^ expected `&str`, found `char`\n  \
    \ |\n   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqv3jcc49.rs:18:16\n   |\n18 |\
    \         if let Some(vowel) = vowels.binary_search(&c) {\n   |              \
    \  ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqv3jcc49.rs:22:54\n   |\n22 |         if let Some(letter) = alphabet.binary_search(&c)\
    \ {\n   |                                                      ^^ expected `&str`,\
    \ found `char`\n   |\n   = note: expected reference `&&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqv3jcc49.rs:22:16\n\
    \   |\n22 |         if let Some(letter) = alphabet.binary_search(&c) {\n   | \
    \               ^^^^^^^^^^^^   -------------------------- this expression has\
    \ type `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqv3jcc49.rs:31:19\n   |\n31 |         result += &c;\n   |     \
    \              ^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    vowels.insert(String::from('a'));\n    vowels.insert(String::from('e'));\n\
    \    vowels.insert(String::from('i'));\n    vowels.insert(String::from('o'));\n\
    \    vowels.insert(String::from('u'));\n    vowels.insert(String::from('y'));\n\
    \    vowels.insert(String::from('A'));\n    vowels.insert(String::from('E'));\n\
    \    vowels.insert(String::from('I'));\n    vowels.insert(String::from('O'));\n\
    \    vowels.insert(String::from('U'));\n    vowels.insert(String::from('Y'));\n\
    \    for c in message.chars() {\n        if vowels.contains(&c) {\n          \
    \  result.push(c);\n        } else {\n            result.push((&c.to_string()[..]).chars().next().unwrap());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpjgdhe1lb.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut i = 0;\n    while i < message.len() {\n  \
    \      if let Some(vowel) = vowels.binary_search(&message[i]) {\n            result.push_str(&letters[vowel\
    \ + 2]);\n        } else {\n            result.push_str(&message[i]);\n      \
    \  }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqzbi42ix.rs:17:52\n\
    \   |\n17 |         if let Some(vowel) = vowels.binary_search(&message[i]) {\n\
    \   |                                                    ^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqzbi42ix.rs:17:16\n\
    \   |\n17 |         if let Some(vowel) = vowels.binary_search(&message[i]) {\n\
    \   |                ^^^^^^^^^^^   --------------------------------- this expression\
    \ has type `Result<usize, usize>`\n   |                |\n   |               \
    \ expected enum `Result`, found enum `Option`\n   |\n   = note: expected enum\
    \ `Result<usize, usize>`\n              found enum `Option<_>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqzbi42ix.rs:20:30\n\
    \   |\n20 |             result.push_str(&message[i]);\n   |                  \
    \            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message {\n        if letter in vowels {\n         \
    \   vowel_counter++;\n        }\n        if letter in letters {\n            letter_counter++;\n\
    \        }\n    }\n    for letter in message {\n        if letter in vowels {\n\
    \            if letter_counter == 2 {\n                result.push_str(&vowels[vowel_counter\
    \ - 2]);\n                letter_counter = 0;\n                vowel_counter--;\n\
    \            } else {\n                result.push_str(&vowels[vowel_counter -\
    \ 1]);\n                letter_counter = 0;\n                vowel_counter--;\n\
    \            }\n        } else {\n            if letter_counter == 2 {\n     \
    \           result.push_str(&letters[letter_counter - 2]);\n                letter_counter\
    \ = 0;\n            } else {\n                result.push_str(&letters[letter_counter\
    \ - 1]);\n                letter_counter = 0;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp4yqlk800.rs:18:19\n\
    \   |\n18 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror: expected `{`, found keyword `in`\n  --> /tmp/tmp4yqlk800.rs:26:19\n\
    \   |\n26 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmp4yqlk800.rs:17:19\n\
    \    |\n17  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmp4yqlk800.rs:25:19\n\
    \    |\n25  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_index = 0;\n    let mut letters_index\
    \ = 0;\n    let mut i = 0;\n    while i < message.len() {\n        if message[i]\
    \ == ' ' {\n            result.push_str(\" \");\n            i += 1;\n       \
    \     continue;\n        }\n        if message[i] == letters[letters_index] {\n\
    \            result.push_str(&vowels[vowels_index]);\n            i += 1;\n  \
    \          vowels_index += 1;\n            letters_index += 1;\n            continue;\n\
    \        }\n        if message[i] == vowels[vowels_index] {\n            result.push_str(&letters[letters_index]);\n\
    \            i += 1;\n            vowels_index += 1;\n            letters_index\
    \ += 1;\n            continue;\n        }\n        if message[i] == letters[letters_index]\
    \ {\n            result.push_str(&vowels[vowels_index]);\n            i += 1;\n\
    \            vowels_index += 1;\n            letters_index += 1;\n           \
    \ continue;\n        }\n        if message[i] == vowels[vowels_index] {\n    \
    \        result.push_str(&letters[letters_index]);\n            i += 1;\n    \
    \        vowels_index += 1;\n            letters_index += 1;\n            continue;\n\
    \        }\n        if message[i] == letters[letters_index] {\n            result.push_str(&vowels[vowels_index]);\n\
    \            i += 1;\n            vowels_index += 1;\n            letters_index\
    \ += 1;\n            continue;\n        }\n        if message[i] == vowels[vowels_index]\
    \ {\n            result.push_str(&letters[letters_index]);\n            i += 1;\n\
    \            vowels_index += 1;\n            letters_index += 1;\n           \
    \ continue;\n        }\n        if message[i] == letters[letters_index] {\n  \
    \          result.push_str(&vowels[vowels_index]);\n            i += 1;\n    \
    \        vowels_index += 1;\n            letters_index += 1;\n            continue;\n\
    \        }\n        if message[i] == vowels[vowels_index] {\n            result.push_str(&letters[letters_index]);\n\
    \            i += 1;\n            vowels_index += 1;\n            letters_index\
    \ += 1;\n            continue;\n        }\n        if message[i] == letters[letters_index]\
    \ {\n            result.push_str(&vowels[vowels_index]);\n            i += 1;\n\
    \            vowels_index += 1;\n            letters_index += 1;\n           \
    \ continue;\n        }\n        if message[i] == vowels[vowels_index] {\n    \
    \        result.push_str(&letters[letters_index]);\n            \n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmv59ue94.rs:99:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < message.len()\
    \ {\n   |                             - unclosed delimiter\n...\n87 |        \
    \ if message[i] == vowels[vowels_index] {\n   |                              \
    \                 - this delimiter might not be properly closed...\n...\n90 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n99 |\
    \ }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmv59ue94.rs:19:12\n   |\n19 |         if message[i] == ' ' {\n\
    \   |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmv59ue94.rs:24:12\n\
    \   |\n24 |         if message[i] == letters[letters_index] {\n   |          \
    \  ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpmv59ue94.rs:31:12\n   |\n31 |  \
    \       if message[i] == vowels[vowels_index] {\n   |            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpmv59ue94.rs:38:12\n   |\n38 |         if message[i]\
    \ == letters[letters_index] {\n   |            ^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpmv59ue94.rs:45:12\n   |\n45 |         if message[i] == vowels[vowels_index]\
    \ {\n   |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm"
  stdout: ''
  timestamp: 1659747167
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for c in message.chars() {\n        if vowels.contains(&c) {\n   \
    \         vowel_counter += 2;\n        }\n        if letters.contains(&c) {\n\
    \            letter_counter += 2;\n        }\n        if vowel_counter > letter_counter\
    \ {\n            result.push(c);\n        } else {\n            result.push(letters[letter_counter]);\n\
    \            letter_counter += 2;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"CGKO\"`,\n right: `\"tgst\"`', /tmp/tmp40cbx2zl.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\
    \ 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\
    \ 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\
    \ 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\
    \ 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\
    \ 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\
    \ 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut letters_index_2\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpt103wqzb.rs:19:1\n   |\n19 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpt103wqzb.rs:18:35\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n18 |     let mut letters_index_2 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, \n   |                \
    \                   ^ unclosed delimiter\n19 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_counter = 0;\n    let mut letter = String::new();\n    let mut letter_index\
    \ = String::new();\n    let mut letter_counter_index = 0;\n    let mut letter_counter_index2\
    \ = 0;\n    let mut letter_counter_index3 = 0;\n    let mut letter_counter_index4\
    \ = 0;\n    let mut letter_counter_index5 = 0;\n    let mut letter_counter_index6\
    \ = 0;\n    let mut letter_counter_index7 = 0;\n    let mut letter_counter_index8\
    \ = 0;\n    let mut letter_counter_index9 = 0;\n    let mut letter_counter_index10\
    \ = 0;\n    let mut letter_counter_index11 = 0;\n    let mut letter_counter_index12\
    \ = 0;\n    let mut letter_counter_index13 = 0;\n    let mut letter_counter_index14\
    \ = 0;\n    let mut letter_counter_index15 = 0;\n    let mut letter_counter_index16\
    \ = 0;\n    let mut letter_counter_index17 = 0;\n    let mut letter_counter_index18\
    \ = 0;\n    let mut letter_counter_index19 = 0;\n    let mut letter_counter_index20\
    \ = 0;\n    let mut letter_counter_index21 = 0;\n    let mut letter_counter_index22\
    \ = 0;\n    let mut letter_counter_index23 = 0;\n    let mut letter_counter_index24\
    \ = 0;\n    let mut letter_counter_index25 = 0;\n    let mut letter_counter_index26\
    \ = 0;\n    let mut letter_counter_index27 = 0;\n    let mut letter_counter_index28\
    \ = 0;\n    let mut letter_counter_index29 = 0;\n    let mut letter_counter_index30\
    \ = 0;\n    let mut letter_counter_index31 = 0;\n    let mut letter_counter_index32\
    \ = 0;\n    let mut letter_counter_index33 = 0;\n    let mut letter_counter_index34\
    \ = 0;\n    let mut letter_counter_index35 = 0;\n    let mut letter_counter_index36\
    \ = 0;\n    let mut letter_counter_index37 = 0;\n    let mut letter_counter_index38\
    \ = 0;\n    let mut letter_counter_index39 = 0;\n    let mut letter_counter_index40\
    \ = 0;\n    let mut letter_counter_index41 = 0;\n    let mut letter_counter_index42\
    \ = 0;\n    let mut letter_counter_index43 = 0;\n    let mut letter_counter_index44\
    \ = 0;\n    let mut letter_counter_index45 = 0;\n    let mut letter_counter_index46\
    \ = 0;\n    let mut letter_counter_index47 = 0;\n    let mut letter_counter_index48\
    \ = 0;\n    let mut letter_counter_index49 = 0;\n    let mut letter_counter_index50\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4nzjg_q3.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4nzjg_q3.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_idx = 0;\n    let mut vowels_idx_prev = 0;\n    let mut letter_counts\
    \ = HashMap::new();\n    let mut letter_counts_idx = 0;\n    let mut letter_counts_idx_prev\
    \ = 0;\n    let mut letter_counts_prev = 0;\n    let mut letter_counts_prev_idx\
    \ = 0;\n    let mut letter_counts_prev_idx_prev = 0;\n    let mut letter_counts_prev_idx_prev_idx\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev = 0;\n    let\
    \ mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev\
    \ = 0;\n    let mut letter_counts_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx_prev_idx\
    \ = 0;\n    let mut letter_count\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzh9s0vrl.rs:42:25\n   |\n\
    42 |     let mut letter_count\n   |                         ^ help: add `;` here\n\
    43 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpzh9s0vrl.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpzh9s0vrl.rs:16:29\n   |\n16 |     let mut letter_counts = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzh9s0vrl.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = 0;\n    let mut letter_count = 1;\n    for letter\
    \ in message.chars() {\n        if let Some(vowel) = vowels.find(&letter) {\n\
    \            result.push_str(&vowels[vowels_index]);\n            vowels_index\
    \ += 2;\n        } else {\n            result.push_str(&letter);\n           \
    \ vowels.insert(letter);\n            vowels_index += 1;\n        }\n        if\
    \ vowels_index == vowels.len() {\n            vowels_index = 0;\n            letter_count\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpw3fyr69i.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw3fyr69i.rs:21:29\n   |\n21 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_idx = 0;\n    let mut letter_counter = 0;\n    let mut letter_counter2\
    \ = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4 = 0;\n \
    \   let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n    let mut\
    \ letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut letter_counter9\
    \ = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11 = 0;\n\
    \    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n    let\
    \ mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let mut letter_counter16\
    \ = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18 = 0;\n\
    \    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n    let\
    \ mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let mut letter_counter23\
    \ = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25 = 0;\n\
    \    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n    let\
    \ mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let mut letter_counter30\
    \ = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32 = 0;\n\
    \    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n    let\
    \ mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let mut letter_counter37\
    \ = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39 = 0;\n\
    \    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n    let\
    \ mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let mut letter_counter44\
    \ = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46 = 0;\n\
    \    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n    let\
    \ mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let mut letter_counter51\
    \ = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53 = 0;\n\
    \    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n    let\
    \ mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let mut letter_counter58\
    \ = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60 = 0;\n\
    \    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp_orvhl4e.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmp_orvhl4e.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    let mut l = letters.len();\n    while i < message.len() {\n      \
    \  if message[i] == ' ' {\n            result.push_str(&message[i..]);\n     \
    \       break;\n        }\n        if message[i] == letters[k] {\n           \
    \ result.push_str(&message[i..]);\n            i += 1;\n            k += 1;\n\
    \            continue;\n        }\n        if message[i] == letters[j] {\n   \
    \         result.push_str(&message[i..]);\n            i += 1;\n            j\
    \ += 1;\n            continue;\n        }\n        if message[i] == vowels[k]\
    \ {\n            result.push_str(&message[i..]);\n            i += 1;\n      \
    \      k += 1;\n            continue;\n        }\n        if message[i] == vowels[j]\
    \ {\n            result.push_str(&message[i..]);\n            i += 1;\n      \
    \      j += 1;\n            continue;\n        }\n        if message[i] == letters[k]\
    \ && message[i] == letters[j] {\n            result.push_str(&message[i..]);\n\
    \            i += 1;\n            k += 1;\n            j += 1;\n            continue;\n\
    \        }\n        if message[i] == letters[k] && message[i] == vowels[j] {\n\
    \            result.push_str(&message[i..]);\n            i += 1;\n          \
    \  k += 1;\n            j += 1;\n            continue;\n        }\n        if\
    \ message[i] == vowels[k] && message[i] == letters[j] {\n            result.push_str(&message[i..]);\n\
    \            i += 1;\n            k += 1;\n            j += 1;\n            continue;\n\
    \        }\n        if message[i] == vowels[j] && message[i] == letters[k] {\n\
    \            result.push_str(&message[i..]);\n            i += 1;\n          \
    \  j += 1;\n            k += 1;\n            continue;\n        }\n        if\
    \ message[i] == letters[k] && message[i] == vowels[j] {\n            result.push_str(&message[i..]);\n\
    \            i += 1;\n            k += 1;\n            j += 1;\n            continue;\n\
    \        }\n        if message[i] == vowels[j] && message[i] == vowels[k] {\n\
    \            result.push_str(&message[i..]);\n            i += 1;\n          \
    \  j += 1;\n            k += 1;\n            continue;\n        }\n        if\
    \ message[i] == letters[k] && message[i] == letters[j] && message[i] == vowels[j]\
    \ {\n            result.push_str(&message[i..]);\n            i += 1;\n      \
    \      k += \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgzhm3oto.rs:103:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n19  |     while i < message.len()\
    \ {\n    |                             - unclosed delimiter\n...\n90  |      \
    \   if message[i] == letters[k] && message[i] == letters[j] && message[i] == vowels[j]\
    \ {\n    |                                                                   \
    \                         - this delimiter might not be properly closed...\n...\n\
    94  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    103 | }\n    |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpgzhm3oto.rs:94:1\n\
    \   |\n94 | }\n   | ^ expected expression\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpgzhm3oto.rs:20:12\n   |\n20 |         if\
    \ message[i] == ' ' {\n   |            ^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgzhm3oto.rs:24:12\n\
    \   |\n24 |         if message[i] == letters[k] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpgzhm3oto.rs:30:12\n   |\n30 |         if message[i]\
    \ == letters[j] {\n   |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgzhm3oto.rs:36:12\n\
    \   |\n36 |         if message[i] == vowels[k] {\n   |            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpgzhm3oto.rs:42:12\n   |\n42 |         if message[i]\
    \ == vowels[j] {\n   |            ^^^^^^^^^^ `String` cannot be ind"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_lowercase() {\n            letters.insert(c);\n        } else {\n\
    \            vowels.insert(c);\n        }\n    }\n    for c in letters.iter()\
    \ {\n        let mut i = 0;\n        while i < vowels.len() {\n            if\
    \ c == vowels.get(i) {\n                result.push(c);\n                i +=\
    \ 2;\n                break;\n            }\n            i += 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpci7f2xuy.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpci7f2xuy.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_counter = 0;\n    let\
    \ mut letters_counter = 0;\n    for c in message.chars() {\n        if c.is_uppercase()\
    \ {\n            letters.insert(c);\n            letters_counter += 1;\n     \
    \   } else {\n            vowels.insert(c);\n            vowels_counter += 1;\n\
    \        }\n    }\n    let mut i = 0;\n    while i < message.len() {\n       \
    \ if letters.contains(&message[i]) {\n            result.push((message[i] - 'A'\
    \ + 2) as char);\n            i += 1;\n        } else if vowels.contains(&message[i])\
    \ {\n            result.push((message[i] - 'A' + 1) as char);\n            i +=\
    \ 1;\n        } else {\n            result.push(message[i]);\n            i +=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmph3sjm530.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmph3sjm530.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmph3sjm530.rs:28:30\n   |\n28 |  \
    \       if letters.contains(&message[i]) {\n   |                             \
    \ ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmph3sjm530.rs:29:26\n   |\n29 |  \
    \           result.push((message[i] - 'A' + 2) as char);\n   |               \
    \           ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmph3sjm530.rs:31:36\n\
    \   |\n31 |         } else if vowels.contains(&message[i]) {\n   |           \
    \                         ^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph3sjm530.rs:32:26\n\
    \   |\n32 |             result.push((message[i] - 'A' + 1) as char);\n   |   \
    \                       ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph3sjm530.rs:35:25\n\
    \   |\n35 |             result.push(message[i]);\n   |                       \
    \  ^^^^^^^^^^ `String` cannot be indexed by `usize`\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt5pak0fg.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut current = 0;\n    let mut next = 0;\n    let mut last = 0;\n    let\
    \ mut currentLetter = String::new();\n    let mut nextLetter = String::new();\n\
    \    let mut lastLetter = String::new();\n    let mut currentVowel = String::new();\n\
    \    let mut nextVowel = String::new();\n    let mut lastVowel = String::new();\n\
    \    let mut currentLetterIndex = String::new();\n    let mut nextLetterIndex\
    \ = String::new();\n    let mut lastLetterIndex = String::new();\n    let mut\
    \ currentVowelIndex = String::new();\n    let mut nextVowelIndex = String::new();\n\
    \    let mut lastVowelIndex = String::new();\n    let mut currentVowelIndex =\
    \ String::new();\n    let mut nextVowelIndex = String::new();\n    let mut lastVowelIndex\
    \ = String::new();\n    let mut currentLetterIndex = String::new();\n    let mut\
    \ nextLetterIndex = String::new();\n    let mut lastLetterIndex = String::new();\n\
    \    let mut currentVowelIndex = String::new();\n    let mut nextVowelIndex =\
    \ String::new();\n    let mut lastVowelIndex = String::new();\n    let mut currentVowelIndex\
    \ = String::new();\n    let mut nextVowelIndex = String::new();\n    let mut lastVowelIndex\
    \ = String::new();\n    let mut currentVowelIndex = String::new();\n    let mut\
    \ nextVowelIndex = String::new();\n    let mut lastVowelIndex = String::new();\n\
    \    let mut currentVowelIndex = String::new();\n    let mut nextVowelIndex =\
    \ String::new();\n    let mut lastVowelIndex = String::new();\n    let mut currentVowelIndex\
    \ = String::new();\n    let mut nextVowelIndex = String::new();\n    let mut lastVowelIndex\
    \ = String::new();\n    let mut currentVow\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbvkz26p2.rs:52:23\n   |\n\
    52 |     let mut currentVow\n   |                       ^ help: add `;` here\n\
    53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbvkz26p2.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut alphabet = HashSet::new();\n\
    \    let mut alphabet = HashSet::\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpmiuuva2i.rs:59:1\n\
    \   |\n59 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpmiuuva2i.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpmiuuva2i.rs:14:24\n   |\n14 |  \
    \   let mut alphabet = HashSet::new();\n   |                        ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpmiuuva2i.rs:15:24\n   |\n15 |  \
    \   let mut alphabet = HashSet::new();\n   |                        ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpmiuuva2i.rs:16:24\n   |\n16 |  \
    \   let mut alphabet = HashSet::new();\n   |                        ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpmiuuva2i.rs:17:24\n   |\n17 |  \
    \   let mut alphabet = HashSet::new();\n   |                        ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpmiuuva2i.rs:18:24\n   |\n18 |  \
    \   let mut alphabet = HashSet::new();\n   |                        ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpmiuuva2i.rs:19:24\n   |\n19 |  \
    \   let mut alphabet = HashSet::new();\n   |                "
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter =\
    \ 0;\n    let mut letters_counter = 0;\n    for letter in message.chars() {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            if letter == vowels[vowels_counter] {\n                result.push_str(&vowels[vowels_counter]);\n\
    \                vowels_counter += 1;\n            } else {\n                result.push_str(&letters[letters_counter]);\n\
    \                letters_counter += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu8q95rks.rs:22:33\n   |\n\
    22 |                 result.push_str(&vowels[vowels_counter]);\n   |         \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu8q95rks.rs:25:33\n   |\n25 |\
    \                 result.push_str(&letters[letters_counter]);\n   |          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut i = 0;\n    while i < message.len() {\n     \
    \   let mut j = i;\n        while j < message.len() && letters.contains(&message[j])\
    \ {\n            j = j + 1;\n        }\n        if j > i {\n            result.push_str(&message[i..j]);\n\
    \            result.push_str(&vowels[i as usize - j as usize]);\n            i\
    \ = j;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1rje01sm.rs:18:54\n\
    \   |\n18 |         while j < message.len() && letters.contains(&message[j]) {\n\
    \   |                                                      ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut index =\
    \ 0;\n    let mut index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n\
    \    let mut index5 = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n \
    \   let mut index8 = 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n \
    \   let mut index11 = 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n\
    \    let mut index14 = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n\
    \    let mut index17 = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n\
    \    let mut index20 = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n\
    \    let mut index23 = 0;\n    let mut index24 = 0;\n    let mut index25 = 0;\n\
    \    let mut index26 = 0;\n    let mut index27 = 0;\n    let mut index28 = 0;\n\
    \    let mut index29 = 0;\n    let mut index30 = 0;\n    let mut index31 = 0;\n\
    \    let mut index32 = 0;\n    let mut index33 = 0;\n    let mut index34 = 0;\n\
    \    let mut index35 = 0;\n    let mut index36 = 0;\n    let mut index37 = 0;\n\
    \    let mut index38 = 0;\n    let mut index39 = 0;\n    let mut index40 = 0;\n\
    \    let mut index41 = 0;\n    let mut index42 = 0;\n    let mut index43 = 0;\n\
    \    let mut index44 = 0;\n    let mut index45 = 0;\n    let mut index46 = 0;\n\
    \    let mut index47 = 0;\n    let mut index48 = 0;\n    let mut index49 = 0;\n\
    \    let mut index50 = 0;\n    let mut index51 = 0;\n    let mut index52 = 0;\n\
    \    let mut index53 = 0;\n    let mut index54 = 0;\n    let mut index55 = 0;\n\
    \    let mut index56 = 0;\n    let mut index57 = 0;\n    let mut index58 = 0;\n\
    \    let mut index59 = 0;\n    let mut index60 = 0;\n    let mut index61 = 0;\n\
    \    let mut index62 = 0;\n    let mut index63 = 0;\n    let mut index64 = 0;\n\
    \    let mut index65 = 0;\n    let mut index66 = 0;\n    let mut index67 = 0;\n\
    \    let mut index68 = 0;\n    let mut index69\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3d83j3gk.rs:83:20\n   |\n\
    83 |     let mut index69\n   |                    ^ help: add `;` here\n84 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3d83j3gk.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .chars();\n    let mut letter_pairs = vec![];\n    let mut letter_pair = vec![];\n\
    \    let mut letter_pair_count = 0;\n    let mut letter_pair_index = -1;\n   \
    \ let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let\
    \ mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let mut\
    \ letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index\
    \ = -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index =\
    \ -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n\
    \    let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n  \
    \  let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let\
    \ mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let mut\
    \ letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index\
    \ = -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index =\
    \ -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n\
    \    let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n  \
    \  let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let\
    \ mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let mut\
    \ letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index\
    \ = -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index =\
    \ -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n\
    \    let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n  \
    \  let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let\
    \ mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let mut\
    \ letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index\
    \ = -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index =\
    \ -1;\n    let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n\
    \    let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n  \
    \  let mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let\
    \ mut letter_pair_index = -1;\n    let mut letter_pair_index = -1;\n    let mut\
    \ letter_pair\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzz_5mzgc.rs:74:24\n   |\n\
    74 |     let mut letter_pair\n   |                        ^ help: add `;` here\n\
    75 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzz_5mzgc.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut i = 0;\n    for letter in message.chars() {\n\
    \        if let Some(vowel) = vowels.binary_search(&letter) {\n            result.push_str(&letters[vowel\
    \ + 2]);\n        } else {\n            result.push_str(&letters[letter]);\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp67nyciyn.rs:17:51\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \                                             ^^^^^^^ expected `&str`, found `char`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp67nyciyn.rs:17:16\n   |\n17 |\
    \         if let Some(vowel) = vowels.binary_search(&letter) {\n   |         \
    \       ^^^^^^^^^^^   ----------------------------- this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0277]: the type `[&str]` cannot\
    \ be indexed by `char`\n  --> /tmp/tmp67nyciyn.rs:20:30\n   |\n20 |          \
    \   result.push_str(&letters[letter]);\n   |                              ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[&str]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<&str>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_encoded = HashSet::new();\n\
    \    let mut letters_encoded = HashSet::new();\n    for c in message.chars() {\n\
    \        if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n\
    \        } else {\n            letters.insert(c.to_uppercase());\n        }\n\
    \    }\n    for c in message.chars() {\n        if c.is_uppercase() {\n      \
    \      vowels.insert(c.to_lowercase());\n        } else {\n            vowels.insert(c.to_uppercase());\n\
    \        }\n    }\n    for c in message.chars() {\n        if c.is_uppercase()\
    \ {\n            vowels_encoded.insert(c.to_lowercase());\n        } else {\n\
    \            vowels_encoded.insert(c.to_uppercase());\n        }\n    }\n    for\
    \ c in message.chars() {\n        if c.is_uppercase() {\n            letters_encoded.insert(c.to_lowercase());\n\
    \        } else {\n            letters_encoded.insert(c.to_uppercase());\n   \
    \     }\n    }\n    for c in message.chars() {\n        if letters.contains(&c)\
    \ {\n            encoded.push_str(&letters[&c]);\n        } else if vowels.contains(&c)\
    \ {\n            encoded.push_str(&vowels[&c]);\n        } else if vowels_encoded.contains(&c)\
    \ {\n            encoded.push_str(&vowels_encoded[&c]);\n        } else if letters_encoded.contains(&c)\
    \ {\n            encoded.push_str(&letters_encoded[&c]);\n        } else {\n \
    \           encoded.push_str(&c);\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpcrx45gt7.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpcrx45gt7.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpcrx45gt7.rs:15:30\n   |\n15\
    \ |     let mut vowels_encoded = HashSet::new();\n   |                       \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpcrx45gt7.rs:16:31\n   |\n16\
    \ |     let mut letters_encoded = HashSet::new();\n   |                      \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcrx45gt7.rs:55:30\n   |\n55 |             encoded.push_str(&c);\n\
    \   |                              ^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmppi4a1nri.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmppi4a1nri.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_letters\
    \ = vec![\"A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowel_letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\
    \ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,\
    \ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\
    \ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\
    \ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\
    \ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\
    \ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,\
    \ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\
    \ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\
    \ 240, 241, 242, 243, 244, 245, 246, 24\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp3gco4hhs.rs:17:1\n   |\n17 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp3gco4hhs.rs:16:39\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n16 |     let mut vowel_letters_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26, ...\n   |                                       ^ unclosed delimiter\n17\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter =\
    \ 0;\n    let mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let\
    \ mut letter_counter3 = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5\
    \ = 0;\n    let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n \
    \   let mut letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut\
    \ letter_counter10 = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12\
    \ = 0;\n    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n\
    \    let mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let\
    \ mut letter_counter17 = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19\
    \ = 0;\n    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n\
    \    let mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let\
    \ mut letter_counter24 = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26\
    \ = 0;\n    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n\
    \    let mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let\
    \ mut letter_counter31 = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33\
    \ = 0;\n    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n\
    \    let mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let\
    \ mut letter_counter38 = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40\
    \ = 0;\n    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n\
    \    let mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let\
    \ mut letter_counter45 = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47\
    \ = 0;\n    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n\
    \    let mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let\
    \ mut letter_counter52 = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54\
    \ = 0;\n    let mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n\
    \    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpeb79fex3.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n\
    \    let mut letter = String::new();\n    let mut letter_next = String::new();\n\
    \    let mut letter_next_next = String::new();\n    let mut letter_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next = String::new();\n\
    \    let mut letter_next_next_next_next_next = String::new();\n    let mut letter_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next = String::new();\n\
    \    let mut letter_next_next_next_next_next_next_next_next = String::new();\n\
    \    let mut letter_next_next_next_next_next_next_next_next_next = String::new();\n\
    \    let mut letter_next_next_next_next_next_next_next_next_next_next = String::new();\n\
    \    let mut letter_next_next_next_next_next_next_next_next_next_next_next = String::new();\n\
    \    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = String::new();\n    let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq73n3c5v.rs:40:80\n   |\n\
    40 |     let mut letter_next_next_next_next_next_next_next_next_next_next_next_next_\n\
    \   |                                                                        \
    \        ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq73n3c5v.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_2places = HashSet::new();\n    let mut vowels_3places = HashSet::new();\n\
    \    let mut vowels_4places = HashSet::new();\n    let mut vowels_5places = HashSet::new();\n\
    \    let mut vowels_6places = HashSet::new();\n    let mut vowels_7places = HashSet::new();\n\
    \    let mut vowels_8places = HashSet::new();\n    let mut vowels_9places = HashSet::new();\n\
    \    let mut vowels_10places = HashSet::new();\n    let mut vowels_11places =\
    \ HashSet::new();\n    let mut vowels_12places = HashSet::new();\n    let mut\
    \ vowels_13places = HashSet::new();\n    let mut vowels_14places = HashSet::new();\n\
    \    let mut vowels_15places = HashSet::new();\n    let mut vowels_16places =\
    \ HashSet::new();\n    let mut vowels_17places = HashSet::new();\n    let mut\
    \ vowels_18places = HashSet::new();\n    let mut vowels_19places = HashSet::new();\n\
    \    let mut vowels_20places = HashSet::new();\n    let mut vowels_21places =\
    \ HashSet::new();\n    let mut vowels_22places = HashSet::new();\n    let mut\
    \ vowels_23places = HashSet::new();\n    let mut vowels_24places = HashSet::new();\n\
    \    let mut vowels_25places = HashSet::new();\n    let mut vowels_26places =\
    \ HashSet::new();\n    let mut vowels_27places = HashSet::new();\n    let mut\
    \ vowels_28places = HashSet::new();\n    let mut vowels_29places = HashSet::new();\n\
    \    let mut vowels_30places = HashSet::new();\n    let mut vowels_31places =\
    \ HashSet::new();\n    let mut vowels_32places = HashSet::new();\n    let mut\
    \ vowels_33places = HashSet::new();\n    let mut vowels_34places = HashSet::new();\n\
    \    let mut vowels_35places = HashSet::new();\n    let mut vowels_36places =\
    \ HashSet::new();\n    let mu\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp17ou9sye.rs:49:11\n   |\n\
    49 |     let mu\n   |           ^ help: add `;` here\n50 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmp17ou9sye.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp17ou9sye.rs:14:30\n\
    \   |\n14 |     let mut vowels_2places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp17ou9sye.rs:15:30\n\
    \   |\n15 |     let mut vowels_3places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp17ou9sye.rs:16:30\n\
    \   |\n16 |     let mut vowels_4places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp17ou9sye.rs:17:30\n\
    \   |\n17 |     let mut vowels_5places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp17ou9sye.rs:18:30\n\
    \   |\n18 |     let mut vowels_6places = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet"
  stdout: ''
  timestamp: 1659747167
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    alphabet.insert(String::from(\"a\"\
    ));\n    alphabet.insert(String::from(\"b\"));\n    alphabet.insert(String::from(\"\
    c\"));\n    alphabet.insert(String::from(\"d\"));\n    alphabet.insert(String::from(\"\
    e\"));\n    alphabet.insert(String::from(\"f\"));\n    alphabet.insert(String::from(\"\
    g\"));\n    alphabet.insert(String::from(\"h\"));\n    alphabet.insert(String::from(\"\
    i\"));\n    alphabet.insert(String::from(\"j\"));\n    alphabet.insert(String::from(\"\
    k\"));\n    alphabet.insert(String::from(\"l\"));\n    alphabet.insert(String::from(\"\
    m\"));\n    alphabet.insert(String::from(\"n\"));\n    alphabet.insert(String::from(\"\
    o\"));\n    alphabet.insert(String::from(\"p\"));\n    alphabet.insert(String::from(\"\
    q\"));\n    alphabet.insert(String::from(\"r\"));\n    alphabet.insert(String::from(\"\
    s\"));\n    alphabet.insert(String::from(\"t\"));\n    alphabet.insert(String::from(\"\
    u\"));\n    alphabet.insert(String::from(\"v\"));\n    alphabet.insert(String::from(\"\
    w\"));\n    alphabet.insert(String::from(\"x\"));\n    alphabet.insert(String::from(\"\
    y\"));\n    alphabet.insert(String::from(\"z\"));\n    alphabet.insert(String::from(\"\
    A\"));\n    alphabet.insert(String::from(\"B\"));\n    alphabet.insert(String::from(\"\
    C\"));\n    alphabet.insert(String::from(\"D\"));\n    alphabet.insert(String::from(\"\
    E\"));\n    alphabet.insert(String::from(\"F\"));\n    alphabet.insert(String::from(\"\
    G\"));\n    alphabet.insert(String::from(\"H\"));\n    alphabet.insert(String::from(\"\
    I\"));\n    alphabet.insert(String::from(\"J\"));\n    alphabet.insert(String::from(\"\
    K\"));\n    alphabet.insert(String::from(\"L\"));\n    alphabet.insert(String::from(\"\
    M\"));\n    alphabet.insert(String::from(\"N\"));\n    alphabet.insert(String::from(\"\
    O\"));\n    alphabet.insert(String::from(\"P\"));\n    alphabet.insert(String::from(\"\
    Q\"));\n    alphabet.insert(String::from(\"\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpvpcfctc6.rs:67:109\n\
    \   |\n67 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    68 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut index = 0;\n    let mut current_letter = String::new();\n\
    \    let mut current_vowel = String::new();\n    let mut current_vowel_pos = 0;\n\
    \    \n    for letter in message.chars() {\n        if letter == ' ' {\n     \
    \       result.push_str(\" \");\n        } else {\n            result.push_str(&letters[letter]);\n\
    \        }\n    }\n    \n    for vowel in vowels {\n        let mut pos = 0;\n\
    \        for letter in message.chars() {\n            if letter == vowel {\n \
    \               pos = pos + 1;\n            }\n        }\n        \n        if\
    \ pos == 2 {\n            current_vowel = vowel;\n            current_vowel_pos\
    \ = pos;\n        }\n    }\n    \n    for letter in message.chars() {\n      \
    \  if letter == ' ' {\n            result.push_str(\" \");\n        } else {\n\
    \            result.push_str(&letters[letter]);\n        }\n    }\n    \n    for\
    \ letter in message.chars() {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            result.push_str(&letters[letter]);\n   \
    \     }\n    }\n    \n    for letter in message.chars() {\n        if letter ==\
    \ ' ' {\n            result.push_str(\" \");\n        } else {\n            result.push_str(&letters[letter]);\n\
    \        }\n    }\n    \n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  result.push_str(&letters[letter]);\n        }\n    }\n    \n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            result.push_str(&letters[letter]);\n   \
    \     }\n    }\n    \n    for letter in message.chars() {\n        if letter ==\
    \ ' ' {\n            result.push_str(\" \");\n        } else {\n            result.push_str(&letters[letter]);\n\
    \        }\n    }\n    \n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  result.push_str(&letters[letter]);\n        }\n    }\n    \n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            result.push_str(&letters[letter]);\n   \
    \     }\n    }\n    \n    for letter in message.chars() {\n        if letter ==\
    \ ' ' {\n            result.push_str(\" \");\n        } else {\n            result.push_str(&letters[letter]);\n\
    \        }\n    }\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[&str]` cannot be indexed by `char`\n  --> /tmp/tmp9svnajbc.rs:24:30\n\
    \   |\n24 |             result.push_str(&letters[letter]);\n   |             \
    \                 ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<&str>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9svnajbc.rs:31:26\n\
    \   |\n31 |             if letter == vowel {\n   |                          ^^^^^\
    \ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9svnajbc.rs:37:29\n\
    \   |\n37 |             current_vowel = vowel;\n   |                         \
    \    ^^^^^- help: try using a conversion method: `.to_string()`\n   |        \
    \                     |\n   |                             expected struct `String`,\
    \ found `&str`\n\nerror[E0277]: the type `[&str]` cannot be indexed by `char`\n\
    \  --> /tmp/tmp9svnajbc.rs:46:30\n   |\n46 |             result.push_str(&letters[letter]);\n\
    \   |                              ^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>` is not\
    \ implemented for `char`\n   = note: required because of the requirements on the\
    \ impl of `Index<char>` for `Vec<&str>`\n\nerror[E0277]: the type `[&str]` cannot\
    \ be indexed by `char`\n  --> /tmp/tmp9svnajbc.rs:54:30\n   |\n54 |          \
    \   result.push_str(&letters[letter]);\n   |                              ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[&str]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<&str>`\n\n\
    error[E0277]: the type `[&str]` cannot be indexed by `char`\n  --> /tmp/tmp9svnajbc.rs:62:30\n\
    \   |\n62 |             result.push_str(&letters[letter]);\n   |             \
    \                 ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    alphabet.insert(\"a\".to_string());\n\
    \    alphabet.insert(\"b\".to_string());\n    alphabet.insert(\"c\".to_string());\n\
    \    alphabet.insert(\"d\".to_string());\n    alphabet.insert(\"e\".to_string());\n\
    \    alphabet.insert(\"f\".to_string());\n    alphabet.insert(\"g\".to_string());\n\
    \    alphabet.insert(\"h\".to_string());\n    alphabet.insert(\"i\".to_string());\n\
    \    alphabet.insert(\"j\".to_string());\n    alphabet.insert(\"k\".to_string());\n\
    \    alphabet.insert(\"l\".to_string());\n    alphabet.insert(\"m\".to_string());\n\
    \    alphabet.insert(\"n\".to_string());\n    alphabet.insert(\"o\".to_string());\n\
    \    alphabet.insert(\"p\".to_string());\n    alphabet.insert(\"q\".to_string());\n\
    \    alphabet.insert(\"r\".to_string());\n    alphabet.insert(\"s\".to_string());\n\
    \    alphabet.insert(\"t\".to_string());\n    alphabet.insert(\"u\".to_string());\n\
    \    alphabet.insert(\"v\".to_string());\n    alphabet.insert(\"w\".to_string());\n\
    \    alphabet.insert(\"x\".to_string());\n    alphabet.insert(\"y\".to_string());\n\
    \    alphabet.insert(\"z\".to_string());\n    alphabet.insert(\"A\".to_string());\n\
    \    alphabet.insert(\"B\".to_string());\n    alphabet.insert(\"C\".to_string());\n\
    \    alphabet.insert(\"D\".to_string());\n    alphabet.insert(\"E\".to_string());\n\
    \    alphabet.insert(\"F\".to_string());\n    alphabet.insert(\"G\".to_string());\n\
    \    alphabet.insert(\"H\".to_string());\n    alphabet.insert(\"I\".to_string());\n\
    \    alphabet.insert(\"J\".to_string());\n    alphabet.insert(\"K\".to_string());\n\
    \    alphabet.insert(\"L\".to_string());\n    alphabet.insert(\"M\".to_string());\n\
    \    alphabet.insert(\"N\".to_string());\n    alphabet.insert(\"O\".to_string());\n\
    \    alphabet.insert(\"P\".to_string());\n    alphabet.insert(\"Q\".to_string());\n\
    \    alphabet.insert(\"R\".to_string());\n    alphabet.insert(\"S\".to_string());\n\
    \    alphabet.insert(\"T\".to_string());\n    alphabet.insert(\"U\".to_string());\n\
    \    alphabet.insert(\"V\".to_string());\n    alphabet.insert(\"W\".to_string());\n\
    \    alphabet.insert(\"X\".to_string());\n    alphabet.insert(\"Y\".to_string());\n\
    \    alphabet.insert(\"Z\".to_string());\n    vowels.insert(\"a\".to_string());\n\
    \    vowels.insert(\"\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpx81jz79i.rs:77:109\n\
    \   |\n77 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    78 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push_str(\" \");\n        } else {\n            if letter == vowels[vowel_counter]\
    \ {\n                vowel_counter = vowel_counter + 1;\n            } else {\n\
    \                vowel_counter = 0;\n            }\n            if letter == letters[letter_counter]\
    \ {\n                letter_counter = letter_counter + 1;\n            } else\
    \ {\n                letter_counter = 0;\n            }\n            result.push_str(&letters[letter_counter]);\n\
    \            result.push_str(&vowels[vowel_counter]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjpydi_ta.rs:31:29\n   |\n\
    31 |             result.push_str(&letters[letter_counter]);\n   |            \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjpydi_ta.rs:32:29\n   |\n32 |\
    \             result.push_str(&vowels[vowel_counter]);\n   |                 \
    \            ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            result.push_str(&vowels[vowel_counter]);\n            vowel_counter\
    \ += 1;\n        } else {\n            result.push_str(&letter);\n           \
    \ letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjmfgj3py.rs:17:28\n   |\n\
    17 |         if vowels.contains(&letter) {\n   |                            ^^^^^^^\
    \ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjmfgj3py.rs:21:29\n   |\n21 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n   \
    \     } else {\n            letters.insert(c.to_uppercase());\n        }\n   \
    \ }\n    for c in letters.keys() {\n        if vowels.contains(&c + &c + &c) {\n\
    \            continue;\n        }\n        vowels.insert(c + &c + &c);\n    }\n\
    \    for c in vowels.keys() {\n        let mut pos = 0;\n        for &c in &message\
    \ {\n            if c == c {\n                pos += 2;\n            }\n     \
    \   }\n        result.push_str(&message[..pos]);\n        result.push_str(&c);\n\
    \        result.push_str(&message[pos + 1..]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp8yd4vdes.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp8yd4vdes.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]: `&String` is\
    \ not an iterator\n   --> /tmp/tmp8yd4vdes.rs:30:19\n    |\n30  |         for\
    \ &c in &message {\n    |                   ^^^^^^^^ `&String` is not an iterator\n\
    \    |\n    = help: the trait `Iterator` is not implemented for `&String`\n  \
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmp8yd4vdes.rs:28:9\n\
    \   |\n28 |     for c in vowels.keys() {\n   |         ^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n  --> /tmp/tmp8yd4vdes.rs:28:14\n\
    \   |\n28 |     for c in vowels.keys() {\n   |              ^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp8yd4vdes.rs:28:5\n    |\n28  | /     for c in vowels.keys() {\n29  |\
    \ |         let mut pos = 0;\n30  | |         for &c in &message {\n31  | |  \
    \           if c == c {\n...   |\n37"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut letter_counter = 1;\n\
    \    let mut letter_counter_index = 0;\n    for letter in message.chars() {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            if letter_counter_index < vowels_index {\n                result.push_str(&vowels[letter_counter_index]);\n\
    \            } else {\n                result.push_str(&vowels[vowels_index]);\n\
    \            }\n            result.push_str(&letter);\n            letter_counter_index\
    \ += 1;\n            letter_counter += 1;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpez772dja.rs:22:34\n\
    \   |\n22 |                 result.push_str(&vowels[letter_counter_index]);\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpez772dja.rs:24:34\n   |\n24 |                 result.push_str(&vowels[vowels_index]);\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez772dja.rs:26:29\n\
    \   |\n26 |             result.push_str(&letter);\n   |                      \
    \       ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n   \
    \     } else {\n            letters.insert(c.to_uppercase());\n        }\n   \
    \ }\n    for c in letters.iter() {\n        if let Some(vowel) = vowels.entry(c).or_insert(c)\
    \ {\n            result.push_str(&vowel);\n            result.push_str(&vowels[c]);\n\
    \        } else {\n            result.push_str(&c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp189kfca0.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp189kfca0.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n  --> /tmp/tmp189kfca0.rs:23:21\n\
    \   |\n23 |         if let Some(vowel) = vowels.entry(c).or_insert(c) {\n   |\
    \                     ^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmp189kfca0.rs:23:16\n    |\n23  |\
    \         if let Some(vowel) = vowels.entry(c).or_insert(c) {\n    |         \
    \       ^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by `Some`\n\n\
    error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp189kfca0.rs:22:9\n   |\n22 |     for c in letters.iter()\
    \ {\n   |         ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n  --> /tmp/tmp189kfca0.rs:22:14\n   |\n22 |     for\
    \ c in letters.iter() {\n   |              ^^^^^^^^^^^^^^ doesn't have a size\
    \ known at compile-time\n   |\n   = help: the trait `Si"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3\
    \ = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n \
    \   let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut\
    \ letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10\
    \ = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n\
    \    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let\
    \ mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17\
    \ = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n\
    \    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let\
    \ mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24\
    \ = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n\
    \    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let\
    \ mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31\
    \ = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n\
    \    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let\
    \ mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38\
    \ = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n\
    \    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let\
    \ mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45\
    \ = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n\
    \    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let\
    \ mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52\
    \ = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n\
    \    let mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let\
    \ mut letter_counter57 = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59\
    \ = 0;\n    let mut letter_counter60\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbgn7i62w.rs:75:29\n   |\n\
    75 |     let mut letter_counter60\n   |                             ^ help: add\
    \ `;` here\n76 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpbgn7i62w.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpbgn7i62w.rs:14:23\n   |\n14 |  \
    \   let mut letters = HashSet::new();\n   |                       ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbgn7i62w.rs:11:31\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |    ------                     ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut i = 0;\n    for letter in message.chars() {\n \
    \       if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            result.push_str(&letters[letters.iter().position(|x| x == letter).unwrap()\
    \ + 1]);\n        }\n    }\n    for vowel in vowels {\n        let index = letters.iter().position(|x|\
    \ x == vowel).unwrap() + 1;\n        result.push_str(&letters[index]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2kzkntnp.rs:20:68\n\
    \   |\n20 |             result.push_str(&letters[letters.iter().position(|x| x\
    \ == letter).unwrap() + 1]);\n   |                                           \
    \                         ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2kzkntnp.rs:20:29\n   |\n20 |             result.push_str(&letters[letters.iter().position(|x|\
    \ x == letter).unwrap() + 1]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0277]: can't compare `&char` with\
    \ `char`\n  --> /tmp/tmp2kzkntnp.rs:24:51\n   |\n24 |         let index = letters.iter().position(|x|\
    \ x == vowel).unwrap() + 1;\n   |                                            \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2kzkntnp.rs:25:25\n\
    \   |\n25 |         result.push_str(&letters[index]);\n   |                  \
    \       ^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_map = HashMap::new();\n    for vowel\
    \ in vowels {\n        vowels_map.insert(vowel.to_string(), vowel);\n    }\n \
    \   for letter in message.chars() {\n        let mut new_letter = letter;\n  \
    \      for vowel in vowels {\n            if letter == vowel {\n             \
    \   new_letter += vowels_map.get(&vowel).unwrap();\n            }\n        }\n\
    \        result.push(new_letter);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpi_oapo26.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    let mut vowels_counter = 0;\n    for letter in message.chars() {\n      \
    \  if letter.is_uppercase() {\n            result.push_str(&format!(\"{}{}\",\
    \ letter.to_lowercase(), vowels_counter));\n            vowels_counter = 0;\n\
    \        } else {\n            result.push_str(&format!(\"{}{}\", letter.to_lowercase(),\
    \ vowels_counter));\n            vowels_counter = vowels.get(&letter).unwrap()\
    \ + 1;\n            vowels.insert(letter, vowels_counter);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpjtpaqm_q.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747168
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpw4_b0esl.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747168
