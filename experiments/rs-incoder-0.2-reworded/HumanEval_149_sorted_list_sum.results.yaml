name: HumanEval_149_sorted_list_sum
language: rs
results:
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() == 0 {\n            res.push(word);\n        } else {\n       \
    \     let mut i = 0;\n            let mut j = res.len();\n            while i\
    \ < j {\n                if res[j].len() < word.len() {\n                    i\
    \ += 1;\n                } else {\n                    j -= 1;\n             \
    \   }\n            }\n            res.swap(i, j);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpoizqhzfr.rs:25:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       let mut i = 0;\n                while sorted_list.last().unwrap().len()\
    \ < word.len() {\n                    sorted_list.push(sorted_list.pop().unwrap());\n\
    \                    i += 1;\n                }\n                sorted_list.push(word);\n\
    \            }\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "warning: variable `i` is assigned to, but never used\n  --> /tmp/tmp939j7egj.rs:26:25\n\
    \   |\n26 |                 let mut i = 0;\n   |                         ^\n \
    \  |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_i` instead\n\nerror[E0499]: cannot borrow `sorted_list` as mutable more\
    \ than once at a time\n  --> /tmp/tmp939j7egj.rs:28:38\n   |\n28 |           \
    \          sorted_list.push(sorted_list.pop().unwrap());\n   |               \
    \      -----------------^^^^^^^^^^^^^^^^^----------\n   |                    \
    \ |           |    |\n   |                     |           |    second mutable\
    \ borrow occurs here\n   |                     |           first borrow later\
    \ used by call\n   |                     first mutable borrow occurs here\n  \
    \ |\nhelp: try adding a local storing this argument...\n  --> /tmp/tmp939j7egj.rs:28:38\n\
    \   |\n28 |                     sorted_list.push(sorted_list.pop().unwrap());\n\
    \   |                                      ^^^^^^^^^^^^^^^^^\nhelp: ...and then\
    \ using that local as the argument to this call\n  --> /tmp/tmp939j7egj.rs:28:21\n\
    \   |\n28 |                     sorted_list.push(sorted_list.pop().unwrap());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                if sorted_list[0].chars().zip(word.chars()).all(|(a,\
    \ b)| a == b) {\n                    sorted_list.push(word);\n               \
    \ } else {\n                    sorted_list.sort_by(|a, b| a.cmp(b));\n      \
    \          }\n            } else {\n                sorted_list.sort_by(|a, b|\
    \ a.cmp(b));\n                sorted_list.push(word);\n            }\n       \
    \ }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpmzjzx2_0.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpmzjzx2_0.rs:23:48\n\
    \   |\n23 |             if sorted_list[0].length() == word.length() {\n   |  \
    \                                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    let mut sorted_list = sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    let mut sorted_list = sorted_list.sort_by(|a, b|\
    \ a.cmp(b));\n    sorted_list.cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmph0tzzaly.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmph0tzzaly.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if lst[i].len() % 2 != 0 {\n\
    \            res.push(lst[i]);\n            i += 1;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    res.sort_by_key(|x| x.len());\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp6df4x3sa.rs:18:9\n\
    \   |\n18 |     let mut len = lst.len();\n   |         ----^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n \
    \ --> /tmp/tmp6df4x3sa.rs:22:22\n   |\n22 |             res.push(lst[i]);\n  \
    \ |                      ^^^^^^ move occurs because value has type `String`, which\
    \ does not implement the `Copy` trait\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() > 0 {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if word.len() < sorted_list.last().unwrap().len() {\n   \
    \                 sorted_list.push(word);\n                }\n            }\n\
    \        } else {\n            sorted_list.push(word);\n        }\n    }\n   \
    \ sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpaa3pp5rn.rs:20:28\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         --------------- consider\
    \ giving `sorted_list` the explicit type `Vec<T>`, where the type parameter `T`\
    \ is specified\n...\n20 |             if sorted_list.last().unwrap().len() < word.len()\
    \ {\n   |                            ^^^^ cannot infer type for type parameter\
    \ `T`\n   |\n   = note: type must be known at this point\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.contains(&word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp58h3todk.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n  \
    \      } else {\n            let mut current_word = sorted_list[0];\n        \
    \    for item in sorted_list {\n                if item.len() < current_word.len()\
    \ {\n                    current_word = item;\n                }\n           \
    \ }\n            if current_word.len() < word.len() {\n                sorted_list.push(word);\n\
    \            } else {\n                sorted_list.push(current_word);\n     \
    \           sorted_list.push(word);\n            }\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmpc2vftoeg.rs:19:12\n\
    \    |\n17  |     let mut sorted_list = vec![];\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n18  |     for word in lst {\n19  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    ...\n23  |             for item in sorted_list {\n    |                      \
    \   ----------- `sorted_list` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `sorted_list`\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n23  |             for item in &sorted_list {\n    |                  \
    \       +\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpc2vftoeg.rs:22:36\n\
    \   |\n22 |             let mut current_word = sorted_list[0];\n   |         \
    \                           ^^^^^^^^^^^^^^\n   |                             \
    \       |\n   |                                    move occurs because value has\
    \ type `String`, which does not implement the `Copy` trait\n   |             \
    \                       help: consider borrowing here: `&sorted_list[0]`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0382, E0507.\nFor more information about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                sorted_list.sort_by(|a, b| a.len() < b.len());\n        \
    \        sorted_list.push(sorted_list[0]);\n            }\n        }\n    }\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv39_55ut.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.len() == 0 {\n\
    \            sorted_list_len.push(word.len());\n        }\n        if sorted_list_len.iter().any(|&x|\
    \ x == word.len()) {\n            sorted_list_len.push(word.len());\n        \
    \    sorted_list.push(word);\n        } else {\n            sorted_list_len.iter().filter(|&x|\
    \ x == word.len()).sort();\n            sorted_list.push(word);\n        }\n \
    \   }\n    sorted_list.sort_by_key(|&x| x.len());\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&usize` with `usize`\n  --> /tmp/tmp38se72ks.rs:27:50\n\
    \   |\n27 |             sorted_list_len.iter().filter(|&x| x == word.len()).sort();\n\
    \   |                                                  ^^ no implementation for\
    \ `&usize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0599]: no method named `sort` found for struct `Filter`\
    \ in the current scope\n  --> /tmp/tmp38se72ks.rs:27:65\n   |\n27 |          \
    \   sorted_list_len.iter().filter(|&x| x == word.len()).sort();\n   |        \
    \                                                         ^^^^ method not found\
    \ in `Filter<std::slice::Iter<'_, usize>, [closure@/tmp/tmp38se72ks.rs:27:43:\
    \ 27:63]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.iter().all(|&x| x.len() == word.len()) {\n            res.sort_by(|a,\
    \ b| a.cmp(b));\n        } else {\n            res.push(word);\n        }\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmp9o9ok1zw.rs:19:28\n\
    \   |\n19 |         if res.iter().all(|&x| x.len() == word.len()) {\n   |    \
    \                        ^^ consider giving this closure parameter the explicit\
    \ type `&T`, with the type parameters specified\n   |\n   = note: type must be\
    \ known at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if word.len()\
    \ < sorted_list[0].len() {\n                sorted_list.push(word);\n        \
    \    } else {\n                if word.len() > sorted_list[0].len() {\n      \
    \              sorted_list = sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \                }\n            }\n        }\n    }\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7zpo_gnt.rs:27:62\n   |\n\
    27 |                     sorted_list = sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \   |                                                              ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7zpo_gnt.rs:27:35\n   |\n18 |     let mut sorted_list =\
    \ vec![];\n   |                           ------ expected due to this value\n\
    ...\n27 |                     sorted_list = sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n  \
    \      } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       if sorted_list.last().unwrap().len() == word.len() {\n               \
    \     sorted_list.last().unwrap().push(word);\n                } else {\n    \
    \                sorted_list.push(word);\n                }\n            }\n \
    \       }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptlxjceiz.rs:26:54\n   |\n\
    26 |                     sorted_list.last().unwrap().push(word);\n   |       \
    \                                               ^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptlxjceiz.rs:33:32\n\
    \   |\n33 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp7onmd0m_.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp7onmd0m_.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    let mut sorted_list = sorted_list.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp4jgrpf11.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp4jgrpf11.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpqlnifkzg.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpqlnifkzg.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                sorted_list.sort_by(|a, b| a.len() < b.len());\n        \
    \        sorted_list.push(sorted_list[0]);\n            }\n        }\n    }\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_mkjky78.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        let mut sorted_word = word;\n        if sorted_word.len() > 1 {\n   \
    \         for c in sorted_word.chars() {\n                if c % 2 == 1 {\n  \
    \                  sorted_word.clear();\n                    break;\n        \
    \        }\n            }\n        }\n        sorted_list.push(sorted_word);\n\
    \    }\n    sorted_list.sort_by_key(|x| x.len());\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmp1g0vzq0i.rs:22:22\n\
    \   |\n22 |                 if c % 2 == 1 {\n   |                    - ^ - {integer}\n\
    \   |                    |\n   |                    char\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmph9r9xk2b.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmph9r9xk2b.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp581_z7dn.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
