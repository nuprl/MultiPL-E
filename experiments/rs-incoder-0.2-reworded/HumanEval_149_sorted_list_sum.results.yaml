language: rs
name: HumanEval_149_sorted_list_sum
results:
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() == 0 {\n            res.push(word);\n        } else {\n       \
    \     let mut i = 0;\n            let mut j = res.len();\n            while i\
    \ < j {\n                if res[j].len() < word.len() {\n                    i\
    \ += 1;\n                } else {\n                    j -= 1;\n             \
    \   }\n            }\n            res.swap(i, j);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpoizqhzfr.rs:25:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       let mut i = 0;\n                while sorted_list.last().unwrap().len()\
    \ < word.len() {\n                    sorted_list.push(sorted_list.pop().unwrap());\n\
    \                    i += 1;\n                }\n                sorted_list.push(word);\n\
    \            }\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `i` is assigned to, but never used\n  --> /tmp/tmp939j7egj.rs:26:25\n\
    \   |\n26 |                 let mut i = 0;\n   |                         ^\n \
    \  |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_i` instead\n\nerror[E0499]: cannot borrow `sorted_list` as mutable more\
    \ than once at a time\n  --> /tmp/tmp939j7egj.rs:28:38\n   |\n28 |           \
    \          sorted_list.push(sorted_list.pop().unwrap());\n   |               \
    \      -----------------^^^^^^^^^^^^^^^^^----------\n   |                    \
    \ |           |    |\n   |                     |           |    second mutable\
    \ borrow occurs here\n   |                     |           first borrow later\
    \ used by call\n   |                     first mutable borrow occurs here\n  \
    \ |\nhelp: try adding a local storing this argument...\n  --> /tmp/tmp939j7egj.rs:28:38\n\
    \   |\n28 |                     sorted_list.push(sorted_list.pop().unwrap());\n\
    \   |                                      ^^^^^^^^^^^^^^^^^\nhelp: ...and then\
    \ using that local as the argument to this call\n  --> /tmp/tmp939j7egj.rs:28:21\n\
    \   |\n28 |                     sorted_list.push(sorted_list.pop().unwrap());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0499`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                if sorted_list[0].chars().zip(word.chars()).all(|(a,\
    \ b)| a == b) {\n                    sorted_list.push(word);\n               \
    \ } else {\n                    sorted_list.sort_by(|a, b| a.cmp(b));\n      \
    \          }\n            } else {\n                sorted_list.sort_by(|a, b|\
    \ a.cmp(b));\n                sorted_list.push(word);\n            }\n       \
    \ }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpmzjzx2_0.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpmzjzx2_0.rs:23:48\n\
    \   |\n23 |             if sorted_list[0].length() == word.length() {\n   |  \
    \                                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    let mut sorted_list = sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    let mut sorted_list = sorted_list.sort_by(|a, b|\
    \ a.cmp(b));\n    sorted_list.cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmph0tzzaly.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmph0tzzaly.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if lst[i].len() % 2 != 0 {\n\
    \            res.push(lst[i]);\n            i += 1;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    res.sort_by_key(|x| x.len());\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp6df4x3sa.rs:18:9\n\
    \   |\n18 |     let mut len = lst.len();\n   |         ----^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n \
    \ --> /tmp/tmp6df4x3sa.rs:22:22\n   |\n22 |             res.push(lst[i]);\n  \
    \ |                      ^^^^^^ move occurs because value has type `String`, which\
    \ does not implement the `Copy` trait\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() > 0 {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if word.len() < sorted_list.last().unwrap().len() {\n   \
    \                 sorted_list.push(word);\n                }\n            }\n\
    \        } else {\n            sorted_list.push(word);\n        }\n    }\n   \
    \ sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpaa3pp5rn.rs:20:28\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         --------------- consider\
    \ giving `sorted_list` the explicit type `Vec<T>`, where the type parameter `T`\
    \ is specified\n...\n20 |             if sorted_list.last().unwrap().len() < word.len()\
    \ {\n   |                            ^^^^ cannot infer type for type parameter\
    \ `T`\n   |\n   = note: type must be known at this point\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.contains(&word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp58h3todk.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n  \
    \      } else {\n            let mut current_word = sorted_list[0];\n        \
    \    for item in sorted_list {\n                if item.len() < current_word.len()\
    \ {\n                    current_word = item;\n                }\n           \
    \ }\n            if current_word.len() < word.len() {\n                sorted_list.push(word);\n\
    \            } else {\n                sorted_list.push(current_word);\n     \
    \           sorted_list.push(word);\n            }\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmpc2vftoeg.rs:19:12\n\
    \    |\n17  |     let mut sorted_list = vec![];\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n18  |     for word in lst {\n19  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    ...\n23  |             for item in sorted_list {\n    |                      \
    \   ----------- `sorted_list` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `sorted_list`\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n23  |             for item in &sorted_list {\n    |                  \
    \       +\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpc2vftoeg.rs:22:36\n\
    \   |\n22 |             let mut current_word = sorted_list[0];\n   |         \
    \                           ^^^^^^^^^^^^^^\n   |                             \
    \       |\n   |                                    move occurs because value has\
    \ type `String`, which does not implement the `Copy` trait\n   |             \
    \                       help: consider borrowing here: `&sorted_list[0]`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0382, E0507.\nFor more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                sorted_list.sort_by(|a, b| a.len() < b.len());\n        \
    \        sorted_list.push(sorted_list[0]);\n            }\n        }\n    }\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv39_55ut.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.len() == 0 {\n\
    \            sorted_list_len.push(word.len());\n        }\n        if sorted_list_len.iter().any(|&x|\
    \ x == word.len()) {\n            sorted_list_len.push(word.len());\n        \
    \    sorted_list.push(word);\n        } else {\n            sorted_list_len.iter().filter(|&x|\
    \ x == word.len()).sort();\n            sorted_list.push(word);\n        }\n \
    \   }\n    sorted_list.sort_by_key(|&x| x.len());\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `usize`\n  --> /tmp/tmp38se72ks.rs:27:50\n\
    \   |\n27 |             sorted_list_len.iter().filter(|&x| x == word.len()).sort();\n\
    \   |                                                  ^^ no implementation for\
    \ `&usize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0599]: no method named `sort` found for struct `Filter`\
    \ in the current scope\n  --> /tmp/tmp38se72ks.rs:27:65\n   |\n27 |          \
    \   sorted_list_len.iter().filter(|&x| x == word.len()).sort();\n   |        \
    \                                                         ^^^^ method not found\
    \ in `Filter<std::slice::Iter<'_, usize>, [closure@/tmp/tmp38se72ks.rs:27:43:\
    \ 27:63]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.iter().all(|&x| x.len() == word.len()) {\n            res.sort_by(|a,\
    \ b| a.cmp(b));\n        } else {\n            res.push(word);\n        }\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmp9o9ok1zw.rs:19:28\n\
    \   |\n19 |         if res.iter().all(|&x| x.len() == word.len()) {\n   |    \
    \                        ^^ consider giving this closure parameter the explicit\
    \ type `&T`, with the type parameters specified\n   |\n   = note: type must be\
    \ known at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if word.len()\
    \ < sorted_list[0].len() {\n                sorted_list.push(word);\n        \
    \    } else {\n                if word.len() > sorted_list[0].len() {\n      \
    \              sorted_list = sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \                }\n            }\n        }\n    }\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7zpo_gnt.rs:27:62\n   |\n\
    27 |                     sorted_list = sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \   |                                                              ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7zpo_gnt.rs:27:35\n   |\n18 |     let mut sorted_list =\
    \ vec![];\n   |                           ------ expected due to this value\n\
    ...\n27 |                     sorted_list = sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n  \
    \      } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       if sorted_list.last().unwrap().len() == word.len() {\n               \
    \     sorted_list.last().unwrap().push(word);\n                } else {\n    \
    \                sorted_list.push(word);\n                }\n            }\n \
    \       }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptlxjceiz.rs:26:54\n   |\n\
    26 |                     sorted_list.last().unwrap().push(word);\n   |       \
    \                                               ^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptlxjceiz.rs:33:32\n\
    \   |\n33 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp7onmd0m_.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp7onmd0m_.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    let mut sorted_list = sorted_list.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp4jgrpf11.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp4jgrpf11.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpqlnifkzg.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpqlnifkzg.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                sorted_list.sort_by(|a, b| a.len() < b.len());\n        \
    \        sorted_list.push(sorted_list[0]);\n            }\n        }\n    }\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_mkjky78.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        let mut sorted_word = word;\n        if sorted_word.len() > 1 {\n   \
    \         for c in sorted_word.chars() {\n                if c % 2 == 1 {\n  \
    \                  sorted_word.clear();\n                    break;\n        \
    \        }\n            }\n        }\n        sorted_list.push(sorted_word);\n\
    \    }\n    sorted_list.sort_by_key(|x| x.len());\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmp1g0vzq0i.rs:22:22\n\
    \   |\n22 |                 if c % 2 == 1 {\n   |                    - ^ - {integer}\n\
    \   |                    |\n   |                    char\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmph9r9xk2b.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmph9r9xk2b.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp581_z7dn.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n  \
    \      } else {\n            if word.len() > sorted_list[0].len() {\n        \
    \        sorted_list.push(word);\n            } else {\n                if word.len()\
    \ < sorted_list[0].len() {\n                    sorted_list = sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n                }\n            }\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj1ym6cuz.rs:26:35\n   |\n\
    26 |                     sorted_list = sorted_list.sort_by(|a, b| a.cmp(b));\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n \
    \          found unit type `()`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpqbhcp607.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpqbhcp607.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.iter().all(|&x| x.len() < word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmprf7ugxo2.rs:19:36\n\
    \   |\n19 |         if sorted_list.iter().all(|&x| x.len() < word.len()) {\n \
    \  |                                    ^^ consider giving this closure parameter\
    \ the explicit type `&T`, with the type parameters specified\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ res.len() == 0 {\n            res.push(s);\n        } else {\n            let\
    \ mut cur = res.iter().cloned().collect::<Vec<_>>();\n            let mut cur2\
    \ = cur.iter().cloned().collect::<Vec<_>>();\n            for x in cur2 {\n  \
    \              if x.len() > s.len() {\n                    cur2.remove(x);\n \
    \               }\n            }\n            for x in cur {\n               \
    \ if x.len() < s.len() {\n                    cur.remove(x);\n               \
    \ }\n            }\n            res.extend(cur.clone());\n        }\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc6ud0en4.rs:26:33\n   |\n\
    26 |                     cur2.remove(x);\n   |                               \
    \  ^ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc6ud0en4.rs:31:32\n   |\n31 |                     cur.remove(x);\n\
    \   |                                ^ expected `usize`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.len() == 0 {\n\
    \            sorted_list_len.push(word.len());\n        }\n        if sorted_list_len.len()\
    \ > sorted_list_len.max() {\n            sorted_list_len = vec![];\n        }\n\
    \        if sorted_list_len.len() == sorted_list_len.max() {\n            sorted_list_len.push(word.len());\n\
    \        }\n        if sorted_list_len.len() < sorted_list_len.max() {\n     \
    \       sorted_list_len.push(word.len());\n        }\n        if sorted_list_len.len()\
    \ == sorted_list_len.max() && sorted_list_len.len() > 0 {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_by_key(|word| word.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpe9kev5x2.rs:23:52\n    |\n23  |         if sorted_list_len.len()\
    \ > sorted_list_len.max() {\n    |                                           \
    \         ^^^- supplied 0 arguments\n    |                                   \
    \                 |\n    |                                                   \
    \ expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe9kev5x2.rs:23:36\n   |\n23 |         if sorted_list_len.len()\
    \ > sorted_list_len.max() {\n   |                                    ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `Vec`\n   |\n   = note: expected type `usize`\n\
    \            found struct `Vec<usize>`\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n   --> /tmp/tmpe9kev5x2.rs:26:53\n \
    \   |\n26  |         if sorted_list_len.len() == sorted_list_len.max() {\n   \
    \ |                                                     ^^^- supplied 0 arguments\n\
    \    |                                                     |\n    |          \
    \                                           expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe9kev5x2.rs:26:37\n\
    \   |\n26 |         if sorted_list_len.len() == sorted_list_len.max() {\n   |\
    \                                     ^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found struct `Vec`\n   |\n   = note: expected type `usize`\n            found\
    \ struct `Vec<usize>`\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmpe9kev5x2.rs:29:52\n    |\n29  |         if sorted_list_len.len()\
    \ < sorted_list_len.max() {\n    |                                           \
    \         ^^^- supplied 0 arguments\n    |                                   \
    \                 |\n    |                                                   \
    \ expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe9kev5x2.rs:29:36\n   |\n29 |         if sorted_lis"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        if elem.len() % 2 != 0 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut i = 0;\n            let mut j = 0;\n  \
    \          while i < sorted_list.len() && j < elem.len() {\n                if\
    \ sorted_list[i].len() < elem[j].len() {\n                    i += 1;\n      \
    \          } else if sorted_list[i].len() > elem[j].len() {\n                \
    \    j += 1;\n                } else {\n                    res.push(sorted_list[i]);\n\
    \                    i += 1;\n                    j += 1;\n                }\n\
    \            }\n            if i == sorted_list.len() {\n                res.push(elem);\n\
    \            } else {\n                res.push(sorted_list[i]);\n           \
    \ }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7y5abe8v.rs:26:43\n\
    \   |\n26 |                 if sorted_list[i].len() < elem[j].len() {\n   |  \
    \                                         ^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7y5abe8v.rs:28:50\n\
    \   |\n28 |                 } else if sorted_list[i].len() > elem[j].len() {\n\
    \   |                                                  ^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp7onmd0m_.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp7onmd0m_.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       if sorted_list.last().unwrap().len() == word.len() {\n               \
    \     sorted_list.last().unwrap().push(word);\n                } else {\n    \
    \                sorted_list.push(word);\n                }\n            }\n \
    \       }\n    }\n    for word in sorted_list {\n        res.push(word);\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtwff5fo.rs:27:54\n   |\n\
    27 |                     sorted_list.last().unwrap().push(word);\n   |       \
    \                                               ^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.cmp(b));\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp6ln4k480.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list.push(word);\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpn8p9y9gu.rs:55:1\n   |\n55\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8p9y9gu.rs:23:32\n\
    \   |\n23 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8p9y9gu.rs:24:32\n\
    \   |\n24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8p9y9gu.rs:25:32\n\
    \   |\n25 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8p9y9gu.rs:26:32\n\
    \   |\n26 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8p9y9gu.rs:27:32\n\
    \   |\n27 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8p9y9gu.rs:28:32\n\
    \   |\n28 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8p9y9gu.rs:29:32\n\
    \   |\n29 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8p9y9gu.rs:30:32\n\
    \   |\n30 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8p9y9gu.rs:31:32\n\
    \   |\n31 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \       "
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list.push(word);\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        for index in 0..word.len() {\n            if index % 2 != 0 {\n \
    \               sorted_list.swap(index, index + 1);\n            }\n        }\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpbu8wzxt1.rs:25:30\n   |\n25 |         for index in 0..word.len()\
    \ {\n   |                              ^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5w8tdx_r.rs:43:58\n   |\n\
    43 |     let mut sorted_list_len = sorted_list_len.saturating_\n   |         \
    \                                                 ^ help: add `;` here\n44 | }\n\
    \   | - unexpected token\n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmp5w8tdx_r.rs:19:62\n   |\n19 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmp5w8tdx_r.rs:20:62\n   |\n20 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n\nwarning: unnecessary parentheses around method\
    \ argument\n  --> /tmp/tmp5w8tdx_r.rs:21:62\n   |\n21 |     let mut sorted_list_len\
    \ = sorted_list_len.saturating_add((sorted_list_len % 2));\n   |             \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^ help:\
    \ remove these parentheses\n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmp5w8tdx_r.rs:22:62\n   |\n22 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n\nwarning: unnecessary parentheses around method\
    \ argument\n  --> /tmp/tmp5w8tdx_r.rs:23:62\n   |\n23 |     let mut sorted_list_len\
    \ = sorted_list_len.saturating_add((sorted_list_len % 2));\n   |             \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^ help:\
    \ remove these parentheses\n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmp5w8tdx_r.rs:24:62\n   |\n24 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                             "
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp8iqc3843.rs:64:1\n   |\n64\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp8iqc3843.rs:63:35\n\
    \   |\n63 |     let mut sorted_list_len = lst.\n   |                         \
    \          ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8iqc3843.rs:16:41\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |    ---------------                     \
    \ ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        sorted_list.push(lst.remove(&word));\n    }\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfdmghqfn.rs:24:37\n   |\n\
    24 |         sorted_list.push(lst.remove(&word));\n   |                      \
    \               ^^^^^ expected `usize`, found `&usize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n24 -         sorted_list.push(lst.remove(&word));\n24 +  \
    \       sorted_list.push(lst.remove(word));\n   | \n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut counter = 0;\n\
    \    for word in lst {\n        if counter % 2 == 0 {\n            sorted_list.push(word);\n\
    \        }\n        counter += 1;\n    }\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_y9cu86v.rs:25:32\n   |\n\
    25 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpq8nq5wjr.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpq8nq5wjr.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        for index in 0..word.len() {\n            if index % 2 == 0 {\n \
    \               sorted_list.push(word.to_owned());\n                break;\n \
    \           }\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpfype8tut.rs:24:30\n   |\n24 |         for index in 0..word.len()\
    \ {\n   |                              ^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfype8tut.rs:31:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                                        \
    \ ----------- expected `Vec<String>` because of return type\n...\n31 |     sorted_list\n\
    \   |     ^^^^^^^^^^^ expected struct `String`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if sorted_list.last().unwrap().len() == word.len() {\n  \
    \                  sorted_list.push(word);\n                } else {\n       \
    \             if sorted_list.last().unwrap().len() > word.len() {\n          \
    \              sorted_list.push(word);\n                    }\n              \
    \  }\n            }\n        }\n    }\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi3e4gp02.rs:36:32\n   |\n\
    36 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for elem in\
    \ sorted_list {\n                if elem.len() == word.len() {\n             \
    \       if elem.cmp(&word) == cmp::Ordering::Less {\n                        sorted_list.push(word);\n\
    \                        found = true;\n                        break;\n     \
    \               }\n                }\n            }\n            if !found {\n\
    \                sorted_list.push(word);\n            }\n        }\n    }\n  \
    \  for elem in sorted_list {\n        res.push(elem);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpim3mrvk1.rs:26:43\n   |\n26 |                     if elem.cmp(&word)\
    \ == cmp::Ordering::Less {\n   |                                           ^^^\
    \ use of undeclared crate or module `cmp`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = lst;\n\
    \    sorted_list.sort();\n    for word in sorted_list {\n        if res.len()\
    \ == 0 {\n            res.push(word);\n        } else {\n            let mut i\
    \ = 0;\n            let mut j = 0;\n            while i < res.len() && j < word.len()\
    \ {\n                if res[i].len() < word[j].len() {\n                    i\
    \ += 1;\n                } else if res[i].len() > word[j].len() {\n          \
    \          j += 1;\n                } else {\n                    res.swap(i,\
    \ j);\n                    i += 1;\n                    j += 1;\n            \
    \    }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1vff_18b.rs:27:35\n\
    \   |\n27 |                 if res[i].len() < word[j].len() {\n   |          \
    \                         ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1vff_18b.rs:29:42\n\
    \   |\n29 |                 } else if res[i].len() > word[j].len() {\n   |   \
    \                                       ^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                sorted_list.sort_by(|a, b| a.len() < b.len());\n        \
    \        sorted_list.push(sorted_list.last().unwrap());\n            }\n     \
    \   }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwty9785l.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwty9785l.rs:27:34\n\
    \   |\n27 |                 sorted_list.push(sorted_list.last().unwrap());\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  |\n\
    \   |                                  expected struct `String`, found `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut counter = 0;\n\
    \    for word in lst {\n        if counter % 2 == 0 {\n            sorted_list.push(word);\n\
    \        }\n        counter += 1;\n    }\n    sorted_list.sort_by_key(|word| word.len());\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpnjde1hfn.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut counter = vec![];\n\
    \    for word in lst {\n        if counter.contains(&word) {\n            sorted_list.push(word);\n\
    \        } else {\n            sorted_list.push(word);\n            counter.push(1);\n\
    \        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx6u6bp55.rs:24:26\n   |\n\
    24 |             counter.push(1);\n   |                          ^- help: try\
    \ using a conversion method: `.to_string()`\n   |                          |\n\
    \   |                          expected struct `String`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx6u6bp55.rs:27:32\n   |\n27 |     sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n   |                                ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len.insert(word.len(), 1);\n        } else {\n  \
    \          sorted_list_len.push(word.len());\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list_len.sort_unstable();\n    sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpwd557g_j.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        let mut sorted_list_word = vec![];\n        for word in lst {\n \
    \           if word.len() == word {\n                sorted_list_word.push(word);\n\
    \            }\n        }\n        sorted_list.push(sorted_list_word);\n    }\n\
    \    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5kvm4k05.rs:26:30\n   |\n\
    26 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5kvm4k05.rs:33:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n33 |     sorted_list\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list_len\
    \ = Vec::new();\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.contains(&word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpvsymozv5.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 ---\n    |                 |\n    |                 `lst` moved\
    \ due to this implicit call to `.into_iter()`\n    |                 help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n23  |     for word\
    \ in lst {\n    |                 ^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp8iqc3843.rs:64:1\n   |\n64\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp8iqc3843.rs:63:35\n\
    \   |\n63 |     let mut sorted_list_len = lst.\n   |                         \
    \          ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8iqc3843.rs:16:41\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |    ---------------                     \
    \ ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    let mut sorted_list_len = sorted_list_\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9zf1em1a.rs:41:43\n   |\n\
    41 |     let mut sorted_list_len = sorted_list_\n   |                        \
    \                   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `sorted_list_` in this scope\n  --> /tmp/tmp9zf1em1a.rs:41:31\n\
    \   |\n41 |     let mut sorted_list_len = sorted_list_\n   |                 \
    \              ^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `sorted_list`\n\nerror[E0599]: no method named `floor` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmp9zf1em1a.rs:19:84\n   |\n19 |     let mut\
    \ sorted_list_len = sorted_list_len.saturating_add((sorted_list_len / 2).floor());\n\
    \   |                                                                        \
    \            ^^^^^ method not found in `usize`\n\nerror[E0599]: no method named\
    \ `floor` found for type `usize` in the current scope\n  --> /tmp/tmp9zf1em1a.rs:20:84\n\
    \   |\n20 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n   |                                                       \
    \                             ^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `floor` found for type `usize` in the current scope\n  --> /tmp/tmp9zf1em1a.rs:21:84\n\
    \   |\n21 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n   |                                                       \
    \                             ^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `floor` found for type `usize` in the current scope\n  --> /tmp/tmp9zf1em1a.rs:22:84\n\
    \   |\n22 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n   |                                                       \
    \                             ^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `floor` found for type `usize` in the current scope\n  --> /tmp/tmp9zf1em1a.rs:23:84\n\
    \   |\n23 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() > 0 {\n            if sorted_list[0].len()\
    \ > word.len() {\n                sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \            }\n        }\n        sorted_list.push(word);\n    }\n    for word\
    \ in sorted_list {\n        if res.len() > 0 {\n            if res[0].len() >\
    \ word.len() {\n                res.sort_by(|a, b| a.len() < b.len());\n     \
    \       }\n        }\n        res.push(word);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpojyalydy.rs:21:16\n\
    \   |\n18 |     let mut sorted_list = vec![];\n   |         --------------- consider\
    \ giving `sorted_list` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n21 |             if sorted_list[0].len() > word.len() {\n   |           \
    \     ^^^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must be known at\
    \ this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmph9r9xk2b.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmph9r9xk2b.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_sum = 0;\n    let mut sorted_list_sum2\
    \ = 0;\n    let mut sorted_list_sum3 = 0;\n    let mut sorted_list_sum4 = 0;\n\
    \    let mut sorted_list_sum5 = 0;\n    let mut sorted_list_sum6 = 0;\n    let\
    \ mut sorted_list_sum7 = 0;\n    let mut sorted_list_sum8 = 0;\n    let mut sorted_list_sum9\
    \ = 0;\n    let mut sorted_list_sum10 = 0;\n    let mut sorted_list_sum11 = 0;\n\
    \    let mut sorted_list_sum12 = 0;\n    let mut sorted_list_sum13 = 0;\n    let\
    \ mut sorted_list_sum14 = 0;\n    let mut sorted_list_sum15 = 0;\n    let mut\
    \ sorted_list_sum16 = 0;\n    let mut sorted_list_sum17 = 0;\n    let mut sorted_list_sum18\
    \ = 0;\n    let mut sorted_list_sum19 = 0;\n    let mut sorted_list_sum20 = 0;\n\
    \    let mut sorted_list_sum21 = 0;\n    let mut sorted_list_sum22 = 0;\n    let\
    \ mut sorted_list_sum23 = 0;\n    let mut sorted_list_sum24 = 0;\n    let mut\
    \ sorted_list_sum25 = 0;\n    let mut sorted_list_sum26 = 0;\n    let mut sorted_list_sum27\
    \ = 0;\n    let mut sorted_list_sum28 = 0;\n    let mut sorted_list_sum29 = 0;\n\
    \    let mut sorted_list_sum30 = 0;\n    let mut sorted_list_sum31 = 0;\n    let\
    \ mut sorted_list_sum32 = 0;\n    let mut sorted_list_sum33 = 0;\n    let mut\
    \ sorted_list_sum34 = 0;\n    let mut sorted_list_sum35 = 0;\n    let mut sorted_list_sum36\
    \ = 0;\n    let mut sorted_list_sum37 = 0;\n    let mut sorted_list_sum38 = 0;\n\
    \    let mut sorted_list_sum39 = 0;\n    let mut sorted_list_sum40 = 0;\n    let\
    \ mut sorted_list_sum41 = 0;\n    let mut sorted_list_sum42 = 0;\n    let mut\
    \ sorted_list_sum43 = 0;\n    let mut sorted_list_sum44 = 0;\n    let mut sorted_list_sum45\
    \ = 0;\n    let mut sorted_list_sum46 = 0;\n    let mut sorted_list_sum47 = 0;\n\
    \    let mut sorted_list_sum48 = 0;\n    let mut sorted_list_sum49 = 0;\n    let\
    \ mut sorted_list_sum50 = 0;\n    let mut sorted_list_sum51 = 0;\n    let mut\
    \ sorted_list_sum52 = 0;\n    let mut sorted_list_sum53 = 0;\n    let mut sorted_list_sum54\
    \ = 0;\n    let mut sorted_list_sum55 = 0;\n    let mu\n}\n\nfn main() {\n   \
    \ let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5hoc73wb.rs:74:11\n   |\n\
    74 |     let mu\n   |           ^ help: add `;` here\n75 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5hoc73wb.rs:16:41\n \
    \  |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                sorted_list.sort();\n                sorted_list.push(sorted_list[0]);\n\
    \                sorted_list.sort();\n            }\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpa66fa45e.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut i = 0;\n        while i < len && lst[i].len()\
    \ < len {\n            i += 1;\n        }\n        if i == len {\n           \
    \ res.push(lst[len - 1]);\n            len -= 1;\n        } else {\n         \
    \   res.push(lst[i]);\n            len -= 1;\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpk6ajiynb.rs:25:22\n\
    \   |\n25 |             res.push(lst[len - 1]);\n   |                      ^^^^^^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpk6ajiynb.rs:28:22\n\
    \   |\n28 |             res.push(lst[i]);\n   |                      ^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if word.len() % 2 == 1 {\n            sorted_list.push(word);\n     \
    \   }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdyyuc4x2.rs:23:32\n   |\n\
    23 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpkbjk0ub9.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpkbjk0ub9.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                let\
    \ mut i = 0;\n                while sorted_list[i].len() < word.len() {\n    \
    \                i += 1;\n                }\n                sorted_list.insert(i,\
    \ word);\n            }\n        }\n    }\n    for word in sorted_list {\n   \
    \     if res.len() == 0 {\n            res.push(word);\n        } else {\n   \
    \         if res[0].len() < word.len() {\n                res.push(word);\n  \
    \          } else {\n                let mut i = 0;\n                while res[i].len()\
    \ < word.len() {\n                    i += 1;\n                }\n           \
    \     res.insert(i, word);\n            }\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp_hsf9km9.rs:54:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if word.len() % 2 != 0 {\n            sorted_list.push(word);\n     \
    \   }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaosr1007.rs:23:32\n   |\n\
    23 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len.insert(word.len(), 1);\n        } else {\n  \
    \          sorted_list_len.insert(word.len(), 0);\n        }\n    }\n    for i\
    \ in sorted_list_len.iter().rev() {\n        sorted_list.extend(&lst[sorted_list_len.iter().rev().skip(i).rev().next().unwrap()]);\n\
    \    }\n    sorted_list.sort_by_key(|x| x.to_string());\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxcvgb97u.rs:27:67\n   |\n\
    27 |         sorted_list.extend(&lst[sorted_list_len.iter().rev().skip(i).rev().next().unwrap()]);\n\
    \   |                                                                   ^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    27 |         sorted_list.extend(&lst[sorted_list_len.iter().rev().skip(*i).rev().next().unwrap()]);\n\
    \   |                                                                   +\n\n\
    error[E0277]: the type `[String]` cannot be indexed by `&usize`\n  --> /tmp/tmpxcvgb97u.rs:27:29\n\
    \   |\n27 |         sorted_list.extend(&lst[sorted_list_len.iter().rev().skip(i).rev().next().unwrap()]);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `&usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&usize>` for `Vec<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        if elem.len() % 2 != 0 {\n            sorted_list.push(elem);\n\
    \        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    for\
    \ elem in sorted_list {\n        res.push(elem);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgwt5mz7g.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word)\
    \ {\n            sorted_list_len.push(word);\n        } else {\n            sorted_list.push(word);\n\
    \            sorted_list_len.push(word.len());\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| b.cmp(&a));\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf4bms9_o.rs:24:34\n   |\n\
    24 |             sorted_list_len.push(word.len());\n   |                     \
    \             ^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                  |\n   |                               \
    \   expected struct `String`, found `usize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp8iqc3843.rs:64:1\n   |\n64\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp8iqc3843.rs:63:35\n\
    \   |\n63 |     let mut sorted_list_len = lst.\n   |                         \
    \          ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8iqc3843.rs:16:41\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |    ---------------                     \
    \ ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.len()\
    \ == 1 {\n                sorted_list.push(word);\n            } else {\n    \
    \            if sorted_list[0].length() < word.length() {\n                  \
    \  sorted_list.push(word);\n                } else {\n                    sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n                    sorted_list.push(word);\n               \
    \ }\n            }\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpl894vll8.rs:26:35\n   |\n26 |                 if\
    \ sorted_list[0].length() < word.length() {\n   |                            \
    \       ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpl894vll8.rs:26:51\n\
    \   |\n26 |                 if sorted_list[0].length() < word.length() {\n   |\
    \                                                   ^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut i = 0;\n        let mut j = len - 1;\n \
    \       while i < j {\n            if lst[i].len() > lst[j].len() {\n        \
    \        i += 1;\n            } else {\n                j -= 1;\n            }\n\
    \        }\n        res.push(lst[i]);\n        len -= 1;\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp6tykwuy9.rs:29:18\n\
    \   |\n29 |         res.push(lst[i]);\n   |                  ^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        let mut sorted_list_word = vec![];\n        for word in lst {\n \
    \           if word.len() == word {\n                sorted_list_word.push(word);\n\
    \            }\n        }\n        sorted_list.push(sorted_list_word);\n    }\n\
    \    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5kvm4k05.rs:26:30\n   |\n\
    26 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5kvm4k05.rs:33:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n33 |     sorted_list\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        let mut sorted_list_word = vec![];\n        for word in lst {\n \
    \           if word.len() == word {\n                sorted_list_word.push(word);\n\
    \            }\n        }\n        sorted_list.push(sorted_list_word);\n    }\n\
    \    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5kvm4k05.rs:26:30\n   |\n\
    26 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5kvm4k05.rs:33:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n33 |     sorted_list\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        sorted_list.push(word.to_string());\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"1\", \"2\", \"3\"]`,\n right: `[\"aa\"]`', /tmp/tmpyqxqsg29.rs:32:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len2 = sorted_list_len;\n    let mut sorted_list_len3\
    \ = sorted_list_len;\n    let mut sorted_list_len4 = sorted_list_len;\n    let\
    \ mut sorted_list_len5 = sorted_list_len;\n    let mut sorted_list_len6 = sorted_list_len;\n\
    \    let mut sorted_list_len7 = sorted_list_len;\n    let mut sorted_list_len8\
    \ = sorted_list_len;\n    let mut sorted_list_len9 = sorted_list_len;\n    let\
    \ mut sorted_list_len10 = sorted_list_len;\n    let mut sorted_list_len11 = sorted_list_len;\n\
    \    let mut sorted_list_len12 = sorted_list_len;\n    let mut sorted_list_len13\
    \ = sorted_list_len;\n    let mut sorted_list_len14 = sorted_list_len;\n    let\
    \ mut sorted_list_len15 = sorted_list_len;\n    let mut sorted_list_len16 = sorted_list_len;\n\
    \    let mut sorted_list_len17 = sorted_list_len;\n    let mut sorted_list_len18\
    \ = sorted_list_len;\n    let mut sorted_list_len19 = sorted_list_len;\n    let\
    \ mut sorted_list_len20 = sorted_list_len;\n    let mut sorted_list_len21 = sorted_list_len;\n\
    \    let mut sorted_list_len22 = sorted_list_len;\n    let mut sorted_list_len23\
    \ = sorted_list_len;\n    let mut sorted_list_len24 = sorted_list_len;\n    let\
    \ mut sorted_list_len25 = sorted_list_len;\n    let mut sorted_list_len26 = sorted_list_len;\n\
    \    let mut sorted_list_len27 = sorted_list_len;\n    let mut sorted_list_len28\
    \ = sorted_list_len;\n    let mut sorted_list_len29 = sorted_list_len;\n    let\
    \ mut sorted_list_len30 = sorted_list_len;\n    let mut sorted_list_len31 = sorted_list_len;\n\
    \    let mut sorted_list_len32 = sorted_list_len;\n    let mut sorted_list_len33\
    \ = sorted_list_len;\n    let mut sorted_list_len34 = sorted_list_len;\n    let\
    \ mut sorted_list_len35 = sorted_list_len;\n    let mut sorted_list_len36 = sorted_list_len;\n\
    \    let mut sorted_list_len37 = sorted_list_len;\n    let mut sorted_list_len38\
    \ = sorted_list_len;\n    let mut sorted_list_len39 = sorted_list_len;\n    let\
    \ mut sorted_list_len40 = sorted_list_len;\n    let mut sorted_list_len41 = sorted_list_len;\n\
    \    let mut sorted_list_len42 = sorted_list_len;\n    let mut sorted_list_len43\
    \ = sorted_list_len;\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjqae1t8q.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() > 0 {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if word.len() < sorted_list.last().unwrap().len() {\n   \
    \                 sorted_list.push(word);\n                }\n            }\n\
    \        } else {\n            sorted_list.push(word);\n        }\n    }\n   \
    \ sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpaa3pp5rn.rs:20:28\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         --------------- consider\
    \ giving `sorted_list` the explicit type `Vec<T>`, where the type parameter `T`\
    \ is specified\n...\n20 |             if sorted_list.last().unwrap().len() < word.len()\
    \ {\n   |                            ^^^^ cannot infer type for type parameter\
    \ `T`\n   |\n   = note: type must be known at this point\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut i = 0;\n    while i\
    \ < lst.len() {\n        if lst[i].len() % 2 != 0 {\n            res.push(lst[i]);\n\
    \            i += 1;\n        } else {\n            let mut j = i;\n         \
    \   while j < lst.len() && lst[j].len() == lst[i].len() {\n                j +=\
    \ 1;\n            }\n            if j != i {\n                res.push(lst[j]);\n\
    \                i += 1;\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpf0gbj2_0.rs:21:22\n\
    \   |\n21 |             res.push(lst[i]);\n   |                      ^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpf0gbj2_0.rs:29:26\n\
    \   |\n29 |                 res.push(lst[j]);\n   |                          ^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    for word in lst {\n      \
    \  if word.len() % 2 != 0 {\n            sorted_list.push(word);\n        }\n\
    \    }\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmph760l558.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        let mut sorted_list_word = vec![];\n        for word in lst {\n \
    \           if word.len() == word {\n                sorted_list_word.push(word);\n\
    \            }\n        }\n        sorted_list.push(sorted_list_word);\n    }\n\
    \    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5kvm4k05.rs:26:30\n   |\n\
    26 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5kvm4k05.rs:33:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n33 |     sorted_list\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if sorted_list.last().unwrap().len() == word.len() {\n  \
    \                  sorted_list.push(word);\n                }\n            }\n\
    \        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaj9ix9rd.rs:32:32\n   |\n\
    32 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            for c in s.chars()\
    \ {\n                if i == 0 {\n                    i += 1;\n              \
    \      continue;\n                }\n                if c != s.chars().nth(i)\
    \ {\n                    i += 1;\n                    continue;\n            \
    \    }\n                i += 1;\n            }\n            sorted_list.push(s);\n\
    \        }\n    }\n    for s in sorted_list {\n        res.push(s);\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptfaaiv7k.rs:29:25\n   |\n\
    29 |                 if c != s.chars().nth(i) {\n   |                        \
    \ ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<char>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            for c in s.chars()\
    \ {\n                i += 1;\n                if i == 2 {\n                  \
    \  res.push(s);\n                    break;\n                }\n            }\n\
    \        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprxdl9xrh.rs:33:32\n   |\n\
    33 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprxdl9xrh.rs:34:32\n   |\n34 |\
    \     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                   \
    \             ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprxdl9xrh.rs:35:32\n   |\n35 |\
    \     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                   \
    \             ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpq8nq5wjr.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpq8nq5wjr.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                if sorted_list[0].len() < word.length()\
    \ {\n                    sorted_list.push(word);\n                } else {\n \
    \                   sorted_list.swap(0, 1);\n                }\n            }\
    \ else {\n                if sorted_list[0].length() < word.length() {\n     \
    \               sorted_list.push(word);\n                } else {\n          \
    \          sorted_list.swap(0, 1);\n                }\n            }\n       \
    \ }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpv5xl32t2.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpv5xl32t2.rs:23:48\n   |\n23 |          \
    \   if sorted_list[0].length() == word.length() {\n   |                      \
    \                          ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpv5xl32t2.rs:24:48\n   |\n24 |                 if sorted_list[0].len()\
    \ < word.length() {\n   |                                                ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `length` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpv5xl32t2.rs:30:35\n\
    \   |\n30 |                 if sorted_list[0].length() < word.length() {\n   |\
    \                                   ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpv5xl32t2.rs:30:51\n   |\n30 |                 if sorted_list[0].length()\
    \ < word.length() {\n   |                                                   ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       let mut i = 0;\n                while i < sorted_list.len() {\n      \
    \              if sorted_list[i].len() < word.len() {\n                      \
    \  i += 1;\n                    } else {\n                        if sorted_list[i].len()\
    \ == word.len() {\n                            if sorted_list[i].cmp(&word) <\
    \ 0 {\n                                sorted_list.insert(i, word);\n        \
    \                        i += 1;\n                            } else {\n     \
    \                           i += 1;\n                            }\n         \
    \               } else {\n                            i += 1;\n              \
    \          }\n                    }\n                }\n            }\n      \
    \  }\n    }\n    for word in sorted_list {\n        res.push(word);\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphgs0j6yp.rs:32:60\n   |\n\
    32 | ...                   if sorted_list[i].cmp(&word) < 0 {\n   |          \
    \                                            ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpkbjk0ub9.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpkbjk0ub9.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    let mut sorted_list = sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmptzt_k_66.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmptzt_k_66.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by_key(|word|\
    \ word.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpf3xuk08f.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n    let mut sorted_list_len = sorted_list_\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsavyntzj.rs:41:43\n   |\n\
    41 |     let mut sorted_list_len = sorted_list_\n   |                        \
    \                   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `sorted_list_` in this scope\n  --> /tmp/tmpsavyntzj.rs:41:31\n\
    \   |\n41 |     let mut sorted_list_len = sorted_list_\n   |                 \
    \              ^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `sorted_list`\n\nerror[E0599]: no method named `unwrap` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpsavyntzj.rs:19:84\n   |\n19 |     let mut\
    \ sorted_list_len = sorted_list_len.saturating_add((sorted_list_len % 2).unwrap());\n\
    \   |                                                                        \
    \            ^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpsavyntzj.rs:20:84\n\
    \   |\n20 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n   |                                                      \
    \                              ^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpsavyntzj.rs:21:84\n   |\n21 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n   |                                                      \
    \                              ^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpsavyntzj.rs:22:84\n   |\n22 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2).unwrap());\n   |                                                      \
    \                              ^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpsavyntzj.rs:23:84\n   |\n23 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_l"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ / 2).floor());\n    for word in lst {\n        if sorted_list_len == sorted_list_len.saturating_add(1)\
    \ {\n            sorted_list.push(word);\n            sorted_list_len = 0;\n \
    \       } else {\n            sorted_list_len += 1;\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `floor` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp3tcp4bk5.rs:19:84\n   |\n19 |     let mut sorted_list_len\
    \ = sorted_list_len.saturating_add((sorted_list_len / 2).floor());\n   |     \
    \                                                                            \
    \   ^^^^^ method not found in `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = lst;\n\
    \    sorted_list.sort_by_key(|x| x.len());\n    for word in sorted_list {\n  \
    \      if res.iter().any(|x| x.len() == word.len()) {\n            sorted_list.sort_by_key(|x|\
    \ x.cmp(&word).unwrap());\n        }\n        res.push(word);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmprum5hhdu.rs:21:28\n\
    \   |\n21 |         if res.iter().any(|x| x.len() == word.len()) {\n   |     \
    \                       ^ consider giving this closure parameter the explicit\
    \ type `&T`, where the type parameter `T` is specified\n   |\n   = note: type\
    \ must be known at this point\n\nerror[E0599]: no method named `unwrap` found\
    \ for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmprum5hhdu.rs:22:54\n\
    \   |\n22 |             sorted_list.sort_by_key(|x| x.cmp(&word).unwrap());\n\
    \   |                                                      ^^^^^^ method not found\
    \ in `std::cmp::Ordering`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0282, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = lst;\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    for s in sorted_list\
    \ {\n        if s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3mrjpf7k.rs:19:32\n   |\n\
    19 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp7onmd0m_.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp7onmd0m_.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqayqkj76.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        for word in lst {\n            if word.len() == word {\n        \
    \        sorted_list.push(word);\n                break;\n            }\n    \
    \    }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmmqbz70b.rs:25:30\n   |\n\
    25 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut i = 0;\n        while i < len {\n      \
    \      if lst[i].len() > len {\n                len = lst[i].len();\n        \
    \    }\n            i += 1;\n        }\n        res.push(lst[i]);\n        lst.swap_remove(i);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp2b_gnimj.rs:27:18\n\
    \   |\n27 |         res.push(lst[i]);\n   |                  ^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror[E0596]: cannot borrow `lst` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp2b_gnimj.rs:28:9\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                    --- help: consider changing this to\
    \ be mutable: `mut lst`\n...\n28 |         lst.swap_remove(i);\n   |         ^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0507, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        let len = word.len();\n        if len % 2 != 0 {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_by_key(|word| word.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp_xkwjp91.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        sorted_list.push(word.to_string());\n    }\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"1\", \"2\", \"3\"]`,\n right: `[\"aa\"]`', /tmp/tmps89jw1ys.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpkbjk0ub9.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpkbjk0ub9.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpbn6k_4tc.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpbn6k_4tc.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if word.len() % 2 != 0 {\n            sorted_list.push(word);\n     \
    \   }\n    }\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmplkn_y70g.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        sorted_list.push(lst.remove(&word));\n    }\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfdmghqfn.rs:24:37\n   |\n\
    24 |         sorted_list.push(lst.remove(&word));\n   |                      \
    \               ^^^^^ expected `usize`, found `&usize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n24 -         sorted_list.push(lst.remove(&word));\n24 +  \
    \       sorted_list.push(lst.remove(word));\n   | \n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if len % 2 == 0 {\n        \
    \    i += 1;\n            continue;\n        }\n        let mut j = 0;\n     \
    \   while j < len {\n            if j % 2 == 0 {\n                j += 1;\n  \
    \              continue;\n            }\n            if lst[j].len() < lst[i].len()\
    \ {\n                res.push(lst[j]);\n                j += 1;\n            \
    \    continue;\n            }\n            if lst[j].len() > lst[i].len() {\n\
    \                res.push(lst[i]);\n                i += 1;\n                continue;\n\
    \            }\n            if lst[j].len() == lst[i].len() {\n              \
    \  res.push(lst[j]);\n                j += 1;\n                i += 1;\n     \
    \           continue;\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpeaov9al_.rs:18:9\n\
    \   |\n18 |     let mut len = lst.len();\n   |         ----^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n \
    \ --> /tmp/tmpeaov9al_.rs:32:26\n   |\n32 |                 res.push(lst[j]);\n\
    \   |                          ^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror[E0507]: cannot move out of\
    \ index of `Vec<String>`\n  --> /tmp/tmpeaov9al_.rs:37:26\n   |\n37 |        \
    \         res.push(lst[i]);\n   |                          ^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpeaov9al_.rs:42:26\n\
    \   |\n42 |                 res.push(lst[j]);\n   |                          ^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n  \
    \      } else {\n            let mut current_word = sorted_list[0];\n        \
    \    let mut current_word_len = word.len();\n            for elem in sorted_list\
    \ {\n                if elem.len() > current_word_len {\n                    current_word\
    \ = elem;\n                    current_word_len = elem.len();\n              \
    \  }\n            }\n            if current_word_len == word.len() {\n       \
    \         sorted_list.push(word);\n            } else {\n                sorted_list.push(current_word);\n\
    \                sorted_list.push(word);\n            }\n        }\n    }\n  \
    \  sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmpg4mh5rqe.rs:19:12\n\
    \    |\n17  |     let mut sorted_list = vec![];\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n18  |     for word in lst {\n19  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^ value borrowed here after move\n...\n24\
    \  |             for elem in sorted_list {\n    |                         -----------\n\
    \    |                         |\n    |                         `sorted_list`\
    \ moved due to this implicit call to `.into_iter()`, in previous iteration of\
    \ loop\n    |                         help: consider borrowing to avoid moving\
    \ into the for loop: `&sorted_list`\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `sorted_list`\n\nerror[E0507]: cannot move\
    \ out of index of `Vec<String>`\n  --> /tmp/tmpg4mh5rqe.rs:22:36\n   |\n22 | \
    \            let mut current_word = sorted_list[0];\n   |                    \
    \                ^^^^^^^^^^^^^^\n   |                                    |\n \
    \  |                                    move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n   |                            \
    \        help: consider borrowing here: `&sorted_list[0]`\n\nerror[E0382]: borrow\
    \ of moved value: `elem`\n  --> /tmp/tmpg4mh5rqe.rs:27:40\n   |\n24 |        \
    \     for elem in sorted_list {\n   |                 ---- move occurs because\
    \ `elem` has type `String`, which does not implement the `Copy` trait\n25 |  \
    \               if elem.len() > current_word_len {\n26 |                     current_word\
    \ = elem;\n   |                                    ---- value moved here\n27 |\
    \                     current_word_len = elem.len();\n   |                   \
    \                     ^^^^ value borrowed here after move\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0507.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() > 0 {\n            if word.len() > res[0].len() {\n           \
    \     res.sort_by(|a, b| a.len() < b.len());\n            } else {\n         \
    \       res.sort_by(|a, b| a.len() < b.len() || a.cmp(b).unwrap() < 0);\n    \
    \        }\n        }\n        res.push(word);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpdz63wrou.rs:20:29\n\
    \   |\n17 |     let mut res = vec![];\n   |         ------- consider giving `res`\
    \ the explicit type `Vec<T>`, with the type parameters specified\n...\n20 |  \
    \           if word.len() > res[0].len() {\n   |                             ^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n  \
    \      } else if sorted_list.len() == 1 {\n            sorted_list.push(word);\n\
    \        } else if sorted_list.last().unwrap().len() < word.len() {\n        \
    \    sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().cmp(&word).is_less()\
    \ {\n                sorted_list.push(word);\n            }\n        }\n    }\n\
    \    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_less` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmp8ia1tqsm.rs:26:55\n   |\n26 |          \
    \   if sorted_list.last().unwrap().cmp(&word).is_less() {\n   |              \
    \                                         ^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_le`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.iter().position(|&len| len == word.len()).is_some() {\n    \
    \        sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpafri8mol.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 ---\n    |                 |\n    |                 `lst` moved\
    \ due to this implicit call to `.into_iter()`\n    |                 help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n23  |     for word\
    \ in lst {\n    |                 ^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqayqkj76.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ > word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if sorted_list.last().unwrap().len() < word.len() {\n   \
    \                 sorted_list.push(sorted_list.last().unwrap());\n           \
    \     }\n            }\n        }\n    }\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyi28rp_p.rs:27:38\n   |\n\
    27 |                     sorted_list.push(sorted_list.last().unwrap());\n   |\
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \          |\n   |                                      expected struct `String`,\
    \ found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyi28rp_p.rs:32:32\n\
    \   |\n32 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for elem in lst {\n        sorted_list_len.push(elem.len());\n\
    \        sorted_list.push(elem);\n    }\n    sorted_list_len.sort_unstable();\n\
    \    sorted_list_len.iter().for_each(|&len| {\n        sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n    });\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp5g5gwiho.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for ele in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(ele);\n\
    \        } else {\n            if sorted_list[0].len() < ele.len() {\n       \
    \         sorted_list.push(ele);\n            } else {\n                sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n                sorted_list.push(ele);\n           \
    \ }\n        }\n    }\n    for ele in sorted_list {\n        res.push(ele);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgjjqb88.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp7onmd0m_.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp7onmd0m_.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       let mut i = 0;\n                while i < sorted_list.len() && sorted_list[i].len()\
    \ < word.len() {\n                    i += 1;\n                }\n           \
    \     sorted_list.insert(i, word);\n            }\n        }\n    }\n    for word\
    \ in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmph16bp813.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for i in 0..sorted_list_len.len()\
    \ {\n        let mut temp_sorted_list = vec![];\n        for word in lst {\n \
    \           if i == sorted_list_len.len() - 1 {\n                if word.len()\
    \ == sorted_list_len.len() {\n                    temp_sorted_list.push(word);\n\
    \                }\n            } else {\n                if word.len() == sorted_list_len[i]\
    \ {\n                    temp_sorted_list.push(word);\n                }\n   \
    \         }\n        }\n        sorted_list.extend(temp_sorted_list);\n    }\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpcri9cees.rs:25:21\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n25  |         for word in lst {\n    |                     ^^^ `lst` moved\
    \ due to this implicit call to `.into_iter()`, in previous iteration of loop\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider borrowing to avoid moving into the for loop\n    |\n25\
    \  |         for word in &lst {\n    |                     ~~~~\nhelp: consider\
    \ borrowing to avoid moving into the for loop\n    |\n19  |     for word in &lst\
    \ {\n    |                 ~~~~\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = lst.len();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = l\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp58m10zpf.rs:63:32\n   |\n\
    63 |     let mut sorted_list_len = l\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `l` in this scope\n  --> /tmp/tmp58m10zpf.rs:63:31\n   |\n63 |     let mut sorted_list_len\
    \ = l\n   |                               ^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp58m10zpf.rs:16:41\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |    ---------------                     \
    \ ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word)\
    \ {\n            sorted_list_len.push(word);\n        } else {\n            sorted_list.push(word);\n\
    \            sorted_list_len.push(word.len());\n        }\n    }\n    sorted_list.sort_by_key(|word|\
    \ word.len());\n    sorted_list.sort_by_key(|word| word.to_lowercase());\n   \
    \ sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9go9hfra.rs:24:34\n   |\n\
    24 |             sorted_list_len.push(word.len());\n   |                     \
    \             ^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                  |\n   |                               \
    \   expected struct `String`, found `usize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        if elem.len() % 2 != 0 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut i = 0;\n            for j in 0..elem.len()\
    \ {\n                if j % 2 == 0 {\n                    i += 1;\n          \
    \      }\n            }\n            sorted_list.push(elem.split_off(i));\n  \
    \      }\n    }\n    for i in 0..sorted_list.len() {\n        res.push(sorted_list[i]);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `elem` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp48mr7z8j.rs:29:30\n   |\n19 |     for elem in lst {\n\
    \   |         ---- help: consider changing this to be mutable: `mut elem`\n...\n\
    29 |             sorted_list.push(elem.split_off(i));\n   |                  \
    \            ^^^^ cannot borrow as mutable\n\nerror[E0507]: cannot move out of\
    \ index of `Vec<String>`\n  --> /tmp/tmp48mr7z8j.rs:33:18\n   |\n33 |        \
    \ res.push(sorted_list[i]);\n   |                  ^^^^^^^^^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0507, E0596.\nFor more information about an error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len.push(word.len());\n            sorted_list.push(word);\n\
    \        } else {\n            sorted_list_len.push(word.len());\n           \
    \ sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b| b.len()\
    \ - a.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp65krc9zq.rs:28:32\n   |\n\
    28 |     sorted_list.sort_by(|a, b| b.len() - a.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `usize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    while sorted_list_len > 0 {\n        let mut sorted_list_len\
    \ = 0;\n        for word in lst {\n            if word.len() > sorted_list_len\
    \ {\n                sorted_list_len = word.len();\n            }\n        }\n\
    \        sorted_list.push(lst.iter().filter(|&word| word.len() == sorted_list_len).cloned().collect::<Vec<String>>().sort());\n\
    \        lst.iter().filter(|&word| word.len() != sorted_list_len).cloned().collect::<Vec<String>>().sort();\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg0o1ippn.rs:29:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n29 |     sorted_list\n   |     ^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<()>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5w8tdx_r.rs:43:58\n   |\n\
    43 |     let mut sorted_list_len = sorted_list_len.saturating_\n   |         \
    \                                                 ^ help: add `;` here\n44 | }\n\
    \   | - unexpected token\n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmp5w8tdx_r.rs:19:62\n   |\n19 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmp5w8tdx_r.rs:20:62\n   |\n20 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n\nwarning: unnecessary parentheses around method\
    \ argument\n  --> /tmp/tmp5w8tdx_r.rs:21:62\n   |\n21 |     let mut sorted_list_len\
    \ = sorted_list_len.saturating_add((sorted_list_len % 2));\n   |             \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^ help:\
    \ remove these parentheses\n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmp5w8tdx_r.rs:22:62\n   |\n22 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n\nwarning: unnecessary parentheses around method\
    \ argument\n  --> /tmp/tmp5w8tdx_r.rs:23:62\n   |\n23 |     let mut sorted_list_len\
    \ = sorted_list_len.saturating_add((sorted_list_len % 2));\n   |             \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^ help:\
    \ remove these parentheses\n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmp5w8tdx_r.rs:24:62\n   |\n24 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                             "
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() == 0 {\n            res.push(word);\n        } else {\n       \
    \     let mut found = false;\n            for elem in res {\n                if\
    \ elem.len() < word.len() {\n                    found = true;\n             \
    \       break;\n                }\n            }\n            if !found {\n  \
    \              res.push(word);\n            }\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n   --> /tmp/tmp21kv66s3.rs:19:12\n\
    \    |\n17  |     let mut res = vec![];\n    |         ------- move occurs because\
    \ `res` has type `Vec<String>`, which does not implement the `Copy` trait\n18\
    \  |     for word in lst {\n19  |         if res.len() == 0 {\n    |         \
    \   ^^^ value borrowed here after move\n...\n23  |             for elem in res\
    \ {\n    |                         ---\n    |                         |\n    |\
    \                         `res` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                         help: consider\
    \ borrowing to avoid moving into the for loop: `&res`\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `res`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp7onmd0m_.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp7onmd0m_.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp581_z7dn.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpkbjk0ub9.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpkbjk0ub9.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if word.len() % 2 != 0 {\n            sorted_list.push(word);\n     \
    \   }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaosr1007.rs:23:32\n   |\n\
    23 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut counter = 0;\n\
    \    for word in lst {\n        if counter % 2 == 1 {\n            sorted_list.push(word);\n\
    \        }\n        counter += 1;\n    }\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi2m5m96l.rs:25:32\n   |\n\
    25 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut len = lst.len();\n\
    \    let mut i = 0;\n    while i < len {\n        let mut j = i;\n        while\
    \ j < len && lst[j].len() < lst[i].len() {\n            j += 1\n        }\n  \
    \      if j == i {\n            sorted_list.push(lst[i]);\n            i += 1;\n\
    \        } else {\n            sorted_list.push(lst[j]);\n            i += 1;\n\
    \        }\n    }\n    sorted_list.sort();\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmps9my01wu.rs:18:9\n\
    \   |\n18 |     let mut len = lst.len();\n   |         ----^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n \
    \ --> /tmp/tmps9my01wu.rs:26:30\n   |\n26 |             sorted_list.push(lst[i]);\n\
    \   |                              ^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror[E0507]: cannot move out of\
    \ index of `Vec<String>`\n  --> /tmp/tmps9my01wu.rs:29:30\n   |\n29 |        \
    \     sorted_list.push(lst[j]);\n   |                              ^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|word| word.len());\n\
    \    sorted_list.sort_by_key(|word| word.to_lowercase());\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmppqj7jd6b.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmppqj7jd6b.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut counter = 0;\n\
    \    for elem in lst {\n        if elem.len() % 2 != 0 {\n            sorted_list.push(elem);\n\
    \            counter += 1;\n        }\n    }\n    if counter > 0 {\n        sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7f6ru52_.rs:26:36\n   |\n\
    26 |         sorted_list.sort_by(|a, b| a.len() < b.len());\n   |            \
    \                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut len = lst.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if i % 2 == 1 {\n          \
    \  res.push(lst[i]);\n        }\n        i += 1;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpk1vhk0we.rs:18:9\n\
    \   |\n18 |     let mut len = lst.len();\n   |         ----^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n \
    \ --> /tmp/tmpk1vhk0we.rs:22:22\n   |\n22 |             res.push(lst[i]);\n  \
    \ |                      ^^^^^^ move occurs because value has type `String`, which\
    \ does not implement the `Copy` trait\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                if sorted_list[0].chars().zip(word.chars()).all(|(a,\
    \ b)| a == b) {\n                    sorted_list.push(word);\n               \
    \ } else {\n                    sorted_list.sort_by(|a, b| a.cmp(b));\n      \
    \          }\n            } else {\n                sorted_list.sort_by(|a, b|\
    \ a.cmp(b));\n                sorted_list.push(word);\n            }\n       \
    \ }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpmzjzx2_0.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpmzjzx2_0.rs:23:48\n\
    \   |\n23 |             if sorted_list[0].length() == word.length() {\n   |  \
    \                                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp581_z7dn.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        sorted_list.push(lst.remove(&word));\n    }\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfdmghqfn.rs:24:37\n   |\n\
    24 |         sorted_list.push(lst.remove(&word));\n   |                      \
    \               ^^^^^ expected `usize`, found `&usize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n24 -         sorted_list.push(lst.remove(&word));\n24 +  \
    \       sorted_list.push(lst.remove(word));\n   | \n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for elem in\
    \ sorted_list {\n                if elem.len() == word.len() {\n             \
    \       if elem.cmp(&word) == cmp::Ordering::Less {\n                        found\
    \ = true;\n                        break;\n                    }\n           \
    \     }\n            }\n            if !found {\n                sorted_list.push(word);\n\
    \            }\n        }\n    }\n    for elem in sorted_list {\n        res.push(elem);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpizv53ef0.rs:26:43\n   |\n26 |                     if elem.cmp(&word)\
    \ == cmp::Ordering::Less {\n   |                                           ^^^\
    \ use of undeclared crate or module `cmp`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list.push(word);\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list.sort_by(|a, b| {\n        if a.len() < b.len() {\n   \
    \         -1\n        } else {\n            a.cmp(b)\n        }\n    });\n   \
    \ sorted_list.sort_by(|a, b| {\n        if a.len() < b.len() {\n            -1\n\
    \        } else {\n            a.cmp(b)\n        }\n    });\n    sorted_list.sort_by(|a,\
    \ b| {\n        if a.len() < b.len() {\n            -1\n        } else {\n   \
    \         a.cmp(b)\n        }\n    });\n    sorted_list\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk5hnv0_9.rs:25:13\n   |\n\
    25 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk5hnv0_9.rs:32:13\n\
    \   |\n32 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk5hnv0_9.rs:39:13\n\
    \   |\n39 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut counter = 0;\n\
    \    for word in lst {\n        if counter == 0 {\n            sorted_list.push(word);\n\
    \            counter += 1;\n        } else {\n            if word.len() < sorted_list[sorted_list.len()\
    \ - 1].len() {\n                sorted_list.push(word);\n                counter\
    \ += 1;\n            } else {\n                let mut i = 0;\n              \
    \  while i < sorted_list.len() {\n                    if sorted_list[i].len()\
    \ < word.len() {\n                        i += 1;\n                    } else\
    \ {\n                        if sorted_list[i].len() == word.len() {\n       \
    \                     if sorted_list[i].cmp(&word) < 0 {\n                   \
    \             sorted_list.swap(i, sorted_list.len() - 1);\n                  \
    \          }\n                        }\n                        i += 1;\n   \
    \                 }\n                }\n                sorted_list.push(word);\n\
    \                counter += 1;\n            }\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2pk0xjas.rs:34:60\n   |\n\
    34 | ...                   if sorted_list[i].cmp(&word) < 0 {\n   |          \
    \                                            ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() > 0 {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if sorted_list.last().unwrap().cmp(&word) == cmp::Ordering::Less\
    \ {\n                    sorted_list.push(word);\n                }\n        \
    \    }\n        } else {\n            sorted_list.push(word);\n        }\n   \
    \ }\n    sorted_list.sort_by(|a, b| a.len().cmp(&b.len()));\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmps2qr9k5c.rs:23:62\n   |\n23 |                 if sorted_list.last().unwrap().cmp(&word)\
    \ == cmp::Ordering::Less {\n   |                                             \
    \                 ^^^ use of undeclared crate or module `cmp`\n\nerror[E0282]:\
    \ type annotations needed for `Vec<T>`\n  --> /tmp/tmps2qr9k5c.rs:20:28\n   |\n\
    17 |     let mut sorted_list = vec![];\n   |         --------------- consider\
    \ giving `sorted_list` the explicit type `Vec<T>`, where the type parameter `T`\
    \ is specified\n...\n20 |             if sorted_list.last().unwrap().len() < word.len()\
    \ {\n   |                            ^^^^ cannot infer type for type parameter\
    \ `T`\n   |\n   = note: type must be known at this point\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0433.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut i = 0;\n        let mut j = 0;\n       \
    \ while i < len && j < len {\n            if lst[i].len() > lst[j].len() {\n \
    \               sorted_list.push(lst[j]);\n                j += 1;\n         \
    \   } else {\n                i += 1;\n            }\n        }\n        sorted_list.push(lst[j]);\n\
    \        len -= 1;\n    }\n    sorted_list.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp70y59g1t.rs:24:34\n\
    \   |\n24 |                 sorted_list.push(lst[j]);\n   |                  \
    \                ^^^^^^ move occurs because value has type `String`, which does\
    \ not implement the `Copy` trait\n\nerror[E0507]: cannot move out of index of\
    \ `Vec<String>`\n  --> /tmp/tmp70y59g1t.rs:30:26\n   |\n30 |         sorted_list.push(lst[j]);\n\
    \   |                          ^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 == 1 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by_key(|word|\
    \ word.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp7a4djkmg.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() > 0 {\n            if sorted_list[0].len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       sorted_list.sort_by(|a, b| a.len() < b.len());\n                sorted_list.push(word);\n\
    \            }\n        } else {\n            sorted_list.push(word);\n      \
    \  }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpahgsuxdf.rs:20:16\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         --------------- consider\
    \ giving `sorted_list` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n20 |             if sorted_list[0].len() < word.len() {\n   |           \
    \     ^^^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must be known at\
    \ this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].length() == word.length() {\n\
    \                sorted_list.sort_by(|a, b| a.cmp(b));\n                sorted_list.push(word);\n\
    \            } else {\n                sorted_list.sort_by(|a, b| a.cmp(b).reverse());\n\
    \                sorted_list.push(word);\n            }\n        }\n    }\n  \
    \  for word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmppy280vth.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmppy280vth.rs:23:48\n   |\n23 |          \
    \   if sorted_list[0].length() == word.length() {\n   |                      \
    \                          ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut cnt = 0;\n    for\
    \ s in lst {\n        if s.len() % 2 != 0 {\n            res.push(*s);\n     \
    \       cnt += 1;\n        }\n    }\n    res.sort();\n    res.sort_by(|a, b| a.cmp(b));\n\
    \    res.into_iter().map(|s| s.to_string()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpblohychy.rs:21:22\n   |\n21 |             res.push(*s);\n\
    \   |                      ^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n   --> /tmp/tmpblohychy.rs:17:19\n\
    \    |\n17  |     let mut res = Vec::new();\n    |                   ^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by `Vec::<T>::new`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpblohychy.rs:17:19\n    |\n17  |     let mut res = Vec::new();\n    |\
    \                   ^^^ doesn't have a size known at compile-time\n    |\n   \
    \ = help: the trait `Sized` is not implemented for `str`\nnote: required by a\
    \ bound in `Vec`\n\nerror[E0599]: no method named `sort` found for struct `Vec`\
    \ in the current scope\n  --> /tmp/tmpblohychy.rs:25:9\n   |\n25 |     res.sort();\n\
    \   |         ^^^^ method not found in `Vec<str>`\n\nerror[E0599]: no method named\
    \ `sort_by` found for struct `Vec` in the current scope\n  --> /tmp/tmpblohychy.rs:26:9\n\
    \   |\n26 |     res.sort_by(|a, b| a.cmp(b));\n   |         ^^^^^^^ method not\
    \ found in `Vec<str>`\n\nerror[E0599]: no method named `into_iter` found for struct\
    \ `Vec` in the current scope\n  --> /tmp/tmpblohychy.rs:27:9\n   |\n27 |     res.into_iter().map(|s|\
    \ s.to_string()).collect()\n   |         ^^^^^^^^^ method not found in `Vec<str>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.iter().position(|x| x == word).is_none() {\n         \
    \   sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp_k3s7krz.rs:19:24\n   |\n19 |         if sorted_list.iter().position(|x|\
    \ x == word).is_none() {\n   |                        ^^^^ doesn't have a size\
    \ known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmp_k3s7krz.rs:19:31\n   |\n19 |         if\
    \ sorted_list.iter().position(|x| x == word).is_none() {\n   |               \
    \                ^^^^^^^^ doesn't have a size known at compile-time\n   |\n  \
    \ = help: the trait `Sized` is not implemented for `str`\n   = note: required\
    \ because of the requirements on the impl of `Iterator` for `std::slice::Iter<'_,\
    \ str>`\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n   --> /tmp/tmp_k3s7krz.rs:17:27\n    |\n17  |     let mut\
    \ sorted_list = vec![];\n    |                           ^^^^^^ doesn't have a\
    \ size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by `Vec::<T>::new`\n    = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n   --> /tmp/tmp_k3s7krz.rs:17:27\n    |\n17  |     let mut\
    \ sorted_list = vec![];\n    |                           ^^^^^^ doesn't have a\
    \ size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec`\n    = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0599]: the method `push` exists for struct `Vec<str>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmp_k3s7krz.rs:20:25\n   |\n20 |\
    \             sorted_list.push(word);\n   |                         ^^^^ method\
    \ cannot be called on `Vec<str>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n "
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        for word in lst {\n            if word.len() == word {\n        \
    \        sorted_list.push(word);\n                break;\n            }\n    \
    \    }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmmqbz70b.rs:25:30\n   |\n\
    25 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if word.len() % 2 != 0 {\n            sorted_list.push(word);\n     \
    \   }\n    }\n    sorted_list.sort_by_key(|word| word.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpnogzujfy.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqayqkj76.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        sorted_list.push(lst.remove(&word));\n    }\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfdmghqfn.rs:24:37\n   |\n\
    24 |         sorted_list.push(lst.remove(&word));\n   |                      \
    \               ^^^^^ expected `usize`, found `&usize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n24 -         sorted_list.push(lst.remove(&word));\n24 +  \
    \       sorted_list.push(lst.remove(word));\n   | \n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                if sorted_list[0].chars().zip(word.chars()).all(|(a,\
    \ b)| a == b) {\n                    sorted_list.push(word);\n               \
    \ }\n            } else {\n                if sorted_list[0].length() < word.length()\
    \ {\n                    sorted_list.push(word);\n                }\n        \
    \    }\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpw8hb3d_k.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpw8hb3d_k.rs:23:48\n   |\n23 |          \
    \   if sorted_list[0].length() == word.length() {\n   |                      \
    \                          ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpw8hb3d_k.rs:28:35\n   |\n28 |                 if sorted_list[0].length()\
    \ < word.length() {\n   |                                   ^^^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpw8hb3d_k.rs:28:51\n   |\n28 | \
    \                if sorted_list[0].length() < word.length() {\n   |          \
    \                                         ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpq8nq5wjr.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpq8nq5wjr.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if sorted_list.last().unwrap().len() == word.len() {\n  \
    \                  if sorted_list.last().unwrap().cmp(&word) == cmp::Ordering::Less\
    \ {\n                        sorted_list.push(word);\n                    }\n\
    \                }\n            }\n        }\n    }\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpwkw9wo8g.rs:27:66\n   |\n27 |                     if sorted_list.last().unwrap().cmp(&word)\
    \ == cmp::Ordering::Less {\n   |                                             \
    \                     ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect::<Vec<_>>();\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmp2rqnvo7_.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect::<Vec<_>>();\n   |                      \
    \                     ^^^^^^ expected struct `String`, found reference\n   |\n\
    \   = note: expected struct `String`\n           found reference `&_`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp2rqnvo7_.rs:18:52\n \
    \  |\n18 |       let mut sorted_list = lst.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                                      ^^^^^^^ method cannot\
    \ be called on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.iter().position(|&x| x == word.len()).is_some() {\n        \
    \    sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpdr48gj8l.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 ---\n    |                 |\n    |                 `lst` moved\
    \ due to this implicit call to `.into_iter()`\n    |                 help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n23  |     for word\
    \ in lst {\n    |                 ^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqayqkj76.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut i = 0;\n        while i < len {\n      \
    \      if lst[i].len() > len {\n                len = lst[i].len();\n        \
    \    }\n            i += 1;\n        }\n        res.push(lst[i]);\n        lst.swap_remove(i);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp2b_gnimj.rs:27:18\n\
    \   |\n27 |         res.push(lst[i]);\n   |                  ^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror[E0596]: cannot borrow `lst` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp2b_gnimj.rs:28:9\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                    --- help: consider changing this to\
    \ be mutable: `mut lst`\n...\n28 |         lst.swap_remove(i);\n   |         ^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0507, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       let mut i = 0;\n                while i < sorted_list.len() {\n      \
    \              if sorted_list[i].len() < word.len() {\n                      \
    \  sorted_list[i] = word;\n                        break;\n                  \
    \  } else {\n                        i += 1;\n                    }\n        \
    \        }\n            }\n        }\n    }\n    for word in sorted_list {\n \
    \       res.push(word);\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp54hi1dpl.rs:46:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    while sorted_list_len > 0 {\n        let mut i = 0;\n        while\
    \ i < sorted_list_len {\n            if lst[i].len() > sorted_list_len {\n   \
    \             sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n                sorted_list.push(lst[i]);\n                sorted_list.sort();\n\
    \                sorted_list.pop();\n                sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n                break;\n            }\n            i += 1;\n       \
    \ }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp_0o3y2r0.rs:19:62\n\
    \   |\n19 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmp_0o3y2r0.rs:24:66\n   |\n24 |                 sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                               \
    \   ^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmp_0o3y2r0.rs:28:66\n   |\n\
    28 |                 sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                               \
    \   ^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp_0o3y2r0.rs:18:9\n   |\n18 |    \
    \ let mut sorted_list_len = lst.len();\n   |         ----^^^^^^^^^^^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n \
    \ --> /tmp/tmp_0o3y2r0.rs:25:34\n   |\n25 |                 sorted_list.push(lst[i]);\n\
    \   |                                  ^^^^^^ move occurs because value has type\
    \ `String`, which does not implement the `Copy` trait\n\nerror: aborting due to\
    \ previous error; 4 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut i = 0;\n        let mut j = len - 1;\n \
    \       while i < j {\n            if lst[i].len() > lst[j].len() {\n        \
    \        res.push(lst[j]);\n                j -= 1;\n            } else {\n  \
    \              i += 1;\n            }\n        }\n        res.push(lst[j]);\n\
    \        len -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpwh9glzut.rs:24:26\n\
    \   |\n24 |                 res.push(lst[j]);\n   |                          ^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpwh9glzut.rs:30:18\n\
    \   |\n30 |         res.push(lst[j]);\n   |                  ^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for elem in lst {\n        sorted_list_len.push(elem.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for elem in sorted_list_len\
    \ {\n        sorted_list.push(lst.remove(&elem));\n    }\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwecmfyfp.rs:24:37\n   |\n\
    24 |         sorted_list.push(lst.remove(&elem));\n   |                      \
    \               ^^^^^ expected `usize`, found `&usize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n24 -         sorted_list.push(lst.remove(&elem));\n24 +  \
    \       sorted_list.push(lst.remove(elem));\n   | \n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        let mut sorted_list = vec![];\n        for word in lst {\n      \
    \      if word.len() == word {\n                sorted_list.push(word);\n    \
    \        }\n        }\n        sorted_list.sort_unstable();\n        sorted_list.push(word);\n\
    \        sorted_list.sort_unstable();\n        sorted_list.push(word);\n     \
    \   sorted_list.sort_unstable();\n        sorted_list.push(word);\n        sorted_list.sort_unstable();\n\
    \        sorted_list.push(word);\n        sorted_list.sort_unstable();\n     \
    \   sorted_list.push(word);\n        sorted_list.sort_unstable();\n        sorted_list.push(word);\n\
    \        sorted_list.sort_unstable();\n        sorted_list.push(word);\n     \
    \   sorted_list.sort_unstable();\n        sorted_list.push(word);\n        sorted_list.sort_unstable();\n\
    \        sorted_list.push(word);\n        sorted_list.sort_unstable();\n     \
    \   sorted_list.push(word);\n        sorted_list.sort_unstable();\n        sorted_list.push(word);\n\
    \        sorted_list.sort_unstable();\n        sorted_list.push(word);\n     \
    \   sorted_list.sort_unstable();\n        sorted_list.push(word);\n        sorted_list.sort_unstable();\n\
    \        sorted_list.push(word);\n        sorted_list.sort_unstable();\n     \
    \   sorted_list.push(word);\n        sorted_list.sort_unstable();\n        sorted_list.push(word);\n\
    \        sorted_list.sort_unstable();\n        sorted_list.push(word);\n     \
    \   sorted_list.sort_unstable();\n        sorted_list.push(word);\n        sorted_list.sort_unstable();\n\
    \        sorted_list.push(word);\n        sorted_list.sort_unstable();\n     \
    \   sorted_list.push(word);\n        sorted_list.sort_unstable();\n        sorted_list.push(word);\n\
    \        sorted_list.sort_unstable();\n        sorted_list.push(word);\n     \
    \   sorted_list.sort_unstable();\n        sorted_list.push(word);\n        sorted_list.sort_unstable();\n\
    \        sorted_list.push(word);\n        sorted_list.sort_unstable();\n     \
    \   sorted_list.push(word);\n        sorted_list.sort_unstable();\n        sorted_list.push(word);\n\
    \        sorted_list.sort_unstable();\n        sorted_list.push(word);\n     \
    \   sorted_list.sort_unstable();\n        sorted_list.push(word);\n        sorted_list.sort_un\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpku28go_c.rs:98:3\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n23\
    \ |     for word in sorted_list_len {\n   |                                 -\
    \ this delimiter might not be properly closed...\n...\n87 | }\n   | - ...as it\
    \ matches this but it has different indentation\n...\n98 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpku28go_c.rs:26:30\n   |\n26 |             if\
    \ word.len() == word {\n   |                              ^^^^ expected `usize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpku28go_c.rs:31:26\n\
    \   |\n31 |         sorted_list.push(word);\n   |                          ^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \        |\n   |                          expected struct `String`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpku28go_c.rs:33:26\n   |\n33 |\
    \         sorted_list.push(word);\n   |                          ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                          |\n\
    \   |                          expected struct `String`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpku28go_c.rs:35:26\n   |\n35 |         sorted_list.push(word);\n\
    \   |                          ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                          |\n   |                          expected struct\
    \ `String`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpku28go_c.rs:37:26\n\
    \   |\n37 |         sorted_list.push(word);\n   |                          ^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \        |\n   |                          expected struct `String`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpku28go_c.rs:39:26\n   |\n39 |\
    \         sorted_list.push(word);\n   |                          ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                          |\n\
    \   |  "
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.len()\
    \ == 1 {\n                sorted_list.push(word);\n            } else {\n    \
    \            if sorted_list[0].length() == word.length() {\n                 \
    \   sorted_list.sort_by(|a, b| a.cmp(b));\n                } else {\n        \
    \            sorted_list.sort_by(|a, b| a.cmp(b).reverse());\n               \
    \ }\n            }\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp9fss22en.rs:26:35\n   |\n26 |                 if\
    \ sorted_list[0].length() == word.length() {\n   |                           \
    \        ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `length` found for struct `String` in the current scope\n  --> /tmp/tmp9fss22en.rs:26:52\n\
    \   |\n26 |                 if sorted_list[0].length() == word.length() {\n  \
    \ |                                                    ^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_sum = 0;\n    for word in lst {\n    \
    \    if sorted_list_len > 1 {\n            if sorted_list_len % 2 == 0 {\n   \
    \             if word.len() > sorted_list_sum {\n                    sorted_list_sum\
    \ += word.len();\n                }\n            } else {\n                if\
    \ word.len() < sorted_list_sum {\n                    sorted_list_sum += word.len();\n\
    \                }\n            }\n        } else {\n            if word.len()\
    \ > sorted_list_sum {\n                sorted_list_sum += word.len();\n      \
    \      }\n        }\n        sorted_list.push(word);\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpchq9zh28.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() > 0 {\n     \
    \       if sorted_list[0].length() == word.length() {\n                if sorted_list[0].len()\
    \ < word.length() {\n                    sorted_list.push(word);\n           \
    \     } else {\n                    sorted_list.sort_by(|a, b| a.cmp(b));\n  \
    \                  sorted_list.push(word);\n                }\n            } else\
    \ {\n                sorted_list.sort_by(|a, b| a.cmp(b));\n                sorted_list.push(word);\n\
    \            }\n        } else {\n            sorted_list.push(word);\n      \
    \  }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp3crnuf_c.rs:21:16\n\
    \   |\n18 |     let mut sorted_list = vec![];\n   |         --------------- consider\
    \ giving `sorted_list` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n21 |             if sorted_list[0].length() == word.length() {\n   |    \
    \            ^^^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must be known\
    \ at this point\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp3crnuf_c.rs:21:48\n   |\n21 |          \
    \   if sorted_list[0].length() == word.length() {\n   |                      \
    \                          ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp3crnuf_c.rs:22:48\n   |\n22 |                 if sorted_list[0].len()\
    \ < word.length() {\n   |                                                ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0282, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word)\
    \ {\n            sorted_list_len.push(word);\n        } else {\n            sorted_list.push(word);\n\
    \            sorted_list_len.push(word);\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzdbas2ut.rs:27:32\n   |\n\
    27 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    let mut sorted_list = sorted_list.sort_by(|a,\
    \ b| a.len().cmp(&b.len()).unwrap());\n    let mut sorted_list = sorted_list.sort_by(|a,\
    \ b| a.cmp(b).unwrap());\n    sorted_list.cloned().collect()\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmp9wayx7sz.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmp9wayx7sz.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = Vec::new();\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].length() == word.length() {\n\
    \                if sorted_list[0].chars().zip(word.chars()).all(|(a, b)| a ==\
    \ b) {\n                    sorted_list.push(word);\n                } else {\n\
    \                    sorted_list.sort_by(|a, b| a.cmp(b));\n                 \
    \   sorted_list.push(word);\n                }\n            } else {\n       \
    \         sorted_list.sort_by(|a, b| a.cmp(b));\n                sorted_list.push(word);\n\
    \            }\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp0kffoyje.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp0kffoyje.rs:23:48\n   |\n23 |          \
    \   if sorted_list[0].length() == word.length() {\n   |                      \
    \                          ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        for word in lst {\n            if word.len() == word {\n        \
    \        sorted_list.push(word);\n            }\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkfyk4a6_.rs:25:30\n   |\n\
    25 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() > 0 {\n            if word.len() > sorted_list[0].len()\
    \ {\n                sorted_list.sort_by(|a, b| a.len() < b.len());\n        \
    \    } else {\n                sorted_list.sort_by(|a, b| a.len() < b.len() ||\
    \ a.cmp(b).is_ok());\n            }\n        }\n        sorted_list.push(word);\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpg2xbrjh2.rs:20:29\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         --------------- consider\
    \ giving `sorted_list` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n20 |             if word.len() > sorted_list[0].len() {\n   |           \
    \                  ^^^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpbn6k_4tc.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpbn6k_4tc.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                if sorted_list[0].chars().zip(word.chars()).all(|(a,\
    \ b)| a == b) {\n                    sorted_list.push(word);\n               \
    \ } else {\n                    sorted_list.sort_by(|a, b| a.cmp(b));\n      \
    \          }\n            } else {\n                sorted_list.sort_by(|a, b|\
    \ a.cmp(b));\n                sorted_list.push(word);\n            }\n       \
    \ }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpmzjzx2_0.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpmzjzx2_0.rs:23:48\n\
    \   |\n23 |             if sorted_list[0].length() == word.length() {\n   |  \
    \                                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if sorted_list.last().unwrap().len() == word.len() {\n  \
    \                  sorted_list.last().unwrap().push(word);\n                }\
    \ else {\n                    sorted_list.push(word);\n                }\n   \
    \         }\n        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmoam277a.rs:27:54\n   |\n\
    27 |                     sorted_list.last().unwrap().push(word);\n   |       \
    \                                               ^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmoam277a.rs:34:32\n\
    \   |\n34 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |         \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    for word in lst {\n        if sorted_list_len == 1 {\n         \
    \   sorted_list.push(word);\n        } else {\n            if word.len() > sorted_list_len\
    \ {\n                sorted_list.push(word);\n                sorted_list_len\
    \ = sorted_list_len.saturating_add((sorted_list_len % 2));\n            } else\
    \ {\n                sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n            }\n        }\n    }\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpxa97ewz9.rs:19:62\n\
    \   |\n19 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmpxa97ewz9.rs:26:66\n   |\n26 |                 sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                               \
    \   ^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmpxa97ewz9.rs:28:66\n   |\n\
    28 |                 sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                               \
    \   ^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxa97ewz9.rs:32:32\n   |\n32 |     sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n   |                                ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to previous\
    \ error; 3 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.len() == 0 {\n\
    \            sorted_list_len.push(word.len());\n        }\n        if sorted_list_len.len()\
    \ == 1 {\n            sorted_list.push(word);\n        }\n        if sorted_list_len.len()\
    \ > 1 {\n            if sorted_list_len.iter().min().unwrap() == word.len() {\n\
    \                sorted_list.push(word);\n            } else {\n             \
    \   sorted_list_len.iter().for_each(|&x| {\n                    if x == sorted_list_len.iter().min().unwrap()\
    \ {\n                        sorted_list.push(word);\n                    }\n\
    \                });\n            }\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `usize`\n  --> /tmp/tmpyc_tk6tg.rs:27:54\n\
    \   |\n27 |             if sorted_list_len.iter().min().unwrap() == word.len()\
    \ {\n   |                                                      ^^ no implementation\
    \ for `&usize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not\
    \ implemented for `&usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyc_tk6tg.rs:31:29\n\
    \   |\n31 |                     if x == sorted_list_len.iter().min().unwrap()\
    \ {\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |                     if x == *sorted_list_len.iter().min().unwrap() {\n  \
    \ |                             +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                sorted_list.sort();\n\
    \                res.push(sorted_list[0]);\n                sorted_list.pop();\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpqmfopz9x.rs:27:26\n\
    \   |\n27 |                 res.push(sorted_list[0]);\n   |                  \
    \        ^^^^^^^^^^^^^^ move occurs because value has type `String`, which does\
    \ not implement the `Copy` trait\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpqbhcp607.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpqbhcp607.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                if sorted_list[0].chars().zip(word.chars()).all(|(a,\
    \ b)| a == b) {\n                    sorted_list.push(word);\n               \
    \ } else {\n                    sorted_list.sort_by(|a, b| a.cmp(b));\n      \
    \          }\n            } else {\n                sorted_list.sort_by(|a, b|\
    \ a.cmp(b));\n            }\n        }\n    }\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpme3exu5c.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpme3exu5c.rs:23:48\n   |\n23 |          \
    \   if sorted_list[0].length() == word.length() {\n   |                      \
    \                          ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut i = 0;\n        while i < len && lst[i].len()\
    \ < len {\n            i += 1;\n        }\n        if i == len {\n           \
    \ break;\n        }\n        res.push(lst[i]);\n        len -= 1;\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpea5wzroq.rs:27:18\n\
    \   |\n27 |         res.push(lst[i]);\n   |                  ^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.len() == 0 {\n\
    \            sorted_list_len.push(word.len());\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list_len.len() == word.len() {\n    \
    \            sorted_list_len.push(word.len());\n                sorted_list.push(word);\n\
    \            } else {\n                if sorted_list_len.len() > word.len() {\n\
    \                    sorted_list_len.push(word.len());\n                    sorted_list.push(word);\n\
    \                }\n            }\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyx8i8070.rs:35:32\n   |\n\
    35 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list.push(word);\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list.sort_by_key(|word| sorted_list_len.iter().position(|x|\
    \ x == word.len()).unwrap());\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `usize`\n  --> /tmp/tmpm5kijvqa.rs:23:74\n\
    \   |\n23 |     sorted_list.sort_by_key(|word| sorted_list_len.iter().position(|x|\
    \ x == word.len()).unwrap());\n   |                                          \
    \                                ^^ no implementation for `&usize == usize`\n\
    \   |\n   = help: the trait `PartialEq<usize>` is not implemented for `&usize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpq8nq5wjr.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpq8nq5wjr.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len2 = sorted_list_len;\n    let mut sorted_list_len3\
    \ = sorted_list_len2;\n    let mut sorted_list_len4 = sorted_list_len3;\n    let\
    \ mut sorted_list_len5 = sorted_list_len4;\n    let mut sorted_list_len6 = sorted_list_len5;\n\
    \    let mut sorted_list_len7 = sorted_list_len6;\n    let mut sorted_list_len8\
    \ = sorted_list_len7;\n    let mut sorted_list_len9 = sorted_list_len8;\n    let\
    \ mut sorted_list_len10 = sorted_list_len9;\n    let mut sorted_list_len11 = sorted_list_len10;\n\
    \    let mut sorted_list_len12 = sorted_list_len11;\n    let mut sorted_list_len13\
    \ = sorted_list_len12;\n    let mut sorted_list_len14 = sorted_list_len13;\n \
    \   let mut sorted_list_len15 = sorted_list_len14;\n    let mut sorted_list_len16\
    \ = sorted_list_len15;\n    let mut sorted_list_len17 = sorted_list_len16;\n \
    \   let mut sorted_list_len18 = sorted_list_len17;\n    let mut sorted_list_len19\
    \ = sorted_list_len18;\n    let mut sorted_list_len20 = sorted_list_len19;\n \
    \   let mut sorted_list_len21 = sorted_list_len20;\n    let mut sorted_list_len22\
    \ = sorted_list_len21;\n    let mut sorted_list_len23 = sorted_list_len22;\n \
    \   let mut sorted_list_len24 = sorted_list_len23;\n    let mut sorted_list_len25\
    \ = sorted_list_len24;\n    let mut sorted_list_len26 = sorted_list_len25;\n \
    \   let mut sorted_list_len27 = sorted_list_len26;\n    let mut sorted_list_len28\
    \ = sorted_list_len27;\n    let mut sorted_list_len29 = sorted_list_len28;\n \
    \   let mut sorted_list_len30 = sorted_list_len29;\n    let mut sorted_list_len31\
    \ = sorted_list_len30;\n    let mut sorted_list_len32 = sorted_list_len31;\n \
    \   let mut sorted_list_len33 = sorted_list_len32;\n    let mut sorted_list_len34\
    \ = sorted_list_len33;\n    let mut sorted_list_len35 = sorted_list_len34;\n \
    \   let mut sorted_list_len36 = sorted_list_len35;\n    let mut sorted_list_len37\
    \ = sorted_list_len36;\n    let mut sorted_list_len38 = sorted_list_len37;\n \
    \   let mut sorted_\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8jmo4lb_.rs:56:20\n   |\n\
    56 |     let mut sorted_\n   |                    ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8jmo4lb_.rs:16:41\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.len() > 0 {\n            if word.len() > sorted_list[0].len()\
    \ {\n                sorted_list.sort_by(|a, b| a.len() < b.len());\n        \
    \    } else {\n                sorted_list.sort_by(|a, b| a.len() > b.len());\n\
    \            }\n        }\n        sorted_list.push(word);\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp5hlrmb6p.rs:20:29\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         --------------- consider\
    \ giving `sorted_list` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n20 |             if word.len() > sorted_list[0].len() {\n   |           \
    \                  ^^^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n    let mut sorted_list_len = sorted_list_len.satur\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkho8rplq.rs:43:52\n   |\n\
    43 |     let mut sorted_list_len = sorted_list_len.satur\n   |               \
    \                                     ^ help: add `;` here\n44 | }\n   | - unexpected\
    \ token\n\nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpkho8rplq.rs:19:62\n\
    \   |\n19 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmpkho8rplq.rs:20:62\n   |\n20 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n\nwarning: unnecessary parentheses around method\
    \ argument\n  --> /tmp/tmpkho8rplq.rs:21:62\n   |\n21 |     let mut sorted_list_len\
    \ = sorted_list_len.saturating_add((sorted_list_len % 2));\n   |             \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^ help:\
    \ remove these parentheses\n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmpkho8rplq.rs:22:62\n   |\n22 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                              ^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n\nwarning: unnecessary parentheses around method\
    \ argument\n  --> /tmp/tmpkho8rplq.rs:23:62\n   |\n23 |     let mut sorted_list_len\
    \ = sorted_list_len.saturating_add((sorted_list_len % 2));\n   |             \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^ help:\
    \ remove these parentheses\n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmpkho8rplq.rs:24:62\n   |\n24 |     let mut sorted_list_len = sorted_list_len.saturating_add((sorted_list_len\
    \ % 2));\n   |                                                         "
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpq8nq5wjr.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpq8nq5wjr.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpdeavx3vo.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \           ^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpdeavx3vo.rs:18:52\n   |\n\
    18 |       let mut sorted_list = lst.into_iter().cloned().collect();\n   |   \
    \                                                   ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = lst.len();\n    let mut sorted_list_index = 0;\n    let mut sorted_list_len\
    \ = lst.len();\n    while sorted_list_len > 0 {\n        if sorted_list_index\
    \ == sorted_list_len {\n            sorted_list_index = 0;\n        }\n      \
    \  let mut current_len = sorted_list_len - 1;\n        let mut current_index =\
    \ sorted_list_index;\n        while current_len > 0 {\n            if current_index\
    \ == sorted_list_len {\n                current_index = 0;\n            }\n  \
    \          if sorted_list[current_index].len() < sorted_list[current_index + 1].len()\
    \ {\n                sorted_list[current_index] = sorted_list[current_index +\
    \ 1];\n                sorted_list_index += 1;\n                current_len -=\
    \ 1;\n                current_index += 1;\n            } else {\n            \
    \    current_len -= 1;\n                current_index += 1;\n            }\n \
    \       }\n        sorted_list_len -= 1;\n    }\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpv24ub8ni.rs:31:16\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         --------------- consider\
    \ giving `sorted_list` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n31 |             if sorted_list[current_index].len() < sorted_list[current_index\
    \ + 1].len() {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for ele in lst {\n        if\
    \ res.iter().all(|&x| x.len() == ele.len()) {\n            res.sort_unstable_by(|a,\
    \ b| a.cmp(b));\n        } else {\n            res.push(ele);\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmptov21a7p.rs:19:28\n\
    \   |\n19 |         if res.iter().all(|&x| x.len() == ele.len()) {\n   |     \
    \                       ^^ consider giving this closure parameter the explicit\
    \ type `&T`, with the type parameters specified\n   |\n   = note: type must be\
    \ known at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ res.iter().all(|&x| x.len() < s.len()) {\n            res.push(s);\n       \
    \ } else {\n            let mut i = 0;\n            for c in s.chars() {\n   \
    \             if i == 0 {\n                    i += 1;\n                    continue;\n\
    \                }\n                if c != res[i - 1].chars().nth(0) {\n    \
    \                i += 1;\n                    continue;\n                }\n \
    \               break;\n            }\n            res.insert(i, s);\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmp3g0dt63a.rs:19:28\n\
    \   |\n19 |         if res.iter().all(|&x| x.len() < s.len()) {\n   |        \
    \                    ^^ consider giving this closure parameter the explicit type\
    \ `&T`, with the type parameters specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                if sorted_list[0].cmp(&word) == Ordering::Less\
    \ {\n                    sorted_list.push(word);\n                }\n        \
    \    } else {\n                if sorted_list[0].length() < word.length() {\n\
    \                    sorted_list.push(word);\n                }\n            }\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpkfqpe04g.rs:24:49\n   |\n24 |                 if sorted_list[0].cmp(&word)\
    \ == Ordering::Less {\n   |                                                 ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpkfqpe04g.rs:23:31\n\
    \   |\n23 |             if sorted_list[0].length() == word.length() {\n   |  \
    \                             ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpkfqpe04g.rs:23:48\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                                                ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `length` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpkfqpe04g.rs:28:35\n\
    \   |\n28 |                 if sorted_list[0].length() < word.length() {\n   |\
    \                                   ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpkfqpe04g.rs:28:51\n   |\n28 |                 if sorted_list[0].length()\
    \ < word.length() {\n   |                                                   ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if sorted_list.last().unwrap().len() == word.len() {\n  \
    \                  sorted_list.push(word);\n                }\n            }\n\
    \        }\n    }\n    sorted_list.sort_by_key(|x| x.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpsf1hry_f.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp581_z7dn.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = lst;\n\
    \    sorted_list.sort_by(|a, b| a.len() < b.len());\n    for word in sorted_list\
    \ {\n        if res.iter().any(|&x| x == word) {\n            continue;\n    \
    \    }\n        res.push(word);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdeiswrjp.rs:19:32\n   |\n\
    19 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() == 0 {\n            res.push(word);\n        } else {\n       \
    \     if word.len() < res[0].len() {\n                res.push(word);\n      \
    \      } else {\n                if word.len() > res[0].len() {\n            \
    \        res.swap(0, 0);\n                }\n            }\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\"]`,\n right: `[\"aa\"]`', /tmp/tmp5w0_fea5.rs:36:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len.push(word.len());\n            sorted_list.push(word);\n\
    \        } else {\n            sorted_list_len.push(word.len());\n        }\n\
    \    }\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"aa\"]`', /tmp/tmp59dfntq9.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.iter().any(|&x| x == word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpaivv22a8.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 ---\n    |                 |\n    |                 `lst` moved\
    \ due to this implicit call to `.into_iter()`\n    |                 help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n23  |     for word\
    \ in lst {\n    |                 ^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        if elem.len() % 2 != 0 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut i = 0;\n            let mut j = 0;\n  \
    \          while i < sorted_list.len() && j < elem.len() {\n                if\
    \ sorted_list[i].len() < elem[j].len() {\n                    i += 1;\n      \
    \          } else if sorted_list[i].len() > elem[j].len() {\n                \
    \    j += 1;\n                } else {\n                    res.push(sorted_list[i]);\n\
    \                    i += 1;\n                    j += 1;\n                }\n\
    \            }\n            if i == sorted_list.len() {\n                res.push(elem);\n\
    \            } else {\n                res.push(sorted_list[i]);\n           \
    \ }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7y5abe8v.rs:26:43\n\
    \   |\n26 |                 if sorted_list[i].len() < elem[j].len() {\n   |  \
    \                                         ^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7y5abe8v.rs:28:50\n\
    \   |\n28 |                 } else if sorted_list[i].len() > elem[j].len() {\n\
    \   |                                                  ^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 == 1 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            let mut j = 0;\n  \
    \          while i < s.len() && j < sorted_list.len() {\n                if s[i].len()\
    \ < sorted_list[j].len() {\n                    i += 1;\n                } else\
    \ if s[i].len() > sorted_list[j].len() {\n                    j += 1;\n      \
    \          } else {\n                    res.push(sorted_list[j]);\n         \
    \           i += 1;\n                    j += 1;\n                }\n        \
    \    }\n            res.push(s);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps5bpnuqn.rs:26:20\n\
    \   |\n26 |                 if s[i].len() < sorted_list[j].len() {\n   |     \
    \               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmps5bpnuqn.rs:28:27\n   |\n\
    28 |                 } else if s[i].len() > sorted_list[j].len() {\n   |     \
    \                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if word.len() % 2 != 0 {\n            sorted_list.push(word);\n     \
    \   }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaosr1007.rs:23:32\n   |\n\
    23 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747867
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len.push(word.len());\n            sorted_list.push(word);\n\
    \        } else {\n            sorted_list_len.push(word.len());\n        }\n\
    \    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgi4y7vh7.rs:27:32\n   |\n\
    27 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for elem in lst {\n        if elem.len() > sorted_list_len.len()\
    \ {\n            sorted_list_len = vec![elem];\n        } else {\n           \
    \ sorted_list_len.push(elem);\n        }\n    }\n    for elem in sorted_list_len\
    \ {\n        let mut sorted_list_len = vec![];\n        for elem in sorted_list_len\
    \ {\n            if elem.len() > elem.len() {\n                sorted_list_len.push(elem);\n\
    \            }\n        }\n        for elem in sorted_list_len {\n           \
    \ if elem != elem {\n                sorted_list.push(elem);\n            }\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp24yufj9y.rs:29:16\n\
    \   |\n27 |         let mut sorted_list_len = vec![];\n   |             -------------------\
    \ consider giving `sorted_list_len` the explicit type `Vec<T>`, with the type\
    \ parameters specified\n28 |         for elem in sorted_list_len {\n29 |     \
    \        if elem.len() > elem.len() {\n   |                ^^^^ cannot infer type\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                sorted_list.sort_by(|a, b| a.cmp(b));\n\
    \                sorted_list.push(word);\n            } else {\n             \
    \   sorted_list.sort_by(|a, b| a.cmp(b));\n                sorted_list.push(word);\n\
    \                sorted_list.push(sorted_list[0]);\n            }\n        }\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp2kgau1u1.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp2kgau1u1.rs:23:48\n   |\n23 |          \
    \   if sorted_list[0].length() == word.length() {\n   |                      \
    \                          ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut cnt = 0;\n    for\
    \ s in lst {\n        if cnt % 2 == 1 {\n            res.push(s);\n        }\n\
    \        cnt += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\"]`,\n right: `[\"aa\"]`', /tmp/tmpnkb64xb7.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for elem in lst {\n        sorted_list_len.push(elem.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for i in 0..sorted_list_len.len()\
    \ {\n        for elem in lst {\n            if elem.len() == sorted_list_len[i]\
    \ {\n                sorted_list.push(elem);\n            }\n        }\n    }\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpz7bd2qp1.rs:24:21\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for elem in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n24  |         for elem in lst {\n    |                     ^^^ `lst` moved\
    \ due to this implicit call to `.into_iter()`, in previous iteration of loop\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider borrowing to avoid moving into the for loop\n    |\n24\
    \  |         for elem in &lst {\n    |                     ~~~~\nhelp: consider\
    \ borrowing to avoid moving into the for loop\n    |\n19  |     for elem in &lst\
    \ {\n    |                 ~~~~\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                let\
    \ mut i = 0;\n                while i < sorted_list.len() {\n                \
    \    if sorted_list[i].len() < word.len() {\n                        break;\n\
    \                    }\n                    i += 1;\n                }\n     \
    \           sorted_list.insert(i, word);\n            }\n        }\n    }\n  \
    \  for word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp9eizzrwx.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect::<Vec<_>>();\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmp2rqnvo7_.rs:18:43\n   |\n18 |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect::<Vec<_>>();\n   |                      \
    \                     ^^^^^^ expected struct `String`, found reference\n   |\n\
    \   = note: expected struct `String`\n           found reference `&_`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp2rqnvo7_.rs:18:52\n \
    \  |\n18 |       let mut sorted_list = lst.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                                      ^^^^^^^ method cannot\
    \ be called on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659747868
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len.insert(word.len(), 1);\n        } else {\n  \
    \          sorted_list_len.insert(word.len(), 0);\n        }\n    }\n    for word\
    \ in lst {\n        if sorted_list_len[word.len()] == 1 {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp3qcbrwn1.rs:26:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 ---\n    |                 |\n    |                 `lst` moved\
    \ due to this implicit call to `.into_iter()`\n    |                 help: consider\
    \ borrowing to avoid moving into the for loop: `&lst`\n...\n26  |     for word\
    \ in lst {\n    |                 ^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut i = 0;\n        let mut j = len - 1;\n \
    \       while i < j {\n            if lst[i].len() > lst[j].len() {\n        \
    \        sorted_list.push(lst[j]);\n                j -= 1;\n            } else\
    \ {\n                i += 1;\n            }\n        }\n        sorted_list.push(lst[i]);\n\
    \        len -= 1;\n    }\n    sorted_list.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp4j5otkv8.rs:24:34\n\
    \   |\n24 |                 sorted_list.push(lst[j]);\n   |                  \
    \                ^^^^^^ move occurs because value has type `String`, which does\
    \ not implement the `Copy` trait\n\nerror[E0507]: cannot move out of index of\
    \ `Vec<String>`\n  --> /tmp/tmp4j5otkv8.rs:30:26\n   |\n30 |         sorted_list.push(lst[i]);\n\
    \   |                          ^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n    res.sort_by_key(|s|\
    \ s.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpq3spmat1.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747869
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       if sorted_list.last().unwrap().len() == word.len() {\n               \
    \     sorted_list.push(word);\n                } else {\n                    let\
    \ mut i = 0;\n                    let mut j = 0;\n                    while i\
    \ < sorted_list.len() && j < word.len() {\n                        if sorted_list[i].len()\
    \ < word[j] {\n                            i += 1;\n                        }\
    \ else {\n                            j += 1;\n                        }\n   \
    \                 }\n                    sorted_list.insert(i, word);\n      \
    \          }\n            }\n        }\n    }\n    for word in sorted_list {\n\
    \        res.push(word);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp04lh533d.rs:32:51\n\
    \   |\n32 |                         if sorted_list[i].len() < word[j] {\n   |\
    \                                                   ^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747869
