language: rs
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    if scale == 0.0 {\n        scale = 0.1;\n    }\n \
    \   let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp212ntkrd.rs:21:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&[min_value]);\n\
    \    new_numbers.extend_from_slice(&[max_value]);\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmp1y7i7x0f.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        new_numbers.push((n - min) / scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpc2lsnps6.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpc2lsnps6.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for number in numbers {\n        if number < min_value {\n\
    \            min_value = number;\n        }\n        if number > max_value {\n\
    \            max_value = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_value) / (max_value - min_value) as f64;\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwdynozzo.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n17  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n8   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = max_value - min_value;\n    for\
    \ n in numbers {\n        *n -= min_value;\n        *n /= scale;\n    }\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp459232gb.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp459232gb.rs:19:9\n   |\n19 |         *n\
    \ /= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0 * (max - min);\n    for &n in numbers {\n        *n /= scale;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnga4stp9.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnga4stp9.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n -= min;\n        n /=\
    \ scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp3qvp9hr3.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp3qvp9hr3.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp3qvp9hr3.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp3qvp9hr3.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 / (max - min);\n    for n in numbers {\n        *n -= min;\n        *n\
    \ *= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmplcnpcc12.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmplcnpcc12.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ new_n < min {\n            new_n -= min;\n        }\n        if new_n > max\
    \ {\n            new_n -= max;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpg5hv3poy.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    for n in numbers {\n        *n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpe8eqd3k6.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    for n in numbers {\n        *n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpbeccd7zn.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        new_numbers.push((n - min) * scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpeayicm52.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpeayicm52.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * max / min;\n    numbers.iter().for_each(|n| {\n        *n /= scale;\n\
    \    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpy5t0_otv.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpy5t0_otv.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpy5t0_otv.rs:17:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut result = Vec::new();\n    for n in numbers\
    \ {\n        result.push((n - min) * scale);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpnzy1683g.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpnzy1683g.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ new_n < min {\n            new_n -= min;\n        }\n        if new_n > max\
    \ {\n            new_n -= max;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpfe07p884.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0f64 / max - min;\n    for n in numbers {\n        *n -= min;\n        *n\
    \ *= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpie4jb79a.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpie4jb79a.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = (max_value - min_value).recip();\n\
    \    for n in numbers {\n        *n -= min_value;\n        *n *= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp_eg8ybkw.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp_eg8ybkw.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers[0];\n    let mut max_number\
    \ = numbers[0];\n    for number in numbers {\n        if number < min_number {\n\
    \            min_number = number;\n        }\n        if number > max_number {\n\
    \            max_number = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_number) / (max_number - min_number);\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpknvg7xs6.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n17  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n8   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value))\
    \ * 2.0 - 1.0;\n        new_numbers.push(new_value);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpv9jm_mwb.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers.iter().min().unwrap();\n   \
    \ let mut max_number = numbers.iter().max().unwrap();\n    min_number = min_number\
    \ / max_number;\n    max_number = max_number / min_number;\n    numbers.iter().map(|x|\
    \ x / max_number).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpv2ctkcyi.rs:6:41\n\
    \     |\n6    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpv2ctkcyi.rs:7:41\n\
    \     |\n7    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpv2ctkcyi.rs:8:18\n  |\n6 |    \
    \ let mut min_number = numbers.iter().min().unwrap();\n  |                   \
    \       ----------------------------- expected due to this value\n7 |     let\
    \ mut max_number = numbers.iter().max().unwrap();\n8 |     min_number = min_number\
    \ / max_number;\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^\n  |           \
    \       |\n  |                  expected `&f64`, found `f64`\n  |            \
    \      help: consider borrowing here: `&(min_number / max_number)`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpv2ctkcyi.rs:9:18\n  |\n7 |     let mut max_number\
    \ = numbers.iter().max().unwrap();\n  |                          -----------------------------\
    \ expected due to this value\n8 |     min_number = min_num"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = (max_value - min_value).recip();\n\
    \    for n in numbers {\n        *n -= min_value;\n        *n *= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp_eg8ybkw.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp_eg8ybkw.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = (max_value - min_value).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min_value) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmprozjiy7s.rs:16:9\n\
    \   |\n16 |     let mut scale = (max_value - min_value).recip();\n   |       \
    \  ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n   =\
    \ note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of moved value:\
    \ `numbers`\n   --> /tmp/tmprozjiy7s.rs:18:14\n    |\n5   | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n    |                    ------- move occurs because\
    \ `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n\
    8   |     for n in numbers {\n    |              -------\n    |              |\n\
    \    |              `numbers` moved due to this implicit call to `.into_iter()`\n\
    \    |              help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n18  |     for n in numbers {\n    |              ^^^^^^^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ new_n < min {\n            new_n -= min;\n        }\n        if new_n > max\
    \ {\n            new_n -= max;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpfe07p884.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n   \
    \     let mut n = n;\n        if n < min_val {\n            n = 0;\n        }\n\
    \        if n > max_val {\n            n = 1;\n        }\n        rescaled_numbers.push(n);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqdpp9bzx.rs:20:17\n   |\n\
    20 |             n = 0;\n   |                 ^\n   |                 |\n   |\
    \                 expected `f64`, found integer\n   |                 help: use\
    \ a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqdpp9bzx.rs:23:17\n\
    \   |\n23 |             n = 1;\n   |                 ^\n   |                 |\n\
    \   |                 expected `f64`, found integer\n   |                 help:\
    \ use a float literal: `1.0`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n -= min;\n        n *=\
    \ scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpt8vdr39d.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpt8vdr39d.rs:19:9\n   |\n19 |         n *=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpt8vdr39d.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpt8vdr39d.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpt8vdr39d.rs:18:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |         n -= min;\n   |         ^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `n`\n  --> /tmp/tmpt8vdr39d.rs:19:9\n   |\n17 |     for n in numbers\
    \ {\n   |         -\n   |         |\n   |         first assignment to `n`\n  \
    \ |         help: consider making this binding mutable: `mut n`\n18 |        \
    \ n -= min;\n19 |        "
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n -= min;\n        n /=\
    \ scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp3qvp9hr3.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp3qvp9hr3.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp3qvp9hr3.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp3qvp9hr3.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = (max_value - min_value).recip();\n\
    \    for n in numbers {\n        *n -= min_value;\n        *n *= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp_eg8ybkw.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp_eg8ybkw.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ new_n < min {\n            new_n = min;\n        }\n        if new_n > max {\n\
    \            new_n = max;\n        }\n        rescaled_numbers.push(new_n);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp_7h5_na5.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut scale = 1.0 * max_val / min_val;\n    for n in numbers {\n \
    \       *n /= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpdi6dpz9l.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers[0];\n    let mut max_number\
    \ = numbers[0];\n    for number in numbers {\n        if number < min_number {\n\
    \            min_number = number;\n        }\n        if number > max_number {\n\
    \            max_number = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_number) / (max_number - min_number);\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpknvg7xs6.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n17  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n8   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_value) / (max_value - min_value)) *\
    \ 2.0 + 0.5;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi_ulvd42.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = (max_value - min_value).recip();\n\
    \    let mut new_numbers = Vec::new();\n    for n in numbers {\n        new_numbers.push((n\
    \ - min_value) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmprozjiy7s.rs:16:9\n\
    \   |\n16 |     let mut scale = (max_value - min_value).recip();\n   |       \
    \  ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n   =\
    \ note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of moved value:\
    \ `numbers`\n   --> /tmp/tmprozjiy7s.rs:18:14\n    |\n5   | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n    |                    ------- move occurs because\
    \ `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n\
    8   |     for n in numbers {\n    |              -------\n    |              |\n\
    \    |              `numbers` moved due to this implicit call to `.into_iter()`\n\
    \    |              help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n18  |     for n in numbers {\n    |              ^^^^^^^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ new_n < min {\n            new_n -= min;\n        }\n        if new_n > max\
    \ {\n            new_n -= max;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpfe07p884.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = max_value - min_value;\n    for\
    \ n in numbers {\n        *n -= min_value;\n        *n /= scale;\n    }\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp459232gb.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp459232gb.rs:19:9\n   |\n19 |         *n\
    \ /= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        new_numbers.push((n - min) * scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpeayicm52.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpeayicm52.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ new_n < min {\n            new_n -= min;\n        }\n        if new_n > max\
    \ {\n            new_n -= max;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpfe07p884.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for number in numbers {\n        if number < min_value {\n\
    \            min_value = number;\n        }\n        if number > max_value {\n\
    \            max_value = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        new_numbers.push(number -\
    \ min_value) / (max_value - min_value);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot divide `()` by `f64`\n  --> /tmp/tmplxds77uj.rs:18:46\n\
    \   |\n18 |         new_numbers.push(number - min_value) / (max_value - min_value);\n\
    \   |         ------------------------------------ ^ ----------------------- f64\n\
    \   |         |\n   |         ()\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * max / min;\n    for n in numbers {\n        n *= scale;\n    }\n   \
    \ numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpgs3zxilp.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpgs3zxilp.rs:18:9\n   |\n18 |         n *=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpgs3zxilp.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpgs3zxilp.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpgs3zxilp.rs:18:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |         n *= scale;\n   |         ^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0382]: use of moved value: `numbers`\n\
    \  --> /tmp/tmpgs3zxilp.rs:20:5\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n   |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n17 |  \
    \   for n in numbe"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ mut new_n = n;\n        if new_n < min_val {\n            new_n -= min_val;\n\
    \        }\n        if new_n > max_val {\n            new_n -= max_val;\n    \
    \    }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpc4v6h0e9.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n -= min;\n        n /=\
    \ scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp3qvp9hr3.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp3qvp9hr3.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp3qvp9hr3.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp3qvp9hr3.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n -= min;\n        n /=\
    \ scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp3qvp9hr3.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp3qvp9hr3.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp3qvp9hr3.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp3qvp9hr3.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    for n in numbers {\n        *n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpbeccd7zn.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ new_val = ((n - min_val) / (max_val - min_val)).floor();\n        new_numbers.push(new_val);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpbjmtrgv4.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_value) / (max_value - min_value)) *\
    \ 2.0 + 0.5;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi_ulvd42.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * max / min;\n    for n in numbers {\n        *n /= scale;\n    }\n  \
    \  numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpx29qz92n.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = (max_value - min_value).recip();\n\
    \    for n in numbers {\n        *n -= min_value;\n        *n *= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp_eg8ybkw.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp_eg8ybkw.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    numbers.iter().for_each(|n| {\n        *n /= scale;\n\
    \    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmp0zmpg162.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp0zmpg162.rs:16:9\n   |\n16 |    \
    \ let mut scale = (max - min).recip();\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `numbers`\n    --> /tmp/tmp0zmpg162.rs:17:5\n\
    \     |\n5    | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n     |  \
    \                  ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n8    |     for n in numbers\
    \ {\n     |              -------\n     |              |\n     |              `numbers`\
    \ moved due to this implicit call to `.into_iter()`\n     |              help:\
    \ consider borrowing to avoid moving into the for loop: `&numbers`\n...\n17  \
    \ |     numbers.iter().for_each(|n| {\n     |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n     |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n     = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nnote: deref defined here\n\nerror: aborting due to 2 previous errors;\
    \ 1 warning emitted\n\nSome errors have detailed explanations: E0382, E0594.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled:\
    \ Vec<f64> = Vec::new();\n    for n in numbers {\n        rescaled.push((n - min)\
    \ / (max - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpqmt3zs5f.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let mut new_n = n;\n        if new_n < min_value {\n    \
    \        new_n -= min_value;\n        }\n        if new_n > max_value {\n    \
    \        new_n -= max_value;\n        }\n        new_numbers.push(new_n);\n  \
    \  }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpjge7s2rq.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n   \
    \     let mut new_val = ((n - min_val) / (max_val - min_val)) * 2.0 - 1.0;\n \
    \       if new_val < 0.0 {\n            new_val = 0.0;\n        }\n        if\
    \ new_val > 1.0 {\n            new_val = 1.0;\n        }\n        rescaled_numbers.push(new_val);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmprn3zlz8v.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * max / min;\n    numbers.iter().for_each(|n| n *= scale);\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `*=` cannot be applied to type\
    \ `&f64`\n  --> /tmp/tmp3rg0kk4k.rs:17:33\n   |\n17 |     numbers.iter().for_each(|n|\
    \ n *= scale);\n   |                                 -^^^^^^^^^\n   |        \
    \                         |\n   |                                 cannot use `*=`\
    \ on type `&f64`\n   |\nhelp: `*=` can be used on `f64`, you can dereference `n`\n\
    \   |\n17 |     numbers.iter().for_each(|n| *n *= scale);\n   |              \
    \                   +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_value) / (max_value - min_value)) *\
    \ 2.0 - 1.0;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp1exhoots.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_value) / (max_value - min_value)) *\
    \ 2.0 - 1.0;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp1exhoots.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    for n in numbers {\n        *n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpbeccd7zn.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = max_value - min_value;\n    for\
    \ n in numbers {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpevmrdbzl.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpevmrdbzl.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value))\
    \ * 2.0 - 1.0;\n        new_numbers.push(new_value);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpv9jm_mwb.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n    for\
    \ n in numbers {\n        rescaled_numbers.push((n - min_value) / (max_value -\
    \ min_value));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpf9khj0zy.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0f64;\n    for &n in numbers {\n        *n /= max - min;\n       \
    \ *n *= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpy72ev49m.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy72ev49m.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    if scale == 0.0 {\n        return vec![];\n    }\n\
    \    let mut new_numbers = vec![];\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp66l6bnm0.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp66l6bnm0.rs:21:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n21  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ new_n < min {\n            new_n -= min;\n        }\n        if new_n > max\
    \ {\n            new_n -= max;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpfe07p884.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut result = Vec::new();\n    for n in numbers\
    \ {\n        result.push((n - min) * scale);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpnzy1683g.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpnzy1683g.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = (max - min).recip();\n    for &n in numbers {\n        *n /= scale;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcw29q7vv.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcw29q7vv.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled\
    \ = Vec::new();\n    for n in numbers {\n        rescaled.push((n - min) / (max\
    \ - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp8aszrfbu.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        new_numbers.push((n - min) * scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpeayicm52.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpeayicm52.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n    for\
    \ n in numbers {\n        rescaled_numbers.push((n - min_value) / (max_value -\
    \ min_value));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpf9khj0zy.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        new_numbers.push((n - min) * scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpeayicm52.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpeayicm52.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    numbers.iter().for_each(|n| {\n        n -= min;\n\
    \        n /= scale;\n    });\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `-=` cannot be applied to type\
    \ `&f64`\n  --> /tmp/tmp7xetyww0.rs:18:9\n   |\n18 |         n -= min;\n   | \
    \        -^^^^^^^\n   |         |\n   |         cannot use `-=` on type `&f64`\n\
    \   |\nhelp: `-=` can be used on `f64`, you can dereference `n`\n   |\n18 |  \
    \       *n -= min;\n   |         +\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `&f64`\n  --> /tmp/tmp7xetyww0.rs:19:9\n   |\n\
    19 |         n /= scale;\n   |         -^^^^^^^^^\n   |         |\n   |      \
    \   cannot use `/=` on type `&f64`\n   |\nhelp: `/=` can be used on `f64`, you\
    \ can dereference `n`\n   |\n19 |         *n /= scale;\n   |         +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        new_numbers.push((n - min) * scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpeayicm52.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpeayicm52.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for number in numbers {\n        if number < min_value {\n\
    \            min_value = number;\n        }\n        if number > max_value {\n\
    \            max_value = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_value) / (max_value - min_value) as f64;\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwdynozzo.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n17  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n8   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ new_n < min {\n            new_n -= min;\n        }\n        if new_n > max\
    \ {\n            new_n -= max;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpfe07p884.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min)\
    \ / (max - min));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpa9r8fb37.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let mut new_n = n;\n        if n < min_value {\n        \
    \    new_n -= min_value;\n        }\n        if n > max_value {\n            new_n\
    \ -= max_value;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpxhv786yl.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value)).ln();\n\
    \        new_numbers.push((new_value * max_value) + min_value);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpsd27m7gn.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * max / min;\n    let mut result = Vec::new();\n    for n in numbers {\n\
    \        result.push(n * scale);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp8iye6fxl.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp8iye6fxl.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n18  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ new_val = ((n - min_val) / (max_val - min_val)) * 2.0 + 0.5;\n        new_numbers.push(new_val);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpyxu7ssy1.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled\
    \ = Vec::new();\n    for n in numbers {\n        rescaled.push((n - min) / (max\
    \ - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp8aszrfbu.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = max - min;\n    scale = scale / 2.0 + 1.0;\n    let mut new_numbers\
    \ = Vec::new();\n    for &n in numbers {\n        new_numbers.push((n - min) *\
    \ scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzb5gwl5d.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzb5gwl5d.rs:19:9\n   |\n19 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ new_n < min {\n            new_n -= min;\n        }\n        if new_n > max\
    \ {\n            new_n -= max;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpfe07p884.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n -= min;\n        n *=\
    \ scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpt8vdr39d.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpt8vdr39d.rs:19:9\n   |\n19 |         n *=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpt8vdr39d.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpt8vdr39d.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpt8vdr39d.rs:18:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |         n -= min;\n   |         ^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `n`\n  --> /tmp/tmpt8vdr39d.rs:19:9\n   |\n17 |     for n in numbers\
    \ {\n   |         -\n   |         |\n   |         first assignment to `n`\n  \
    \ |         help: consider making this binding mutable: `mut n`\n18 |        \
    \ n -= min;\n19 |        "
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value))\
    \ * 2.0 + 0.5;\n        new_numbers.push(new_value);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp35zkomdn.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_value) / (max_value - min_value)) *\
    \ 2.0 + 0.5;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi_ulvd42.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n    for\
    \ n in numbers {\n        rescaled_numbers.push((n - min_value) / (max_value -\
    \ min_value));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpf9khj0zy.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers[0];\n    let mut max_number\
    \ = numbers[0];\n    for n in numbers {\n        if n < min_number {\n       \
    \     min_number = n;\n        }\n        if n > max_number {\n            max_number\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_number) / (max_number - min_number))\
    \ * 2.0 + 0.5;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptcaf34kl.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value))\
    \ * 1.0 + 0.0;\n        new_numbers.push(new_value);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp2saf9trc.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_value) / (max_value - min_value)).ln();\n\
    \        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpmxds4yaf.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for number in numbers {\n        if number < min_value {\n\
    \            min_value = number;\n        }\n        if number > max_value {\n\
    \            max_value = number;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - min_value) / (max_value - min_value);\n    }\n    rescaled_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot divide `()` by `f64`\n  --> /tmp/tmp72ybp827.rs:18:51\n\
    \   |\n18 |         rescaled_numbers.push(number - min_value) / (max_value - min_value);\n\
    \   |         ----------------------------------------- ^ -----------------------\
    \ f64\n   |         |\n   |         ()\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0 * (max - min);\n    for &n in numbers {\n        *n /= scale;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnga4stp9.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnga4stp9.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled\
    \ = Vec::new();\n    for n in numbers {\n        rescaled.push((n - min) / (max\
    \ - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp8aszrfbu.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    if scale == 0.0 {\n        scale = 0.1;\n    }\n \
    \   for n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp70369qly.rs:21:9\n\
    \   |\n21 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for number in numbers {\n        if number < min_value {\n\
    \            min_value = number;\n        }\n        if number > max_value {\n\
    \            max_value = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_value) / (max_value - min_value);\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpskbnawqn.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n17  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_value) / (max_value - min_value)).ln();\n\
    \        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpmxds4yaf.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0 * max / min;\n    for &n in numbers {\n        *n /= scale;\n  \
    \  }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp77cvqcva.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77cvqcva.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut rescaled = (n - min)\
    \ / (max - min);\n        if rescaled < 0.0 {\n            rescaled += 1.0;\n\
    \        }\n        rescaled_numbers.push(rescaled);\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpmdud1s64.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    for n in numbers {\n        *n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpbeccd7zn.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value))\
    \ * 2.0 + 0.5;\n        new_numbers.push(new_value);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp35zkomdn.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    if scale == 0.0 {\n        return vec![];\n    }\n\
    \    let mut new_numbers = vec![];\n    for n in numbers {\n        new_numbers.push((n\
    \ - min) / scale);\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp66l6bnm0.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp66l6bnm0.rs:21:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n21  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ mut new_n = n;\n        if n < min_val {\n            new_n -= min_val;\n  \
    \      }\n        if n > max_val {\n            new_n -= max_val;\n        }\n\
    \        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpgf4p7nzw.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        new_numbers.push((n - min) * scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpeayicm52.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpeayicm52.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 / (max - min);\n    for n in numbers {\n        *n -= min;\n        *n\
    \ *= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmplcnpcc12.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmplcnpcc12.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let new_n = ((n - min) / (max\
    \ - min)) * 2.0 - 1.0;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpv5ar5zce.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let new_n = ((n - min) / (max\
    \ - min)) as f64;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpua0nxp23.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled\
    \ = Vec::new();\n    for n in numbers {\n        rescaled.push((n - min) / (max\
    \ - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp8aszrfbu.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0 * (max - min);\n    let mut new_numbers = Vec::new();\n    for &n\
    \ in numbers {\n        new_numbers.push((n - min) / scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpofykgzg1.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpofykgzg1.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled:\
    \ Vec<f64> = Vec::new();\n    for n in numbers {\n        rescaled.push((n - min)\
    \ / (max - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpqmt3zs5f.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut result = Vec::new();\n    for n in numbers\
    \ {\n        result.push((n - min) * scale);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpnzy1683g.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpnzy1683g.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * max / min;\n    for n in numbers {\n        *n /= scale;\n    }\n  \
    \  numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpx29qz92n.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value))\
    \ * 2.0 + 0.5;\n        new_numbers.push(new_value);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp35zkomdn.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        *n -= min;\n        *n\
    \ /= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpxzyz0zml.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpxzyz0zml.rs:19:9\n   |\n19 |         *n /= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    for n in numbers {\n        *n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpbeccd7zn.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut scale = max_val - min_val;\n    for n in numbers {\n       \
    \ *n -= min_val;\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmppz3dou0a.rs:18:9\n\
    \   |\n18 |         *n -= min_val;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmppz3dou0a.rs:19:9\n   |\n19 |         *n\
    \ /= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = (max_value - min_value).recip();\n\
    \    for n in numbers {\n        *n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpikwpi822.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut scale = (max_value - min_value).recip();\n\
    \    for n in numbers {\n        *n -= min_value;\n        *n *= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp_eg8ybkw.rs:18:9\n\
    \   |\n18 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp_eg8ybkw.rs:19:9\n   |\n19 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value)).ln();\n\
    \        new_numbers.push(new_value);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp3nxqtn0d.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min)\
    \ / (max - min));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpa9r8fb37.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut result = Vec::new();\n    for n in numbers\
    \ {\n        result.push((n - min).div(scale));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `div` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmp2zz4q2eo.rs:19:31\n    |\n19  |         result.push((n\
    \ - min).div(scale));\n    |                               ^^^ method not found\
    \ in `f64`\n    |\n    = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n    |\n1   | use std::ops::Div;\n    |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers.iter().min().unwrap();\n   \
    \ let mut max_number = numbers.iter().max().unwrap();\n    min_number = min_number\
    \ / max_number;\n    max_number = max_number / min_number;\n    numbers.iter().map(|x|\
    \ x / max_number).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpv2ctkcyi.rs:6:41\n\
    \     |\n6    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpv2ctkcyi.rs:7:41\n\
    \     |\n7    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpv2ctkcyi.rs:8:18\n  |\n6 |    \
    \ let mut min_number = numbers.iter().min().unwrap();\n  |                   \
    \       ----------------------------- expected due to this value\n7 |     let\
    \ mut max_number = numbers.iter().max().unwrap();\n8 |     min_number = min_number\
    \ / max_number;\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^\n  |           \
    \       |\n  |                  expected `&f64`, found `f64`\n  |            \
    \      help: consider borrowing here: `&(min_number / max_number)`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpv2ctkcyi.rs:9:18\n  |\n7 |     let mut max_number\
    \ = numbers.iter().max().unwrap();\n  |                          -----------------------------\
    \ expected due to this value\n8 |     min_number = min_num"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = max - min;\n    let mut new_numbers = Vec::new();\n    for &n in numbers\
    \ {\n        new_numbers.push((n - min) / scale);\n    }\n    new_numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7xn92ras.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7xn92ras.rs:18:9\n   |\n18 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut scale = (max_val - min_val).recip();\n    for n in numbers {\n\
    \        *n /= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpc8lhmdb5.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for &n in numbers {\n        if n < min_value {\n         \
    \   min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for &n in\
    \ numbers {\n        let mut new_n = n;\n        if new_n < min_value {\n    \
    \        new_n -= min_value;\n        }\n        if new_n > max_value {\n    \
    \        new_n -= max_value;\n        }\n        new_numbers.push(new_n);\n  \
    \  }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkpi1rr42.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkpi1rr42.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        new_numbers.push((n - min) * scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpeayicm52.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpeayicm52.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    numbers.iter().for_each(|n| {\n        *n /= scale;\n\
    \    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmp0zmpg162.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp0zmpg162.rs:16:9\n   |\n16 |    \
    \ let mut scale = (max - min).recip();\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `numbers`\n    --> /tmp/tmp0zmpg162.rs:17:5\n\
    \     |\n5    | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n     |  \
    \                  ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n8    |     for n in numbers\
    \ {\n     |              -------\n     |              |\n     |              `numbers`\
    \ moved due to this implicit call to `.into_iter()`\n     |              help:\
    \ consider borrowing to avoid moving into the for loop: `&numbers`\n...\n17  \
    \ |     numbers.iter().for_each(|n| {\n     |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n     |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n     = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nnote: deref defined here\n\nerror: aborting due to 2 previous errors;\
    \ 1 warning emitted\n\nSome errors have detailed explanations: E0382, E0594.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value))\
    \ * 1.0 + 0.0;\n        new_numbers.push(new_value);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp2saf9trc.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for number in numbers {\n        if number < min_value {\n\
    \            min_value = number;\n        }\n        if number > max_value {\n\
    \            max_value = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_value) / (max_value - min_value) * (1.0 + 1.0e-10);\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpdqp59pbz.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n17  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n   \
    \     rescaled_numbers.push((n - min_val) / (max_val - min_val));\n    }\n   \
    \ rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpimxozcfv.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = max - min;\n    numbers.iter().for_each(|n| {\n        *n /= scale;\n    });\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpyrsncv1_.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpyrsncv1_.rs:16:9\n   |\n16 |    \
    \ let mut scale = max - min;\n   |         ----^^^^^\n   |         |\n   |   \
    \      help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0382]: borrow of moved value: `numbers`\n    --> /tmp/tmpyrsncv1_.rs:17:5\n\
    \     |\n5    | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n     |  \
    \                  ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n8    |     for n in numbers\
    \ {\n     |              -------\n     |              |\n     |              `numbers`\
    \ moved due to this implicit call to `.into_iter()`\n     |              help:\
    \ consider borrowing to avoid moving into the for loop: `&numbers`\n...\n17  \
    \ |     numbers.iter().for_each(|n| {\n     |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n     |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n     = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nnote: deref defined here\n\nerror: aborting due to 2 previous errors;\
    \ 1 warning emitted\n\nSome errors have detailed explanations: E0382, E0594.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min)\
    \ / (max - min));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpa9r8fb37.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min)\
    \ / (max - min));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpa9r8fb37.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 / (max - min);\n    for n in numbers {\n        *n -= min;\n        *n\
    \ *= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmplcnpcc12.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmplcnpcc12.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers[0];\n    let mut max_number\
    \ = numbers[0];\n    for n in numbers {\n        if n < min_number {\n       \
    \     min_number = n;\n        }\n        if n > max_number {\n            max_number\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let mut new_n = n;\n        if new_n < min_number {\n   \
    \         new_n -= min_number;\n        }\n        if new_n > max_number {\n \
    \           new_n -= max_number;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpjhuijtwz.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers[0];\n    let mut max_number\
    \ = numbers[0];\n    for number in numbers {\n        if number < min_number {\n\
    \            min_number = number;\n        }\n        if number > max_number {\n\
    \            max_number = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_number) / (max_number - min_number);\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpknvg7xs6.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n17  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n8   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for number in numbers {\n        if number < min_value {\n\
    \            min_value = number;\n        }\n        if number > max_value {\n\
    \            max_value = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_value) / (max_value - min_value) * (1.0 + 1.0e-10);\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpdqp59pbz.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n17  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let mut new_n = n;\n        if new_n < min_value {\n    \
    \        new_n -= min_value;\n        }\n        if new_n > max_value {\n    \
    \        new_n -= max_value;\n        }\n        new_numbers.push(new_n);\n  \
    \  }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpjge7s2rq.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ mut new_n = n;\n        if new_n < min_val {\n            new_n -= min_val;\n\
    \        }\n        if new_n > max_val {\n            new_n -= max_val;\n    \
    \    }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpc4v6h0e9.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&[min_value]);\n\
    \    new_numbers.extend_from_slice(&[max_value]);\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmp1y7i7x0f.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let mut new_n = n;\n        if new_n < min_value {\n    \
    \        new_n -= min_value;\n        }\n        if new_n > max_value {\n    \
    \        new_n -= max_value;\n        }\n        new_numbers.push(new_n);\n  \
    \  }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpjge7s2rq.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers[0];\n    let mut max_number\
    \ = numbers[0];\n    for n in numbers {\n        if n < min_number {\n       \
    \     min_number = n;\n        }\n        if n > max_number {\n            max_number\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_number) / (max_number - min_number))\
    \ * 2.0 - 1.0;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmph0jqlxqo.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers[0];\n    let mut max_number\
    \ = numbers[0];\n    for n in numbers {\n        if n < min_number {\n       \
    \     min_number = n;\n        }\n        if n > max_number {\n            max_number\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let mut new_n = n;\n        if new_n < min_number {\n   \
    \         new_n -= min_number;\n        }\n        if new_n > max_number {\n \
    \           new_n -= max_number;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpjhuijtwz.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut rescaled = (n - min)\
    \ / (max - min);\n        if rescaled < 0 {\n            rescaled += 1;\n    \
    \    }\n        rescaled_numbers.push(rescaled);\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpojgyvkvg.rs:19:23\n   |\n\
    19 |         if rescaled < 0 {\n   |                       ^\n   |           \
    \            |\n   |                       expected `f64`, found integer\n   |\
    \                       help: use a float literal: `0.0`\n\nerror[E0277]: cannot\
    \ add-assign `{integer}` to `f64`\n  --> /tmp/tmpojgyvkvg.rs:20:22\n   |\n20 |\
    \             rescaled += 1;\n   |                      ^^ no implementation for\
    \ `f64 += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>` is not\
    \ implemented for `f64`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let new_n = ((n - min) / (max\
    \ - min)) as f64;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpua0nxp23.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * max / min;\n    for n in numbers {\n        n *= scale;\n    }\n   \
    \ numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpgs3zxilp.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpgs3zxilp.rs:18:9\n   |\n18 |         n *=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpgs3zxilp.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpgs3zxilp.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpgs3zxilp.rs:18:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |         n *= scale;\n   |         ^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0382]: use of moved value: `numbers`\n\
    \  --> /tmp/tmpgs3zxilp.rs:20:5\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n   |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n17 |  \
    \   for n in numbe"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n /= scale;\n    }\n \
    \   numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmplt2nh7lf.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmplt2nh7lf.rs:18:9\n   |\n18 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmplt2nh7lf.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmplt2nh7lf.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmplt2nh7lf.rs:18:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |         n /= scale;\n   |         ^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0382]: use of moved value: `numbers`\n\
    \  --> /tmp/tmplt2nh7lf.rs:20:5\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n   |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n17 |  \
    \   for n in num"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_value) / (max_value - min_value)).floor()\
    \ as f64;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpyhqmizs0.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min)\
    \ / (max - min));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpa9r8fb37.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n    for\
    \ n in numbers {\n        rescaled_numbers.push((n - min_value) / (max_value -\
    \ min_value));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpf9khj0zy.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let mut new_n = n;\n        if new_n < min_value {\n    \
    \        new_n -= min_value;\n        }\n        if new_n > max_value {\n    \
    \        new_n -= max_value;\n        }\n        new_numbers.push(new_n);\n  \
    \  }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpjge7s2rq.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0f64;\n    if min == max {\n        scale = 1.0f64;\n    } else {\n\
    \        scale = max - min;\n    }\n    let mut result = Vec::new();\n    for\
    \ &n in numbers {\n        result.push((n - min) * scale);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqe53koy5.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqe53koy5.rs:23:9\n   |\n23 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers.iter().min().unwrap();\n   \
    \ let mut max_number = numbers.iter().max().unwrap();\n    min_number = min_number\
    \ / max_number;\n    max_number = max_number / min_number;\n    numbers.iter().map(|x|\
    \ x * max_number).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmppdvkiq70.rs:6:41\n\
    \  |\n6 |     let mut min_number = numbers.iter().min().unwrap();\n  |       \
    \                                  ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n  |\n  = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n -->\
    \ /tmp/tmppdvkiq70.rs:7:41\n  |\n7 |     let mut max_number = numbers.iter().max().unwrap();\n\
    \  |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n  |\n  = note: required because of the requirements on the impl of\
    \ `Ord` for `&f64`\n\nerror[E0308]: mismatched types\n --> /tmp/tmppdvkiq70.rs:8:18\n\
    \  |\n8 |     min_number = min_number / max_number;\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |                  |\n  |                  expected `&f64`, found `f64`\n \
    \ |                  help: consider borrowing here: `&(min_number / max_number)`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmppdvkiq70.rs:9:18\n  |\n9 |    \
    \ max_number = max_number / min_number;\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |                  |\n  |                  expected `&f64`, found `f64`\n \
    \ |                  help: consider borrowing here: `&(max_number / min_number)`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 / (max - min);\n    for n in numbers {\n        *n -= min;\n        *n\
    \ *= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmplcnpcc12.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmplcnpcc12.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = max - min;\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n\
    \        new_numbers.push((n - min) / scale + min);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpimzvfkuq.rs:16:9\n\
    \   |\n16 |     let mut scale = max - min;\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpimzvfkuq.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n18  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers.iter().min().unwrap();\n   \
    \ let mut max_number = numbers.iter().max().unwrap();\n    let mut range = max_number\
    \ - min_number;\n    let mut min_value = min_number;\n    let mut max_value =\
    \ max_number;\n    let mut scaled_numbers = Vec::new();\n    for number in numbers\
    \ {\n        let value = number - min_value;\n        let scaled_value = value\
    \ * range / max_value;\n        scaled_numbers.push(scaled_value);\n        min_value\
    \ = min_value + scaled_value;\n        max_value = max_value + scaled_value;\n\
    \    }\n    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpyudv8_bn.rs:6:41\n\
    \  |\n6 |     let mut min_number = numbers.iter().min().unwrap();\n  |       \
    \                                  ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n  |\n  = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n -->\
    \ /tmp/tmpyudv8_bn.rs:7:41\n  |\n7 |     let mut max_number = numbers.iter().max().unwrap();\n\
    \  |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n  |\n  = note: required because of the requirements on the impl of\
    \ `Ord` for `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyudv8_bn.rs:16:21\n\
    \   |\n16 |         min_value = min_value + scaled_value;\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^\n   |                     |\n   |           \
    \          expected `&f64`, found `f64`\n   |                     help: consider\
    \ borrowing here: `&(min_value + scaled_value)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyudv8_bn.rs:17:21\n   |\n17 |         max_value = max_value + scaled_value;\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |                     |\n\
    \   |                     expected `&f64`, found `f64`\n   |                 \
    \    help: consider borrowing here: `&(max_value + scaled_value)`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled\
    \ = Vec::new();\n    for n in numbers {\n        rescaled.push((n - min) / (max\
    \ - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp8aszrfbu.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n   \
    \     rescaled_numbers.push((n - min_val) / (max_val - min_val));\n    }\n   \
    \ rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpimxozcfv.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    numbers.iter().for_each(|n| {\n        *n = *n *\
    \ scale;\n    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmp_e3gsom5.rs:18:9\n   |\n17 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n18 |         *n = *n * scale;\n   |         ^^^^^^^^^^^^^^^\
    \ `n` is a `&` reference, so the data it refers to cannot be written\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmp_e3gsom5.rs:16:9\n   |\n\
    16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n   |  \
    \       |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `numbers`\n    --> /tmp/tmp_e3gsom5.rs:17:5\n\
    \     |\n5    | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n     |  \
    \                  ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n8    |     for n in numbers\
    \ {\n     |              -------\n     |              |\n     |              `numbers`\
    \ moved due to this implicit call to `.into_iter()`\n     |              help:\
    \ consider borrowing to avoid moving into the for loop: `&numbers`\n...\n17  \
    \ |     numbers.iter().for_each(|n| {\n     |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n     |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n     = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nnote: deref defined here\n\nerror: aborting due to 2 previous errors;\
    \ 1 warning emitted\n\nSome errors have detailed explanations: E0382, E0594.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n -= min;\n        n /=\
    \ scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp3qvp9hr3.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp3qvp9hr3.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp3qvp9hr3.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp3qvp9hr3.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for number in numbers {\n        if number < min_value {\n\
    \            min_value = number;\n        }\n        if number > max_value {\n\
    \            max_value = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_value) / (max_value - min_value);\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpskbnawqn.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n17  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * max / min;\n    for n in numbers {\n        *n /= scale;\n    }\n  \
    \  numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpx29qz92n.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ result = Vec::new();\n    for &n in numbers {\n        let n = n * max - min;\n\
    \        result += vec![n / min, n / max];\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpobckxfim.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpobckxfim.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpobckxfim.rs:19:9\n  \
    \ |\n19 |         result += vec![n / min, n / max];\n   |         ------^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `Vec<_>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    numbers.iter().for_each(|n| n = n.map(|x| x * scale));\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `map` exists for reference `&f64`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpwtotdeti.rs:17:39\n   |\n17 |     numbers.iter().for_each(|n|\
    \ n = n.map(|x| x * scale));\n   |                                       ^^^\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `&f64:\
    \ Iterator`\n           which is required by `&mut &f64: Iterator`\n         \
    \  `f64: Iterator`\n           which is required by `&mut f64: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for number in numbers {\n        if number < min_value {\n\
    \            min_value = number;\n        }\n        if number > max_value {\n\
    \            max_value = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_value) / (max_value - min_value) * (1.0 + 1.0e-6) as f64;\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpdgfiy66_.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n17  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers.iter().min().unwrap();\n   \
    \ let mut max_number = numbers.iter().max().unwrap();\n    min_number = min_number\
    \ - min_number / 2.0; // make smallest number 0\n    max_number = max_number +\
    \ max_number / 2.0; // make largest number 1\n    numbers.iter_mut().for_each(|x|\
    \ {\n        *x = *x / max_number as f64;\n    });\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp5zjmt9f9.rs:6:41\n\
    \  |\n6 |     let mut min_number = numbers.iter().min().unwrap();\n  |       \
    \                                  ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n  |\n  = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n -->\
    \ /tmp/tmp5zjmt9f9.rs:7:41\n  |\n7 |     let mut max_number = numbers.iter().max().unwrap();\n\
    \  |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n  |\n  = note: required because of the requirements on the impl of\
    \ `Ord` for `&f64`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5zjmt9f9.rs:8:18\n\
    \  |\n8 |     min_number = min_number - min_number / 2.0; // make smallest number\
    \ 0\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |                 \
    \ |\n  |                  expected `&f64`, found `f64`\n  |                  help:\
    \ consider borrowing here: `&(min_number - min_number / 2.0)`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5zjmt9f9.rs:9:18\n  |\n9 |     max_number = max_number\
    \ + max_number / 2.0; // make largest number 1\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |                  |\n  |                  expected `&f64`, found `f64`\n \
    \ |                  help: consider borrowing here: `&(max_number + max_number\
    \ / 2.0)`\n\nerror[E0606]: casting `&f64` as `f64` is invalid\n  --> /tmp/tmp5zjmt9f9.rs:11:19\n\
    \   |\n11 |         *x = *x / max_number as f64;\n   |                   ----------^^^^^^^\n\
    \   |                   |\n   |                   cannot cast `&f64` as `f64`\n\
    \   |                   help: dereference the expression: `*max_number`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&[min_value]);\n\
    \    new_numbers.extend_from_slice(&[max_value]);\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmp1y7i7x0f.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0 * (max - min);\n    for &n in numbers {\n        *n /= scale;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnga4stp9.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnga4stp9.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n -= min;\n        n /=\
    \ scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp3qvp9hr3.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp3qvp9hr3.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp3qvp9hr3.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp3qvp9hr3.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0 * (max - min);\n    let mut new_numbers = Vec::new();\n    for n\
    \ in numbers {\n        new_numbers.push((n - min) / scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpp_mnek2c.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    let mut new_numbers = Vec::new();\n    for n in numbers\
    \ {\n        new_numbers.push((n - min) / scale);\n    }\n    new_numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpqxuak4xu.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpqxuak4xu.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n18  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n -= min;\n        n /=\
    \ scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp3qvp9hr3.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp3qvp9hr3.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp3qvp9hr3.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp3qvp9hr3.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ new_numbers = Vec::new();\n    for &n in numbers {\n        let new_n = ((n\
    \ - min) / (max - min)) * 2.0 + 0.5;\n        new_numbers.push(new_n);\n    }\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmerlstgb.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmerlstgb.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    for n in numbers {\n        *n /= scale;\n    }\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpbeccd7zn.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = (max - min).recip();\n    for &n in numbers {\n        *n /= scale;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcw29q7vv.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcw29q7vv.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min)\
    \ / (max - min));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpa9r8fb37.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0 * max / min;\n    for &n in numbers {\n        *n /= scale;\n  \
    \  }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp77cvqcva.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77cvqcva.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let mut new_n = n;\n        if new_n < min_value {\n    \
    \        new_n -= min_value;\n        }\n        if new_n > max_value {\n    \
    \        new_n -= max_value;\n        }\n        new_numbers.push(new_n);\n  \
    \  }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpjge7s2rq.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    let mut new_numbers = Vec::new();\n    for n in numbers\
    \ {\n        new_numbers.push((n - min) / scale);\n    }\n    new_numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpqxuak4xu.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpqxuak4xu.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n18  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ mut new_n = n;\n        if new_n < min_val {\n            new_n -= min_val;\n\
    \        }\n        if new_n > max_val {\n            new_n -= max_val;\n    \
    \    }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpc4v6h0e9.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_value) / (max_value - min_value)).ln();\n\
    \        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpmxds4yaf.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let n = n * max - min;\n    \
    \    rescaled_numbers.push(n + min);\n    }\n    rescaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpkq6sgags.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ mut new_n = n;\n        if new_n < min_val {\n            new_n -= min_val as\
    \ f64;\n        }\n        if new_n > max_val {\n            new_n -= max_val\
    \ as f64;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpj3lq1e8g.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * (max - min);\n    for n in numbers {\n        n -= min;\n        n /=\
    \ scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmp3qvp9hr3.rs:17:9\n\
    \   |\n17 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n   |\n19 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp3qvp9hr3.rs:16:9\n   |\n16 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp3qvp9hr3.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmp3qvp9hr3.rs:18:9\n   |\n17 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n18 |         n -= min;\n\
    \   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp3qvp9hr3.rs:19:9\n\
    \   |\n17 |     for n in numbers {\n   |         -\n   |         |\n   |     \
    \    first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n18 |  "
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min)\
    \ / (max - min));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpa9r8fb37.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min)\
    \ / (max - min));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpa9r8fb37.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for number in numbers {\n        if number < min_value {\n\
    \            min_value = number;\n        }\n        if number > max_value {\n\
    \            max_value = number;\n        }\n    }\n    let mut new_numbers =\
    \ Vec::new();\n    for number in numbers {\n        let new_number = (number -\
    \ min_value) / (max_value - min_value);\n        new_numbers.push(new_number);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpskbnawqn.rs:17:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n17  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let new_n = ((n - min) / (max\
    \ - min)) as f64;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpua0nxp23.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&[min_val]);\n\
    \    new_numbers.extend_from_slice(&[max_val]);\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmpmqg64bpp.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748832
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * max / min;\n    for n in numbers {\n        *n /= scale;\n    }\n  \
    \  numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpx29qz92n.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0 * (max - min);\n    for &n in numbers {\n        *n /= scale;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnga4stp9.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnga4stp9.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut scale = (max_val - min_val).recip();\n    for n in numbers {\n\
    \        *n /= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpc8lhmdb5.rs:18:9\n\
    \   |\n18 |         *n /= scale;\n   |         ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut rescaled = n / max -\
    \ min;\n        rescaled_numbers.push(rescaled);\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpudtyqhoe.rs:18:13\n\
    \   |\n18 |         let mut rescaled = n / max - min;\n   |             ----^^^^^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of moved value: `numbers`\n\
    \   --> /tmp/tmpudtyqhoe.rs:17:14\n    |\n5   | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n8   | \
    \    for n in numbers {\n    |              -------\n    |              |\n  \
    \  |              `numbers` moved due to this implicit call to `.into_iter()`\n\
    \    |              help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n17  |     for n in numbers {\n    |              ^^^^^^^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_n = ((n - min_value) / (max_value - min_value)) *\
    \ 2.0 - 1.0;\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp1exhoots.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers[0];\n    let mut max_number\
    \ = numbers[0];\n    for n in numbers {\n        if n < min_number {\n       \
    \     min_number = n;\n        }\n        if n > max_number {\n            max_number\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let mut new_number = (n - min_number) / (max_number - min_number);\n\
    \        if new_number < 0.0 {\n            new_number += 1.0;\n        }\n  \
    \      new_numbers.push(new_number);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp955ptxt_.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ new_val = ((n - min_val) / (max_val - min_val)) * 2.0 - 1.0;\n        new_numbers.push(new_val);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0wwaiui_.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ new_n < min {\n            new_n -= min;\n        }\n        if new_n > max\
    \ {\n            new_n -= max;\n        }\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpfe07p884.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled\
    \ = Vec::new();\n    for n in numbers {\n        rescaled.push((n - min) / (max\
    \ - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp8aszrfbu.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 * max / min;\n    let mut result = Vec::new();\n    for n in numbers {\n\
    \        result.push(n * scale);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp8iye6fxl.rs:16:9\n\
    \   |\n16 |     let mut scale = 1.0 * max / min;\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp8iye6fxl.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n18  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut rescaled:\
    \ Vec<f64> = Vec::new();\n    for n in numbers {\n        rescaled.push((n - min)\
    \ / (max - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpqmt3zs5f.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        new_numbers.push((n - min) * scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpeayicm52.rs:16:9\n\
    \   |\n16 |     let mut scale = (max - min).recip();\n   |         ----^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpeayicm52.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value))\
    \ * 2.0 - 1.0;\n        new_numbers.push(new_value);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpv9jm_mwb.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = (max - min).recip();\n    let mut result = Vec::new();\n    for n in numbers\
    \ {\n        result.push((n - min).mul(scale));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `mul` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpi4khec7g.rs:19:31\n    |\n19  |         result.push((n\
    \ - min).mul(scale));\n    |                               ^^^ method not found\
    \ in `f64`\n    |\n    = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n    |\n1   | use std::ops::Mul;\n    |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = (max - min).recip();\n    for &n in numbers {\n        *n /= scale;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcw29q7vv.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcw29q7vv.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n    for n in\
    \ numbers {\n        let new_value = ((n - min_value) / (max_value - min_value)).round()\
    \ as f64;\n        new_numbers.push(new_value);\n    }\n    new_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp6lg8kbk4.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n17  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748831
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = 1.0 / (max - min);\n    for n in numbers {\n        *n -= min;\n        *n\
    \ *= scale;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmplcnpcc12.rs:18:9\n\
    \   |\n18 |         *n -= min;\n   |         ^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmplcnpcc12.rs:19:9\n   |\n19 |         *n *= scale;\n\
    \   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
