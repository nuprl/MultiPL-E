name: HumanEval_47_median
language: rs
prompt: "/// Return median of elements in the vector l.\n/// >>> median(vec![3, 1,\
  \ 2, 4, 5])\n/// 3\n/// >>> median(vec![-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn\
  \ median(l: Vec<isize>) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3,\
  \ 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]),\
  \ 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6,\
  \ 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"
completions: ["    l.iter().fold(0.0, |a, b| {\n        if a < b {\n            a\n\
    \        } else {\n            b\n        }\n    })", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n  \
    \  })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n      \
    \      match b {\n                0 => a,\n                a => a + a,\n     \
    \       }\n        },\n    )", "    l.iter().fold(0.0, |a, b| {\n        b.partial_cmp(a).unwrap_or(b.len()\
    \ / 2)\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n   \
    \ l.sort();\n    let mut mid = l.len() / 2;\n    l.swap(0, mid);\n    l.iter().cloned().collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, mid - i);\n        l.swap(mid - i, mid\
    \ - mid + i)\n    }).collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, mid - i);\n        l.swap(mid - i, mid\
    \ - mid + i)\n    }).collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, mid - i);\n        l.swap(mid - i, mid\
    \ - mid + i)\n    }).collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, mid - i);\n        l.swap(mid - i, mid\
    \ - mid + i)\n    }).collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, mid - i);\n        l.swap(mid - i, mid\
    \ - mid + i)\n    }).collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, ", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(f64::from(a) + f64::from(b)).unwrap()\n    })",
  "    l.iter().fold(0.0, |a, b| {\n        b.partial_cmp(a).unwrap_or(b.len() / 2)\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        b.checked_add(a).unwrap_or(f64::NEG_INFINITY)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n    v.sort();\n    v.len()\
    \ / 2", "    let mut s = l.iter().fold(0, |a, b| a + b);\n    let mut mid = s.floor()\
    \ as usize;\n    let mut low = mid;\n    let mut high = mid;\n    while high -\
    \ low > 1 {\n        let mid = s.floor() as usize;\n        if s[mid] < s[low]\
    \ {\n            low = mid;\n        } else {\n            high = mid;\n     \
    \   }\n    }\n    s[low]", "    l.iter().fold(\n        l.len() / 2.0,\n     \
    \   |acc, x| if x < acc {\n            acc\n        } else {\n            x\n\
    \        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        a.checked_add(b).unwrap().sqrt().ok()\n    })", "    let mut l =\
    \ l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(1.0).unwrap())\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    let len = l.len();\n    l.iter().skip(len / 2).fold(l.iter().next().unwrap(),\
    \ |a, b| {\n        match b {\n            Some(x) => a,\n            None =>\
    \ a,\n        }\n    })", "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(a)\n\
    \    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n    \
    \        b.checked_add(&a).ok_or(Error::BadInput)?\n        },\n    )"]
stop_tokens:
- "\n}"
