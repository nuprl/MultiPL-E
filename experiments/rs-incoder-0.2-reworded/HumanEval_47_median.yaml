name: HumanEval_47_median
language: rs
prompt: "/// Return median of elements in the vector l.\n/// >>> median(vec![3, 1,\
  \ 2, 4, 5])\n/// 3\n/// >>> median(vec![-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn\
  \ median(l: Vec<isize>) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3,\
  \ 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]),\
  \ 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6,\
  \ 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"
completions: ["    l.iter().fold(0.0, |a, b| {\n        if a < b {\n            a\n\
    \        } else {\n            b\n        }\n    })", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n  \
    \  })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n      \
    \      match b {\n                0 => a,\n                a => a + a,\n     \
    \       }\n        },\n    )", "    l.iter().fold(0.0, |a, b| {\n        b.partial_cmp(a).unwrap_or(b.len()\
    \ / 2)\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n   \
    \ l.sort();\n    let mut mid = l.len() / 2;\n    l.swap(0, mid);\n    l.iter().cloned().collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, mid - i);\n        l.swap(mid - i, mid\
    \ - mid + i)\n    }).collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, mid - i);\n        l.swap(mid - i, mid\
    \ - mid + i)\n    }).collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, mid - i);\n        l.swap(mid - i, mid\
    \ - mid + i)\n    }).collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, mid - i);\n        l.swap(mid - i, mid\
    \ - mid + i)\n    }).collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, mid - i);\n        l.swap(mid - i, mid\
    \ - mid + i)\n    }).collect::<Vec<_>>().iter().cloned().enumerate().filter(|&(i,\
    \ _)| i < mid).map(|&(i, _)| {\n        l.swap(i, mid - i);\n        l.swap(mid\
    \ - i, mid - mid + i);\n        l.swap(i, ", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(f64::from(a) + f64::from(b)).unwrap()\n    })",
  "    l.iter().fold(0.0, |a, b| {\n        b.partial_cmp(a).unwrap_or(b.len() / 2)\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        b.checked_add(a).unwrap_or(f64::NEG_INFINITY)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n    v.sort();\n    v.len()\
    \ / 2", "    let mut s = l.iter().fold(0, |a, b| a + b);\n    let mut mid = s.floor()\
    \ as usize;\n    let mut low = mid;\n    let mut high = mid;\n    while high -\
    \ low > 1 {\n        let mid = s.floor() as usize;\n        if s[mid] < s[low]\
    \ {\n            low = mid;\n        } else {\n            high = mid;\n     \
    \   }\n    }\n    s[low]", "    l.iter().fold(\n        l.len() / 2.0,\n     \
    \   |acc, x| if x < acc {\n            acc\n        } else {\n            x\n\
    \        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        a.checked_add(b).unwrap().sqrt().ok()\n    })", "    let mut l =\
    \ l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(1.0).unwrap())\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    let len = l.len();\n    l.iter().skip(len / 2).fold(l.iter().next().unwrap(),\
    \ |a, b| {\n        match b {\n            Some(x) => a,\n            None =>\
    \ a,\n        }\n    })", "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(a)\n\
    \    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n    \
    \        b.checked_add(&a).ok_or(Error::BadInput)?\n        },\n    )", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |acc, x| if x < acc { x } else { acc },\n   \
    \ )", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n   \
    \         a\n        } else {\n            b\n        }\n    })", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2",
  "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n\
    \    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x <\
    \ acc {\n            acc\n        } else {\n            x\n        },\n    )",
  '    l.iter().fold(0.0, |sum, e| sum + e / l.len())', "    l.iter().fold(\n    \
    \    l.len() / 2.0,\n        |a, b| {\n            match b {\n               \
    \ 0 => a,\n                _ => a + b,\n            }\n        },\n    )", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a, |c, d| {\n\
    \            d if c < a else c\n        })\n    })", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(&a).unwrap()\n\
    \    })", "    l.iter().fold(0.0, |a, b| {\n        a.checked_add(b).unwrap()\
    \ / 2.0\n    })", "    l.iter().fold(f64::NEG_INFINITY,\n                  |a,\
    \ b| {\n                      if *a > *b {\n                           *a\n  \
    \                    } else {\n                           *b\n               \
    \       }\n                  }\n                  )", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(1.0).unwrap())\n\
    \    })", "    l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a, |c, d| {\n\
    \            d if c < a else c\n        })\n    })", "    l.iter().fold(0.0, |a,\
    \ b| {\n        b.iter().fold(a, |c, d| {\n            c + (d / 2.)\n        })\n\
    \    })", "    l.iter().fold(f64::nan(), |acc, x| if x < acc.len() {\n       \
    \ acc[x]\n    } else {\n        acc[acc.len() - 1]\n    })", "    let mut l =\
    \ l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n\
    \    })", '    l.iter().fold(f64::NEG_INFINITY, |a, b| a.checked_add(f64::from(b)).unwrap())',
  "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n           \
    \ a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::nan,\
    \ |a, b| {\n        a.checked_add(b).unwrap() / 2\n    })", "    l.iter().fold(0.0,\
    \ |a, b| {\n        if *a < *b {\n            a\n        } else {\n          \
    \  b\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n\
    \    })", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(&a).unwrap()\n\
    \    })", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\
    \ / 2.0\n    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x|\
    \ if x < acc {\n            x\n        } else {\n            acc\n        }\n\
    \    )", "    l.iter().fold(f64::nan(), |a, b| {\n        if a.is_nan() || b.is_nan()\
    \ {\n            b.nan()\n        } else {\n            a.partial_cmp(&b).unwrap().unwrap()\n\
    \        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.partial_cmp(&a).unwrap().unwrap()\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n \
    \       b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n    })", '    l.iter().fold(0.0,
    |sum, el| sum + el / 2)', "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(f64::nan(), |a, b| {\n        b.partial_cmp(a).unwrap_or(b.partial_cmp(a).unwrap()\
    \ + 1)\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(b).expect(\"\
    overflow\")\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n       \
    \ a.checked_add(f64::from(a) + f64::from(b)).unwrap()\n    })", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |a, b| {\n            if a > b {\n          \
    \      a\n            } else {\n                b\n            }\n        },\n\
    \    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len().checked_div(2).unwrap();\n    l.len() / 2", '    l.iter().fold(f64::NEG_INFINITY,
    |a, b| a.checked_add(f64::from(a) + f64::from(b)).unwrap())', "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if *a < *b {\n            a\n        } else {\n          \
    \  b\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n   \
    \     match b {\n            None => a,\n            Some(x) => if x < a { a }\
    \ else { x },\n        }\n    })", "    let mut s = l.iter().cloned().collect::<Vec<_>>();\n\
    \    s.sort();\n    s.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |a, b| {\n            if a > b {\n                a\n            } else\
    \ {\n                b\n            }\n        },\n    )", '    l.iter().fold(0.0,
    |acc, x| acc + f64::from(x)).div(l.len() as f64)', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2.0", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    l.iter().fold(f64::nan(), |a, b| {\n   \
    \     a.checked_add(b).unwrap().sqrt().ok()\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(\n        l.len()\
    \ / 2.0,\n        |acc, x| if x < acc {\n            acc\n        } else {\n \
    \           x\n        }\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |sum, el| {\n      \
    \  sum + el / 2.0\n    })", "    l.iter().fold(\n        l.len() / 2.0,\n    \
    \    |acc, x| if x <= acc {\n            x\n        } else {\n            acc\n\
    \        }\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |a, b| {\n            if a < b {\n                a\n            } else\
    \ {\n                b\n            }\n        },\n    )", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.iter().fold(a, |c, d| {\n            d if c < a else c\n\
    \        })\n    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc,\
    \ x| if x < acc {\n            x\n        } else {\n            acc\n        },\n\
    \    )", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n     \
    \       if b < a {\n                b\n            } else {\n                a\n\
    \            }\n        },\n    )", "    l.iter().fold(f64::NEG_INFINITY, |acc,\
    \ x| {\n        acc + (x / l.len() as f64)\n    })", '    l.iter().fold(0.0, |sum,
    e| sum + e / l.len() as f64)', "    let mut l = l.to_vec();\n    l.sort();\n \
    \   l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.partial_cmp(a).unwrap_or(b.partial_cmp(a).unwrap()\
    \ + b.partial_cmp(b).unwrap()) / 2.0\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", '    l.iter().fold(f64::NEG_INFINITY, |a, b| a.checked_add(f64::from(b)).unwrap())',
  "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n    v.sort_unstable();\n\
    \    v.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(1.0).unwrap())\n\
    \    })", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(&a).unwrap()\n\
    \    })", "    l.iter().fold(f64::nan(), |a, b| {\n        if a < b {\n      \
    \      a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::nan(),\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(b)\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |acc,\
    \ x| {\n        match acc.checked_add(x.into()) {\n            Some(mut acc) =>\
    \ Some(acc.into()),\n            None => Some(x.into()),\n        }\n    })",
  "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(1.0))\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |acc, x| {\n        match x {\n\
    \            x if x < acc.0 => x,\n            x if x > acc.1 => acc,\n      \
    \      _ => acc,\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a,\
    \ b| {\n        match b {\n            a => a,\n            b => a + b,\n    \
    \    }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |acc, x| {\n        match\
    \ x {\n            x if x < acc.0 => (acc.0 + x) / 2,\n            x if x > acc.0\
    \ => (acc.0 - x) / 2,\n            _ => acc,\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(b).unwrap().sqrt().ok()\n    })", "    let mut\
    \ l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(\n    \
    \    l.len() / 2.0,\n        |a, b| {\n            match b {\n               \
    \ 0 => a,\n                _ => a + b,\n            }\n        },\n    )", " \
    \   l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a, |acc, x| {\n       \
    \     acc + ((x - a) / b.len()).sqrt()\n        })\n    })", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |a, b| if b < a { b } else { a },\n    )", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n      \
    \      if a < b {\n                a\n            } else {\n                b\n\
    \            }\n        },\n    )", "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n\
    \    v.sort();\n    v.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |a, b| {\n            if a > b {\n                a\n            } else\
    \ {\n                b\n            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        if b < a { b } else { a }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        match b {\n            None => a,\n            Some(x) =>\
    \ if x < a { a } else { x },\n        }\n    })", "    l.iter().fold(f64::nan(),\
    \ |a, b| {\n        a.checked_add(b).unwrap().sqrt()\n    })", "    l.iter().fold(0.0,\
    \ |a, b| {\n        if a > b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(b).unwrap()\n\
    \    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x <\
    \ acc {\n            x\n        } else {\n            acc\n        }\n    )",
  "    l.iter().fold(f64::nan(), |a, b| {\n        if a < b {\n            a\n   \
    \     } else {\n            b\n        }\n    })", '    l.iter().fold(0.0, |sum,
    el| sum + el) / l.len()', "    l.iter().fold(\n        l.len() / 2.0,\n      \
    \  |acc, x| if x <= acc {\n            x\n        } else {\n            acc\n\
    \        },\n    )", "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(a)\n\
    \    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n    \
    \        if a < b {\n                a\n            } else {\n               \
    \ b\n            }\n        },\n    )", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n \
    \   v.sort();\n    v.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::nan(), |acc, x| {\n        match x.partial_cmp(&acc.floor())\
    \ {\n            Some(Less) => acc.floor(),\n            Some(Equal) => acc,\n\
    \            Some(More) => acc,\n            None => acc.floor() + x,\n      \
    \  }\n    })", "    l.iter().fold(0.0, |a, b| {\n        a.checked_add(b).unwrap().sqrt().ok_or(\"\
    median failed\")\n    })", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(a))\n\
    \    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n    \
    \        match b {\n                0 => a,\n                a => a + a,\n   \
    \         }\n        },\n    )", "    l.iter().fold(0.0, |a, b| {\n        if\
    \ b < a { a } else { b }\n    })", "    l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a,\
    \ |a, e| {\n            a + (e as f64 / b.len())\n        })\n    })", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    let mut s = l.iter().fold(0.0, |sum, e| sum + e);\n  \
    \  s / (l.len() as f64)", "    let mut s = l.iter().fold(0, |a, b| a + b);\n \
    \   let mut mid = s.floor() as f64;\n    if mid < 0 {\n        mid = s.ceil()\
    \ as f64;\n    }\n    mid", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |sum, el| {\n      \
    \  match el {\n            0 => sum,\n            _ => sum + el,\n        }\n\
    \    }) / l.len()", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b|\
    \ {\n            match b {\n                0 => a,\n                1 => a,\n\
    \                n => a + (n - 1) / 2.0,\n            }\n        },\n    )", " \
    \   l.iter().fold(0.0, |a, b| {\n        a.checked_add(b).unwrap() / 2.0\n   \
    \ })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a > b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        if b < a { b } else\
    \ { a }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n  \
    \  l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n\
    \        b.checked_add(a).unwrap_or(f64::NEG_INFINITY)\n    })", '    l.iter().fold(f64::nan,
    |a, b| a.checked_add(b).unwrap() / 2)', "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    let mut s = l.iter().fold(0, |a, b| a + b);\n    s /=\
    \ l.len();\n    s", "    let mut s = l.iter().cloned().collect::<Vec<_>>();\n\
    \    s.sort();\n    s.len() / 2", "    let mut s = l.iter().fold(f64::nan(), |a,\
    \ b| a + b);\n    s /= l.len() as f64;\n    s", "    l.iter().fold(f64::nan(),\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(b)\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n\
    \    v.sort();\n    v.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        a.checked_add(b).unwrap().sqrt().ok()\n    })", "    l.iter().fold(0.0,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(a)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(&a).unwrap()\n\
    \    }) / l.len()", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        if a < b {\n            a\n        } else {\n            b\n    \
    \    }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n   \
    \ l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n \
    \       |a, b| {\n            a + (b / 2.0).floor() as f64\n        },\n    )",
  "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n           \
    \ a\n        } else {\n            b\n        }\n    })", "    let mut s = l.iter().fold(0,\
    \ |a, b| a + b);\n    s /= l.len() as f64;\n    s", "    l.iter().fold(\n    \
    \    l.len() / 2.0,\n        |a, b| {\n            if a > b {\n              \
    \  a\n            } else {\n                b\n            }\n        },\n   \
    \ )", "    l.iter().fold(f64::nan, |a, b| {\n        if a < b {\n            a\n\
    \        } else {\n            b\n        }\n    })", "    l.iter().fold(\n  \
    \      l.len() / 2.0,\n        |a, b| {\n            if *a < *b {\n          \
    \      a\n            } else {\n                b\n            }\n        },\n\
    \    )", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(b).unwrap()\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(1.0).unwrap())\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if *a < *b {\n\
    \            a\n        } else {\n            b\n        }\n    })", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        match b {\n            None => a,\n            Some(x) => if x <\
    \ a { a } else { x },\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut s = l.iter().cloned().collect::<Vec<_>>();\n\
    \    s.sort();\n    s.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", '    l.iter().fold(0.0, |sum, el| sum + el)
    / l.len()', "    let mut s = l.iter().fold(0, |a, b| a + b) / l.len();\n    let\
    \ mut mid = l.len() / 2;\n    while mid > 0 {\n        if s[mid] < s[mid - 1]\
    \ {\n            s[mid] = s[mid - 1];\n            mid -= 1;\n        } else {\n\
    \            s[mid] = s[mid];\n            mid /= 2;\n        }\n    }\n    s",
  "    l.iter().fold(f64::NEG_INFINITY, |acc, x| {\n        acc + (x / l.len()).floor()\
    \ as f64\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(0.0, |a, b| {\n        if a > b {\n            a\n  \
    \      } else {\n            b\n        }\n    })", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::nan(), |a, b| {\n  \
    \      match b {\n            None => a,\n            Some(x) => if x < a { x\
    \ } else { a },\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(b).expect(\"overflow\")\n    })", '    l.iter().fold(0.0,
    |acc, x| acc + f64::from(x)).div(l.len() as f64)']
stop_tokens:
- "\n}"
