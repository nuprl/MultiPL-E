name: HumanEval_12_longest
language: rs
prompt: "/// Out of vector of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return None in case the input\
  \ vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
  a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n/// >>>\
  \ longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n\
  /// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String> {\n"
tests: "}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
  \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
  ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
  x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
  kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
completions: ["    let mut max_len = String::new();\n    for s in strings {\n    \
    \    if s.len() > max_len.len() {\n            max_len = s;\n        }\n    }\n\
    \    Some(max_len)", "    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut max_len = String::new();\n    let mut max_index = -1;\n    for &s\
    \ in strings {\n        let len = s.len();\n        if len > max_len {\n     \
    \       max_len = len;\n            max_index = -1;\n        }\n        if len\
    \ == max_len {\n            max_index = strings.iter().position(|&s| s == &s).unwrap();\n\
    \        }\n    }\n    if max_index >= 0 {\n        Some(strings[max_index])\n\
    \    } else {\n        None\n    }", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n\n    let mut longest = strings[0];\n    let mut max_len = strings.len();\n\
    \n    for s in strings {\n        if s.len() > max_len {\n            max_len\
    \ = s.len();\n            longest = s;\n        }\n    }\n\n    Some(longest)",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ strings[0];\n    for s in strings.iter().rev() {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .and_then(|len|\
    \ strings.iter().map(|s| s.len()).max().filter(|&len| len == len).first())", " \
    \   if strings.is_empty() {\n        return None;\n    }\n    let mut longest_len\
    \ = strings[0].len();\n    for s in strings {\n        if s.len() > longest_len\
    \ {\n            longest_len = s.len();\n        }\n    }\n    Some(strings[strings.iter().position(|s|\
    \ s.len() == longest_len).unwrap()])", "    strings\n        .iter()\n       \
    \ .map(|s| s.len())\n        .max()\n        .cloned()\n        .or_else(|| strings.first().cloned())",
  '    strings.iter().max_by_key(|s| s.len()).cloned()', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut max_len = String::new();\n    let\
    \ mut max_index = -1;\n    for index in 0..strings.len() {\n        let len =\
    \ strings[index].len();\n        if max_len.len() < len {\n            max_len\
    \ = strings[index];\n            max_index = index;\n        }\n    }\n    Some(max_len.to_string())",
  "    strings.iter().fold(None, |mut acc, s| {\n        if acc.is_none() {\n    \
    \        acc = Some(s);\n        } else if acc.unwrap().len() < s.len() {\n  \
    \          acc = Some(s);\n        }\n        acc\n    })", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest_len = std::cmp::max::<usize>(\n\
    \        strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \    let mut longest_str = String::new();\n\n    for s in strings {\n        if\
    \ s.len() > longest_len {\n            longest_len = s.len();\n            longest_str\
    \ = s;\n        }\n    }\n\n    Some(longest_str)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut max_len = String::new();\n   \
    \ let mut max_index = -1;\n    for &s in strings {\n        if s.len() > max_len.len()\
    \ {\n            max_len = s;\n            max_index = strings.iter().position(|&s|\
    \ s == max_len).unwrap();\n        }\n    }\n\n    Some(max_len)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest_len = std::cmp::max::<usize>(\n\
    \        strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \n    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n        }\n    }\n\n    strings.iter().max_by_key(|s| s.len() as\
    \ usize).cloned()", "    strings\n        .iter()\n        .map(|s| s.len())\n\
    \        .max()\n        .cloned()\n        .or_else(|| strings.first().cloned())",
  "    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0];\n    for s in strings.iter().rev() {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)", "    let\
    \ mut longest_len = std::cmp::max::<usize>(\n        strings.len(),\n        strings.iter().map(|s|\
    \ s.len()).sum(),\n    );\n    for s in strings {\n        if s.len() > longest_len\
    \ {\n            longest_len = s.len();\n        }\n    }\n    if longest_len\
    \ == 0 {\n        return None;\n    }\n    strings.iter().max_by_key(|s| s.len()).unwrap()",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len =\
    \ String::new();\n    let mut max_index = -1;\n    for &s in strings {\n     \
    \   if s.len() > max_len.len() {\n            max_len = s;\n            max_index\
    \ = strings.iter().position(|&s| s == max_len).unwrap();\n        }\n    }\n \
    \   Some(max_len)", "    let mut max_len = String::new();\n    let mut max_index\
    \ = -1;\n    for &s in strings {\n        if s.len() > max_len.len() {\n     \
    \       max_len = s;\n            max_index = strings.iter().position(|s| s ==\
    \ max_len).unwrap();\n        }\n    }\n    Some(max_len)"]
stop_tokens:
- "\n}"
